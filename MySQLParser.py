# Generated from MySQLParser.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

if "." in __name__:
    from .MySQLParserBase import MySQLParserBase
else:
    from MySQLParserBase import MySQLParserBase

def serializedATN():
    return [
        4,1,833,9275,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
        91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,
        98,7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,
        2,104,7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,
        7,109,2,110,7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,
        2,115,7,115,2,116,7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,
        7,120,2,121,7,121,2,122,7,122,2,123,7,123,2,124,7,124,2,125,7,125,
        2,126,7,126,2,127,7,127,2,128,7,128,2,129,7,129,2,130,7,130,2,131,
        7,131,2,132,7,132,2,133,7,133,2,134,7,134,2,135,7,135,2,136,7,136,
        2,137,7,137,2,138,7,138,2,139,7,139,2,140,7,140,2,141,7,141,2,142,
        7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,7,146,2,147,7,147,
        2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,7,152,2,153,
        7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,7,158,
        2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
        7,164,2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,
        2,170,7,170,2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,
        7,175,2,176,7,176,2,177,7,177,2,178,7,178,2,179,7,179,2,180,7,180,
        2,181,7,181,2,182,7,182,2,183,7,183,2,184,7,184,2,185,7,185,2,186,
        7,186,2,187,7,187,2,188,7,188,2,189,7,189,2,190,7,190,2,191,7,191,
        2,192,7,192,2,193,7,193,2,194,7,194,2,195,7,195,2,196,7,196,2,197,
        7,197,2,198,7,198,2,199,7,199,2,200,7,200,2,201,7,201,2,202,7,202,
        2,203,7,203,2,204,7,204,2,205,7,205,2,206,7,206,2,207,7,207,2,208,
        7,208,2,209,7,209,2,210,7,210,2,211,7,211,2,212,7,212,2,213,7,213,
        2,214,7,214,2,215,7,215,2,216,7,216,2,217,7,217,2,218,7,218,2,219,
        7,219,2,220,7,220,2,221,7,221,2,222,7,222,2,223,7,223,2,224,7,224,
        2,225,7,225,2,226,7,226,2,227,7,227,2,228,7,228,2,229,7,229,2,230,
        7,230,2,231,7,231,2,232,7,232,2,233,7,233,2,234,7,234,2,235,7,235,
        2,236,7,236,2,237,7,237,2,238,7,238,2,239,7,239,2,240,7,240,2,241,
        7,241,2,242,7,242,2,243,7,243,2,244,7,244,2,245,7,245,2,246,7,246,
        2,247,7,247,2,248,7,248,2,249,7,249,2,250,7,250,2,251,7,251,2,252,
        7,252,2,253,7,253,2,254,7,254,2,255,7,255,2,256,7,256,2,257,7,257,
        2,258,7,258,2,259,7,259,2,260,7,260,2,261,7,261,2,262,7,262,2,263,
        7,263,2,264,7,264,2,265,7,265,2,266,7,266,2,267,7,267,2,268,7,268,
        2,269,7,269,2,270,7,270,2,271,7,271,2,272,7,272,2,273,7,273,2,274,
        7,274,2,275,7,275,2,276,7,276,2,277,7,277,2,278,7,278,2,279,7,279,
        2,280,7,280,2,281,7,281,2,282,7,282,2,283,7,283,2,284,7,284,2,285,
        7,285,2,286,7,286,2,287,7,287,2,288,7,288,2,289,7,289,2,290,7,290,
        2,291,7,291,2,292,7,292,2,293,7,293,2,294,7,294,2,295,7,295,2,296,
        7,296,2,297,7,297,2,298,7,298,2,299,7,299,2,300,7,300,2,301,7,301,
        2,302,7,302,2,303,7,303,2,304,7,304,2,305,7,305,2,306,7,306,2,307,
        7,307,2,308,7,308,2,309,7,309,2,310,7,310,2,311,7,311,2,312,7,312,
        2,313,7,313,2,314,7,314,2,315,7,315,2,316,7,316,2,317,7,317,2,318,
        7,318,2,319,7,319,2,320,7,320,2,321,7,321,2,322,7,322,2,323,7,323,
        2,324,7,324,2,325,7,325,2,326,7,326,2,327,7,327,2,328,7,328,2,329,
        7,329,2,330,7,330,2,331,7,331,2,332,7,332,2,333,7,333,2,334,7,334,
        2,335,7,335,2,336,7,336,2,337,7,337,2,338,7,338,2,339,7,339,2,340,
        7,340,2,341,7,341,2,342,7,342,2,343,7,343,2,344,7,344,2,345,7,345,
        2,346,7,346,2,347,7,347,2,348,7,348,2,349,7,349,2,350,7,350,2,351,
        7,351,2,352,7,352,2,353,7,353,2,354,7,354,2,355,7,355,2,356,7,356,
        2,357,7,357,2,358,7,358,2,359,7,359,2,360,7,360,2,361,7,361,2,362,
        7,362,2,363,7,363,2,364,7,364,2,365,7,365,2,366,7,366,2,367,7,367,
        2,368,7,368,2,369,7,369,2,370,7,370,2,371,7,371,2,372,7,372,2,373,
        7,373,2,374,7,374,2,375,7,375,2,376,7,376,2,377,7,377,2,378,7,378,
        2,379,7,379,2,380,7,380,2,381,7,381,2,382,7,382,2,383,7,383,2,384,
        7,384,2,385,7,385,2,386,7,386,2,387,7,387,2,388,7,388,2,389,7,389,
        2,390,7,390,2,391,7,391,2,392,7,392,2,393,7,393,2,394,7,394,2,395,
        7,395,2,396,7,396,2,397,7,397,2,398,7,398,2,399,7,399,2,400,7,400,
        2,401,7,401,2,402,7,402,2,403,7,403,2,404,7,404,2,405,7,405,2,406,
        7,406,2,407,7,407,2,408,7,408,2,409,7,409,2,410,7,410,2,411,7,411,
        2,412,7,412,2,413,7,413,2,414,7,414,2,415,7,415,2,416,7,416,2,417,
        7,417,2,418,7,418,2,419,7,419,2,420,7,420,2,421,7,421,2,422,7,422,
        2,423,7,423,2,424,7,424,2,425,7,425,2,426,7,426,2,427,7,427,2,428,
        7,428,2,429,7,429,2,430,7,430,2,431,7,431,2,432,7,432,2,433,7,433,
        2,434,7,434,2,435,7,435,2,436,7,436,2,437,7,437,2,438,7,438,2,439,
        7,439,2,440,7,440,2,441,7,441,2,442,7,442,2,443,7,443,2,444,7,444,
        2,445,7,445,2,446,7,446,2,447,7,447,2,448,7,448,2,449,7,449,2,450,
        7,450,2,451,7,451,2,452,7,452,2,453,7,453,2,454,7,454,2,455,7,455,
        2,456,7,456,2,457,7,457,2,458,7,458,2,459,7,459,2,460,7,460,2,461,
        7,461,2,462,7,462,2,463,7,463,2,464,7,464,2,465,7,465,2,466,7,466,
        2,467,7,467,2,468,7,468,2,469,7,469,2,470,7,470,2,471,7,471,2,472,
        7,472,2,473,7,473,2,474,7,474,2,475,7,475,2,476,7,476,2,477,7,477,
        2,478,7,478,2,479,7,479,2,480,7,480,2,481,7,481,2,482,7,482,2,483,
        7,483,2,484,7,484,2,485,7,485,2,486,7,486,2,487,7,487,2,488,7,488,
        2,489,7,489,2,490,7,490,2,491,7,491,2,492,7,492,2,493,7,493,2,494,
        7,494,2,495,7,495,2,496,7,496,2,497,7,497,2,498,7,498,2,499,7,499,
        2,500,7,500,2,501,7,501,2,502,7,502,2,503,7,503,2,504,7,504,2,505,
        7,505,2,506,7,506,2,507,7,507,2,508,7,508,2,509,7,509,2,510,7,510,
        2,511,7,511,2,512,7,512,2,513,7,513,2,514,7,514,2,515,7,515,2,516,
        7,516,2,517,7,517,2,518,7,518,2,519,7,519,2,520,7,520,2,521,7,521,
        2,522,7,522,2,523,7,523,2,524,7,524,2,525,7,525,2,526,7,526,2,527,
        7,527,2,528,7,528,2,529,7,529,2,530,7,530,2,531,7,531,2,532,7,532,
        2,533,7,533,2,534,7,534,2,535,7,535,2,536,7,536,2,537,7,537,2,538,
        7,538,2,539,7,539,2,540,7,540,2,541,7,541,2,542,7,542,2,543,7,543,
        2,544,7,544,2,545,7,545,2,546,7,546,2,547,7,547,2,548,7,548,2,549,
        7,549,2,550,7,550,2,551,7,551,2,552,7,552,2,553,7,553,2,554,7,554,
        2,555,7,555,2,556,7,556,2,557,7,557,2,558,7,558,2,559,7,559,2,560,
        7,560,2,561,7,561,2,562,7,562,2,563,7,563,2,564,7,564,2,565,7,565,
        2,566,7,566,2,567,7,567,2,568,7,568,2,569,7,569,2,570,7,570,2,571,
        7,571,2,572,7,572,2,573,7,573,2,574,7,574,2,575,7,575,2,576,7,576,
        2,577,7,577,2,578,7,578,2,579,7,579,2,580,7,580,2,581,7,581,2,582,
        7,582,2,583,7,583,2,584,7,584,2,585,7,585,2,586,7,586,2,587,7,587,
        2,588,7,588,2,589,7,589,2,590,7,590,2,591,7,591,2,592,7,592,2,593,
        7,593,2,594,7,594,2,595,7,595,2,596,7,596,2,597,7,597,2,598,7,598,
        2,599,7,599,2,600,7,600,2,601,7,601,2,602,7,602,2,603,7,603,2,604,
        7,604,2,605,7,605,2,606,7,606,2,607,7,607,2,608,7,608,2,609,7,609,
        2,610,7,610,2,611,7,611,2,612,7,612,2,613,7,613,2,614,7,614,2,615,
        7,615,2,616,7,616,2,617,7,617,2,618,7,618,2,619,7,619,2,620,7,620,
        2,621,7,621,2,622,7,622,2,623,7,623,2,624,7,624,2,625,7,625,2,626,
        7,626,2,627,7,627,2,628,7,628,2,629,7,629,2,630,7,630,2,631,7,631,
        2,632,7,632,2,633,7,633,2,634,7,634,2,635,7,635,2,636,7,636,2,637,
        7,637,2,638,7,638,2,639,7,639,2,640,7,640,2,641,7,641,2,642,7,642,
        2,643,7,643,2,644,7,644,2,645,7,645,2,646,7,646,2,647,7,647,2,648,
        7,648,2,649,7,649,2,650,7,650,2,651,7,651,2,652,7,652,2,653,7,653,
        2,654,7,654,2,655,7,655,2,656,7,656,2,657,7,657,2,658,7,658,2,659,
        7,659,2,660,7,660,2,661,7,661,2,662,7,662,2,663,7,663,2,664,7,664,
        2,665,7,665,2,666,7,666,2,667,7,667,2,668,7,668,2,669,7,669,2,670,
        7,670,2,671,7,671,2,672,7,672,2,673,7,673,2,674,7,674,2,675,7,675,
        2,676,7,676,2,677,7,677,2,678,7,678,2,679,7,679,2,680,7,680,2,681,
        7,681,2,682,7,682,2,683,7,683,2,684,7,684,2,685,7,685,2,686,7,686,
        2,687,7,687,2,688,7,688,2,689,7,689,2,690,7,690,2,691,7,691,2,692,
        7,692,2,693,7,693,2,694,7,694,2,695,7,695,2,696,7,696,2,697,7,697,
        2,698,7,698,2,699,7,699,2,700,7,700,2,701,7,701,2,702,7,702,2,703,
        7,703,2,704,7,704,2,705,7,705,2,706,7,706,2,707,7,707,2,708,7,708,
        2,709,7,709,2,710,7,710,2,711,7,711,2,712,7,712,2,713,7,713,2,714,
        7,714,2,715,7,715,2,716,7,716,2,717,7,717,2,718,7,718,2,719,7,719,
        2,720,7,720,2,721,7,721,2,722,7,722,2,723,7,723,2,724,7,724,2,725,
        7,725,2,726,7,726,2,727,7,727,2,728,7,728,2,729,7,729,2,730,7,730,
        2,731,7,731,2,732,7,732,2,733,7,733,2,734,7,734,2,735,7,735,2,736,
        7,736,2,737,7,737,2,738,7,738,2,739,7,739,2,740,7,740,2,741,7,741,
        2,742,7,742,2,743,7,743,2,744,7,744,2,745,7,745,2,746,7,746,2,747,
        7,747,2,748,7,748,2,749,7,749,2,750,7,750,2,751,7,751,2,752,7,752,
        2,753,7,753,2,754,7,754,1,0,5,0,1512,8,0,10,0,12,0,1515,9,0,1,0,
        1,0,1,1,1,1,3,1,1521,8,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
        1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
        1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
        1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
        1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
        1,2,1,2,1,2,1,2,3,2,1601,8,2,1,3,1,3,1,3,1,3,1,3,1,3,3,3,1609,8,
        3,1,3,1,3,1,3,3,3,1614,8,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,3,3,1624,
        8,3,1,4,1,4,1,4,4,4,1629,8,4,11,4,12,4,1630,1,5,1,5,1,5,1,5,3,5,
        1637,8,5,1,5,3,5,1640,8,5,1,6,3,6,1643,8,6,1,6,1,6,1,6,1,6,1,6,3,
        6,1650,8,6,1,6,1,6,1,6,3,6,1655,8,6,1,6,3,6,1658,8,6,1,6,1,6,1,6,
        3,6,1663,8,6,1,6,1,6,1,6,1,6,3,6,1669,8,6,3,6,1671,8,6,1,6,1,6,3,
        6,1675,8,6,1,6,1,6,3,6,1679,8,6,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,
        1688,8,7,1,8,1,8,3,8,1692,8,8,1,8,5,8,1695,8,8,10,8,12,8,1698,9,
        8,1,9,1,9,1,9,3,9,1703,8,9,1,10,1,10,1,10,1,10,1,11,3,11,1710,8,
        11,1,11,1,11,1,11,3,11,1715,8,11,1,12,1,12,1,12,3,12,1720,8,12,1,
        12,1,12,1,12,1,12,1,12,3,12,1727,8,12,1,12,3,12,1730,8,12,1,13,1,
        13,1,13,1,13,3,13,1736,8,13,1,13,3,13,1739,8,13,1,14,1,14,1,14,5,
        14,1744,8,14,10,14,12,14,1747,9,14,1,15,1,15,1,15,1,15,1,15,1,15,
        1,15,3,15,1756,8,15,1,16,1,16,1,16,3,16,1761,8,16,1,16,1,16,1,16,
        3,16,1766,8,16,1,16,1,16,1,16,1,16,1,16,1,16,3,16,1774,8,16,1,16,
        1,16,1,16,1,16,3,16,1780,8,16,1,16,1,16,3,16,1784,8,16,1,16,1,16,
        1,16,3,16,1789,8,16,1,16,1,16,1,16,1,16,1,16,5,16,1796,8,16,10,16,
        12,16,1799,9,16,1,16,1,16,1,16,3,16,1804,8,16,1,16,1,16,5,16,1808,
        8,16,10,16,12,16,1811,9,16,1,16,1,16,1,16,3,16,1816,8,16,1,16,1,
        16,1,16,1,16,1,16,1,16,1,16,3,16,1825,8,16,1,16,1,16,1,16,1,16,3,
        16,1831,8,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,3,16,1840,8,16,1,
        16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,3,16,1852,8,16,1,
        17,1,17,3,17,1856,8,17,1,17,1,17,1,17,1,17,3,17,1862,8,17,5,17,1864,
        8,17,10,17,12,17,1867,9,17,1,18,1,18,1,18,3,18,1872,8,18,1,19,1,
        19,3,19,1876,8,19,1,19,1,19,1,19,3,19,1881,8,19,1,19,3,19,1884,8,
        19,1,19,1,19,1,19,1,19,3,19,1890,8,19,1,19,1,19,1,19,1,19,3,19,1896,
        8,19,1,19,1,19,1,19,1,19,3,19,1902,8,19,1,19,1,19,3,19,1906,8,19,
        1,19,1,19,1,19,3,19,1911,8,19,1,19,1,19,3,19,1915,8,19,1,19,1,19,
        3,19,1919,8,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,
        1,19,1,19,1,19,1,19,3,19,1935,8,19,1,19,1,19,1,19,1,19,1,19,1,19,
        3,19,1943,8,19,1,19,1,19,1,19,1,19,1,19,1,19,3,19,1951,8,19,1,19,
        1,19,1,19,1,19,1,19,3,19,1958,8,19,1,19,1,19,1,19,1,19,1,19,1,19,
        1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,
        1,19,1,19,1,19,1,19,1,19,1,19,3,19,1985,8,19,1,19,1,19,1,19,1,19,
        1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,3,19,2000,8,19,1,19,
        3,19,2003,8,19,1,19,1,19,1,19,1,19,3,19,2009,8,19,1,20,1,20,1,20,
        3,20,2014,8,20,1,21,1,21,1,22,1,22,3,22,2020,8,22,1,22,1,22,1,22,
        3,22,2025,8,22,5,22,2027,8,22,10,22,12,22,2030,9,22,1,23,1,23,3,
        23,2034,8,23,1,23,1,23,3,23,2038,8,23,1,24,1,24,3,24,2042,8,24,1,
        24,1,24,3,24,2046,8,24,1,25,1,25,3,25,2050,8,25,1,25,1,25,3,25,2054,
        8,25,3,25,2056,8,25,1,26,1,26,1,26,1,27,1,27,1,27,1,28,1,28,3,28,
        2066,8,28,1,29,1,29,1,29,1,29,1,29,1,29,3,29,2074,8,29,1,29,1,29,
        1,29,1,29,1,29,3,29,2081,8,29,1,30,1,30,1,30,1,30,1,30,1,30,3,30,
        2089,8,30,1,31,1,31,3,31,2093,8,31,1,31,5,31,2096,8,31,10,31,12,
        31,2099,9,31,1,32,1,32,1,33,1,33,3,33,2105,8,33,1,33,5,33,2108,8,
        33,10,33,12,33,2111,9,33,1,34,1,34,3,34,2115,8,34,1,34,1,34,1,34,
        1,34,1,34,1,34,1,34,1,34,3,34,2125,8,34,1,35,1,35,3,35,2129,8,35,
        1,35,1,35,1,35,3,35,2134,8,35,1,36,3,36,2137,8,36,1,36,3,36,2140,
        8,36,1,36,3,36,2143,8,36,1,36,1,36,1,36,1,36,1,37,3,37,2150,8,37,
        1,37,1,37,1,37,1,38,1,38,3,38,2157,8,38,1,39,1,39,3,39,2161,8,39,
        1,39,1,39,1,39,1,40,1,40,1,40,1,40,1,40,1,40,1,40,1,40,1,40,1,40,
        1,40,1,40,1,40,1,40,1,40,1,40,1,40,1,40,1,40,1,40,3,40,2186,8,40,
        3,40,2188,8,40,1,40,1,40,1,40,1,40,1,40,1,40,3,40,2196,8,40,3,40,
        2198,8,40,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,
        1,41,1,41,1,41,1,41,1,41,1,41,1,41,3,41,2218,8,41,1,42,1,42,3,42,
        2222,8,42,1,42,1,42,5,42,2226,8,42,10,42,12,42,2229,9,42,1,43,1,
        43,1,43,1,43,3,43,2235,8,43,1,44,3,44,2238,8,44,1,44,1,44,3,44,2242,
        8,44,1,44,1,44,1,44,1,44,1,44,3,44,2249,8,44,1,44,3,44,2252,8,44,
        1,44,1,44,1,44,1,44,1,44,1,44,1,44,3,44,2261,8,44,1,45,1,45,1,45,
        5,45,2266,8,45,10,45,12,45,2269,9,45,1,46,1,46,3,46,2273,8,46,1,
        47,3,47,2276,8,47,1,47,1,47,1,48,3,48,2281,8,48,1,48,1,48,1,49,1,
        49,3,49,2287,8,49,1,49,3,49,2290,8,49,1,50,1,50,3,50,2294,8,50,1,
        51,1,51,1,51,1,51,3,51,2300,8,51,1,51,3,51,2303,8,51,1,51,1,51,1,
        52,3,52,2308,8,52,1,52,1,52,3,52,2312,8,52,1,52,1,52,1,52,1,52,1,
        52,5,52,2319,8,52,10,52,12,52,2322,9,52,3,52,2324,8,52,1,52,1,52,
        5,52,2328,8,52,10,52,12,52,2331,9,52,1,52,1,52,1,53,1,53,3,53,2337,
        8,53,1,54,1,54,1,54,1,54,3,54,2343,8,54,1,55,3,55,2346,8,55,1,55,
        1,55,3,55,2350,8,55,1,55,1,55,1,55,1,55,1,55,5,55,2357,8,55,10,55,
        12,55,2360,9,55,3,55,2362,8,55,1,55,1,55,1,55,1,55,5,55,2368,8,55,
        10,55,12,55,2371,9,55,1,55,1,55,1,56,3,56,2376,8,56,1,56,1,56,3,
        56,2380,8,56,1,56,1,56,1,56,1,56,1,56,1,56,1,57,1,57,3,57,2390,8,
        57,1,57,3,57,2393,8,57,1,58,4,58,2396,8,58,11,58,12,58,2397,1,59,
        1,59,1,59,1,59,1,59,1,59,3,59,2406,8,59,1,59,1,59,1,59,1,59,1,59,
        1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,3,59,2421,8,59,1,60,3,60,
        2424,8,60,1,60,3,60,2427,8,60,1,60,1,60,1,60,3,60,2432,8,60,1,60,
        1,60,5,60,2436,8,60,10,60,12,60,2439,9,60,1,60,1,60,1,60,1,60,1,
        60,5,60,2446,8,60,10,60,12,60,2449,9,60,1,60,1,60,1,60,1,60,1,60,
        5,60,2456,8,60,10,60,12,60,2459,9,60,3,60,2461,8,60,1,60,3,60,2464,
        8,60,1,61,1,61,3,61,2468,8,61,1,61,1,61,1,61,1,61,1,61,1,61,3,61,
        2476,8,61,1,62,1,62,1,62,1,62,1,63,1,63,1,63,1,63,1,63,1,63,1,63,
        3,63,2489,8,63,1,64,1,64,3,64,2493,8,64,1,64,5,64,2496,8,64,10,64,
        12,64,2499,9,64,1,65,1,65,1,65,1,65,1,65,1,65,3,65,2507,8,65,1,66,
        1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,67,1,67,1,67,1,67,1,67,5,67,
        2522,8,67,10,67,12,67,2525,9,67,1,67,1,67,1,68,1,68,1,68,1,68,1,
        68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,3,68,2543,8,68,1,
        69,1,69,1,69,1,69,1,69,1,69,1,69,3,69,2552,8,69,1,69,3,69,2555,8,
        69,1,70,1,70,1,70,1,70,1,70,1,70,3,70,2563,8,70,1,71,1,71,1,71,1,
        71,1,71,3,71,2570,8,71,3,71,2572,8,71,1,72,1,72,1,72,1,73,1,73,3,
        73,2579,8,73,1,73,5,73,2582,8,73,10,73,12,73,2585,9,73,1,74,1,74,
        1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,2598,8,74,1,75,
        1,75,3,75,2602,8,75,1,75,1,75,1,76,1,76,3,76,2608,8,76,1,76,1,76,
        1,77,1,77,3,77,2614,8,77,1,77,1,77,1,78,1,78,3,78,2620,8,78,1,78,
        1,78,1,79,1,79,3,79,2626,8,79,1,79,1,79,1,80,1,80,3,80,2632,8,80,
        1,80,1,80,1,81,3,81,2637,8,81,1,81,1,81,3,81,2641,8,81,1,81,1,81,
        1,82,1,82,1,83,1,83,3,83,2649,8,83,1,83,1,83,1,84,1,84,3,84,2655,
        8,84,1,84,1,84,1,85,1,85,3,85,2661,8,85,1,85,1,85,1,86,1,86,3,86,
        2667,8,86,1,86,1,86,1,87,3,87,2672,8,87,1,87,3,87,2675,8,87,1,87,
        3,87,2678,8,87,1,87,1,87,1,87,1,87,1,88,1,88,1,88,3,88,2687,8,88,
        1,88,3,88,2690,8,88,1,89,1,89,1,89,1,89,1,90,1,90,1,90,1,90,1,91,
        3,91,2701,8,91,1,91,1,91,3,91,2705,8,91,1,91,1,91,1,91,1,91,1,91,
        1,91,1,91,1,91,1,91,3,91,2716,8,91,1,91,1,91,1,92,1,92,1,92,1,93,
        3,93,2724,8,93,1,93,1,93,3,93,2728,8,93,1,93,1,93,1,93,1,93,1,93,
        1,93,1,93,3,93,2737,8,93,1,93,3,93,2740,8,93,1,93,1,93,1,93,1,93,
        3,93,2746,8,93,3,93,2748,8,93,1,93,1,93,3,93,2752,8,93,1,93,1,93,
        1,93,1,94,1,94,3,94,2759,8,94,1,94,1,94,1,95,1,95,1,95,1,95,1,95,
        1,95,1,95,5,95,2770,8,95,10,95,12,95,2773,9,95,1,95,1,95,1,95,1,
        95,3,95,2779,8,95,1,95,1,95,5,95,2783,8,95,10,95,12,95,2786,9,95,
        3,95,2788,8,95,1,96,1,96,1,96,1,96,1,96,1,96,1,96,1,96,1,96,1,96,
        1,96,1,96,1,96,1,96,1,96,3,96,2805,8,96,1,97,1,97,1,97,1,97,1,97,
        1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,3,97,
        2824,8,97,1,98,1,98,3,98,2828,8,98,1,98,1,98,1,99,1,99,3,99,2834,
        8,99,1,99,1,99,1,100,1,100,3,100,2840,8,100,1,100,1,100,1,101,1,
        101,3,101,2846,8,101,1,101,1,101,1,102,3,102,2851,8,102,1,102,1,
        102,1,102,1,102,1,102,3,102,2858,8,102,1,103,1,103,1,103,1,103,1,
        103,3,103,2865,8,103,1,103,5,103,2868,8,103,10,103,12,103,2871,9,
        103,3,103,2873,8,103,1,104,1,104,3,104,2877,8,104,1,105,1,105,3,
        105,2881,8,105,1,105,1,105,1,106,3,106,2886,8,106,1,106,1,106,3,
        106,2890,8,106,1,106,1,106,3,106,2894,8,106,1,107,1,107,1,107,1,
        107,3,107,2900,8,107,1,107,5,107,2903,8,107,10,107,12,107,2906,9,
        107,3,107,2908,8,107,1,108,1,108,3,108,2912,8,108,1,108,1,108,1,
        109,1,109,3,109,2918,8,109,1,109,1,109,3,109,2922,8,109,1,110,1,
        110,3,110,2926,8,110,1,110,1,110,1,111,1,111,1,111,1,111,3,111,2934,
        8,111,1,111,1,111,1,112,1,112,1,112,1,112,3,112,2942,8,112,1,113,
        1,113,1,113,1,113,1,113,5,113,2949,8,113,10,113,12,113,2952,9,113,
        1,114,1,114,1,114,1,114,1,115,1,115,3,115,2960,8,115,1,115,1,115,
        1,116,1,116,1,116,1,116,1,116,1,117,1,117,1,117,1,117,3,117,2973,
        8,117,1,117,3,117,2976,8,117,1,118,3,118,2979,8,118,1,118,1,118,
        5,118,2983,8,118,10,118,12,118,2986,9,118,1,118,1,118,1,118,1,118,
        1,118,3,118,2993,8,118,1,118,1,118,1,118,3,118,2998,8,118,1,118,
        3,118,3001,8,118,1,118,3,118,3004,8,118,1,118,3,118,3007,8,118,1,
        118,3,118,3010,8,118,3,118,3012,8,118,1,118,1,118,1,118,1,118,3,
        118,3018,8,118,3,118,3020,8,118,1,119,1,119,1,119,1,119,1,119,1,
        120,1,120,1,121,1,121,1,121,1,122,1,122,1,122,1,122,3,122,3036,8,
        122,1,122,1,122,1,122,1,122,1,122,3,122,3043,8,122,1,122,3,122,3046,
        8,122,3,122,3048,8,122,3,122,3050,8,122,1,123,1,123,1,123,1,123,
        1,123,1,123,1,123,1,123,3,123,3060,8,123,3,123,3062,8,123,1,124,
        1,124,3,124,3066,8,124,1,124,3,124,3069,8,124,1,124,3,124,3072,8,
        124,1,124,1,124,3,124,3076,8,124,1,124,1,124,3,124,3080,8,124,1,
        124,1,124,1,124,3,124,3085,8,124,1,124,3,124,3088,8,124,1,124,3,
        124,3091,8,124,1,125,1,125,1,126,1,126,3,126,3097,8,126,1,126,3,
        126,3100,8,126,1,126,1,126,1,127,1,127,1,127,5,127,3107,8,127,10,
        127,12,127,3110,9,127,1,128,1,128,1,128,1,129,1,129,1,129,1,129,
        3,129,3119,8,129,1,129,3,129,3122,8,129,1,129,3,129,3125,8,129,1,
        130,1,130,3,130,3129,8,130,1,130,1,130,1,130,1,130,3,130,3135,8,
        130,1,130,5,130,3138,8,130,10,130,12,130,3141,9,130,1,131,1,131,
        3,131,3145,8,131,1,131,1,131,1,131,3,131,3150,8,131,5,131,3152,8,
        131,10,131,12,131,3155,9,131,1,132,1,132,1,132,1,132,3,132,3161,
        8,132,1,133,1,133,1,133,1,133,1,133,1,133,1,134,1,134,1,134,3,134,
        3172,8,134,1,134,3,134,3175,8,134,1,134,3,134,3178,8,134,1,134,3,
        134,3181,8,134,1,134,1,134,3,134,3185,8,134,1,134,3,134,3188,8,134,
        1,134,3,134,3191,8,134,1,134,1,134,1,134,1,134,3,134,3197,8,134,
        1,134,3,134,3200,8,134,1,134,3,134,3203,8,134,1,134,3,134,3206,8,
        134,1,134,3,134,3209,8,134,1,134,1,134,3,134,3213,8,134,1,134,3,
        134,3216,8,134,1,134,3,134,3219,8,134,1,135,1,135,1,136,1,136,1,
        137,1,137,1,137,1,138,1,138,1,138,3,138,3231,8,138,1,139,1,139,1,
        139,1,139,1,139,1,139,3,139,3239,8,139,1,140,1,140,1,140,1,140,1,
        140,1,140,1,141,1,141,1,141,1,141,1,141,1,142,1,142,1,142,3,142,
        3255,8,142,1,142,3,142,3258,8,142,1,142,1,142,3,142,3262,8,142,1,
        143,1,143,3,143,3266,8,143,1,143,1,143,1,144,1,144,1,144,1,144,3,
        144,3274,8,144,1,144,1,144,1,144,1,144,1,144,1,144,3,144,3282,8,
        144,5,144,3284,8,144,10,144,12,144,3287,9,144,1,145,1,145,1,145,
        1,145,1,145,1,146,1,146,1,146,1,146,1,146,1,147,1,147,1,147,1,147,
        1,147,1,148,1,148,3,148,3306,8,148,1,148,3,148,3309,8,148,1,148,
        1,148,3,148,3313,8,148,1,148,1,148,1,148,1,148,3,148,3319,8,148,
        1,149,1,149,3,149,3323,8,149,1,149,3,149,3326,8,149,1,150,1,150,
        1,150,1,150,1,150,1,150,1,150,3,150,3335,8,150,1,150,1,150,1,150,
        1,150,1,150,1,150,1,150,1,150,3,150,3345,8,150,1,151,3,151,3348,
        8,151,1,151,1,151,3,151,3352,8,151,1,151,3,151,3355,8,151,1,152,
        1,152,3,152,3359,8,152,1,152,1,152,1,152,3,152,3364,8,152,1,152,
        3,152,3367,8,152,1,152,5,152,3370,8,152,10,152,12,152,3373,9,152,
        1,153,1,153,1,153,3,153,3378,8,153,1,153,1,153,1,154,1,154,1,154,
        1,154,1,154,3,154,3387,8,154,1,155,1,155,5,155,3391,8,155,10,155,
        12,155,3394,9,155,1,155,1,155,3,155,3398,8,155,1,155,3,155,3401,
        8,155,1,155,3,155,3404,8,155,1,155,3,155,3407,8,155,1,155,3,155,
        3410,8,155,1,155,3,155,3413,8,155,1,155,3,155,3416,8,155,1,156,1,
        156,1,157,1,157,1,158,1,158,1,158,1,159,1,159,1,159,1,160,1,160,
        1,160,3,160,3431,8,160,1,161,1,161,3,161,3435,8,161,1,162,1,162,
        1,162,1,162,3,162,3441,8,162,1,162,3,162,3444,8,162,1,162,3,162,
        3447,8,162,1,162,1,162,1,162,1,162,3,162,3453,8,162,1,162,1,162,
        1,162,3,162,3458,8,162,5,162,3460,8,162,10,162,12,162,3463,9,162,
        3,162,3465,8,162,1,163,1,163,1,163,1,163,1,163,3,163,3472,8,163,
        3,163,3474,8,163,1,163,1,163,1,164,1,164,1,164,1,165,1,165,1,165,
        1,165,1,166,1,166,1,166,1,166,5,166,3489,8,166,10,166,12,166,3492,
        9,166,1,167,1,167,1,167,1,167,1,168,1,168,1,168,1,168,1,169,3,169,
        3503,8,169,1,169,1,169,1,169,3,169,3508,8,169,1,169,3,169,3511,8,
        169,1,169,3,169,3514,8,169,1,170,1,170,1,170,3,170,3519,8,170,1,
        171,1,171,1,172,1,172,3,172,3525,8,172,1,173,1,173,1,173,1,173,1,
        173,1,173,1,173,1,173,1,173,1,173,1,173,1,173,1,173,1,173,3,173,
        3541,8,173,1,174,1,174,1,174,1,174,1,174,1,175,1,175,1,175,1,175,
        1,175,1,175,1,175,1,175,1,175,1,175,1,175,1,175,1,175,3,175,3561,
        8,175,1,176,1,176,1,176,1,176,1,176,1,176,1,176,3,176,3570,8,176,
        1,177,1,177,3,177,3574,8,177,1,177,1,177,1,177,5,177,3579,8,177,
        10,177,12,177,3582,9,177,1,178,1,178,3,178,3586,8,178,1,178,1,178,
        1,178,1,179,1,179,1,179,1,179,3,179,3595,8,179,1,179,1,179,1,179,
        1,179,1,179,1,179,1,179,1,179,3,179,3605,8,179,1,180,1,180,1,180,
        1,181,1,181,1,181,1,181,1,182,1,182,1,183,1,183,1,183,3,183,3619,
        8,183,1,184,1,184,1,184,5,184,3624,8,184,10,184,12,184,3627,9,184,
        1,185,1,185,1,185,1,185,5,185,3633,8,185,10,185,12,185,3636,9,185,
        1,186,1,186,1,186,1,187,1,187,1,187,3,187,3644,8,187,1,187,1,187,
        1,188,1,188,3,188,3650,8,188,1,189,1,189,4,189,3654,8,189,11,189,
        12,189,3655,1,190,1,190,1,190,1,190,3,190,3662,8,190,1,190,3,190,
        3665,8,190,1,190,1,190,1,190,1,190,3,190,3671,8,190,1,191,1,191,
        1,192,1,192,1,192,3,192,3678,8,192,1,193,1,193,3,193,3682,8,193,
        1,193,1,193,5,193,3686,8,193,10,193,12,193,3689,9,193,1,194,1,194,
        1,194,3,194,3694,8,194,3,194,3696,8,194,1,195,3,195,3699,8,195,1,
        195,1,195,3,195,3703,8,195,1,196,1,196,1,196,1,197,1,197,1,197,1,
        197,1,197,3,197,3713,8,197,1,197,1,197,1,197,3,197,3718,8,197,1,
        197,5,197,3721,8,197,10,197,12,197,3724,9,197,1,198,1,198,5,198,
        3728,8,198,10,198,12,198,3731,9,198,1,199,1,199,1,199,1,199,1,199,
        1,199,3,199,3739,8,199,1,199,1,199,1,199,1,199,1,199,1,199,3,199,
        3747,8,199,1,199,1,199,1,199,3,199,3752,8,199,1,200,1,200,3,200,
        3756,8,200,1,200,1,200,1,200,1,200,3,200,3762,8,200,1,200,3,200,
        3765,8,200,1,201,3,201,3768,8,201,1,201,1,201,3,201,3772,8,201,1,
        202,1,202,3,202,3776,8,202,1,202,1,202,1,203,1,203,1,203,1,203,1,
        203,1,203,3,203,3786,8,203,1,204,1,204,3,204,3790,8,204,1,204,3,
        204,3793,8,204,1,204,3,204,3796,8,204,1,204,3,204,3799,8,204,1,205,
        1,205,1,205,3,205,3804,8,205,1,205,1,205,1,206,1,206,3,206,3810,
        8,206,1,206,3,206,3813,8,206,1,206,1,206,1,206,1,206,3,206,3819,
        8,206,1,206,3,206,3822,8,206,3,206,3824,8,206,1,207,1,207,1,207,
        3,207,3829,8,207,1,207,1,207,1,208,1,208,1,208,1,208,1,208,1,208,
        1,208,1,208,3,208,3841,8,208,1,209,1,209,1,209,1,209,1,209,5,209,
        3848,8,209,10,209,12,209,3851,9,209,1,209,1,209,1,210,1,210,1,210,
        1,210,1,210,1,210,1,210,1,210,3,210,3863,8,210,1,210,3,210,3866,
        8,210,1,210,1,210,1,210,3,210,3871,8,210,1,210,1,210,1,210,1,210,
        1,210,3,210,3878,8,210,1,211,1,211,3,211,3882,8,211,1,211,3,211,
        3885,8,211,1,212,1,212,1,212,1,212,3,212,3891,8,212,1,213,1,213,
        1,213,1,213,1,214,1,214,1,214,1,214,1,215,1,215,1,215,1,215,3,215,
        3905,8,215,1,216,1,216,1,217,1,217,1,217,3,217,3912,8,217,1,217,
        1,217,1,218,1,218,1,218,5,218,3919,8,218,10,218,12,218,3922,9,218,
        1,219,1,219,1,219,3,219,3927,8,219,1,219,1,219,1,219,1,219,1,219,
        1,219,1,219,3,219,3936,8,219,1,219,1,219,3,219,3940,8,219,1,219,
        1,219,3,219,3944,8,219,1,220,1,220,1,221,1,221,1,222,1,222,1,222,
        1,222,3,222,3954,8,222,3,222,3956,8,222,1,223,1,223,1,223,1,223,
        1,223,1,223,3,223,3964,8,223,1,224,1,224,1,224,5,224,3969,8,224,
        10,224,12,224,3972,9,224,1,225,1,225,3,225,3976,8,225,1,226,3,226,
        3979,8,226,1,226,1,226,3,226,3983,8,226,1,226,3,226,3986,8,226,1,
        226,1,226,1,226,1,226,3,226,3992,8,226,1,226,3,226,3995,8,226,1,
        226,3,226,3998,8,226,1,227,1,227,1,227,1,227,3,227,4004,8,227,1,
        228,1,228,1,228,5,228,4009,8,228,10,228,12,228,4012,9,228,1,228,
        1,228,3,228,4016,8,228,1,228,1,228,3,228,4020,8,228,1,228,3,228,
        4023,8,228,1,228,3,228,4026,8,228,1,228,3,228,4029,8,228,3,228,4031,
        8,228,1,229,1,229,3,229,4035,8,229,1,230,1,230,1,230,1,230,1,230,
        3,230,4042,8,230,1,231,1,231,1,231,1,231,3,231,4048,8,231,1,231,
        1,231,3,231,4052,8,231,1,231,1,231,1,231,3,231,4057,8,231,1,231,
        3,231,4060,8,231,1,231,3,231,4063,8,231,1,231,3,231,4066,8,231,3,
        231,4068,8,231,1,231,1,231,1,231,3,231,4073,8,231,1,232,1,232,1,
        232,1,232,1,232,5,232,4080,8,232,10,232,12,232,4083,9,232,1,232,
        1,232,1,232,1,232,1,232,1,232,3,232,4091,8,232,1,233,1,233,3,233,
        4095,8,233,1,233,1,233,1,234,1,234,3,234,4101,8,234,1,234,3,234,
        4104,8,234,1,234,3,234,4107,8,234,1,235,1,235,1,235,1,235,3,235,
        4113,8,235,1,235,1,235,1,235,1,235,1,235,3,235,4120,8,235,3,235,
        4122,8,235,1,235,1,235,1,235,1,235,1,235,1,235,3,235,4130,8,235,
        1,235,1,235,1,235,1,235,3,235,4136,8,235,3,235,4138,8,235,1,236,
        1,236,1,236,1,237,1,237,1,237,1,237,1,237,3,237,4148,8,237,3,237,
        4150,8,237,1,238,1,238,1,238,1,238,1,238,1,238,1,238,5,238,4159,
        8,238,10,238,12,238,4162,9,238,1,238,1,238,1,238,3,238,4167,8,238,
        1,238,1,238,1,238,1,238,1,238,3,238,4174,8,238,1,239,1,239,1,239,
        1,239,1,239,1,239,3,239,4182,8,239,1,240,1,240,3,240,4186,8,240,
        1,240,1,240,3,240,4190,8,240,1,240,3,240,4193,8,240,3,240,4195,8,
        240,1,241,1,241,1,241,1,241,1,241,1,241,3,241,4203,8,241,1,242,1,
        242,1,242,1,243,1,243,1,243,1,243,3,243,4212,8,243,1,243,1,243,1,
        243,1,244,1,244,1,244,1,244,3,244,4221,8,244,1,245,1,245,1,245,1,
        245,1,245,3,245,4228,8,245,1,246,1,246,1,246,5,246,4233,8,246,10,
        246,12,246,4236,9,246,1,247,1,247,1,247,1,247,1,247,1,247,1,247,
        1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,
        1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,
        1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,
        1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,
        1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,
        1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,
        1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,
        1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,
        1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,
        1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,
        1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,
        3,247,4366,8,247,1,248,1,248,1,249,1,249,1,250,1,250,1,251,1,251,
        1,252,1,252,1,253,1,253,1,254,1,254,1,255,1,255,1,256,1,256,1,257,
        1,257,1,258,1,258,1,259,1,259,1,260,1,260,1,261,1,261,1,262,1,262,
        1,263,1,263,1,264,1,264,1,265,1,265,1,266,1,266,1,267,1,267,1,268,
        1,268,1,269,1,269,1,270,1,270,1,271,1,271,1,272,1,272,1,273,1,273,
        3,273,4420,8,273,1,274,1,274,1,275,1,275,1,275,3,275,4427,8,275,
        1,276,1,276,3,276,4431,8,276,1,277,1,277,1,277,1,277,1,277,1,277,
        1,277,1,277,1,277,1,277,1,277,1,277,1,277,1,277,3,277,4447,8,277,
        1,278,1,278,1,279,1,279,1,280,1,280,1,280,1,280,5,280,4457,8,280,
        10,280,12,280,4460,9,280,3,280,4462,8,280,1,280,1,280,1,281,1,281,
        1,281,1,281,1,281,1,281,5,281,4472,8,281,10,281,12,281,4475,9,281,
        1,281,3,281,4478,8,281,1,282,1,282,1,282,1,282,3,282,4484,8,282,
        1,282,1,282,1,282,1,282,1,282,3,282,4491,8,282,1,282,1,282,1,282,
        1,282,1,282,3,282,4498,8,282,1,282,1,282,1,282,1,282,1,282,3,282,
        4505,8,282,1,282,1,282,1,282,1,282,1,282,3,282,4512,8,282,1,282,
        1,282,1,282,1,282,1,282,3,282,4519,8,282,1,282,1,282,1,282,1,282,
        1,282,3,282,4526,8,282,1,282,3,282,4529,8,282,1,283,1,283,1,283,
        5,283,4534,8,283,10,283,12,283,4537,9,283,1,284,1,284,1,284,5,284,
        4542,8,284,10,284,12,284,4545,9,284,1,285,1,285,1,285,5,285,4550,
        8,285,10,285,12,285,4553,9,285,1,286,1,286,1,287,1,287,1,287,5,287,
        4560,8,287,10,287,12,287,4563,9,287,1,288,1,288,1,288,3,288,4568,
        8,288,1,288,1,288,3,288,4572,8,288,1,288,3,288,4575,8,288,1,288,
        3,288,4578,8,288,1,288,3,288,4581,8,288,1,288,3,288,4584,8,288,1,
        288,3,288,4587,8,288,1,289,1,289,1,289,3,289,4592,8,289,1,289,3,
        289,4595,8,289,1,290,1,290,1,290,1,290,1,290,3,290,4602,8,290,1,
        290,1,290,5,290,4606,8,290,10,290,12,290,4609,9,290,1,291,1,291,
        1,291,1,291,1,292,1,292,1,292,1,292,1,293,1,293,1,293,1,293,1,294,
        1,294,1,294,1,294,1,295,1,295,1,295,5,295,4630,8,295,10,295,12,295,
        4633,9,295,1,296,1,296,1,297,1,297,3,297,4639,8,297,1,297,3,297,
        4642,8,297,1,297,1,297,1,298,1,298,1,298,5,298,4649,8,298,10,298,
        12,298,4652,9,298,1,299,1,299,1,299,3,299,4657,8,299,1,300,1,300,
        1,300,1,300,1,301,1,301,1,301,1,301,1,302,1,302,1,302,1,302,1,303,
        1,303,1,304,1,304,1,304,1,304,1,304,3,304,4678,8,304,1,304,1,304,
        1,304,1,304,3,304,4684,8,304,1,305,1,305,1,305,1,305,3,305,4690,
        8,305,1,306,1,306,1,306,5,306,4695,8,306,10,306,12,306,4698,9,306,
        1,307,1,307,1,307,1,307,1,307,3,307,4705,8,307,1,307,1,307,1,307,
        1,307,3,307,4711,8,307,1,307,1,307,1,307,1,307,1,307,1,307,1,307,
        1,307,1,307,1,307,3,307,4723,8,307,3,307,4725,8,307,1,308,1,308,
        1,308,1,308,3,308,4731,8,308,1,308,1,308,3,308,4735,8,308,3,308,
        4737,8,308,1,309,1,309,3,309,4741,8,309,1,309,1,309,1,310,1,310,
        1,310,1,310,1,310,1,310,1,310,3,310,4752,8,310,1,311,1,311,1,311,
        3,311,4757,8,311,1,311,1,311,1,311,1,311,3,311,4763,8,311,1,311,
        1,311,1,311,1,311,1,311,3,311,4770,8,311,1,311,3,311,4773,8,311,
        1,311,3,311,4776,8,311,1,311,1,311,1,311,1,311,3,311,4782,8,311,
        3,311,4784,8,311,1,311,1,311,1,311,1,311,1,311,1,311,3,311,4792,
        8,311,1,311,3,311,4795,8,311,3,311,4797,8,311,3,311,4799,8,311,1,
        312,1,312,1,312,5,312,4804,8,312,10,312,12,312,4807,9,312,1,313,
        1,313,1,313,1,313,1,313,1,313,1,313,1,313,3,313,4817,8,313,1,313,
        3,313,4820,8,313,3,313,4822,8,313,1,313,1,313,3,313,4826,8,313,1,
        313,1,313,1,313,3,313,4831,8,313,3,313,4833,8,313,1,313,1,313,1,
        313,3,313,4838,8,313,1,313,1,313,1,313,1,313,3,313,4844,8,313,1,
        313,3,313,4847,8,313,3,313,4849,8,313,1,313,1,313,3,313,4853,8,313,
        1,313,3,313,4856,8,313,1,313,1,313,1,313,1,313,1,313,1,313,1,313,
        3,313,4865,8,313,1,313,1,313,1,313,1,313,1,313,1,313,1,313,3,313,
        4874,8,313,1,313,1,313,1,313,1,313,3,313,4880,8,313,3,313,4882,8,
        313,3,313,4884,8,313,1,314,1,314,1,314,1,314,1,314,1,314,1,314,3,
        314,4893,8,314,1,314,1,314,3,314,4897,8,314,1,314,1,314,1,314,1,
        314,3,314,4903,8,314,1,314,3,314,4906,8,314,3,314,4908,8,314,1,314,
        1,314,1,314,1,314,1,314,1,314,1,314,1,314,1,314,3,314,4919,8,314,
        1,314,1,314,1,314,3,314,4924,8,314,1,314,1,314,1,314,3,314,4929,
        8,314,1,314,1,314,1,314,1,314,3,314,4935,8,314,3,314,4937,8,314,
        1,314,1,314,3,314,4941,8,314,3,314,4943,8,314,1,315,1,315,1,315,
        1,316,1,316,1,316,3,316,4951,8,316,1,316,1,316,3,316,4955,8,316,
        1,316,1,316,1,317,3,317,4960,8,317,1,317,3,317,4963,8,317,1,317,
        5,317,4966,8,317,10,317,12,317,4969,9,317,1,317,1,317,3,317,4973,
        8,317,1,318,1,318,1,318,1,318,3,318,4979,8,318,1,319,1,319,1,319,
        1,319,1,320,1,320,1,320,3,320,4988,8,320,1,321,1,321,1,321,1,321,
        1,321,1,321,1,321,1,321,1,321,4,321,4999,8,321,11,321,12,321,5000,
        1,322,1,322,1,322,1,322,1,322,1,322,1,322,1,322,1,322,1,322,3,322,
        5013,8,322,1,322,1,322,1,322,3,322,5018,8,322,1,322,1,322,1,322,
        1,322,1,322,1,322,3,322,5026,8,322,1,322,1,322,1,322,1,322,3,322,
        5032,8,322,3,322,5034,8,322,1,322,1,322,1,322,1,322,1,322,3,322,
        5041,8,322,3,322,5043,8,322,1,323,1,323,1,323,1,323,1,323,3,323,
        5050,8,323,1,324,1,324,1,324,3,324,5055,8,324,1,324,1,324,1,325,
        1,325,1,325,1,325,1,325,1,325,1,325,3,325,5066,8,325,1,325,1,325,
        1,325,3,325,5071,8,325,3,325,5073,8,325,1,325,1,325,3,325,5077,8,
        325,1,325,1,325,1,325,1,325,3,325,5083,8,325,1,325,3,325,5086,8,
        325,1,325,3,325,5089,8,325,1,325,1,325,1,325,1,325,1,325,1,325,1,
        325,1,325,3,325,5099,8,325,3,325,5101,8,325,1,326,1,326,1,326,1,
        326,3,326,5107,8,326,1,327,1,327,1,327,1,328,1,328,1,328,1,329,1,
        329,1,329,1,329,1,329,3,329,5120,8,329,1,329,1,329,3,329,5124,8,
        329,1,330,1,330,1,330,3,330,5129,8,330,1,331,1,331,1,331,1,332,1,
        332,1,332,1,332,1,332,1,332,1,332,1,332,1,332,1,332,5,332,5144,8,
        332,10,332,12,332,5147,9,332,1,333,1,333,1,333,3,333,5152,8,333,
        1,333,1,333,1,333,1,333,1,333,1,333,1,333,3,333,5161,8,333,1,333,
        1,333,1,333,1,333,1,333,1,333,3,333,5169,8,333,1,333,1,333,3,333,
        5173,8,333,1,333,1,333,1,333,1,333,3,333,5179,8,333,1,333,1,333,
        1,333,1,333,1,333,1,333,1,333,1,333,3,333,5189,8,333,1,333,1,333,
        3,333,5193,8,333,1,334,1,334,1,335,1,335,1,335,5,335,5200,8,335,
        10,335,12,335,5203,9,335,1,336,1,336,3,336,5207,8,336,1,336,1,336,
        1,336,1,336,3,336,5213,8,336,3,336,5215,8,336,1,336,1,336,3,336,
        5219,8,336,1,336,1,336,1,336,1,336,1,336,1,336,1,336,1,336,1,336,
        3,336,5230,8,336,1,336,1,336,1,336,1,336,1,336,3,336,5237,8,336,
        1,336,1,336,1,336,1,336,3,336,5243,8,336,1,336,1,336,3,336,5247,
        8,336,1,337,1,337,1,337,3,337,5252,8,337,1,337,1,337,1,337,3,337,
        5257,8,337,1,337,1,337,1,337,1,337,1,337,1,337,3,337,5265,8,337,
        1,338,1,338,3,338,5269,8,338,1,338,5,338,5272,8,338,10,338,12,338,
        5275,9,338,1,339,1,339,1,339,1,339,1,339,1,339,3,339,5283,8,339,
        1,340,1,340,1,340,1,340,1,340,1,340,1,340,1,340,1,340,1,340,1,340,
        3,340,5296,8,340,3,340,5298,8,340,1,341,1,341,1,341,1,341,1,341,
        1,341,1,341,1,341,1,341,1,341,1,341,1,341,3,341,5312,8,341,1,341,
        1,341,1,341,1,341,1,341,1,341,1,341,3,341,5321,8,341,3,341,5323,
        8,341,1,342,1,342,1,342,5,342,5328,8,342,10,342,12,342,5331,9,342,
        1,343,1,343,3,343,5335,8,343,1,344,1,344,3,344,5339,8,344,1,344,
        1,344,1,344,3,344,5344,8,344,1,344,1,344,1,344,1,344,5,344,5350,
        8,344,10,344,12,344,5353,9,344,1,344,1,344,1,344,1,344,3,344,5359,
        8,344,1,344,1,344,3,344,5363,8,344,1,344,1,344,1,344,1,344,3,344,
        5369,8,344,1,344,1,344,1,344,5,344,5374,8,344,10,344,12,344,5377,
        9,344,3,344,5379,8,344,1,345,1,345,1,345,1,345,1,346,3,346,5386,
        8,346,1,346,3,346,5389,8,346,1,346,1,346,1,346,1,346,3,346,5395,
        8,346,1,347,1,347,1,347,1,347,1,347,1,348,1,348,1,348,1,348,1,348,
        1,348,1,348,1,348,1,348,1,348,3,348,5412,8,348,1,349,1,349,1,349,
        3,349,5417,8,349,1,350,1,350,1,351,1,351,1,351,1,351,1,351,1,351,
        1,351,5,351,5428,8,351,10,351,12,351,5431,9,351,3,351,5433,8,351,
        1,352,1,352,1,352,1,352,1,352,1,352,1,352,1,352,1,352,3,352,5444,
        8,352,3,352,5446,8,352,1,353,1,353,1,354,1,354,3,354,5452,8,354,
        1,355,1,355,1,355,1,355,1,355,1,356,1,356,1,356,1,356,1,356,5,356,
        5464,8,356,10,356,12,356,5467,9,356,1,357,1,357,1,357,1,358,1,358,
        1,358,1,358,1,358,1,358,1,358,1,358,1,358,1,358,1,358,3,358,5483,
        8,358,1,358,1,358,1,358,3,358,5488,8,358,1,358,3,358,5491,8,358,
        1,358,1,358,3,358,5495,8,358,1,358,3,358,5498,8,358,1,358,1,358,
        1,358,1,358,1,358,1,358,3,358,5506,8,358,1,358,1,358,1,358,1,358,
        3,358,5512,8,358,1,358,1,358,1,358,3,358,5517,8,358,1,358,3,358,
        5520,8,358,3,358,5522,8,358,1,359,1,359,3,359,5526,8,359,1,359,1,
        359,1,359,3,359,5531,8,359,3,359,5533,8,359,1,360,1,360,1,360,1,
        361,1,361,1,361,1,361,1,361,1,361,1,361,3,361,5545,8,361,1,362,1,
        362,5,362,5549,8,362,10,362,12,362,5552,9,362,1,363,1,363,1,363,
        1,363,1,363,1,363,1,363,1,363,1,363,1,363,1,363,3,363,5565,8,363,
        1,363,1,363,1,363,1,363,1,363,1,363,1,363,1,363,1,363,1,363,3,363,
        5577,8,363,1,363,1,363,3,363,5581,8,363,3,363,5583,8,363,1,364,1,
        364,1,364,1,364,1,364,1,364,3,364,5591,8,364,1,365,1,365,3,365,5595,
        8,365,1,365,1,365,1,366,1,366,1,366,1,366,1,366,3,366,5604,8,366,
        1,367,1,367,1,367,1,367,1,368,1,368,1,368,1,368,1,368,1,368,1,368,
        3,368,5617,8,368,1,369,1,369,1,369,3,369,5622,8,369,1,370,1,370,
        3,370,5626,8,370,1,370,1,370,3,370,5630,8,370,1,370,3,370,5633,8,
        370,1,371,1,371,3,371,5637,8,371,1,371,1,371,3,371,5641,8,371,1,
        371,3,371,5644,8,371,1,372,1,372,1,372,3,372,5649,8,372,1,372,3,
        372,5652,8,372,1,373,1,373,1,373,1,373,3,373,5658,8,373,1,373,3,
        373,5661,8,373,1,374,1,374,1,374,1,374,3,374,5667,8,374,1,374,3,
        374,5670,8,374,1,375,1,375,1,375,1,375,1,375,1,376,1,376,1,376,1,
        377,1,377,1,377,1,377,1,377,1,378,1,378,1,378,1,378,1,378,1,379,
        1,379,1,379,1,379,1,379,1,380,1,380,3,380,5697,8,380,1,380,1,380,
        1,380,1,380,3,380,5703,8,380,1,380,3,380,5706,8,380,1,381,1,381,
        1,381,1,381,1,382,1,382,1,382,1,382,1,382,1,383,1,383,1,383,1,383,
        1,383,3,383,5722,8,383,1,384,1,384,1,384,1,384,1,384,3,384,5729,
        8,384,1,384,1,384,3,384,5733,8,384,1,384,3,384,5736,8,384,1,384,
        3,384,5739,8,384,1,385,1,385,1,385,1,385,1,385,3,385,5746,8,385,
        1,385,1,385,3,385,5750,8,385,1,385,3,385,5753,8,385,1,385,3,385,
        5756,8,385,1,386,1,386,3,386,5760,8,386,1,386,1,386,1,386,1,386,
        3,386,5766,8,386,1,386,3,386,5769,8,386,1,387,1,387,3,387,5773,8,
        387,1,387,1,387,1,388,1,388,1,388,1,388,1,388,1,388,1,388,1,389,
        1,389,1,389,1,389,1,389,1,389,1,389,1,390,1,390,1,390,3,390,5794,
        8,390,1,391,1,391,1,391,3,391,5799,8,391,1,392,1,392,1,392,1,393,
        1,393,1,393,3,393,5807,8,393,1,393,1,393,1,393,3,393,5812,8,393,
        1,393,3,393,5815,8,393,1,394,1,394,3,394,5819,8,394,1,394,1,394,
        3,394,5823,8,394,1,395,1,395,3,395,5827,8,395,1,395,1,395,1,396,
        1,396,3,396,5833,8,396,1,396,1,396,3,396,5837,8,396,1,397,1,397,
        1,397,3,397,5842,8,397,1,398,1,398,1,398,3,398,5847,8,398,1,399,
        1,399,1,399,1,400,1,400,1,400,1,400,1,400,1,400,3,400,5858,8,400,
        3,400,5860,8,400,1,401,1,401,1,401,1,401,3,401,5866,8,401,1,401,
        1,401,1,402,1,402,1,402,1,402,1,402,1,403,1,403,1,403,1,403,1,403,
        1,404,1,404,1,404,1,404,1,405,1,405,1,405,1,405,3,405,5888,8,405,
        1,406,1,406,1,406,1,406,1,406,1,407,1,407,1,407,1,407,1,407,1,408,
        1,408,1,408,1,408,1,408,1,409,1,409,1,409,1,409,1,409,3,409,5910,
        8,409,1,410,1,410,1,410,1,410,1,410,3,410,5917,8,410,1,411,1,411,
        1,411,1,411,1,411,1,411,1,412,1,412,1,412,1,412,1,412,1,412,1,413,
        1,413,1,413,1,413,1,413,1,414,1,414,1,414,1,414,1,414,1,415,1,415,
        1,415,3,415,5944,8,415,3,415,5946,8,415,1,416,1,416,3,416,5950,8,
        416,1,417,1,417,1,418,1,418,1,418,1,419,1,419,1,419,5,419,5960,8,
        419,10,419,12,419,5963,9,419,1,420,1,420,1,420,1,420,1,420,1,420,
        1,420,3,420,5972,8,420,1,421,1,421,1,421,1,421,1,421,1,421,1,421,
        1,421,3,421,5982,8,421,1,421,1,421,3,421,5986,8,421,1,421,1,421,
        1,421,1,421,5,421,5992,8,421,10,421,12,421,5995,9,421,3,421,5997,
        8,421,1,421,1,421,3,421,6001,8,421,1,421,1,421,1,421,1,421,1,421,
        1,421,1,421,3,421,6010,8,421,1,422,1,422,3,422,6014,8,422,1,423,
        1,423,1,423,5,423,6019,8,423,10,423,12,423,6022,9,423,1,424,1,424,
        3,424,6026,8,424,1,425,1,425,1,425,1,425,1,425,1,425,3,425,6034,
        8,425,1,426,1,426,1,426,3,426,6039,8,426,1,426,1,426,1,427,1,427,
        3,427,6045,8,427,1,428,1,428,1,428,5,428,6050,8,428,10,428,12,428,
        6053,9,428,1,429,1,429,3,429,6057,8,429,1,429,1,429,1,429,1,429,
        3,429,6063,8,429,1,429,3,429,6066,8,429,1,430,1,430,1,431,1,431,
        1,431,1,431,1,431,1,431,3,431,6076,8,431,3,431,6078,8,431,1,432,
        1,432,1,432,1,432,1,432,3,432,6085,8,432,1,433,1,433,1,433,3,433,
        6090,8,433,1,433,1,433,3,433,6094,8,433,1,433,3,433,6097,8,433,1,
        434,1,434,1,434,5,434,6102,8,434,10,434,12,434,6105,9,434,1,435,
        1,435,3,435,6109,8,435,1,435,1,435,3,435,6113,8,435,1,436,1,436,
        1,436,1,436,1,436,1,437,1,437,1,437,1,437,3,437,6124,8,437,1,438,
        1,438,1,438,1,438,1,438,1,438,3,438,6132,8,438,1,438,1,438,3,438,
        6136,8,438,1,438,3,438,6139,8,438,1,438,3,438,6142,8,438,1,439,1,
        439,3,439,6146,8,439,1,439,1,439,3,439,6150,8,439,1,439,5,439,6153,
        8,439,10,439,12,439,6156,9,439,1,440,1,440,1,440,3,440,6161,8,440,
        1,441,1,441,3,441,6165,8,441,1,441,1,441,1,442,1,442,1,443,1,443,
        1,443,1,443,1,443,3,443,6176,8,443,1,443,3,443,6179,8,443,1,443,
        3,443,6182,8,443,1,443,3,443,6185,8,443,1,444,1,444,1,444,1,444,
        1,444,1,444,3,444,6193,8,444,1,445,1,445,3,445,6197,8,445,1,445,
        5,445,6200,8,445,10,445,12,445,6203,9,445,1,446,1,446,1,446,1,446,
        1,446,3,446,6210,8,446,1,447,1,447,1,447,1,447,1,447,1,447,3,447,
        6218,8,447,1,448,1,448,1,448,1,448,3,448,6224,8,448,1,449,1,449,
        3,449,6228,8,449,1,449,1,449,1,449,1,449,3,449,6234,8,449,1,449,
        1,449,1,450,1,450,1,450,1,450,1,450,3,450,6243,8,450,1,450,1,450,
        1,450,1,450,1,450,1,450,1,450,1,450,1,450,3,450,6254,8,450,1,451,
        1,451,1,451,1,451,1,451,1,451,1,451,1,451,3,451,6264,8,451,1,452,
        1,452,1,452,1,452,1,453,1,453,1,453,1,454,1,454,1,454,1,455,1,455,
        1,456,1,456,1,456,1,456,3,456,6282,8,456,1,456,3,456,6285,8,456,
        1,456,1,456,3,456,6289,8,456,1,456,1,456,1,456,1,456,1,456,1,456,
        1,456,1,456,1,456,5,456,6300,8,456,10,456,12,456,6303,9,456,1,457,
        1,457,1,457,1,457,1,457,1,457,3,457,6311,8,457,1,457,1,457,1,457,
        1,457,1,457,1,457,1,457,1,457,1,457,1,457,5,457,6323,8,457,10,457,
        12,457,6326,9,457,1,458,1,458,1,459,1,459,3,459,6332,8,459,1,459,
        1,459,1,459,1,459,3,459,6338,8,459,1,459,1,459,1,459,1,459,3,459,
        6344,8,459,1,460,1,460,1,460,1,460,1,460,1,460,3,460,6352,8,460,
        1,460,1,460,1,460,1,460,1,460,1,460,1,460,1,460,1,460,3,460,6363,
        8,460,1,460,1,460,3,460,6367,8,460,1,461,1,461,1,461,1,461,1,461,
        1,461,1,461,1,461,1,461,1,461,1,461,1,461,1,461,1,461,1,461,1,461,
        1,461,1,461,1,461,1,461,1,461,1,461,1,461,1,461,1,461,1,461,1,461,
        5,461,6396,8,461,10,461,12,461,6399,9,461,1,462,1,462,1,462,3,462,
        6404,8,462,1,462,1,462,1,462,1,462,1,462,1,462,1,462,1,462,1,462,
        1,462,1,462,1,462,1,462,1,462,1,462,3,462,6421,8,462,1,462,1,462,
        1,462,1,462,1,462,3,462,6428,8,462,1,462,1,462,1,462,1,462,1,462,
        1,462,1,462,1,462,1,462,1,462,1,462,1,462,3,462,6442,8,462,1,462,
        1,462,1,462,1,462,1,462,1,462,1,462,1,462,1,462,3,462,6453,8,462,
        1,462,1,462,1,462,3,462,6458,8,462,1,462,1,462,1,462,1,462,1,462,
        1,462,1,462,1,462,1,462,3,462,6469,8,462,1,462,1,462,1,462,1,462,
        1,462,1,462,1,462,1,462,3,462,6479,8,462,1,462,1,462,1,462,4,462,
        6484,8,462,11,462,12,462,6485,1,462,3,462,6489,8,462,1,462,1,462,
        1,462,1,462,1,462,1,462,1,462,1,462,1,462,1,462,1,462,1,462,1,462,
        1,462,1,462,1,462,1,462,1,462,1,462,1,462,1,462,1,462,1,462,1,462,
        1,462,1,462,1,462,1,462,1,462,1,462,1,462,1,462,3,462,6523,8,462,
        1,462,1,462,1,462,1,462,1,462,1,462,5,462,6531,8,462,10,462,12,462,
        6534,9,462,1,463,1,463,1,463,1,464,1,464,1,464,1,464,3,464,6543,
        8,464,1,465,1,465,1,465,3,465,6548,8,465,1,465,1,465,1,465,3,465,
        6553,8,465,1,465,1,465,1,465,1,465,1,465,3,465,6560,8,465,1,465,
        1,465,1,465,1,465,3,465,6566,8,465,1,465,1,465,1,465,3,465,6571,
        8,465,1,465,1,465,1,465,3,465,6576,8,465,1,465,1,465,1,465,1,465,
        3,465,6582,8,465,1,465,1,465,3,465,6586,8,465,1,465,1,465,1,465,
        3,465,6591,8,465,1,465,1,465,1,465,3,465,6596,8,465,1,465,1,465,
        1,465,1,465,1,465,3,465,6603,8,465,1,465,1,465,1,465,1,465,1,465,
        1,465,3,465,6611,8,465,1,465,1,465,1,465,3,465,6616,8,465,1,465,
        1,465,3,465,6620,8,465,1,465,1,465,3,465,6624,8,465,1,465,1,465,
        3,465,6628,8,465,3,465,6630,8,465,1,466,1,466,1,466,1,466,1,466,
        1,467,1,467,1,467,1,467,1,467,1,467,1,467,1,467,1,467,1,467,1,467,
        3,467,6648,8,467,1,467,1,467,1,467,1,467,1,467,1,467,3,467,6656,
        8,467,1,467,1,467,3,467,6660,8,467,1,467,1,467,1,467,1,467,1,467,
        3,467,6667,8,467,1,467,1,467,1,467,1,467,1,467,1,467,1,467,1,467,
        1,467,1,467,3,467,6679,8,467,1,467,3,467,6682,8,467,1,467,1,467,
        3,467,6686,8,467,1,468,1,468,1,469,1,469,1,469,1,469,3,469,6694,
        8,469,1,470,1,470,1,470,1,470,1,470,1,470,1,470,1,471,1,471,1,471,
        3,471,6706,8,471,1,472,1,472,1,472,1,472,1,472,3,472,6713,8,472,
        1,472,1,472,3,472,6717,8,472,1,473,1,473,3,473,6721,8,473,1,474,
        1,474,1,474,1,474,3,474,6727,8,474,1,475,1,475,1,475,1,476,1,476,
        1,476,1,476,1,476,3,476,6737,8,476,1,476,1,476,1,476,1,476,1,476,
        1,476,1,476,3,476,6746,8,476,3,476,6748,8,476,1,477,3,477,6751,8,
        477,1,477,1,477,1,478,1,478,1,478,1,478,1,478,3,478,6760,8,478,1,
        479,1,479,1,479,5,479,6765,8,479,10,479,12,479,6768,9,479,1,480,
        1,480,1,480,1,480,1,480,1,480,1,480,1,480,1,480,1,480,3,480,6780,
        8,480,1,480,1,480,1,480,3,480,6785,8,480,1,481,1,481,1,481,1,481,
        1,481,3,481,6792,8,481,1,481,1,481,1,481,1,481,3,481,6798,8,481,
        1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,
        1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,
        4,481,6822,8,481,11,481,12,481,6823,1,481,1,481,1,481,1,481,1,481,
        1,481,1,481,1,481,3,481,6834,8,481,1,481,1,481,1,481,1,481,1,481,
        1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,
        1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,
        1,481,1,481,1,481,3,481,6866,8,481,1,481,1,481,1,481,1,481,1,481,
        1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,
        1,481,3,481,6885,8,481,1,481,1,481,1,481,1,481,3,481,6891,8,481,
        1,481,1,481,3,481,6895,8,481,1,481,1,481,1,481,1,481,1,481,1,481,
        1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,
        1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,
        1,481,3,481,6926,8,481,1,481,1,481,1,481,1,481,3,481,6932,8,481,
        1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,3,481,
        6944,8,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,
        1,481,1,481,3,481,6957,8,481,1,481,1,481,3,481,6961,8,481,1,481,
        1,481,3,481,6965,8,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,
        1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,
        1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,3,481,6993,8,481,
        1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,
        1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,
        1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,
        1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,1,481,
        1,481,1,481,1,481,1,481,3,481,7043,8,481,1,481,1,481,1,481,1,481,
        1,481,1,481,1,481,1,481,3,481,7053,8,481,1,481,1,481,1,481,1,481,
        1,481,1,481,1,481,1,481,1,481,1,481,3,481,7065,8,481,1,481,1,481,
        1,481,3,481,7070,8,481,1,482,1,482,1,482,1,483,1,483,1,483,3,483,
        7078,8,483,1,483,1,483,1,483,1,483,1,483,1,483,1,483,1,483,1,483,
        1,483,1,483,1,483,1,483,1,483,1,483,1,483,1,483,1,483,3,483,7098,
        8,483,1,484,1,484,3,484,7102,8,484,1,484,1,484,1,485,1,485,1,486,
        1,486,1,486,1,486,1,486,1,486,1,486,1,486,5,486,7116,8,486,10,486,
        12,486,7119,9,486,3,486,7121,8,486,1,487,1,487,1,487,3,487,7126,
        8,487,1,487,3,487,7129,8,487,1,488,1,488,1,489,1,489,1,489,1,489,
        1,489,3,489,7138,8,489,1,489,1,489,3,489,7142,8,489,1,489,1,489,
        1,489,1,489,3,489,7148,8,489,1,489,1,489,1,489,1,489,3,489,7154,
        8,489,1,489,1,489,3,489,7158,8,489,1,489,1,489,1,490,1,490,1,490,
        1,490,1,490,1,490,1,490,3,490,7169,8,490,1,490,1,490,1,490,1,490,
        3,490,7175,8,490,3,490,7177,8,490,1,490,1,490,1,491,1,491,1,491,
        3,491,7184,8,491,1,491,1,491,1,491,1,491,1,491,3,491,7191,8,491,
        1,491,1,491,3,491,7195,8,491,1,492,1,492,1,492,5,492,7200,8,492,
        10,492,12,492,7203,9,492,1,493,1,493,3,493,7207,8,493,1,494,1,494,
        1,494,3,494,7212,8,494,1,495,1,495,1,495,1,495,1,496,1,496,1,496,
        3,496,7221,8,496,1,496,3,496,7224,8,496,1,497,1,497,3,497,7228,8,
        497,1,497,1,497,1,497,3,497,7233,8,497,3,497,7235,8,497,1,497,1,
        497,3,497,7239,8,497,1,498,1,498,3,498,7243,8,498,1,499,1,499,1,
        499,1,500,1,500,1,500,1,501,1,501,1,501,1,502,1,502,3,502,7256,8,
        502,1,502,1,502,3,502,7260,8,502,1,502,3,502,7263,8,502,1,502,1,
        502,3,502,7267,8,502,1,502,1,502,3,502,7271,8,502,1,502,1,502,3,
        502,7275,8,502,1,502,1,502,1,502,1,502,1,502,3,502,7282,8,502,1,
        502,1,502,3,502,7286,8,502,1,502,1,502,3,502,7290,8,502,1,502,1,
        502,1,502,1,502,1,502,1,502,3,502,7298,8,502,1,502,1,502,3,502,7302,
        8,502,1,503,1,503,1,503,5,503,7307,8,503,10,503,12,503,7310,9,503,
        1,504,1,504,1,504,3,504,7315,8,504,1,505,1,505,1,506,1,506,1,507,
        1,507,3,507,7323,8,507,1,508,1,508,1,509,1,509,1,509,1,509,1,510,
        1,510,1,510,1,510,1,511,1,511,1,511,1,511,1,512,1,512,1,512,5,512,
        7342,8,512,10,512,12,512,7345,9,512,1,513,1,513,3,513,7349,8,513,
        1,514,1,514,1,514,5,514,7354,8,514,10,514,12,514,7357,9,514,1,515,
        1,515,1,516,1,516,1,516,1,516,1,517,1,517,1,517,1,517,1,517,1,517,
        1,517,1,517,1,517,1,517,1,517,1,517,1,517,3,517,7378,8,517,1,518,
        1,518,1,518,1,519,1,519,1,519,1,519,1,519,1,520,1,520,1,520,1,520,
        1,520,1,520,3,520,7394,8,520,1,521,1,521,1,521,1,522,1,522,1,522,
        4,522,7402,8,522,11,522,12,522,7403,1,523,1,523,3,523,7408,8,523,
        1,523,1,523,1,523,4,523,7413,8,523,11,523,12,523,7414,1,523,3,523,
        7418,8,523,1,523,1,523,1,523,1,524,1,524,1,524,1,525,1,525,1,525,
        3,525,7429,8,525,1,526,1,526,1,527,1,527,1,527,1,528,1,528,3,528,
        7438,8,528,1,528,3,528,7441,8,528,1,528,1,528,1,529,1,529,1,529,
        3,529,7448,8,529,1,530,1,530,1,530,3,530,7453,8,530,1,531,1,531,
        1,531,1,531,1,531,1,532,1,532,1,532,1,532,1,532,1,532,1,532,1,533,
        1,533,1,533,1,533,1,533,1,533,1,533,1,534,1,534,1,534,4,534,7477,
        8,534,11,534,12,534,7478,1,535,1,535,1,535,1,535,3,535,7485,8,535,
        1,536,1,536,1,536,1,536,3,536,7491,8,536,1,536,1,536,3,536,7495,
        8,536,1,537,1,537,1,537,1,537,1,537,1,537,1,538,1,538,3,538,7505,
        8,538,1,539,1,539,3,539,7509,8,539,1,539,1,539,1,540,1,540,1,540,
        1,540,1,540,1,540,1,540,5,540,7520,8,540,10,540,12,540,7523,9,540,
        1,540,1,540,1,541,1,541,1,541,1,541,1,541,1,541,1,541,3,541,7534,
        8,541,1,542,1,542,1,542,1,542,1,542,1,542,1,543,1,543,1,543,1,544,
        1,544,1,544,1,545,1,545,3,545,7550,8,545,1,545,1,545,1,545,1,545,
        5,545,7556,8,545,10,545,12,545,7559,9,545,1,545,1,545,1,545,1,545,
        1,545,5,545,7566,8,545,10,545,12,545,7569,9,545,3,545,7571,8,545,
        1,546,1,546,1,546,3,546,7576,8,546,1,547,1,547,3,547,7580,8,547,
        1,547,1,547,1,547,1,548,1,548,3,548,7587,8,548,1,548,1,548,1,548,
        3,548,7592,8,548,1,549,1,549,1,550,1,550,1,550,3,550,7599,8,550,
        1,550,1,550,1,550,1,550,5,550,7605,8,550,10,550,12,550,7608,9,550,
        3,550,7610,8,550,1,551,1,551,1,551,3,551,7615,8,551,1,551,1,551,
        1,551,1,551,5,551,7621,8,551,10,551,12,551,7624,9,551,3,551,7626,
        8,551,1,552,1,552,1,552,1,552,1,553,1,553,1,553,1,554,1,554,1,554,
        1,555,1,555,3,555,7640,8,555,1,555,3,555,7643,8,555,1,555,1,555,
        1,555,1,555,1,556,1,556,1,556,1,556,1,556,1,556,1,556,3,556,7656,
        8,556,1,556,1,556,3,556,7660,8,556,3,556,7662,8,556,1,557,1,557,
        1,557,3,557,7667,8,557,1,558,1,558,1,558,3,558,7672,8,558,1,559,
        1,559,1,559,1,560,1,560,3,560,7679,8,560,1,560,1,560,1,561,1,561,
        3,561,7685,8,561,1,561,1,561,5,561,7689,8,561,10,561,12,561,7692,
        9,561,1,561,1,561,3,561,7696,8,561,1,561,3,561,7699,8,561,1,561,
        1,561,5,561,7703,8,561,10,561,12,561,7706,9,561,1,561,1,561,3,561,
        7710,8,561,1,561,3,561,7713,8,561,1,561,1,561,5,561,7717,8,561,10,
        561,12,561,7720,9,561,1,561,3,561,7723,8,561,1,561,1,561,1,561,1,
        561,3,561,7729,8,561,3,561,7731,8,561,1,561,3,561,7734,8,561,1,561,
        1,561,5,561,7738,8,561,10,561,12,561,7741,9,561,1,561,1,561,1,561,
        3,561,7746,8,561,1,561,1,561,1,561,1,561,1,561,3,561,7753,8,561,
        3,561,7755,8,561,3,561,7757,8,561,1,562,1,562,3,562,7761,8,562,1,
        563,1,563,5,563,7765,8,563,10,563,12,563,7768,9,563,1,563,3,563,
        7771,8,563,1,563,1,563,3,563,7775,8,563,1,563,1,563,1,563,3,563,
        7780,8,563,1,563,5,563,7783,8,563,10,563,12,563,7786,9,563,3,563,
        7788,8,563,1,564,3,564,7791,8,564,1,564,1,564,1,564,1,564,1,564,
        1,564,1,564,1,564,3,564,7801,8,564,1,564,1,564,1,564,1,564,3,564,
        7807,8,564,1,564,1,564,1,564,1,564,1,564,3,564,7814,8,564,1,564,
        1,564,1,564,3,564,7819,8,564,1,564,1,564,1,564,1,564,1,564,1,564,
        1,564,1,564,1,564,1,564,1,564,3,564,7832,8,564,1,564,1,564,1,564,
        1,564,1,564,1,564,3,564,7840,8,564,1,564,1,564,1,564,1,564,3,564,
        7846,8,564,1,564,1,564,1,564,3,564,7851,8,564,1,565,1,565,1,566,
        1,566,1,567,1,567,1,567,1,568,1,568,3,568,7862,8,568,1,569,1,569,
        3,569,7866,8,569,1,569,1,569,1,569,3,569,7871,8,569,1,569,1,569,
        3,569,7875,8,569,1,569,3,569,7878,8,569,1,570,1,570,1,570,3,570,
        7883,8,570,1,570,1,570,3,570,7887,8,570,1,570,1,570,1,570,1,570,
        1,570,1,570,3,570,7895,8,570,1,570,1,570,1,570,1,570,1,570,1,570,
        3,570,7903,8,570,3,570,7905,8,570,1,571,1,571,1,571,1,571,1,571,
        1,571,1,571,3,571,7914,8,571,1,572,1,572,1,572,1,572,5,572,7920,
        8,572,10,572,12,572,7923,9,572,1,572,1,572,1,573,1,573,3,573,7929,
        8,573,1,573,3,573,7932,8,573,1,574,1,574,1,574,1,574,5,574,7938,
        8,574,10,574,12,574,7941,9,574,1,574,1,574,1,575,1,575,1,575,1,575,
        3,575,7949,8,575,3,575,7951,8,575,1,576,1,576,1,577,1,577,3,577,
        7957,8,577,1,578,1,578,3,578,7961,8,578,1,578,1,578,1,578,1,578,
        1,578,1,578,1,578,3,578,7970,8,578,1,578,1,578,1,578,1,578,3,578,
        7976,8,578,1,578,3,578,7979,8,578,1,579,1,579,1,580,1,580,1,580,
        1,581,1,581,1,581,1,581,3,581,7990,8,581,1,582,1,582,1,583,1,583,
        1,583,1,584,1,584,3,584,7999,8,584,1,584,3,584,8002,8,584,1,584,
        1,584,1,584,3,584,8007,8,584,3,584,8009,8,584,1,584,3,584,8012,8,
        584,1,584,3,584,8015,8,584,1,584,1,584,3,584,8019,8,584,1,584,3,
        584,8022,8,584,1,584,1,584,3,584,8026,8,584,1,584,1,584,1,584,3,
        584,8031,8,584,1,584,3,584,8034,8,584,1,584,1,584,3,584,8038,8,584,
        1,584,3,584,8041,8,584,1,584,1,584,3,584,8045,8,584,1,584,1,584,
        1,584,3,584,8050,8,584,1,584,1,584,3,584,8054,8,584,1,584,1,584,
        1,584,1,584,1,584,1,584,1,584,1,584,1,584,1,584,3,584,8066,8,584,
        1,584,1,584,3,584,8070,8,584,1,584,1,584,1,584,1,584,3,584,8076,
        8,584,1,584,3,584,8079,8,584,1,584,1,584,1,584,3,584,8084,8,584,
        1,584,1,584,3,584,8088,8,584,1,584,1,584,3,584,8092,8,584,1,584,
        1,584,1,584,3,584,8097,8,584,1,584,1,584,1,584,1,584,1,584,1,584,
        1,584,3,584,8106,8,584,1,584,3,584,8109,8,584,1,584,1,584,3,584,
        8113,8,584,1,584,1,584,3,584,8117,8,584,1,584,3,584,8120,8,584,1,
        584,1,584,3,584,8124,8,584,1,584,1,584,3,584,8128,8,584,1,584,1,
        584,1,584,3,584,8133,8,584,1,584,1,584,1,584,3,584,8138,8,584,1,
        584,1,584,1,584,3,584,8143,8,584,1,585,1,585,1,585,3,585,8148,8,
        585,1,586,1,586,1,586,3,586,8153,8,586,3,586,8155,8,586,1,587,1,
        587,1,587,3,587,8160,8,587,1,587,1,587,1,588,4,588,8165,8,588,11,
        588,12,588,8166,1,589,1,589,1,589,1,589,1,589,1,589,3,589,8175,8,
        589,1,589,1,589,1,589,1,589,3,589,8181,8,589,3,589,8183,8,589,1,
        590,1,590,3,590,8187,8,590,1,590,1,590,3,590,8191,8,590,1,591,1,
        591,3,591,8195,8,591,1,591,1,591,3,591,8199,8,591,1,592,1,592,1,
        592,1,592,1,593,1,593,1,593,1,593,1,594,1,594,1,594,1,594,1,594,
        3,594,8214,8,594,1,595,1,595,1,595,1,595,3,595,8220,8,595,1,596,
        1,596,1,596,1,596,1,596,3,596,8227,8,596,1,597,1,597,3,597,8231,
        8,597,1,597,5,597,8234,8,597,10,597,12,597,8237,9,597,1,598,1,598,
        3,598,8241,8,598,1,598,3,598,8244,8,598,1,599,1,599,3,599,8248,8,
        599,1,599,3,599,8251,8,599,1,600,4,600,8254,8,600,11,600,12,600,
        8255,1,601,1,601,3,601,8260,8,601,1,601,1,601,1,601,1,601,3,601,
        8266,8,601,1,601,1,601,3,601,8270,8,601,1,601,1,601,3,601,8274,8,
        601,1,601,1,601,1,601,3,601,8279,8,601,1,601,1,601,1,601,3,601,8284,
        8,601,1,601,1,601,1,601,3,601,8289,8,601,1,601,1,601,1,601,3,601,
        8294,8,601,1,601,1,601,1,601,3,601,8299,8,601,1,601,1,601,1,601,
        3,601,8304,8,601,1,601,1,601,1,601,3,601,8309,8,601,1,601,1,601,
        1,601,3,601,8314,8,601,1,601,1,601,1,601,3,601,8319,8,601,1,601,
        1,601,1,601,3,601,8324,8,601,1,601,1,601,1,601,3,601,8329,8,601,
        1,601,1,601,1,601,3,601,8334,8,601,1,601,1,601,1,601,3,601,8339,
        8,601,1,601,1,601,1,601,1,601,1,601,1,601,1,601,1,601,3,601,8349,
        8,601,1,601,1,601,1,601,1,601,3,601,8355,8,601,1,601,1,601,1,601,
        1,601,3,601,8361,8,601,1,601,1,601,1,601,3,601,8366,8,601,1,601,
        1,601,1,601,1,601,1,601,3,601,8373,8,601,1,601,1,601,1,601,3,601,
        8378,8,601,1,601,1,601,1,601,1,601,1,601,1,601,1,601,3,601,8387,
        8,601,1,601,1,601,1,601,1,601,3,601,8393,8,601,1,601,1,601,1,601,
        3,601,8398,8,601,1,602,1,602,3,602,8402,8,602,1,603,3,603,8405,8,
        603,1,603,1,603,3,603,8409,8,603,1,603,1,603,1,604,3,604,8414,8,
        604,1,604,1,604,3,604,8418,8,604,1,604,1,604,1,605,3,605,8423,8,
        605,1,605,1,605,3,605,8427,8,605,1,605,1,605,1,606,1,606,1,606,1,
        606,1,606,3,606,8436,8,606,1,606,3,606,8439,8,606,1,606,3,606,8442,
        8,606,1,607,3,607,8445,8,607,1,607,1,607,3,607,8449,8,607,1,607,
        1,607,3,607,8453,8,607,1,607,1,607,3,607,8457,8,607,1,607,1,607,
        1,607,1,607,1,607,1,607,1,607,1,607,1,607,1,607,1,607,1,607,1,607,
        3,607,8472,8,607,1,607,3,607,8475,8,607,3,607,8477,8,607,1,608,1,
        608,1,608,3,608,8482,8,608,1,608,1,608,1,608,1,608,1,608,1,608,1,
        608,3,608,8491,8,608,1,608,3,608,8494,8,608,1,608,1,608,3,608,8498,
        8,608,1,609,1,609,1,609,1,609,1,610,1,610,1,610,1,610,5,610,8508,
        8,610,10,610,12,610,8511,9,610,1,610,1,610,1,611,1,611,1,611,1,611,
        1,611,1,611,1,611,3,611,8522,8,611,1,611,1,611,1,611,3,611,8527,
        8,611,1,611,5,611,8530,8,611,10,611,12,611,8533,9,611,1,611,1,611,
        1,611,1,611,5,611,8539,8,611,10,611,12,611,8542,9,611,1,611,1,611,
        3,611,8546,8,611,1,612,1,612,1,612,1,612,1,612,5,612,8553,8,612,
        10,612,12,612,8556,9,612,1,612,1,612,3,612,8560,8,612,1,613,1,613,
        3,613,8564,8,613,1,613,1,613,3,613,8568,8,613,1,613,1,613,3,613,
        8572,8,613,1,613,1,613,1,613,3,613,8577,8,613,1,613,1,613,1,613,
        3,613,8582,8,613,1,613,1,613,1,613,1,613,3,613,8588,8,613,1,613,
        1,613,1,613,3,613,8593,8,613,1,613,3,613,8596,8,613,1,614,1,614,
        1,614,5,614,8601,8,614,10,614,12,614,8604,9,614,1,615,1,615,1,615,
        1,615,5,615,8610,8,615,10,615,12,615,8613,9,615,1,615,1,615,1,616,
        1,616,3,616,8619,8,616,1,617,1,617,1,617,1,617,1,618,1,618,1,618,
        1,619,1,619,1,619,1,620,1,620,1,620,1,620,1,620,3,620,8636,8,620,
        3,620,8638,8,620,1,621,1,621,1,621,1,621,1,622,1,622,1,622,1,622,
        1,623,3,623,8649,8,623,1,623,1,623,1,624,1,624,1,624,1,625,1,625,
        1,625,1,626,1,626,3,626,8661,8,626,1,627,1,627,1,627,1,627,1,627,
        1,627,1,628,1,628,1,628,5,628,8672,8,628,10,628,12,628,8675,9,628,
        1,629,1,629,1,629,5,629,8680,8,629,10,629,12,629,8683,9,629,1,630,
        1,630,1,630,1,630,3,630,8689,8,630,1,631,1,631,1,631,1,632,1,632,
        4,632,8696,8,632,11,632,12,632,8697,1,633,1,633,1,633,1,633,3,633,
        8704,8,633,1,633,1,633,1,633,1,633,1,633,1,633,3,633,8712,8,633,
        1,634,1,634,4,634,8716,8,634,11,634,12,634,8717,1,635,1,635,1,635,
        1,635,1,636,1,636,1,636,5,636,8727,8,636,10,636,12,636,8730,9,636,
        1,637,1,637,1,637,5,637,8735,8,637,10,637,12,637,8738,9,637,1,638,
        1,638,1,638,3,638,8743,8,638,1,638,1,638,3,638,8747,8,638,1,638,
        3,638,8750,8,638,1,639,1,639,1,639,1,639,3,639,8756,8,639,1,640,
        1,640,1,640,1,640,1,640,1,640,3,640,8764,8,640,1,641,1,641,1,641,
        1,641,1,642,1,642,1,642,1,642,1,642,1,643,1,643,1,643,1,643,1,644,
        1,644,1,644,1,644,1,644,1,644,1,645,1,645,1,645,1,645,1,645,1,645,
        1,646,1,646,1,646,1,646,1,646,1,646,1,646,1,647,1,647,1,647,1,647,
        1,647,3,647,8803,8,647,1,648,1,648,1,648,1,648,1,649,1,649,1,649,
        1,649,1,650,1,650,1,650,1,650,1,650,1,650,1,650,1,650,1,650,1,650,
        1,650,1,650,1,650,1,650,1,650,3,650,8828,8,650,1,651,1,651,1,651,
        1,652,1,652,1,652,1,653,1,653,3,653,8838,8,653,1,654,1,654,1,654,
        3,654,8843,8,654,3,654,8845,8,654,1,655,1,655,1,655,1,656,1,656,
        3,656,8852,8,656,1,657,1,657,1,658,1,658,1,659,1,659,1,659,1,660,
        1,660,1,660,3,660,8864,8,660,3,660,8866,8,660,1,661,1,661,1,662,
        1,662,1,663,1,663,1,663,1,663,5,663,8876,8,663,10,663,12,663,8879,
        9,663,1,663,1,663,1,664,1,664,1,665,1,665,3,665,8887,8,665,1,666,
        1,666,1,667,1,667,1,668,1,668,1,668,1,668,1,668,3,668,8898,8,668,
        1,668,1,668,1,669,1,669,1,670,1,670,1,671,1,671,1,672,1,672,1,673,
        1,673,1,674,1,674,1,675,1,675,1,676,1,676,1,677,1,677,3,677,8920,
        8,677,1,678,1,678,3,678,8924,8,678,1,679,1,679,1,680,1,680,1,681,
        1,681,1,682,1,682,1,683,1,683,1,684,1,684,1,685,1,685,1,686,1,686,
        1,687,1,687,1,688,1,688,1,689,1,689,3,689,8948,8,689,1,690,1,690,
        1,690,1,691,1,691,1,691,1,691,1,691,1,691,3,691,8959,8,691,3,691,
        8961,8,691,1,692,1,692,3,692,8965,8,692,1,693,1,693,1,693,5,693,
        8970,8,693,10,693,12,693,8973,9,693,1,694,1,694,1,694,5,694,8978,
        8,694,10,694,12,694,8981,9,694,1,695,1,695,1,696,1,696,3,696,8987,
        8,696,1,697,1,697,1,698,1,698,3,698,8993,8,698,1,699,1,699,1,700,
        1,700,1,701,1,701,1,702,1,702,1,703,1,703,1,703,3,703,9006,8,703,
        1,704,1,704,3,704,9010,8,704,1,705,1,705,1,705,5,705,9015,8,705,
        10,705,12,705,9018,9,705,1,706,1,706,1,706,1,706,1,707,1,707,3,707,
        9026,8,707,1,708,1,708,1,708,3,708,9031,8,708,3,708,9033,8,708,1,
        709,1,709,1,709,1,710,1,710,1,711,1,711,1,712,1,712,1,713,1,713,
        1,713,1,713,1,713,3,713,9049,8,713,1,714,1,714,1,714,1,714,1,714,
        3,714,9056,8,714,1,715,1,715,1,715,3,715,9061,8,715,1,716,1,716,
        1,716,1,716,1,716,1,716,3,716,9069,8,716,1,716,3,716,9072,8,716,
        1,717,1,717,1,717,3,717,9077,8,717,1,718,1,718,1,719,1,719,1,719,
        1,719,5,719,9085,8,719,10,719,12,719,9088,9,719,1,719,1,719,1,720,
        1,720,1,720,3,720,9095,8,720,1,721,1,721,1,721,3,721,9100,8,721,
        1,722,1,722,1,722,3,722,9105,8,722,1,723,3,723,9108,8,723,1,723,
        1,723,3,723,9112,8,723,1,723,5,723,9115,8,723,10,723,12,723,9118,
        9,723,1,724,1,724,1,725,1,725,1,725,5,725,9125,8,725,10,725,12,725,
        9128,9,725,1,726,1,726,1,726,3,726,9133,8,726,1,727,1,727,1,728,
        1,728,1,729,1,729,1,730,1,730,1,730,1,730,1,730,1,730,3,730,9147,
        8,730,1,731,1,731,3,731,9151,8,731,1,732,1,732,1,733,1,733,1,733,
        1,733,1,733,1,733,1,734,1,734,3,734,9163,8,734,1,735,1,735,3,735,
        9167,8,735,1,736,1,736,3,736,9171,8,736,1,737,1,737,3,737,9175,8,
        737,1,738,1,738,1,738,1,739,1,739,1,740,1,740,1,741,1,741,1,741,
        1,741,1,741,1,741,3,741,9190,8,741,1,742,1,742,1,742,1,743,1,743,
        1,744,1,744,1,744,1,744,1,744,1,744,1,744,3,744,9204,8,744,1,744,
        1,744,1,744,1,744,1,744,3,744,9211,8,744,3,744,9213,8,744,1,745,
        1,745,1,746,1,746,1,747,1,747,1,747,1,747,1,747,1,747,1,747,1,747,
        1,747,1,747,1,747,3,747,9230,8,747,1,747,1,747,1,747,3,747,9235,
        8,747,3,747,9237,8,747,1,748,1,748,1,749,1,749,1,749,1,749,1,749,
        3,749,9246,8,749,1,750,1,750,1,750,3,750,9251,8,750,1,750,1,750,
        1,750,3,750,9256,8,750,3,750,9258,8,750,1,751,1,751,1,751,1,751,
        3,751,9264,8,751,1,752,1,752,1,753,1,753,1,754,1,754,1,754,3,754,
        9273,8,754,1,754,0,4,912,914,922,924,755,0,2,4,6,8,10,12,14,16,18,
        20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,
        64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,
        106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,
        138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,
        170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,
        202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,
        234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,
        266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,
        298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,
        330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,
        362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,
        394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,
        426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,
        458,460,462,464,466,468,470,472,474,476,478,480,482,484,486,488,
        490,492,494,496,498,500,502,504,506,508,510,512,514,516,518,520,
        522,524,526,528,530,532,534,536,538,540,542,544,546,548,550,552,
        554,556,558,560,562,564,566,568,570,572,574,576,578,580,582,584,
        586,588,590,592,594,596,598,600,602,604,606,608,610,612,614,616,
        618,620,622,624,626,628,630,632,634,636,638,640,642,644,646,648,
        650,652,654,656,658,660,662,664,666,668,670,672,674,676,678,680,
        682,684,686,688,690,692,694,696,698,700,702,704,706,708,710,712,
        714,716,718,720,722,724,726,728,730,732,734,736,738,740,742,744,
        746,748,750,752,754,756,758,760,762,764,766,768,770,772,774,776,
        778,780,782,784,786,788,790,792,794,796,798,800,802,804,806,808,
        810,812,814,816,818,820,822,824,826,828,830,832,834,836,838,840,
        842,844,846,848,850,852,854,856,858,860,862,864,866,868,870,872,
        874,876,878,880,882,884,886,888,890,892,894,896,898,900,902,904,
        906,908,910,912,914,916,918,920,922,924,926,928,930,932,934,936,
        938,940,942,944,946,948,950,952,954,956,958,960,962,964,966,968,
        970,972,974,976,978,980,982,984,986,988,990,992,994,996,998,1000,
        1002,1004,1006,1008,1010,1012,1014,1016,1018,1020,1022,1024,1026,
        1028,1030,1032,1034,1036,1038,1040,1042,1044,1046,1048,1050,1052,
        1054,1056,1058,1060,1062,1064,1066,1068,1070,1072,1074,1076,1078,
        1080,1082,1084,1086,1088,1090,1092,1094,1096,1098,1100,1102,1104,
        1106,1108,1110,1112,1114,1116,1118,1120,1122,1124,1126,1128,1130,
        1132,1134,1136,1138,1140,1142,1144,1146,1148,1150,1152,1154,1156,
        1158,1160,1162,1164,1166,1168,1170,1172,1174,1176,1178,1180,1182,
        1184,1186,1188,1190,1192,1194,1196,1198,1200,1202,1204,1206,1208,
        1210,1212,1214,1216,1218,1220,1222,1224,1226,1228,1230,1232,1234,
        1236,1238,1240,1242,1244,1246,1248,1250,1252,1254,1256,1258,1260,
        1262,1264,1266,1268,1270,1272,1274,1276,1278,1280,1282,1284,1286,
        1288,1290,1292,1294,1296,1298,1300,1302,1304,1306,1308,1310,1312,
        1314,1316,1318,1320,1322,1324,1326,1328,1330,1332,1334,1336,1338,
        1340,1342,1344,1346,1348,1350,1352,1354,1356,1358,1360,1362,1364,
        1366,1368,1370,1372,1374,1376,1378,1380,1382,1384,1386,1388,1390,
        1392,1394,1396,1398,1400,1402,1404,1406,1408,1410,1412,1414,1416,
        1418,1420,1422,1424,1426,1428,1430,1432,1434,1436,1438,1440,1442,
        1444,1446,1448,1450,1452,1454,1456,1458,1460,1462,1464,1466,1468,
        1470,1472,1474,1476,1478,1480,1482,1484,1486,1488,1490,1492,1494,
        1496,1498,1500,1502,1504,1506,1508,0,176,1,0,730,731,2,0,63,63,599,
        599,2,0,93,93,488,488,1,0,653,654,2,0,51,51,184,184,1,0,732,733,
        2,0,94,94,312,312,2,0,177,177,192,192,2,0,264,264,475,475,4,0,164,
        164,280,280,455,455,566,566,2,0,168,168,281,281,2,0,458,458,613,
        613,2,0,393,393,646,646,3,0,359,359,587,587,611,611,2,0,53,53,73,
        73,3,0,171,171,274,274,623,623,2,0,229,229,433,433,2,0,581,581,583,
        583,3,0,264,264,321,321,449,449,2,0,225,225,387,387,4,0,225,225,
        298,298,387,387,437,437,2,0,6,6,9,12,3,0,169,169,255,255,321,321,
        1,0,635,636,2,0,153,153,661,661,2,0,125,125,321,321,2,0,805,805,
        811,811,2,0,308,308,500,500,2,0,169,169,321,321,2,0,671,671,803,
        803,6,0,57,57,180,180,255,255,542,544,546,546,565,565,2,0,29,29,
        400,400,2,0,3,5,43,43,3,0,450,450,500,500,691,691,2,0,141,141,497,
        497,2,0,64,64,172,172,2,0,520,520,623,623,2,0,302,302,495,495,2,
        0,140,140,271,271,2,0,57,57,180,180,2,0,230,230,264,264,2,0,268,
        268,295,295,2,0,404,404,657,657,3,0,276,276,581,581,583,583,2,0,
        74,74,553,553,2,0,291,291,489,489,2,0,77,77,341,341,2,0,322,322,
        766,766,2,0,326,326,772,772,2,0,323,323,767,767,2,0,343,343,790,
        790,2,0,329,329,775,775,2,0,330,330,776,776,2,0,324,324,769,769,
        2,0,331,331,778,778,2,0,325,325,770,770,2,0,339,339,779,779,2,0,
        333,333,780,780,2,0,332,332,781,781,2,0,335,335,783,783,2,0,336,
        336,784,784,2,0,337,337,785,785,2,0,338,338,786,786,2,0,340,340,
        787,787,2,0,342,342,789,789,2,0,746,746,788,788,2,0,334,334,782,
        782,2,0,720,720,777,777,2,0,721,721,765,765,2,0,344,344,771,771,
        2,0,743,743,768,768,2,0,744,744,791,791,3,0,401,401,751,752,806,
        806,2,0,327,327,773,773,2,0,328,328,774,774,2,0,539,539,541,541,
        2,0,466,466,548,548,2,0,526,526,762,762,2,0,163,163,184,184,3,0,
        389,389,549,549,658,658,2,0,314,314,620,620,2,0,166,166,727,727,
        3,0,238,238,440,440,583,583,4,0,274,274,460,460,511,511,623,623,
        13,0,171,171,184,184,205,205,208,208,222,222,268,268,441,441,445,
        445,468,468,522,522,575,575,603,603,625,625,4,0,499,499,582,582,
        627,627,644,644,2,0,139,139,184,184,2,0,166,166,389,389,2,0,215,
        215,449,449,1,0,813,814,5,0,100,100,215,215,219,219,357,357,449,
        449,3,0,215,215,449,449,628,628,2,0,246,246,666,666,2,0,119,119,
        610,610,2,0,235,235,282,282,2,0,267,268,293,293,6,0,57,57,138,138,
        286,286,358,358,533,533,577,577,2,0,127,127,448,448,4,0,257,257,
        439,439,557,557,626,626,5,0,77,77,198,198,200,200,240,240,527,527,
        2,0,627,627,718,718,2,0,172,173,213,213,3,0,218,218,605,605,619,
        619,2,0,23,23,61,61,2,0,26,26,412,412,2,0,57,57,62,62,2,0,6,6,8,
        13,3,0,16,18,181,181,372,372,1,0,14,15,1,0,21,22,2,0,14,15,20,20,
        2,0,79,80,82,82,2,0,350,350,368,368,5,0,558,558,561,561,574,574,
        640,640,643,643,4,0,686,687,700,700,702,702,704,704,2,0,692,692,
        694,694,2,0,689,689,693,693,2,0,225,225,298,298,2,0,718,718,815,
        815,2,0,264,264,703,703,2,0,52,52,568,568,1,0,155,156,1,0,593,594,
        4,0,154,154,157,157,592,592,595,595,4,0,243,243,309,309,374,376,
        429,430,2,0,1,1,390,390,2,0,1,1,19,19,5,0,158,161,258,260,364,365,
        508,508,663,663,9,0,162,162,261,261,361,361,366,366,373,373,447,
        447,509,509,648,648,664,664,3,0,135,135,210,210,614,614,2,0,143,
        143,550,550,2,0,396,396,501,501,10,0,97,97,107,107,116,116,130,132,
        148,148,360,360,378,378,507,507,567,567,585,585,2,0,564,564,645,
        645,3,0,166,166,188,188,226,226,3,0,166,166,179,179,358,358,3,0,
        236,236,420,420,525,525,3,0,88,88,252,252,504,504,1,0,669,670,2,
        0,608,608,630,630,5,0,76,76,280,280,355,355,528,528,597,597,3,0,
        164,164,226,227,397,397,1,0,85,86,2,0,317,317,354,354,4,0,243,244,
        309,309,374,376,429,430,3,0,524,524,621,621,665,665,1,0,554,556,
        2,0,104,104,584,584,6,0,121,121,123,123,166,166,188,188,226,226,
        459,459,3,0,225,225,298,298,392,392,2,0,179,179,358,358,2,0,310,
        310,450,450,2,0,348,348,367,367,2,0,153,153,268,268,3,0,272,272,
        282,282,415,415,2,0,551,551,588,588,2,0,399,399,403,403,2,0,312,
        312,394,394,2,0,821,821,823,823,3,0,3,5,44,44,46,47,2,0,3,5,44,44,
        2,0,3,5,46,47,1,0,44,45,2,0,218,218,605,605,2,0,42,42,395,395,1,
        0,3,5,1,0,6,7,5,0,246,246,312,312,516,516,666,666,681,681,3,0,208,
        208,522,522,722,722,32,0,65,65,74,74,90,91,102,102,104,104,118,118,
        120,120,133,133,163,163,183,183,195,195,228,229,251,251,254,254,
        266,266,277,277,297,297,392,392,433,433,435,435,472,472,485,485,
        496,496,505,505,524,524,526,526,553,553,562,562,606,606,615,616,
        659,659,685,685,9,0,205,205,222,222,389,389,441,441,445,445,468,
        468,476,476,575,575,717,717,157,0,49,50,52,56,59,59,62,62,67,72,
        78,78,81,81,84,86,88,88,94,94,97,98,100,101,106,111,113,114,116,
        117,119,119,121,125,127,128,130,132,134,134,138,138,143,143,148,
        148,152,154,157,157,162,162,167,168,170,170,175,179,186,188,192,
        192,194,194,196,201,203,204,206,207,211,212,214,216,219,220,223,
        226,233,234,236,236,240,240,242,245,248,248,252,252,256,257,261,
        262,265,265,267,267,270,270,275,276,281,281,285,286,288,289,292,
        292,294,294,298,298,300,300,303,304,309,310,313,313,315,316,322,
        322,324,339,341,344,346,349,351,352,357,361,363,363,366,367,369,
        369,371,371,373,381,383,388,393,393,396,396,398,398,400,400,402,
        402,404,405,408,408,416,422,424,431,436,437,439,439,442,444,447,
        449,452,452,456,459,462,466,469,469,471,471,473,473,477,483,487,
        487,489,491,493,493,497,499,501,502,504,504,506,507,509,510,514,
        515,517,517,520,520,525,525,527,527,529,533,539,541,543,543,545,
        545,548,548,550,550,552,552,554,557,563,563,566,571,576,578,581,
        582,584,587,589,590,592,595,601,602,607,608,610,613,619,619,622,
        622,624,624,626,628,634,634,636,636,639,639,644,644,646,649,654,
        656,658,658,660,661,664,664,667,670,672,672,677,679,682,683,688,
        688,690,690,697,698,701,701,703,703,705,706,710,716,719,721,723,
        733,735,738,740,740,743,746,753,756,758,760,762,802,4,0,592,592,
        595,595,739,739,741,752,4,0,804,804,806,809,811,811,815,815,54,0,
        49,49,59,59,65,65,72,72,74,74,90,91,102,102,104,104,109,109,118,
        118,120,120,133,133,163,163,183,183,195,195,228,229,233,233,242,
        242,251,251,254,254,256,256,277,277,297,297,392,392,405,405,408,
        408,416,416,419,419,423,423,431,431,433,433,435,435,469,469,472,
        472,485,485,487,487,496,496,505,505,510,510,517,517,524,524,526,
        526,530,531,553,553,562,562,606,606,615,616,624,624,656,656,659,
        659,667,667,669,670,685,685,728,731,148,0,50,50,52,56,62,62,67,71,
        78,78,81,81,84,86,88,88,94,94,97,98,100,101,106,108,110,111,113,
        114,116,117,119,119,121,125,127,128,130,132,134,134,138,138,143,
        143,148,148,152,154,157,157,162,162,167,168,170,170,175,179,186,
        188,192,192,194,194,196,201,203,204,206,206,211,211,214,216,219,
        220,223,226,234,234,236,236,240,240,243,246,248,248,252,252,257,
        257,261,262,265,265,267,267,270,270,275,276,281,281,285,286,288,
        289,292,292,294,294,298,298,300,300,303,304,309,310,312,313,315,
        316,322,322,324,339,341,344,346,349,351,352,357,361,363,363,366,
        367,369,369,371,371,373,381,383,388,393,393,396,396,398,398,400,
        400,402,402,417,418,420,422,424,430,436,437,439,439,442,444,447,
        449,452,452,456,459,462,466,471,471,473,473,477,483,489,491,493,
        493,497,499,501,502,504,504,506,507,509,509,514,516,520,520,525,
        525,527,527,529,529,532,533,539,541,543,543,545,545,548,548,550,
        550,552,552,554,557,563,563,566,571,575,578,581,582,584,587,589,
        590,592,595,601,602,607,613,619,619,622,622,626,628,636,636,639,
        639,644,644,646,649,655,655,658,658,660,661,664,664,672,672,677,
        679,682,684,688,688,690,690,697,698,701,701,703,703,705,706,710,
        716,719,720,724,725,727,727,732,733,735,736,757,757,10337,0,1513,
        1,0,0,0,2,1520,1,0,0,0,4,1600,1,0,0,0,6,1602,1,0,0,0,8,1625,1,0,
        0,0,10,1639,1,0,0,0,12,1642,1,0,0,0,14,1680,1,0,0,0,16,1689,1,0,
        0,0,18,1702,1,0,0,0,20,1704,1,0,0,0,22,1709,1,0,0,0,24,1729,1,0,
        0,0,26,1738,1,0,0,0,28,1740,1,0,0,0,30,1755,1,0,0,0,32,1851,1,0,
        0,0,34,1855,1,0,0,0,36,1871,1,0,0,0,38,2008,1,0,0,0,40,2013,1,0,
        0,0,42,2015,1,0,0,0,44,2017,1,0,0,0,46,2031,1,0,0,0,48,2039,1,0,
        0,0,50,2055,1,0,0,0,52,2057,1,0,0,0,54,2060,1,0,0,0,56,2065,1,0,
        0,0,58,2067,1,0,0,0,60,2082,1,0,0,0,62,2090,1,0,0,0,64,2100,1,0,
        0,0,66,2102,1,0,0,0,68,2124,1,0,0,0,70,2133,1,0,0,0,72,2136,1,0,
        0,0,74,2149,1,0,0,0,76,2154,1,0,0,0,78,2158,1,0,0,0,80,2197,1,0,
        0,0,82,2199,1,0,0,0,84,2219,1,0,0,0,86,2234,1,0,0,0,88,2237,1,0,
        0,0,90,2262,1,0,0,0,92,2272,1,0,0,0,94,2275,1,0,0,0,96,2280,1,0,
        0,0,98,2289,1,0,0,0,100,2291,1,0,0,0,102,2295,1,0,0,0,104,2307,1,
        0,0,0,106,2336,1,0,0,0,108,2342,1,0,0,0,110,2345,1,0,0,0,112,2375,
        1,0,0,0,114,2392,1,0,0,0,116,2395,1,0,0,0,118,2420,1,0,0,0,120,2423,
        1,0,0,0,122,2475,1,0,0,0,124,2477,1,0,0,0,126,2481,1,0,0,0,128,2490,
        1,0,0,0,130,2506,1,0,0,0,132,2508,1,0,0,0,134,2516,1,0,0,0,136,2542,
        1,0,0,0,138,2544,1,0,0,0,140,2556,1,0,0,0,142,2571,1,0,0,0,144,2573,
        1,0,0,0,146,2576,1,0,0,0,148,2597,1,0,0,0,150,2599,1,0,0,0,152,2605,
        1,0,0,0,154,2611,1,0,0,0,156,2617,1,0,0,0,158,2623,1,0,0,0,160,2629,
        1,0,0,0,162,2636,1,0,0,0,164,2644,1,0,0,0,166,2646,1,0,0,0,168,2652,
        1,0,0,0,170,2658,1,0,0,0,172,2664,1,0,0,0,174,2671,1,0,0,0,176,2689,
        1,0,0,0,178,2691,1,0,0,0,180,2695,1,0,0,0,182,2700,1,0,0,0,184,2719,
        1,0,0,0,186,2723,1,0,0,0,188,2756,1,0,0,0,190,2787,1,0,0,0,192,2804,
        1,0,0,0,194,2806,1,0,0,0,196,2825,1,0,0,0,198,2831,1,0,0,0,200,2837,
        1,0,0,0,202,2843,1,0,0,0,204,2850,1,0,0,0,206,2859,1,0,0,0,208,2876,
        1,0,0,0,210,2878,1,0,0,0,212,2885,1,0,0,0,214,2895,1,0,0,0,216,2909,
        1,0,0,0,218,2915,1,0,0,0,220,2923,1,0,0,0,222,2929,1,0,0,0,224,2937,
        1,0,0,0,226,2943,1,0,0,0,228,2953,1,0,0,0,230,2957,1,0,0,0,232,2963,
        1,0,0,0,234,2968,1,0,0,0,236,2978,1,0,0,0,238,3021,1,0,0,0,240,3026,
        1,0,0,0,242,3028,1,0,0,0,244,3031,1,0,0,0,246,3061,1,0,0,0,248,3063,
        1,0,0,0,250,3092,1,0,0,0,252,3099,1,0,0,0,254,3103,1,0,0,0,256,3111,
        1,0,0,0,258,3124,1,0,0,0,260,3126,1,0,0,0,262,3144,1,0,0,0,264,3156,
        1,0,0,0,266,3162,1,0,0,0,268,3168,1,0,0,0,270,3220,1,0,0,0,272,3222,
        1,0,0,0,274,3224,1,0,0,0,276,3230,1,0,0,0,278,3232,1,0,0,0,280,3240,
        1,0,0,0,282,3246,1,0,0,0,284,3254,1,0,0,0,286,3263,1,0,0,0,288,3273,
        1,0,0,0,290,3288,1,0,0,0,292,3293,1,0,0,0,294,3298,1,0,0,0,296,3303,
        1,0,0,0,298,3325,1,0,0,0,300,3344,1,0,0,0,302,3347,1,0,0,0,304,3358,
        1,0,0,0,306,3374,1,0,0,0,308,3386,1,0,0,0,310,3388,1,0,0,0,312,3417,
        1,0,0,0,314,3419,1,0,0,0,316,3421,1,0,0,0,318,3424,1,0,0,0,320,3427,
        1,0,0,0,322,3434,1,0,0,0,324,3436,1,0,0,0,326,3466,1,0,0,0,328,3477,
        1,0,0,0,330,3480,1,0,0,0,332,3484,1,0,0,0,334,3493,1,0,0,0,336,3497,
        1,0,0,0,338,3502,1,0,0,0,340,3515,1,0,0,0,342,3520,1,0,0,0,344,3524,
        1,0,0,0,346,3540,1,0,0,0,348,3542,1,0,0,0,350,3560,1,0,0,0,352,3562,
        1,0,0,0,354,3571,1,0,0,0,356,3583,1,0,0,0,358,3604,1,0,0,0,360,3606,
        1,0,0,0,362,3609,1,0,0,0,364,3613,1,0,0,0,366,3615,1,0,0,0,368,3620,
        1,0,0,0,370,3628,1,0,0,0,372,3637,1,0,0,0,374,3640,1,0,0,0,376,3649,
        1,0,0,0,378,3651,1,0,0,0,380,3670,1,0,0,0,382,3672,1,0,0,0,384,3677,
        1,0,0,0,386,3681,1,0,0,0,388,3695,1,0,0,0,390,3698,1,0,0,0,392,3704,
        1,0,0,0,394,3717,1,0,0,0,396,3725,1,0,0,0,398,3751,1,0,0,0,400,3764,
        1,0,0,0,402,3771,1,0,0,0,404,3773,1,0,0,0,406,3785,1,0,0,0,408,3787,
        1,0,0,0,410,3800,1,0,0,0,412,3823,1,0,0,0,414,3825,1,0,0,0,416,3832,
        1,0,0,0,418,3842,1,0,0,0,420,3877,1,0,0,0,422,3884,1,0,0,0,424,3890,
        1,0,0,0,426,3892,1,0,0,0,428,3896,1,0,0,0,430,3904,1,0,0,0,432,3906,
        1,0,0,0,434,3911,1,0,0,0,436,3915,1,0,0,0,438,3943,1,0,0,0,440,3945,
        1,0,0,0,442,3947,1,0,0,0,444,3955,1,0,0,0,446,3957,1,0,0,0,448,3965,
        1,0,0,0,450,3975,1,0,0,0,452,3978,1,0,0,0,454,4003,1,0,0,0,456,4030,
        1,0,0,0,458,4032,1,0,0,0,460,4041,1,0,0,0,462,4072,1,0,0,0,464,4090,
        1,0,0,0,466,4092,1,0,0,0,468,4106,1,0,0,0,470,4108,1,0,0,0,472,4139,
        1,0,0,0,474,4142,1,0,0,0,476,4173,1,0,0,0,478,4175,1,0,0,0,480,4194,
        1,0,0,0,482,4202,1,0,0,0,484,4204,1,0,0,0,486,4207,1,0,0,0,488,4220,
        1,0,0,0,490,4222,1,0,0,0,492,4229,1,0,0,0,494,4365,1,0,0,0,496,4367,
        1,0,0,0,498,4369,1,0,0,0,500,4371,1,0,0,0,502,4373,1,0,0,0,504,4375,
        1,0,0,0,506,4377,1,0,0,0,508,4379,1,0,0,0,510,4381,1,0,0,0,512,4383,
        1,0,0,0,514,4385,1,0,0,0,516,4387,1,0,0,0,518,4389,1,0,0,0,520,4391,
        1,0,0,0,522,4393,1,0,0,0,524,4395,1,0,0,0,526,4397,1,0,0,0,528,4399,
        1,0,0,0,530,4401,1,0,0,0,532,4403,1,0,0,0,534,4405,1,0,0,0,536,4407,
        1,0,0,0,538,4409,1,0,0,0,540,4411,1,0,0,0,542,4413,1,0,0,0,544,4415,
        1,0,0,0,546,4419,1,0,0,0,548,4421,1,0,0,0,550,4426,1,0,0,0,552,4430,
        1,0,0,0,554,4446,1,0,0,0,556,4448,1,0,0,0,558,4450,1,0,0,0,560,4452,
        1,0,0,0,562,4465,1,0,0,0,564,4528,1,0,0,0,566,4530,1,0,0,0,568,4538,
        1,0,0,0,570,4546,1,0,0,0,572,4554,1,0,0,0,574,4556,1,0,0,0,576,4564,
        1,0,0,0,578,4588,1,0,0,0,580,4601,1,0,0,0,582,4610,1,0,0,0,584,4614,
        1,0,0,0,586,4618,1,0,0,0,588,4622,1,0,0,0,590,4626,1,0,0,0,592,4634,
        1,0,0,0,594,4641,1,0,0,0,596,4645,1,0,0,0,598,4656,1,0,0,0,600,4658,
        1,0,0,0,602,4662,1,0,0,0,604,4666,1,0,0,0,606,4670,1,0,0,0,608,4683,
        1,0,0,0,610,4685,1,0,0,0,612,4691,1,0,0,0,614,4699,1,0,0,0,616,4736,
        1,0,0,0,618,4738,1,0,0,0,620,4751,1,0,0,0,622,4753,1,0,0,0,624,4800,
        1,0,0,0,626,4883,1,0,0,0,628,4942,1,0,0,0,630,4944,1,0,0,0,632,4947,
        1,0,0,0,634,4959,1,0,0,0,636,4978,1,0,0,0,638,4980,1,0,0,0,640,4984,
        1,0,0,0,642,4989,1,0,0,0,644,5042,1,0,0,0,646,5049,1,0,0,0,648,5051,
        1,0,0,0,650,5058,1,0,0,0,652,5106,1,0,0,0,654,5108,1,0,0,0,656,5111,
        1,0,0,0,658,5114,1,0,0,0,660,5125,1,0,0,0,662,5130,1,0,0,0,664,5133,
        1,0,0,0,666,5148,1,0,0,0,668,5194,1,0,0,0,670,5196,1,0,0,0,672,5246,
        1,0,0,0,674,5264,1,0,0,0,676,5266,1,0,0,0,678,5282,1,0,0,0,680,5297,
        1,0,0,0,682,5322,1,0,0,0,684,5324,1,0,0,0,686,5332,1,0,0,0,688,5378,
        1,0,0,0,690,5380,1,0,0,0,692,5394,1,0,0,0,694,5396,1,0,0,0,696,5411,
        1,0,0,0,698,5416,1,0,0,0,700,5418,1,0,0,0,702,5420,1,0,0,0,704,5434,
        1,0,0,0,706,5447,1,0,0,0,708,5451,1,0,0,0,710,5453,1,0,0,0,712,5458,
        1,0,0,0,714,5468,1,0,0,0,716,5521,1,0,0,0,718,5532,1,0,0,0,720,5534,
        1,0,0,0,722,5537,1,0,0,0,724,5550,1,0,0,0,726,5582,1,0,0,0,728,5590,
        1,0,0,0,730,5592,1,0,0,0,732,5603,1,0,0,0,734,5605,1,0,0,0,736,5616,
        1,0,0,0,738,5618,1,0,0,0,740,5623,1,0,0,0,742,5634,1,0,0,0,744,5645,
        1,0,0,0,746,5653,1,0,0,0,748,5662,1,0,0,0,750,5671,1,0,0,0,752,5676,
        1,0,0,0,754,5679,1,0,0,0,756,5684,1,0,0,0,758,5689,1,0,0,0,760,5694,
        1,0,0,0,762,5707,1,0,0,0,764,5711,1,0,0,0,766,5716,1,0,0,0,768,5723,
        1,0,0,0,770,5740,1,0,0,0,772,5757,1,0,0,0,774,5770,1,0,0,0,776,5776,
        1,0,0,0,778,5783,1,0,0,0,780,5790,1,0,0,0,782,5795,1,0,0,0,784,5800,
        1,0,0,0,786,5803,1,0,0,0,788,5816,1,0,0,0,790,5824,1,0,0,0,792,5830,
        1,0,0,0,794,5838,1,0,0,0,796,5843,1,0,0,0,798,5848,1,0,0,0,800,5851,
        1,0,0,0,802,5861,1,0,0,0,804,5869,1,0,0,0,806,5874,1,0,0,0,808,5879,
        1,0,0,0,810,5883,1,0,0,0,812,5889,1,0,0,0,814,5894,1,0,0,0,816,5899,
        1,0,0,0,818,5904,1,0,0,0,820,5911,1,0,0,0,822,5918,1,0,0,0,824,5924,
        1,0,0,0,826,5930,1,0,0,0,828,5935,1,0,0,0,830,5945,1,0,0,0,832,5949,
        1,0,0,0,834,5951,1,0,0,0,836,5953,1,0,0,0,838,5956,1,0,0,0,840,5971,
        1,0,0,0,842,6009,1,0,0,0,844,6013,1,0,0,0,846,6015,1,0,0,0,848,6023,
        1,0,0,0,850,6027,1,0,0,0,852,6035,1,0,0,0,854,6044,1,0,0,0,856,6046,
        1,0,0,0,858,6065,1,0,0,0,860,6067,1,0,0,0,862,6069,1,0,0,0,864,6084,
        1,0,0,0,866,6096,1,0,0,0,868,6098,1,0,0,0,870,6106,1,0,0,0,872,6114,
        1,0,0,0,874,6123,1,0,0,0,876,6125,1,0,0,0,878,6143,1,0,0,0,880,6157,
        1,0,0,0,882,6162,1,0,0,0,884,6168,1,0,0,0,886,6170,1,0,0,0,888,6186,
        1,0,0,0,890,6194,1,0,0,0,892,6204,1,0,0,0,894,6217,1,0,0,0,896,6219,
        1,0,0,0,898,6225,1,0,0,0,900,6253,1,0,0,0,902,6263,1,0,0,0,904,6265,
        1,0,0,0,906,6269,1,0,0,0,908,6272,1,0,0,0,910,6275,1,0,0,0,912,6288,
        1,0,0,0,914,6304,1,0,0,0,916,6327,1,0,0,0,918,6329,1,0,0,0,920,6366,
        1,0,0,0,922,6368,1,0,0,0,924,6522,1,0,0,0,926,6535,1,0,0,0,928,6542,
        1,0,0,0,930,6629,1,0,0,0,932,6631,1,0,0,0,934,6685,1,0,0,0,936,6687,
        1,0,0,0,938,6693,1,0,0,0,940,6695,1,0,0,0,942,6702,1,0,0,0,944,6707,
        1,0,0,0,946,6720,1,0,0,0,948,6726,1,0,0,0,950,6728,1,0,0,0,952,6747,
        1,0,0,0,954,6750,1,0,0,0,956,6759,1,0,0,0,958,6761,1,0,0,0,960,6784,
        1,0,0,0,962,7069,1,0,0,0,964,7071,1,0,0,0,966,7097,1,0,0,0,968,7099,
        1,0,0,0,970,7105,1,0,0,0,972,7107,1,0,0,0,974,7122,1,0,0,0,976,7130,
        1,0,0,0,978,7132,1,0,0,0,980,7161,1,0,0,0,982,7194,1,0,0,0,984,7196,
        1,0,0,0,986,7204,1,0,0,0,988,7211,1,0,0,0,990,7213,1,0,0,0,992,7223,
        1,0,0,0,994,7238,1,0,0,0,996,7240,1,0,0,0,998,7244,1,0,0,0,1000,
        7247,1,0,0,0,1002,7250,1,0,0,0,1004,7301,1,0,0,0,1006,7303,1,0,0,
        0,1008,7314,1,0,0,0,1010,7316,1,0,0,0,1012,7318,1,0,0,0,1014,7322,
        1,0,0,0,1016,7324,1,0,0,0,1018,7326,1,0,0,0,1020,7330,1,0,0,0,1022,
        7334,1,0,0,0,1024,7338,1,0,0,0,1026,7346,1,0,0,0,1028,7350,1,0,0,
        0,1030,7358,1,0,0,0,1032,7360,1,0,0,0,1034,7377,1,0,0,0,1036,7379,
        1,0,0,0,1038,7382,1,0,0,0,1040,7387,1,0,0,0,1042,7395,1,0,0,0,1044,
        7401,1,0,0,0,1046,7405,1,0,0,0,1048,7422,1,0,0,0,1050,7425,1,0,0,
        0,1052,7430,1,0,0,0,1054,7432,1,0,0,0,1056,7435,1,0,0,0,1058,7444,
        1,0,0,0,1060,7452,1,0,0,0,1062,7454,1,0,0,0,1064,7459,1,0,0,0,1066,
        7466,1,0,0,0,1068,7476,1,0,0,0,1070,7484,1,0,0,0,1072,7486,1,0,0,
        0,1074,7496,1,0,0,0,1076,7504,1,0,0,0,1078,7506,1,0,0,0,1080,7512,
        1,0,0,0,1082,7533,1,0,0,0,1084,7535,1,0,0,0,1086,7541,1,0,0,0,1088,
        7544,1,0,0,0,1090,7547,1,0,0,0,1092,7575,1,0,0,0,1094,7579,1,0,0,
        0,1096,7586,1,0,0,0,1098,7593,1,0,0,0,1100,7595,1,0,0,0,1102,7611,
        1,0,0,0,1104,7627,1,0,0,0,1106,7631,1,0,0,0,1108,7634,1,0,0,0,1110,
        7637,1,0,0,0,1112,7661,1,0,0,0,1114,7663,1,0,0,0,1116,7671,1,0,0,
        0,1118,7673,1,0,0,0,1120,7676,1,0,0,0,1122,7756,1,0,0,0,1124,7758,
        1,0,0,0,1126,7762,1,0,0,0,1128,7850,1,0,0,0,1130,7852,1,0,0,0,1132,
        7854,1,0,0,0,1134,7856,1,0,0,0,1136,7861,1,0,0,0,1138,7877,1,0,0,
        0,1140,7879,1,0,0,0,1142,7913,1,0,0,0,1144,7915,1,0,0,0,1146,7926,
        1,0,0,0,1148,7933,1,0,0,0,1150,7950,1,0,0,0,1152,7952,1,0,0,0,1154,
        7956,1,0,0,0,1156,7978,1,0,0,0,1158,7980,1,0,0,0,1160,7982,1,0,0,
        0,1162,7989,1,0,0,0,1164,7991,1,0,0,0,1166,7993,1,0,0,0,1168,8142,
        1,0,0,0,1170,8147,1,0,0,0,1172,8154,1,0,0,0,1174,8156,1,0,0,0,1176,
        8164,1,0,0,0,1178,8182,1,0,0,0,1180,8190,1,0,0,0,1182,8198,1,0,0,
        0,1184,8200,1,0,0,0,1186,8204,1,0,0,0,1188,8213,1,0,0,0,1190,8219,
        1,0,0,0,1192,8226,1,0,0,0,1194,8228,1,0,0,0,1196,8243,1,0,0,0,1198,
        8250,1,0,0,0,1200,8253,1,0,0,0,1202,8397,1,0,0,0,1204,8401,1,0,0,
        0,1206,8404,1,0,0,0,1208,8413,1,0,0,0,1210,8422,1,0,0,0,1212,8430,
        1,0,0,0,1214,8476,1,0,0,0,1216,8478,1,0,0,0,1218,8499,1,0,0,0,1220,
        8503,1,0,0,0,1222,8514,1,0,0,0,1224,8559,1,0,0,0,1226,8595,1,0,0,
        0,1228,8597,1,0,0,0,1230,8605,1,0,0,0,1232,8618,1,0,0,0,1234,8620,
        1,0,0,0,1236,8624,1,0,0,0,1238,8627,1,0,0,0,1240,8637,1,0,0,0,1242,
        8639,1,0,0,0,1244,8643,1,0,0,0,1246,8648,1,0,0,0,1248,8652,1,0,0,
        0,1250,8655,1,0,0,0,1252,8658,1,0,0,0,1254,8662,1,0,0,0,1256,8668,
        1,0,0,0,1258,8676,1,0,0,0,1260,8684,1,0,0,0,1262,8690,1,0,0,0,1264,
        8693,1,0,0,0,1266,8711,1,0,0,0,1268,8713,1,0,0,0,1270,8719,1,0,0,
        0,1272,8723,1,0,0,0,1274,8731,1,0,0,0,1276,8739,1,0,0,0,1278,8751,
        1,0,0,0,1280,8763,1,0,0,0,1282,8765,1,0,0,0,1284,8769,1,0,0,0,1286,
        8774,1,0,0,0,1288,8778,1,0,0,0,1290,8784,1,0,0,0,1292,8790,1,0,0,
        0,1294,8797,1,0,0,0,1296,8804,1,0,0,0,1298,8808,1,0,0,0,1300,8827,
        1,0,0,0,1302,8829,1,0,0,0,1304,8832,1,0,0,0,1306,8835,1,0,0,0,1308,
        8844,1,0,0,0,1310,8846,1,0,0,0,1312,8851,1,0,0,0,1314,8853,1,0,0,
        0,1316,8855,1,0,0,0,1318,8857,1,0,0,0,1320,8865,1,0,0,0,1322,8867,
        1,0,0,0,1324,8869,1,0,0,0,1326,8871,1,0,0,0,1328,8882,1,0,0,0,1330,
        8886,1,0,0,0,1332,8888,1,0,0,0,1334,8890,1,0,0,0,1336,8892,1,0,0,
        0,1338,8901,1,0,0,0,1340,8903,1,0,0,0,1342,8905,1,0,0,0,1344,8907,
        1,0,0,0,1346,8909,1,0,0,0,1348,8911,1,0,0,0,1350,8913,1,0,0,0,1352,
        8915,1,0,0,0,1354,8919,1,0,0,0,1356,8923,1,0,0,0,1358,8925,1,0,0,
        0,1360,8927,1,0,0,0,1362,8929,1,0,0,0,1364,8931,1,0,0,0,1366,8933,
        1,0,0,0,1368,8935,1,0,0,0,1370,8937,1,0,0,0,1372,8939,1,0,0,0,1374,
        8941,1,0,0,0,1376,8943,1,0,0,0,1378,8947,1,0,0,0,1380,8949,1,0,0,
        0,1382,8952,1,0,0,0,1384,8964,1,0,0,0,1386,8966,1,0,0,0,1388,8974,
        1,0,0,0,1390,8982,1,0,0,0,1392,8986,1,0,0,0,1394,8988,1,0,0,0,1396,
        8992,1,0,0,0,1398,8994,1,0,0,0,1400,8996,1,0,0,0,1402,8998,1,0,0,
        0,1404,9000,1,0,0,0,1406,9005,1,0,0,0,1408,9009,1,0,0,0,1410,9011,
        1,0,0,0,1412,9019,1,0,0,0,1414,9023,1,0,0,0,1416,9027,1,0,0,0,1418,
        9034,1,0,0,0,1420,9037,1,0,0,0,1422,9039,1,0,0,0,1424,9041,1,0,0,
        0,1426,9048,1,0,0,0,1428,9055,1,0,0,0,1430,9060,1,0,0,0,1432,9071,
        1,0,0,0,1434,9076,1,0,0,0,1436,9078,1,0,0,0,1438,9080,1,0,0,0,1440,
        9094,1,0,0,0,1442,9099,1,0,0,0,1444,9104,1,0,0,0,1446,9111,1,0,0,
        0,1448,9119,1,0,0,0,1450,9121,1,0,0,0,1452,9132,1,0,0,0,1454,9134,
        1,0,0,0,1456,9136,1,0,0,0,1458,9138,1,0,0,0,1460,9146,1,0,0,0,1462,
        9150,1,0,0,0,1464,9152,1,0,0,0,1466,9154,1,0,0,0,1468,9162,1,0,0,
        0,1470,9166,1,0,0,0,1472,9170,1,0,0,0,1474,9174,1,0,0,0,1476,9176,
        1,0,0,0,1478,9179,1,0,0,0,1480,9181,1,0,0,0,1482,9189,1,0,0,0,1484,
        9191,1,0,0,0,1486,9194,1,0,0,0,1488,9212,1,0,0,0,1490,9214,1,0,0,
        0,1492,9216,1,0,0,0,1494,9236,1,0,0,0,1496,9238,1,0,0,0,1498,9245,
        1,0,0,0,1500,9257,1,0,0,0,1502,9263,1,0,0,0,1504,9265,1,0,0,0,1506,
        9267,1,0,0,0,1508,9272,1,0,0,0,1510,1512,3,2,1,0,1511,1510,1,0,0,
        0,1512,1515,1,0,0,0,1513,1511,1,0,0,0,1513,1514,1,0,0,0,1514,1516,
        1,0,0,0,1515,1513,1,0,0,0,1516,1517,5,0,0,1,1517,1,1,0,0,0,1518,
        1521,3,4,2,0,1519,1521,3,458,229,0,1520,1518,1,0,0,0,1520,1519,1,
        0,0,0,1521,1522,1,0,0,0,1522,1523,5,30,0,0,1523,3,1,0,0,0,1524,1601,
        3,6,3,0,1525,1601,3,82,41,0,1526,1601,3,194,97,0,1527,1601,3,226,
        113,0,1528,1601,3,230,115,0,1529,1601,3,232,116,0,1530,1601,3,234,
        117,0,1531,1601,3,236,118,0,1532,1601,3,242,121,0,1533,1601,3,244,
        122,0,1534,1601,3,248,124,0,1535,1601,3,268,134,0,1536,1601,3,296,
        148,0,1537,1601,3,298,149,0,1538,1601,3,452,226,0,1539,1601,3,454,
        227,0,1540,1601,3,476,238,0,1541,1601,3,608,304,0,1542,1601,3,614,
        307,0,1543,1601,3,620,310,0,1544,1601,3,688,344,0,1545,1601,3,702,
        351,0,1546,1601,3,704,352,0,1547,1601,3,714,357,0,1548,1601,3,738,
        369,0,1549,1601,3,740,370,0,1550,1601,3,742,371,0,1551,1601,3,744,
        372,0,1552,1601,3,746,373,0,1553,1601,3,748,374,0,1554,1601,3,750,
        375,0,1555,1601,3,752,376,0,1556,1601,3,754,377,0,1557,1601,3,756,
        378,0,1558,1601,3,758,379,0,1559,1601,3,760,380,0,1560,1601,3,762,
        381,0,1561,1601,3,764,382,0,1562,1601,3,766,383,0,1563,1601,3,768,
        384,0,1564,1601,3,770,385,0,1565,1601,3,772,386,0,1566,1601,3,774,
        387,0,1567,1601,3,776,388,0,1568,1601,3,778,389,0,1569,1601,3,780,
        390,0,1570,1601,3,782,391,0,1571,1601,3,784,392,0,1572,1601,3,786,
        393,0,1573,1601,3,788,394,0,1574,1601,3,790,395,0,1575,1601,3,792,
        396,0,1576,1601,3,794,397,0,1577,1601,3,796,398,0,1578,1601,3,798,
        399,0,1579,1601,3,800,400,0,1580,1601,3,802,401,0,1581,1601,3,804,
        402,0,1582,1601,3,806,403,0,1583,1601,3,808,404,0,1584,1601,3,810,
        405,0,1585,1601,3,812,406,0,1586,1601,3,814,407,0,1587,1601,3,816,
        408,0,1588,1601,3,818,409,0,1589,1601,3,820,410,0,1590,1601,3,822,
        411,0,1591,1601,3,824,412,0,1592,1601,3,826,413,0,1593,1601,3,828,
        414,0,1594,1601,3,874,437,0,1595,1601,3,842,421,0,1596,1601,3,894,
        447,0,1597,1601,3,1090,545,0,1598,1601,3,1100,550,0,1599,1601,3,
        1102,551,0,1600,1524,1,0,0,0,1600,1525,1,0,0,0,1600,1526,1,0,0,0,
        1600,1527,1,0,0,0,1600,1528,1,0,0,0,1600,1529,1,0,0,0,1600,1530,
        1,0,0,0,1600,1531,1,0,0,0,1600,1532,1,0,0,0,1600,1533,1,0,0,0,1600,
        1534,1,0,0,0,1600,1535,1,0,0,0,1600,1536,1,0,0,0,1600,1537,1,0,0,
        0,1600,1538,1,0,0,0,1600,1539,1,0,0,0,1600,1540,1,0,0,0,1600,1541,
        1,0,0,0,1600,1542,1,0,0,0,1600,1543,1,0,0,0,1600,1544,1,0,0,0,1600,
        1545,1,0,0,0,1600,1546,1,0,0,0,1600,1547,1,0,0,0,1600,1548,1,0,0,
        0,1600,1549,1,0,0,0,1600,1550,1,0,0,0,1600,1551,1,0,0,0,1600,1552,
        1,0,0,0,1600,1553,1,0,0,0,1600,1554,1,0,0,0,1600,1555,1,0,0,0,1600,
        1556,1,0,0,0,1600,1557,1,0,0,0,1600,1558,1,0,0,0,1600,1559,1,0,0,
        0,1600,1560,1,0,0,0,1600,1561,1,0,0,0,1600,1562,1,0,0,0,1600,1563,
        1,0,0,0,1600,1564,1,0,0,0,1600,1565,1,0,0,0,1600,1566,1,0,0,0,1600,
        1567,1,0,0,0,1600,1568,1,0,0,0,1600,1569,1,0,0,0,1600,1570,1,0,0,
        0,1600,1571,1,0,0,0,1600,1572,1,0,0,0,1600,1573,1,0,0,0,1600,1574,
        1,0,0,0,1600,1575,1,0,0,0,1600,1576,1,0,0,0,1600,1577,1,0,0,0,1600,
        1578,1,0,0,0,1600,1579,1,0,0,0,1600,1580,1,0,0,0,1600,1581,1,0,0,
        0,1600,1582,1,0,0,0,1600,1583,1,0,0,0,1600,1584,1,0,0,0,1600,1585,
        1,0,0,0,1600,1586,1,0,0,0,1600,1587,1,0,0,0,1600,1588,1,0,0,0,1600,
        1589,1,0,0,0,1600,1590,1,0,0,0,1600,1591,1,0,0,0,1600,1592,1,0,0,
        0,1600,1593,1,0,0,0,1600,1594,1,0,0,0,1600,1595,1,0,0,0,1600,1596,
        1,0,0,0,1600,1597,1,0,0,0,1600,1598,1,0,0,0,1600,1599,1,0,0,0,1601,
        5,1,0,0,0,1602,1623,5,58,0,0,1603,1624,3,22,11,0,1604,1624,3,8,4,
        0,1605,1606,5,440,0,0,1606,1608,3,1344,672,0,1607,1609,3,116,58,
        0,1608,1607,1,0,0,0,1608,1609,1,0,0,0,1609,1624,1,0,0,0,1610,1611,
        5,238,0,0,1611,1613,3,1348,674,0,1612,1614,3,116,58,0,1613,1612,
        1,0,0,0,1613,1614,1,0,0,0,1614,1624,1,0,0,0,1615,1624,3,72,36,0,
        1616,1624,3,12,6,0,1617,1624,3,58,29,0,1618,1619,4,3,0,0,1619,1624,
        3,60,30,0,1620,1624,3,14,7,0,1621,1624,3,20,10,0,1622,1624,3,80,
        40,0,1623,1603,1,0,0,0,1623,1604,1,0,0,0,1623,1605,1,0,0,0,1623,
        1610,1,0,0,0,1623,1615,1,0,0,0,1623,1616,1,0,0,0,1623,1617,1,0,0,
        0,1623,1618,1,0,0,0,1623,1620,1,0,0,0,1623,1621,1,0,0,0,1623,1622,
        1,0,0,0,1624,7,1,0,0,0,1625,1626,5,150,0,0,1626,1628,3,1340,670,
        0,1627,1629,3,10,5,0,1628,1627,1,0,0,0,1629,1630,1,0,0,0,1630,1628,
        1,0,0,0,1630,1631,1,0,0,0,1631,9,1,0,0,0,1632,1640,3,86,43,0,1633,
        1634,5,453,0,0,1634,1636,5,404,0,0,1635,1637,5,6,0,0,1636,1635,1,
        0,0,0,1636,1637,1,0,0,0,1637,1638,1,0,0,0,1638,1640,3,1204,602,0,
        1639,1632,1,0,0,0,1639,1633,1,0,0,0,1640,11,1,0,0,0,1641,1643,3,
        1234,617,0,1642,1641,1,0,0,0,1642,1643,1,0,0,0,1643,1644,1,0,0,0,
        1644,1645,5,205,0,0,1645,1649,3,1368,684,0,1646,1647,5,401,0,0,1647,
        1648,5,506,0,0,1648,1650,3,1112,556,0,1649,1646,1,0,0,0,1649,1650,
        1,0,0,0,1650,1657,1,0,0,0,1651,1652,5,401,0,0,1652,1654,5,122,0,
        0,1653,1655,5,390,0,0,1654,1653,1,0,0,0,1654,1655,1,0,0,0,1655,1656,
        1,0,0,0,1656,1658,5,436,0,0,1657,1651,1,0,0,0,1657,1658,1,0,0,0,
        1658,1662,1,0,0,0,1659,1660,5,470,0,0,1660,1661,5,599,0,0,1661,1663,
        3,1408,704,0,1662,1659,1,0,0,0,1662,1663,1,0,0,0,1663,1670,1,0,0,
        0,1664,1671,5,192,0,0,1665,1668,5,177,0,0,1666,1667,5,401,0,0,1667,
        1669,3,606,303,0,1668,1666,1,0,0,0,1668,1669,1,0,0,0,1669,1671,1,
        0,0,0,1670,1664,1,0,0,0,1670,1665,1,0,0,0,1670,1671,1,0,0,0,1671,
        1674,1,0,0,0,1672,1673,5,118,0,0,1673,1675,3,1446,723,0,1674,1672,
        1,0,0,0,1674,1675,1,0,0,0,1675,1678,1,0,0,0,1676,1677,5,183,0,0,
        1677,1679,3,1034,517,0,1678,1676,1,0,0,0,1678,1679,1,0,0,0,1679,
        13,1,0,0,0,1680,1681,5,315,0,0,1681,1682,5,249,0,0,1682,1683,3,1364,
        682,0,1683,1684,5,51,0,0,1684,1685,5,612,0,0,1685,1687,3,1446,723,
        0,1686,1688,3,16,8,0,1687,1686,1,0,0,0,1687,1688,1,0,0,0,1688,15,
        1,0,0,0,1689,1696,3,18,9,0,1690,1692,5,29,0,0,1691,1690,1,0,0,0,
        1691,1692,1,0,0,0,1692,1693,1,0,0,0,1693,1695,3,18,9,0,1694,1691,
        1,0,0,0,1695,1698,1,0,0,0,1696,1694,1,0,0,0,1696,1697,1,0,0,0,1697,
        17,1,0,0,0,1698,1696,1,0,0,0,1699,1703,3,150,75,0,1700,1703,3,162,
        81,0,1701,1703,3,164,82,0,1702,1699,1,0,0,0,1702,1700,1,0,0,0,1702,
        1701,1,0,0,0,1703,19,1,0,0,0,1704,1705,5,517,0,0,1705,1706,3,1374,
        687,0,1706,1707,3,134,67,0,1707,21,1,0,0,0,1708,1710,3,1314,657,
        0,1709,1708,1,0,0,0,1709,1710,1,0,0,0,1710,1711,1,0,0,0,1711,1712,
        5,583,0,0,1712,1714,3,1384,692,0,1713,1715,3,24,12,0,1714,1713,1,
        0,0,0,1714,1715,1,0,0,0,1715,23,1,0,0,0,1716,1719,3,26,13,0,1717,
        1720,3,1212,606,0,1718,1720,3,54,27,0,1719,1717,1,0,0,0,1719,1718,
        1,0,0,0,1719,1720,1,0,0,0,1720,1730,1,0,0,0,1721,1730,3,1212,606,
        0,1722,1730,3,54,27,0,1723,1724,3,28,14,0,1724,1725,5,29,0,0,1725,
        1727,1,0,0,0,1726,1723,1,0,0,0,1726,1727,1,0,0,0,1727,1728,1,0,0,
        0,1728,1730,3,30,15,0,1729,1716,1,0,0,0,1729,1721,1,0,0,0,1729,1722,
        1,0,0,0,1729,1726,1,0,0,0,1730,25,1,0,0,0,1731,1739,3,28,14,0,1732,
        1733,3,28,14,0,1733,1734,5,29,0,0,1734,1736,1,0,0,0,1735,1732,1,
        0,0,0,1735,1736,1,0,0,0,1736,1737,1,0,0,0,1737,1739,3,34,17,0,1738,
        1731,1,0,0,0,1738,1735,1,0,0,0,1739,27,1,0,0,0,1740,1745,3,36,18,
        0,1741,1742,5,29,0,0,1742,1744,3,36,18,0,1743,1741,1,0,0,0,1744,
        1747,1,0,0,0,1745,1743,1,0,0,0,1745,1746,1,0,0,0,1746,29,1,0,0,0,
        1747,1745,1,0,0,0,1748,1749,5,178,0,0,1749,1756,5,582,0,0,1750,1751,
        5,266,0,0,1751,1756,5,582,0,0,1752,1756,3,32,16,0,1753,1754,4,15,
        1,0,1754,1756,7,0,0,0,1755,1748,1,0,0,0,1755,1750,1,0,0,0,1755,1752,
        1,0,0,0,1755,1753,1,0,0,0,1756,31,1,0,0,0,1757,1758,5,51,0,0,1758,
        1760,5,423,0,0,1759,1761,3,1316,658,0,1760,1759,1,0,0,0,1760,1761,
        1,0,0,0,1761,1765,1,0,0,0,1762,1766,3,1220,610,0,1763,1764,5,422,
        0,0,1764,1766,3,1422,711,0,1765,1762,1,0,0,0,1765,1763,1,0,0,0,1766,
        1852,1,0,0,0,1767,1768,5,184,0,0,1768,1769,5,423,0,0,1769,1852,3,
        1410,705,0,1770,1771,5,456,0,0,1771,1773,5,423,0,0,1772,1774,3,1316,
        658,0,1773,1772,1,0,0,0,1773,1774,1,0,0,0,1774,1775,1,0,0,0,1775,
        1852,3,56,28,0,1776,1777,5,406,0,0,1777,1779,5,423,0,0,1778,1780,
        3,1316,658,0,1779,1778,1,0,0,0,1779,1780,1,0,0,0,1780,1781,1,0,0,
        0,1781,1783,3,56,28,0,1782,1784,3,1316,658,0,1783,1782,1,0,0,0,1783,
        1784,1,0,0,0,1784,1852,1,0,0,0,1785,1786,5,60,0,0,1786,1788,5,423,
        0,0,1787,1789,3,1316,658,0,1788,1787,1,0,0,0,1788,1789,1,0,0,0,1789,
        1790,1,0,0,0,1790,1852,3,56,28,0,1791,1792,5,105,0,0,1792,1793,5,
        423,0,0,1793,1797,3,56,28,0,1794,1796,3,698,349,0,1795,1794,1,0,
        0,0,1796,1799,1,0,0,0,1797,1795,1,0,0,0,1797,1798,1,0,0,0,1798,1852,
        1,0,0,0,1799,1797,1,0,0,0,1800,1801,5,472,0,0,1801,1803,5,423,0,
        0,1802,1804,3,1316,658,0,1803,1802,1,0,0,0,1803,1804,1,0,0,0,1804,
        1805,1,0,0,0,1805,1809,3,56,28,0,1806,1808,3,700,350,0,1807,1806,
        1,0,0,0,1808,1811,1,0,0,0,1809,1807,1,0,0,0,1809,1810,1,0,0,0,1810,
        1852,1,0,0,0,1811,1809,1,0,0,0,1812,1813,5,110,0,0,1813,1815,5,423,
        0,0,1814,1816,3,1316,658,0,1815,1814,1,0,0,0,1815,1816,1,0,0,0,1816,
        1817,1,0,0,0,1817,1852,3,1422,711,0,1818,1819,5,606,0,0,1819,1820,
        5,423,0,0,1820,1852,3,56,28,0,1821,1822,5,471,0,0,1822,1824,5,423,
        0,0,1823,1825,3,1316,658,0,1824,1823,1,0,0,0,1824,1825,1,0,0,0,1825,
        1830,1,0,0,0,1826,1827,3,1410,705,0,1827,1828,5,279,0,0,1828,1829,
        3,1220,610,0,1829,1831,1,0,0,0,1830,1826,1,0,0,0,1830,1831,1,0,0,
        0,1831,1852,1,0,0,0,1832,1833,5,207,0,0,1833,1834,5,423,0,0,1834,
        1835,3,1408,704,0,1835,1836,5,653,0,0,1836,1837,5,583,0,0,1837,1839,
        3,1384,692,0,1838,1840,3,52,26,0,1839,1838,1,0,0,0,1839,1840,1,0,
        0,0,1840,1852,1,0,0,0,1841,1842,5,178,0,0,1842,1843,5,423,0,0,1843,
        1844,3,56,28,0,1844,1845,5,582,0,0,1845,1852,1,0,0,0,1846,1847,5,
        266,0,0,1847,1848,5,423,0,0,1848,1849,3,56,28,0,1849,1850,5,582,
        0,0,1850,1852,1,0,0,0,1851,1757,1,0,0,0,1851,1767,1,0,0,0,1851,1770,
        1,0,0,0,1851,1776,1,0,0,0,1851,1785,1,0,0,0,1851,1791,1,0,0,0,1851,
        1800,1,0,0,0,1851,1812,1,0,0,0,1851,1818,1,0,0,0,1851,1821,1,0,0,
        0,1851,1832,1,0,0,0,1851,1841,1,0,0,0,1851,1846,1,0,0,0,1852,33,
        1,0,0,0,1853,1856,3,38,19,0,1854,1856,3,1200,600,0,1855,1853,1,0,
        0,0,1855,1854,1,0,0,0,1856,1865,1,0,0,0,1857,1861,5,29,0,0,1858,
        1862,3,38,19,0,1859,1862,3,36,18,0,1860,1862,3,1200,600,0,1861,1858,
        1,0,0,0,1861,1859,1,0,0,0,1861,1860,1,0,0,0,1862,1864,1,0,0,0,1863,
        1857,1,0,0,0,1864,1867,1,0,0,0,1865,1863,1,0,0,0,1865,1866,1,0,0,
        0,1866,35,1,0,0,0,1867,1865,1,0,0,0,1868,1872,3,46,23,0,1869,1872,
        3,48,24,0,1870,1872,3,52,26,0,1871,1868,1,0,0,0,1871,1869,1,0,0,
        0,1871,1870,1,0,0,0,1872,37,1,0,0,0,1873,1875,5,51,0,0,1874,1876,
        5,115,0,0,1875,1874,1,0,0,0,1875,1876,1,0,0,0,1876,1889,1,0,0,0,
        1877,1878,3,1408,704,0,1878,1880,3,1126,563,0,1879,1881,3,1116,558,
        0,1880,1879,1,0,0,0,1880,1881,1,0,0,0,1881,1883,1,0,0,0,1882,1884,
        3,40,20,0,1883,1882,1,0,0,0,1883,1884,1,0,0,0,1884,1890,1,0,0,0,
        1885,1886,5,32,0,0,1886,1887,3,90,45,0,1887,1888,5,33,0,0,1888,1890,
        1,0,0,0,1889,1877,1,0,0,0,1889,1885,1,0,0,0,1890,2009,1,0,0,0,1891,
        1892,5,51,0,0,1892,2009,3,1122,561,0,1893,1895,5,99,0,0,1894,1896,
        5,115,0,0,1895,1894,1,0,0,0,1895,1896,1,0,0,0,1896,1897,1,0,0,0,
        1897,1898,3,1324,662,0,1898,1899,3,1408,704,0,1899,1901,3,1126,563,
        0,1900,1902,3,40,20,0,1901,1900,1,0,0,0,1901,1902,1,0,0,0,1902,2009,
        1,0,0,0,1903,1905,5,371,0,0,1904,1906,5,115,0,0,1905,1904,1,0,0,
        0,1905,1906,1,0,0,0,1906,1907,1,0,0,0,1907,1908,3,1324,662,0,1908,
        1910,3,1126,563,0,1909,1911,3,40,20,0,1910,1909,1,0,0,0,1910,1911,
        1,0,0,0,1911,2009,1,0,0,0,1912,1934,5,184,0,0,1913,1915,5,115,0,
        0,1914,1913,1,0,0,0,1914,1915,1,0,0,0,1915,1916,1,0,0,0,1916,1918,
        3,1324,662,0,1917,1919,3,42,21,0,1918,1917,1,0,0,0,1918,1919,1,0,
        0,0,1919,1935,1,0,0,0,1920,1921,5,231,0,0,1921,1922,5,295,0,0,1922,
        1935,3,1324,662,0,1923,1924,5,438,0,0,1924,1935,5,295,0,0,1925,1926,
        3,442,221,0,1926,1927,3,1334,667,0,1927,1935,1,0,0,0,1928,1929,4,
        19,2,0,1929,1930,5,105,0,0,1930,1935,3,1408,704,0,1931,1932,4,19,
        3,0,1932,1933,5,129,0,0,1933,1935,3,1408,704,0,1934,1914,1,0,0,0,
        1934,1920,1,0,0,0,1934,1923,1,0,0,0,1934,1925,1,0,0,0,1934,1928,
        1,0,0,0,1934,1931,1,0,0,0,1935,2009,1,0,0,0,1936,1937,5,177,0,0,
        1937,2009,5,293,0,0,1938,1939,5,192,0,0,1939,2009,5,293,0,0,1940,
        1942,5,58,0,0,1941,1943,5,115,0,0,1942,1941,1,0,0,0,1942,1943,1,
        0,0,0,1943,1944,1,0,0,0,1944,1957,3,1324,662,0,1945,1946,5,519,0,
        0,1946,1950,5,166,0,0,1947,1948,4,19,4,0,1948,1951,3,1020,510,0,
        1949,1951,3,1430,715,0,1950,1947,1,0,0,0,1950,1949,1,0,0,0,1951,
        1958,1,0,0,0,1952,1953,5,184,0,0,1953,1958,5,166,0,0,1954,1955,4,
        19,5,0,1955,1956,5,519,0,0,1956,1958,3,1158,579,0,1957,1945,1,0,
        0,0,1957,1952,1,0,0,0,1957,1954,1,0,0,0,1958,2009,1,0,0,0,1959,1960,
        5,58,0,0,1960,1961,5,268,0,0,1961,1962,3,1334,667,0,1962,1963,3,
        1158,579,0,1963,2009,1,0,0,0,1964,1965,4,19,6,0,1965,1966,5,58,0,
        0,1966,1967,5,105,0,0,1967,1968,3,1408,704,0,1968,1969,3,1120,560,
        0,1969,2009,1,0,0,0,1970,1971,4,19,7,0,1971,1972,5,58,0,0,1972,1973,
        5,129,0,0,1973,1974,3,1408,704,0,1974,1975,3,1120,560,0,1975,2009,
        1,0,0,0,1976,1977,5,470,0,0,1977,1978,5,115,0,0,1978,1979,3,1324,
        662,0,1979,1980,5,599,0,0,1980,1981,3,1408,704,0,1981,2009,1,0,0,
        0,1982,1984,5,470,0,0,1983,1985,7,1,0,0,1984,1983,1,0,0,0,1984,1985,
        1,0,0,0,1985,1986,1,0,0,0,1986,2009,3,1378,689,0,1987,1988,5,470,
        0,0,1988,1989,3,442,221,0,1989,1990,3,1334,667,0,1990,1991,5,599,
        0,0,1991,1992,3,1332,666,0,1992,2009,1,0,0,0,1993,1994,5,136,0,0,
        1994,1995,5,599,0,0,1995,1999,3,1008,504,0,1996,1997,4,19,8,0,1997,
        2000,5,166,0,0,1998,2000,3,1190,595,0,1999,1996,1,0,0,0,1999,1998,
        1,0,0,0,2000,2002,1,0,0,0,2001,2003,3,1250,625,0,2002,2001,1,0,0,
        0,2002,2003,1,0,0,0,2003,2009,1,0,0,0,2004,2009,5,230,0,0,2005,2006,
        5,411,0,0,2006,2007,5,89,0,0,2007,2009,3,44,22,0,2008,1873,1,0,0,
        0,2008,1891,1,0,0,0,2008,1893,1,0,0,0,2008,1903,1,0,0,0,2008,1912,
        1,0,0,0,2008,1936,1,0,0,0,2008,1938,1,0,0,0,2008,1940,1,0,0,0,2008,
        1959,1,0,0,0,2008,1964,1,0,0,0,2008,1970,1,0,0,0,2008,1976,1,0,0,
        0,2008,1982,1,0,0,0,2008,1987,1,0,0,0,2008,1993,1,0,0,0,2008,2004,
        1,0,0,0,2008,2005,1,0,0,0,2009,39,1,0,0,0,2010,2011,5,53,0,0,2011,
        2014,3,1408,704,0,2012,2014,5,225,0,0,2013,2010,1,0,0,0,2013,2012,
        1,0,0,0,2014,41,1,0,0,0,2015,2016,7,2,0,0,2016,43,1,0,0,0,2017,2019,
        3,1408,704,0,2018,2020,3,364,182,0,2019,2018,1,0,0,0,2019,2020,1,
        0,0,0,2020,2028,1,0,0,0,2021,2022,5,29,0,0,2022,2024,3,1408,704,
        0,2023,2025,3,364,182,0,2024,2023,1,0,0,0,2024,2025,1,0,0,0,2025,
        2027,1,0,0,0,2026,2021,1,0,0,0,2027,2030,1,0,0,0,2028,2026,1,0,0,
        0,2028,2029,1,0,0,0,2029,45,1,0,0,0,2030,2028,1,0,0,0,2031,2033,
        5,56,0,0,2032,2034,5,6,0,0,2033,2032,1,0,0,0,2033,2034,1,0,0,0,2034,
        2037,1,0,0,0,2035,2038,5,166,0,0,2036,2038,3,1408,704,0,2037,2035,
        1,0,0,0,2037,2036,1,0,0,0,2038,47,1,0,0,0,2039,2041,5,314,0,0,2040,
        2042,5,6,0,0,2041,2040,1,0,0,0,2041,2042,1,0,0,0,2042,2045,1,0,0,
        0,2043,2046,5,166,0,0,2044,2046,3,1408,704,0,2045,2043,1,0,0,0,2045,
        2044,1,0,0,0,2046,49,1,0,0,0,2047,2049,3,46,23,0,2048,2050,3,48,
        24,0,2049,2048,1,0,0,0,2049,2050,1,0,0,0,2050,2056,1,0,0,0,2051,
        2053,3,48,24,0,2052,2054,3,46,23,0,2053,2052,1,0,0,0,2053,2054,1,
        0,0,0,2054,2056,1,0,0,0,2055,2047,1,0,0,0,2055,2051,1,0,0,0,2056,
        51,1,0,0,0,2057,2058,7,3,0,0,2058,2059,5,634,0,0,2059,53,1,0,0,0,
        2060,2061,5,469,0,0,2061,2062,5,421,0,0,2062,55,1,0,0,0,2063,2066,
        5,57,0,0,2064,2066,3,1410,705,0,2065,2063,1,0,0,0,2065,2064,1,0,
        0,0,2066,57,1,0,0,0,2067,2068,5,582,0,0,2068,2080,3,1360,680,0,2069,
        2070,7,4,0,0,2070,2071,5,152,0,0,2071,2073,3,1446,723,0,2072,2074,
        3,66,33,0,2073,2072,1,0,0,0,2073,2074,1,0,0,0,2074,2081,1,0,0,0,
        2075,2076,5,470,0,0,2076,2077,5,599,0,0,2077,2081,3,1408,704,0,2078,
        2079,4,29,9,0,2079,2081,3,66,33,0,2080,2069,1,0,0,0,2080,2075,1,
        0,0,0,2080,2078,1,0,0,0,2081,59,1,0,0,0,2082,2083,5,614,0,0,2083,
        2084,5,582,0,0,2084,2085,3,1360,680,0,2085,2086,5,519,0,0,2086,2088,
        7,5,0,0,2087,2089,3,62,31,0,2088,2087,1,0,0,0,2088,2089,1,0,0,0,
        2089,61,1,0,0,0,2090,2097,3,64,32,0,2091,2093,5,29,0,0,2092,2091,
        1,0,0,0,2092,2093,1,0,0,0,2093,2094,1,0,0,0,2094,2096,3,64,32,0,
        2095,2092,1,0,0,0,2096,2099,1,0,0,0,2097,2095,1,0,0,0,2097,2098,
        1,0,0,0,2098,63,1,0,0,0,2099,2097,1,0,0,0,2100,2101,3,162,81,0,2101,
        65,1,0,0,0,2102,2109,3,68,34,0,2103,2105,5,29,0,0,2104,2103,1,0,
        0,0,2104,2105,1,0,0,0,2105,2106,1,0,0,0,2106,2108,3,68,34,0,2107,
        2104,1,0,0,0,2108,2111,1,0,0,0,2109,2107,1,0,0,0,2109,2110,1,0,0,
        0,2110,67,1,0,0,0,2111,2109,1,0,0,0,2112,2114,5,270,0,0,2113,2115,
        5,6,0,0,2114,2113,1,0,0,0,2114,2115,1,0,0,0,2115,2116,1,0,0,0,2116,
        2125,3,1474,737,0,2117,2125,3,154,77,0,2118,2125,3,156,78,0,2119,
        2125,3,162,81,0,2120,2125,3,164,82,0,2121,2125,3,170,85,0,2122,2123,
        4,34,10,0,2123,2125,3,172,86,0,2124,2112,1,0,0,0,2124,2117,1,0,0,
        0,2124,2118,1,0,0,0,2124,2119,1,0,0,0,2124,2120,1,0,0,0,2124,2121,
        1,0,0,0,2124,2122,1,0,0,0,2125,69,1,0,0,0,2126,2128,5,270,0,0,2127,
        2129,5,6,0,0,2128,2127,1,0,0,0,2128,2129,1,0,0,0,2129,2130,1,0,0,
        0,2130,2134,3,1474,737,0,2131,2134,3,154,77,0,2132,2134,3,156,78,
        0,2133,2126,1,0,0,0,2133,2131,1,0,0,0,2133,2132,1,0,0,0,2134,71,
        1,0,0,0,2135,2137,3,178,89,0,2136,2135,1,0,0,0,2136,2137,1,0,0,0,
        2137,2139,1,0,0,0,2138,2140,3,1234,617,0,2139,2138,1,0,0,0,2139,
        2140,1,0,0,0,2140,2142,1,0,0,0,2141,2143,3,180,90,0,2142,2141,1,
        0,0,0,2142,2143,1,0,0,0,2143,2144,1,0,0,0,2144,2145,5,644,0,0,2145,
        2146,3,1356,678,0,2146,2147,3,74,37,0,2147,73,1,0,0,0,2148,2150,
        3,1326,663,0,2149,2148,1,0,0,0,2149,2150,1,0,0,0,2150,2151,1,0,0,
        0,2151,2152,5,63,0,0,2152,2153,3,76,38,0,2153,75,1,0,0,0,2154,2156,
        3,100,50,0,2155,2157,3,78,39,0,2156,2155,1,0,0,0,2156,2157,1,0,0,
        0,2157,77,1,0,0,0,2158,2160,5,653,0,0,2159,2161,7,6,0,0,2160,2159,
        1,0,0,0,2160,2161,1,0,0,0,2161,2162,1,0,0,0,2162,2163,5,105,0,0,
        2163,2164,5,409,0,0,2164,79,1,0,0,0,2165,2166,5,276,0,0,2166,2167,
        5,498,0,0,2167,2168,3,1468,734,0,2168,2169,5,341,0,0,2169,2170,5,
        295,0,0,2170,2198,1,0,0,0,2171,2195,4,40,11,0,2172,2173,5,468,0,
        0,2173,2187,5,755,0,0,2174,2175,5,392,0,0,2175,2176,5,496,0,0,2176,
        2177,5,401,0,0,2177,2188,5,200,0,0,2178,2179,5,232,0,0,2179,2180,
        5,101,0,0,2180,2185,3,1408,704,0,2181,2182,5,392,0,0,2182,2183,5,
        496,0,0,2183,2184,5,401,0,0,2184,2186,5,200,0,0,2185,2181,1,0,0,
        0,2185,2186,1,0,0,0,2186,2188,1,0,0,0,2187,2174,1,0,0,0,2187,2178,
        1,0,0,0,2188,2196,1,0,0,0,2189,2190,7,7,0,0,2190,2191,3,1408,704,
        0,2191,2192,3,1408,704,0,2192,2196,1,0,0,0,2193,2194,5,468,0,0,2194,
        2196,5,793,0,0,2195,2172,1,0,0,0,2195,2189,1,0,0,0,2195,2193,1,0,
        0,0,2196,2198,1,0,0,0,2197,2165,1,0,0,0,2197,2171,1,0,0,0,2198,81,
        1,0,0,0,2199,2217,5,139,0,0,2200,2218,3,84,42,0,2201,2218,3,88,44,
        0,2202,2218,3,110,55,0,2203,2218,3,104,52,0,2204,2218,3,112,56,0,
        2205,2218,3,126,63,0,2206,2218,3,174,87,0,2207,2218,3,182,91,0,2208,
        2218,3,120,60,0,2209,2218,3,132,66,0,2210,2218,3,138,69,0,2211,2218,
        3,186,93,0,2212,2218,3,188,94,0,2213,2214,4,41,12,0,2214,2218,3,
        190,95,0,2215,2216,4,41,13,0,2216,2218,3,140,70,0,2217,2200,1,0,
        0,0,2217,2201,1,0,0,0,2217,2202,1,0,0,0,2217,2203,1,0,0,0,2217,2204,
        1,0,0,0,2217,2205,1,0,0,0,2217,2206,1,0,0,0,2217,2207,1,0,0,0,2217,
        2208,1,0,0,0,2217,2209,1,0,0,0,2217,2210,1,0,0,0,2217,2211,1,0,0,
        0,2217,2212,1,0,0,0,2217,2213,1,0,0,0,2217,2215,1,0,0,0,2218,83,
        1,0,0,0,2219,2221,5,150,0,0,2220,2222,3,1242,621,0,2221,2220,1,0,
        0,0,2221,2222,1,0,0,0,2222,2223,1,0,0,0,2223,2227,3,1338,669,0,2224,
        2226,3,86,43,0,2225,2224,1,0,0,0,2226,2229,1,0,0,0,2227,2225,1,0,
        0,0,2227,2228,1,0,0,0,2228,85,1,0,0,0,2229,2227,1,0,0,0,2230,2235,
        3,1210,605,0,2231,2235,3,1206,603,0,2232,2233,4,43,14,0,2233,2235,
        3,1208,604,0,2234,2230,1,0,0,0,2234,2231,1,0,0,0,2234,2232,1,0,0,
        0,2235,87,1,0,0,0,2236,2238,5,586,0,0,2237,2236,1,0,0,0,2237,2238,
        1,0,0,0,2238,2239,1,0,0,0,2239,2241,5,583,0,0,2240,2242,3,1242,621,
        0,2241,2240,1,0,0,0,2241,2242,1,0,0,0,2242,2243,1,0,0,0,2243,2260,
        3,1378,689,0,2244,2245,5,32,0,0,2245,2246,3,90,45,0,2246,2247,5,
        33,0,0,2247,2249,1,0,0,0,2248,2244,1,0,0,0,2248,2249,1,0,0,0,2249,
        2251,1,0,0,0,2250,2252,3,1196,598,0,2251,2250,1,0,0,0,2251,2252,
        1,0,0,0,2252,2261,1,0,0,0,2253,2254,5,305,0,0,2254,2261,3,1384,692,
        0,2255,2256,5,32,0,0,2256,2257,5,305,0,0,2257,2258,3,1384,692,0,
        2258,2259,5,33,0,0,2259,2261,1,0,0,0,2260,2248,1,0,0,0,2260,2253,
        1,0,0,0,2260,2255,1,0,0,0,2261,89,1,0,0,0,2262,2267,3,92,46,0,2263,
        2264,5,29,0,0,2264,2266,3,92,46,0,2265,2263,1,0,0,0,2266,2269,1,
        0,0,0,2267,2265,1,0,0,0,2267,2268,1,0,0,0,2268,91,1,0,0,0,2269,2267,
        1,0,0,0,2270,2273,3,1114,557,0,2271,2273,3,1122,561,0,2272,2270,
        1,0,0,0,2272,2271,1,0,0,0,2273,93,1,0,0,0,2274,2276,7,8,0,0,2275,
        2274,1,0,0,0,2275,2276,1,0,0,0,2276,2277,1,0,0,0,2277,2278,3,96,
        48,0,2278,95,1,0,0,0,2279,2281,5,63,0,0,2280,2279,1,0,0,0,2280,2281,
        1,0,0,0,2281,2282,1,0,0,0,2282,2283,3,100,50,0,2283,97,1,0,0,0,2284,
        2286,3,302,151,0,2285,2287,3,378,189,0,2286,2285,1,0,0,0,2286,2287,
        1,0,0,0,2287,2290,1,0,0,0,2288,2290,3,306,153,0,2289,2284,1,0,0,
        0,2289,2288,1,0,0,0,2290,99,1,0,0,0,2291,2293,3,302,151,0,2292,2294,
        3,378,189,0,2293,2292,1,0,0,0,2293,2294,1,0,0,0,2294,101,1,0,0,0,
        2295,2299,5,139,0,0,2296,2300,3,104,52,0,2297,2300,3,110,55,0,2298,
        2300,3,112,56,0,2299,2296,1,0,0,0,2299,2297,1,0,0,0,2299,2298,1,
        0,0,0,2300,2302,1,0,0,0,2301,2303,5,30,0,0,2302,2301,1,0,0,0,2302,
        2303,1,0,0,0,2303,2304,1,0,0,0,2304,2305,5,0,0,1,2305,103,1,0,0,
        0,2306,2308,3,1234,617,0,2307,2306,1,0,0,0,2307,2308,1,0,0,0,2308,
        2309,1,0,0,0,2309,2311,5,440,0,0,2310,2312,3,1242,621,0,2311,2310,
        1,0,0,0,2311,2312,1,0,0,0,2312,2313,1,0,0,0,2313,2314,3,1342,671,
        0,2314,2323,5,32,0,0,2315,2320,3,1246,623,0,2316,2317,5,29,0,0,2317,
        2319,3,1246,623,0,2318,2316,1,0,0,0,2319,2322,1,0,0,0,2320,2318,
        1,0,0,0,2320,2321,1,0,0,0,2321,2324,1,0,0,0,2322,2320,1,0,0,0,2323,
        2315,1,0,0,0,2323,2324,1,0,0,0,2324,2325,1,0,0,0,2325,2329,5,33,
        0,0,2326,2328,3,114,57,0,2327,2326,1,0,0,0,2328,2331,1,0,0,0,2329,
        2327,1,0,0,0,2329,2330,1,0,0,0,2330,2332,1,0,0,0,2331,2329,1,0,0,
        0,2332,2333,3,108,54,0,2333,105,1,0,0,0,2334,2337,3,1440,720,0,2335,
        2337,5,820,0,0,2336,2334,1,0,0,0,2336,2335,1,0,0,0,2337,107,1,0,
        0,0,2338,2343,3,1034,517,0,2339,2340,4,54,15,0,2340,2341,5,63,0,
        0,2341,2343,3,106,53,0,2342,2338,1,0,0,0,2342,2339,1,0,0,0,2343,
        109,1,0,0,0,2344,2346,3,1234,617,0,2345,2344,1,0,0,0,2345,2346,1,
        0,0,0,2346,2347,1,0,0,0,2347,2349,5,238,0,0,2348,2350,3,1242,621,
        0,2349,2348,1,0,0,0,2349,2350,1,0,0,0,2350,2351,1,0,0,0,2351,2352,
        3,1346,673,0,2352,2361,5,32,0,0,2353,2358,3,1248,624,0,2354,2355,
        5,29,0,0,2355,2357,3,1248,624,0,2356,2354,1,0,0,0,2357,2360,1,0,
        0,0,2358,2356,1,0,0,0,2358,2359,1,0,0,0,2359,2362,1,0,0,0,2360,2358,
        1,0,0,0,2361,2353,1,0,0,0,2361,2362,1,0,0,0,2362,2363,1,0,0,0,2363,
        2364,5,33,0,0,2364,2365,5,491,0,0,2365,2369,3,1252,626,0,2366,2368,
        3,114,57,0,2367,2366,1,0,0,0,2368,2371,1,0,0,0,2369,2367,1,0,0,0,
        2369,2370,1,0,0,0,2370,2372,1,0,0,0,2371,2369,1,0,0,0,2372,2373,
        3,108,54,0,2373,111,1,0,0,0,2374,2376,5,55,0,0,2375,2374,1,0,0,0,
        2375,2376,1,0,0,0,2376,2377,1,0,0,0,2377,2379,5,238,0,0,2378,2380,
        3,1242,621,0,2379,2378,1,0,0,0,2379,2380,1,0,0,0,2380,2381,1,0,0,
        0,2381,2382,3,1370,685,0,2382,2383,5,491,0,0,2383,2384,7,9,0,0,2384,
        2385,5,531,0,0,2385,2386,3,1446,723,0,2386,113,1,0,0,0,2387,2393,
        3,118,59,0,2388,2390,5,390,0,0,2389,2388,1,0,0,0,2389,2390,1,0,0,
        0,2390,2391,1,0,0,0,2391,2393,5,174,0,0,2392,2387,1,0,0,0,2392,2389,
        1,0,0,0,2393,115,1,0,0,0,2394,2396,3,114,57,0,2395,2394,1,0,0,0,
        2396,2397,1,0,0,0,2397,2395,1,0,0,0,2397,2398,1,0,0,0,2398,117,1,
        0,0,0,2399,2400,5,118,0,0,2400,2421,3,1446,723,0,2401,2405,5,297,
        0,0,2402,2406,5,547,0,0,2403,2404,4,59,16,0,2404,2406,3,1408,704,
        0,2405,2402,1,0,0,0,2405,2403,1,0,0,0,2406,2421,1,0,0,0,2407,2408,
        5,392,0,0,2408,2421,5,547,0,0,2409,2410,5,133,0,0,2410,2421,5,547,
        0,0,2411,2412,5,451,0,0,2412,2413,5,547,0,0,2413,2421,5,153,0,0,
        2414,2415,5,370,0,0,2415,2416,5,547,0,0,2416,2421,5,153,0,0,2417,
        2418,5,547,0,0,2418,2419,5,510,0,0,2419,2421,7,10,0,0,2420,2399,
        1,0,0,0,2420,2401,1,0,0,0,2420,2407,1,0,0,0,2420,2409,1,0,0,0,2420,
        2411,1,0,0,0,2420,2414,1,0,0,0,2420,2417,1,0,0,0,2421,119,1,0,0,
        0,2422,2424,3,1314,657,0,2423,2422,1,0,0,0,2423,2424,1,0,0,0,2424,
        2460,1,0,0,0,2425,2427,5,618,0,0,2426,2425,1,0,0,0,2426,2427,1,0,
        0,0,2427,2428,1,0,0,0,2428,2429,5,268,0,0,2429,2431,3,1332,666,0,
        2430,2432,3,1160,580,0,2431,2430,1,0,0,0,2431,2432,1,0,0,0,2432,
        2433,1,0,0,0,2433,2437,3,124,62,0,2434,2436,3,1154,577,0,2435,2434,
        1,0,0,0,2436,2439,1,0,0,0,2437,2435,1,0,0,0,2437,2438,1,0,0,0,2438,
        2461,1,0,0,0,2439,2437,1,0,0,0,2440,2441,5,237,0,0,2441,2442,5,268,
        0,0,2442,2443,3,1332,666,0,2443,2447,3,124,62,0,2444,2446,3,1162,
        581,0,2445,2444,1,0,0,0,2446,2449,1,0,0,0,2447,2445,1,0,0,0,2447,
        2448,1,0,0,0,2448,2461,1,0,0,0,2449,2447,1,0,0,0,2450,2451,5,534,
        0,0,2451,2452,5,268,0,0,2452,2453,3,1332,666,0,2453,2457,3,124,62,
        0,2454,2456,3,1164,582,0,2455,2454,1,0,0,0,2456,2459,1,0,0,0,2457,
        2455,1,0,0,0,2457,2458,1,0,0,0,2458,2461,1,0,0,0,2459,2457,1,0,0,
        0,2460,2426,1,0,0,0,2460,2440,1,0,0,0,2460,2450,1,0,0,0,2461,2463,
        1,0,0,0,2462,2464,3,50,25,0,2463,2462,1,0,0,0,2463,2464,1,0,0,0,
        2464,121,1,0,0,0,2465,2476,3,1332,666,0,2466,2468,3,1332,666,0,2467,
        2466,1,0,0,0,2467,2468,1,0,0,0,2468,2469,1,0,0,0,2469,2470,5,630,
        0,0,2470,2476,3,1152,576,0,2471,2472,3,1332,666,0,2472,2473,5,608,
        0,0,2473,2474,3,1152,576,0,2474,2476,1,0,0,0,2475,2465,1,0,0,0,2475,
        2467,1,0,0,0,2475,2471,1,0,0,0,2476,123,1,0,0,0,2477,2478,5,401,
        0,0,2478,2479,3,1384,692,0,2479,2480,3,1148,574,0,2480,125,1,0,0,
        0,2481,2482,5,315,0,0,2482,2483,5,249,0,0,2483,2484,3,1362,681,0,
        2484,2485,5,51,0,0,2485,2486,5,612,0,0,2486,2488,3,1446,723,0,2487,
        2489,3,128,64,0,2488,2487,1,0,0,0,2488,2489,1,0,0,0,2489,127,1,0,
        0,0,2490,2497,3,130,65,0,2491,2493,5,29,0,0,2492,2491,1,0,0,0,2492,
        2493,1,0,0,0,2493,2494,1,0,0,0,2494,2496,3,130,65,0,2495,2492,1,
        0,0,0,2496,2499,1,0,0,0,2497,2495,1,0,0,0,2497,2498,1,0,0,0,2498,
        129,1,0,0,0,2499,2497,1,0,0,0,2500,2507,3,150,75,0,2501,2507,3,152,
        76,0,2502,2507,3,160,80,0,2503,2507,3,162,81,0,2504,2507,3,164,82,
        0,2505,2507,3,166,83,0,2506,2500,1,0,0,0,2506,2501,1,0,0,0,2506,
        2502,1,0,0,0,2506,2503,1,0,0,0,2506,2504,1,0,0,0,2506,2505,1,0,0,
        0,2507,131,1,0,0,0,2508,2509,5,517,0,0,2509,2510,3,1372,686,0,2510,
        2511,5,231,0,0,2511,2512,5,153,0,0,2512,2513,5,656,0,0,2513,2514,
        3,1468,734,0,2514,2515,3,134,67,0,2515,133,1,0,0,0,2516,2517,5,408,
        0,0,2517,2518,5,32,0,0,2518,2523,3,136,68,0,2519,2520,5,29,0,0,2520,
        2522,3,136,68,0,2521,2519,1,0,0,0,2522,2525,1,0,0,0,2523,2521,1,
        0,0,0,2523,2524,1,0,0,0,2524,2526,1,0,0,0,2525,2523,1,0,0,0,2526,
        2527,5,33,0,0,2527,135,1,0,0,0,2528,2529,5,256,0,0,2529,2543,3,1446,
        723,0,2530,2531,5,150,0,0,2531,2543,3,1446,723,0,2532,2533,5,627,
        0,0,2533,2543,3,1446,723,0,2534,2535,5,424,0,0,2535,2543,3,1446,
        723,0,2536,2537,5,530,0,0,2537,2543,3,1446,723,0,2538,2539,5,416,
        0,0,2539,2543,3,1446,723,0,2540,2541,5,431,0,0,2541,2543,3,1420,
        710,0,2542,2528,1,0,0,0,2542,2530,1,0,0,0,2542,2532,1,0,0,0,2542,
        2534,1,0,0,0,2542,2536,1,0,0,0,2542,2538,1,0,0,0,2542,2540,1,0,0,
        0,2543,137,1,0,0,0,2544,2545,5,582,0,0,2545,2546,3,1358,679,0,2546,
        2551,3,142,71,0,2547,2548,5,629,0,0,2548,2549,5,315,0,0,2549,2550,
        5,249,0,0,2550,2552,3,1364,682,0,2551,2547,1,0,0,0,2551,2552,1,0,
        0,0,2552,2554,1,0,0,0,2553,2555,3,146,73,0,2554,2553,1,0,0,0,2554,
        2555,1,0,0,0,2555,139,1,0,0,0,2556,2557,5,614,0,0,2557,2558,5,582,
        0,0,2558,2559,3,1358,679,0,2559,2560,5,51,0,0,2560,2562,3,144,72,
        0,2561,2563,3,62,31,0,2562,2561,1,0,0,0,2562,2563,1,0,0,0,2563,141,
        1,0,0,0,2564,2565,5,51,0,0,2565,2572,3,144,72,0,2566,2569,4,71,17,
        0,2567,2568,5,51,0,0,2568,2570,3,144,72,0,2569,2567,1,0,0,0,2569,
        2570,1,0,0,0,2570,2572,1,0,0,0,2571,2564,1,0,0,0,2571,2566,1,0,0,
        0,2572,143,1,0,0,0,2573,2574,5,152,0,0,2574,2575,3,1446,723,0,2575,
        145,1,0,0,0,2576,2583,3,148,74,0,2577,2579,5,29,0,0,2578,2577,1,
        0,0,0,2578,2579,1,0,0,0,2579,2580,1,0,0,0,2580,2582,3,148,74,0,2581,
        2578,1,0,0,0,2582,2585,1,0,0,0,2583,2581,1,0,0,0,2583,2584,1,0,0,
        0,2584,147,1,0,0,0,2585,2583,1,0,0,0,2586,2598,3,150,75,0,2587,2598,
        3,154,77,0,2588,2598,3,156,78,0,2589,2598,3,158,79,0,2590,2598,3,
        160,80,0,2591,2598,3,162,81,0,2592,2598,3,164,82,0,2593,2598,3,166,
        83,0,2594,2598,3,168,84,0,2595,2596,4,74,18,0,2596,2598,3,170,85,
        0,2597,2586,1,0,0,0,2597,2587,1,0,0,0,2597,2588,1,0,0,0,2597,2589,
        1,0,0,0,2597,2590,1,0,0,0,2597,2591,1,0,0,0,2597,2592,1,0,0,0,2597,
        2593,1,0,0,0,2597,2594,1,0,0,0,2597,2595,1,0,0,0,2598,149,1,0,0,
        0,2599,2601,5,270,0,0,2600,2602,5,6,0,0,2601,2600,1,0,0,0,2601,2602,
        1,0,0,0,2602,2603,1,0,0,0,2603,2604,3,1474,737,0,2604,151,1,0,0,
        0,2605,2607,7,11,0,0,2606,2608,5,6,0,0,2607,2606,1,0,0,0,2607,2608,
        1,0,0,0,2608,2609,1,0,0,0,2609,2610,3,1474,737,0,2610,153,1,0,0,
        0,2611,2613,5,68,0,0,2612,2614,5,6,0,0,2613,2612,1,0,0,0,2613,2614,
        1,0,0,0,2614,2615,1,0,0,0,2615,2616,3,1474,737,0,2616,155,1,0,0,
        0,2617,2619,5,349,0,0,2618,2620,5,6,0,0,2619,2618,1,0,0,0,2619,2620,
        1,0,0,0,2620,2621,1,0,0,0,2621,2622,3,1474,737,0,2622,157,1,0,0,
        0,2623,2625,5,216,0,0,2624,2626,5,6,0,0,2625,2624,1,0,0,0,2625,2626,
        1,0,0,0,2626,2627,1,0,0,0,2627,2628,3,1474,737,0,2628,159,1,0,0,
        0,2629,2631,5,388,0,0,2630,2632,5,6,0,0,2631,2630,1,0,0,0,2631,2632,
        1,0,0,0,2632,2633,1,0,0,0,2633,2634,3,1422,711,0,2634,161,1,0,0,
        0,2635,2637,5,563,0,0,2636,2635,1,0,0,0,2636,2637,1,0,0,0,2637,2638,
        1,0,0,0,2638,2640,5,198,0,0,2639,2641,5,6,0,0,2640,2639,1,0,0,0,
        2640,2641,1,0,0,0,2641,2642,1,0,0,0,2642,2643,3,1376,688,0,2643,
        163,1,0,0,0,2644,2645,7,12,0,0,2645,165,1,0,0,0,2646,2648,5,118,
        0,0,2647,2649,5,6,0,0,2648,2647,1,0,0,0,2648,2649,1,0,0,0,2649,2650,
        1,0,0,0,2650,2651,3,1446,723,0,2651,167,1,0,0,0,2652,2654,5,223,
        0,0,2653,2655,5,6,0,0,2654,2653,1,0,0,0,2654,2655,1,0,0,0,2655,2656,
        1,0,0,0,2656,2657,3,1474,737,0,2657,169,1,0,0,0,2658,2660,5,194,
        0,0,2659,2661,5,6,0,0,2660,2659,1,0,0,0,2660,2661,1,0,0,0,2661,2662,
        1,0,0,0,2662,2663,3,1440,720,0,2663,171,1,0,0,0,2664,2666,5,198,
        0,0,2665,2667,5,6,0,0,2666,2665,1,0,0,0,2666,2667,1,0,0,0,2667,2668,
        1,0,0,0,2668,2669,3,1486,743,0,2669,173,1,0,0,0,2670,2672,3,176,
        88,0,2671,2670,1,0,0,0,2671,2672,1,0,0,0,2672,2674,1,0,0,0,2673,
        2675,3,1234,617,0,2674,2673,1,0,0,0,2674,2675,1,0,0,0,2675,2677,
        1,0,0,0,2676,2678,3,180,90,0,2677,2676,1,0,0,0,2677,2678,1,0,0,0,
        2678,2679,1,0,0,0,2679,2680,5,644,0,0,2680,2681,3,1354,677,0,2681,
        2682,3,74,37,0,2682,175,1,0,0,0,2683,2684,5,412,0,0,2684,2686,5,
        475,0,0,2685,2687,3,178,89,0,2686,2685,1,0,0,0,2686,2687,1,0,0,0,
        2687,2690,1,0,0,0,2688,2690,3,178,89,0,2689,2683,1,0,0,0,2689,2688,
        1,0,0,0,2690,177,1,0,0,0,2691,2692,5,56,0,0,2692,2693,5,6,0,0,2693,
        2694,7,13,0,0,2694,179,1,0,0,0,2695,2696,5,547,0,0,2696,2697,5,510,
        0,0,2697,2698,7,10,0,0,2698,181,1,0,0,0,2699,2701,3,1234,617,0,2700,
        2699,1,0,0,0,2700,2701,1,0,0,0,2701,2702,1,0,0,0,2702,2704,5,603,
        0,0,2703,2705,3,1242,621,0,2704,2703,1,0,0,0,2704,2705,1,0,0,0,2705,
        2706,1,0,0,0,2706,2707,3,1350,675,0,2707,2708,7,14,0,0,2708,2709,
        7,15,0,0,2709,2710,5,401,0,0,2710,2711,3,1384,692,0,2711,2712,5,
        232,0,0,2712,2713,5,189,0,0,2713,2715,5,503,0,0,2714,2716,3,184,
        92,0,2715,2714,1,0,0,0,2715,2716,1,0,0,0,2716,2717,1,0,0,0,2717,
        2718,3,1034,517,0,2718,183,1,0,0,0,2719,2720,7,16,0,0,2720,2721,
        3,1468,734,0,2721,185,1,0,0,0,2722,2724,3,1234,617,0,2723,2722,1,
        0,0,0,2723,2724,1,0,0,0,2724,2725,1,0,0,0,2725,2727,5,205,0,0,2726,
        2728,3,1242,621,0,2727,2726,1,0,0,0,2727,2728,1,0,0,0,2728,2729,
        1,0,0,0,2729,2730,3,1366,683,0,2730,2731,5,401,0,0,2731,2732,5,506,
        0,0,2732,2739,3,1112,556,0,2733,2734,5,401,0,0,2734,2736,5,122,0,
        0,2735,2737,5,390,0,0,2736,2735,1,0,0,0,2736,2737,1,0,0,0,2737,2738,
        1,0,0,0,2738,2740,5,436,0,0,2739,2733,1,0,0,0,2739,2740,1,0,0,0,
        2740,2747,1,0,0,0,2741,2748,5,192,0,0,2742,2745,5,177,0,0,2743,2744,
        5,401,0,0,2744,2746,3,606,303,0,2745,2743,1,0,0,0,2745,2746,1,0,
        0,0,2746,2748,1,0,0,0,2747,2741,1,0,0,0,2747,2742,1,0,0,0,2747,2748,
        1,0,0,0,2748,2751,1,0,0,0,2749,2750,5,118,0,0,2750,2752,3,1446,723,
        0,2751,2749,1,0,0,0,2751,2752,1,0,0,0,2752,2753,1,0,0,0,2753,2754,
        5,183,0,0,2754,2755,3,1034,517,0,2755,187,1,0,0,0,2756,2758,5,667,
        0,0,2757,2759,3,1242,621,0,2758,2757,1,0,0,0,2758,2759,1,0,0,0,2759,
        2760,1,0,0,0,2760,2761,3,684,342,0,2761,189,1,0,0,0,2762,2763,5,
        412,0,0,2763,2764,5,475,0,0,2764,2765,5,534,0,0,2765,2766,5,726,
        0,0,2766,2767,5,718,0,0,2767,2771,3,1426,713,0,2768,2770,3,192,96,
        0,2769,2768,1,0,0,0,2770,2773,1,0,0,0,2771,2769,1,0,0,0,2771,2772,
        1,0,0,0,2772,2788,1,0,0,0,2773,2771,1,0,0,0,2774,2775,5,534,0,0,
        2775,2776,5,726,0,0,2776,2778,5,718,0,0,2777,2779,3,1242,621,0,2778,
        2777,1,0,0,0,2778,2779,1,0,0,0,2779,2780,1,0,0,0,2780,2784,3,1426,
        713,0,2781,2783,3,192,96,0,2782,2781,1,0,0,0,2783,2786,1,0,0,0,2784,
        2782,1,0,0,0,2784,2785,1,0,0,0,2785,2788,1,0,0,0,2786,2784,1,0,0,
        0,2787,2762,1,0,0,0,2787,2774,1,0,0,0,2788,191,1,0,0,0,2789,2790,
        5,380,0,0,2790,2791,5,589,0,0,2791,2805,3,1448,724,0,2792,2793,5,
        723,0,0,2793,2794,5,589,0,0,2794,2805,3,1448,724,0,2795,2796,5,725,
        0,0,2796,2797,3,1448,724,0,2797,2798,5,262,0,0,2798,2799,5,89,0,
        0,2799,2800,3,1426,713,0,2800,2805,1,0,0,0,2801,2802,5,724,0,0,2802,
        2803,5,589,0,0,2803,2805,3,1448,724,0,2804,2789,1,0,0,0,2804,2792,
        1,0,0,0,2804,2795,1,0,0,0,2804,2801,1,0,0,0,2805,193,1,0,0,0,2806,
        2823,5,184,0,0,2807,2824,3,196,98,0,2808,2824,3,198,99,0,2809,2824,
        3,200,100,0,2810,2824,3,202,101,0,2811,2824,3,204,102,0,2812,2824,
        3,206,103,0,2813,2824,3,210,105,0,2814,2824,3,212,106,0,2815,2824,
        3,214,107,0,2816,2824,3,216,108,0,2817,2824,3,218,109,0,2818,2824,
        3,220,110,0,2819,2820,4,97,19,0,2820,2824,3,222,111,0,2821,2822,
        4,97,20,0,2822,2824,3,224,112,0,2823,2807,1,0,0,0,2823,2808,1,0,
        0,0,2823,2809,1,0,0,0,2823,2810,1,0,0,0,2823,2811,1,0,0,0,2823,2812,
        1,0,0,0,2823,2813,1,0,0,0,2823,2814,1,0,0,0,2823,2815,1,0,0,0,2823,
        2816,1,0,0,0,2823,2817,1,0,0,0,2823,2818,1,0,0,0,2823,2819,1,0,0,
        0,2823,2821,1,0,0,0,2824,195,1,0,0,0,2825,2827,5,150,0,0,2826,2828,
        3,1236,618,0,2827,2826,1,0,0,0,2827,2828,1,0,0,0,2828,2829,1,0,0,
        0,2829,2830,3,1340,670,0,2830,197,1,0,0,0,2831,2833,5,205,0,0,2832,
        2834,3,1236,618,0,2833,2832,1,0,0,0,2833,2834,1,0,0,0,2834,2835,
        1,0,0,0,2835,2836,3,1368,684,0,2836,199,1,0,0,0,2837,2839,5,238,
        0,0,2838,2840,3,1236,618,0,2839,2838,1,0,0,0,2839,2840,1,0,0,0,2840,
        2841,1,0,0,0,2841,2842,3,1348,674,0,2842,201,1,0,0,0,2843,2845,5,
        440,0,0,2844,2846,3,1236,618,0,2845,2844,1,0,0,0,2845,2846,1,0,0,
        0,2846,2847,1,0,0,0,2847,2848,3,1344,672,0,2848,203,1,0,0,0,2849,
        2851,3,1314,657,0,2850,2849,1,0,0,0,2850,2851,1,0,0,0,2851,2852,
        1,0,0,0,2852,2853,5,268,0,0,2853,2854,3,1334,667,0,2854,2855,5,401,
        0,0,2855,2857,3,1384,692,0,2856,2858,3,50,25,0,2857,2856,1,0,0,0,
        2857,2858,1,0,0,0,2858,205,1,0,0,0,2859,2860,5,315,0,0,2860,2861,
        5,249,0,0,2861,2872,3,1364,682,0,2862,2869,3,208,104,0,2863,2865,
        5,29,0,0,2864,2863,1,0,0,0,2864,2865,1,0,0,0,2865,2866,1,0,0,0,2866,
        2868,3,208,104,0,2867,2864,1,0,0,0,2868,2871,1,0,0,0,2869,2867,1,
        0,0,0,2869,2870,1,0,0,0,2870,2873,1,0,0,0,2871,2869,1,0,0,0,2872,
        2862,1,0,0,0,2872,2873,1,0,0,0,2873,207,1,0,0,0,2874,2877,3,164,
        82,0,2875,2877,3,162,81,0,2876,2874,1,0,0,0,2876,2875,1,0,0,0,2877,
        209,1,0,0,0,2878,2880,5,517,0,0,2879,2881,3,1236,618,0,2880,2879,
        1,0,0,0,2880,2881,1,0,0,0,2881,2882,1,0,0,0,2882,2883,3,1374,687,
        0,2883,211,1,0,0,0,2884,2886,5,586,0,0,2885,2884,1,0,0,0,2885,2886,
        1,0,0,0,2886,2887,1,0,0,0,2887,2889,7,17,0,0,2888,2890,3,1236,618,
        0,2889,2888,1,0,0,0,2889,2890,1,0,0,0,2890,2891,1,0,0,0,2891,2893,
        3,1386,693,0,2892,2894,7,2,0,0,2893,2892,1,0,0,0,2893,2894,1,0,0,
        0,2894,213,1,0,0,0,2895,2896,5,582,0,0,2896,2907,3,1360,680,0,2897,
        2904,3,208,104,0,2898,2900,5,29,0,0,2899,2898,1,0,0,0,2899,2900,
        1,0,0,0,2900,2901,1,0,0,0,2901,2903,3,208,104,0,2902,2899,1,0,0,
        0,2903,2906,1,0,0,0,2904,2902,1,0,0,0,2904,2905,1,0,0,0,2905,2908,
        1,0,0,0,2906,2904,1,0,0,0,2907,2897,1,0,0,0,2907,2908,1,0,0,0,2908,
        215,1,0,0,0,2909,2911,5,603,0,0,2910,2912,3,1236,618,0,2911,2910,
        1,0,0,0,2911,2912,1,0,0,0,2912,2913,1,0,0,0,2913,2914,3,1352,676,
        0,2914,217,1,0,0,0,2915,2917,5,644,0,0,2916,2918,3,1236,618,0,2917,
        2916,1,0,0,0,2917,2918,1,0,0,0,2918,2919,1,0,0,0,2919,2921,3,1256,
        628,0,2920,2922,7,2,0,0,2921,2920,1,0,0,0,2921,2922,1,0,0,0,2922,
        219,1,0,0,0,2923,2925,5,667,0,0,2924,2926,3,1236,618,0,2925,2924,
        1,0,0,0,2925,2926,1,0,0,0,2926,2927,1,0,0,0,2927,2928,3,684,342,
        0,2928,221,1,0,0,0,2929,2930,5,534,0,0,2930,2931,5,726,0,0,2931,
        2933,5,718,0,0,2932,2934,3,1236,618,0,2933,2932,1,0,0,0,2933,2934,
        1,0,0,0,2934,2935,1,0,0,0,2935,2936,3,1426,713,0,2936,223,1,0,0,
        0,2937,2938,5,614,0,0,2938,2939,5,582,0,0,2939,2941,3,1360,680,0,
        2940,2942,3,62,31,0,2941,2940,1,0,0,0,2941,2942,1,0,0,0,2942,225,
        1,0,0,0,2943,2944,5,470,0,0,2944,2945,7,17,0,0,2945,2950,3,228,114,
        0,2946,2947,5,29,0,0,2947,2949,3,228,114,0,2948,2946,1,0,0,0,2949,
        2952,1,0,0,0,2950,2948,1,0,0,0,2950,2951,1,0,0,0,2951,227,1,0,0,
        0,2952,2950,1,0,0,0,2953,2954,3,1384,692,0,2954,2955,5,599,0,0,2955,
        2956,3,1378,689,0,2956,229,1,0,0,0,2957,2959,5,606,0,0,2958,2960,
        5,583,0,0,2959,2958,1,0,0,0,2959,2960,1,0,0,0,2960,2961,1,0,0,0,
        2961,2962,3,1384,692,0,2962,231,1,0,0,0,2963,2964,5,266,0,0,2964,
        2965,5,583,0,0,2965,2966,5,235,0,0,2966,2967,3,1450,725,0,2967,233,
        1,0,0,0,2968,2969,5,92,0,0,2969,2975,3,1344,672,0,2970,2972,5,32,
        0,0,2971,2973,3,1006,503,0,2972,2971,1,0,0,0,2972,2973,1,0,0,0,2973,
        2974,1,0,0,0,2974,2976,5,33,0,0,2975,2970,1,0,0,0,2975,2976,1,0,
        0,0,2976,235,1,0,0,0,2977,2979,3,354,177,0,2978,2977,1,0,0,0,2978,
        2979,1,0,0,0,2979,2980,1,0,0,0,2980,2984,5,171,0,0,2981,2983,3,240,
        120,0,2982,2981,1,0,0,0,2983,2986,1,0,0,0,2984,2982,1,0,0,0,2984,
        2985,1,0,0,0,2985,3019,1,0,0,0,2986,2984,1,0,0,0,2987,3011,5,235,
        0,0,2988,2989,3,1388,694,0,2989,2990,5,630,0,0,2990,2992,3,368,184,
        0,2991,2993,3,392,196,0,2992,2991,1,0,0,0,2992,2993,1,0,0,0,2993,
        3012,1,0,0,0,2994,2997,3,1384,692,0,2995,2996,4,118,21,0,2996,2998,
        3,434,217,0,2997,2995,1,0,0,0,2997,2998,1,0,0,0,2998,3000,1,0,0,
        0,2999,3001,3,238,119,0,3000,2999,1,0,0,0,3000,3001,1,0,0,0,3001,
        3003,1,0,0,0,3002,3004,3,392,196,0,3003,3002,1,0,0,0,3003,3004,1,
        0,0,0,3004,3006,1,0,0,0,3005,3007,3,362,181,0,3006,3005,1,0,0,0,
        3006,3007,1,0,0,0,3007,3009,1,0,0,0,3008,3010,3,318,159,0,3009,3008,
        1,0,0,0,3009,3010,1,0,0,0,3010,3012,1,0,0,0,3011,2988,1,0,0,0,3011,
        2994,1,0,0,0,3012,3020,1,0,0,0,3013,3014,3,1388,694,0,3014,3015,
        5,235,0,0,3015,3017,3,368,184,0,3016,3018,3,392,196,0,3017,3016,
        1,0,0,0,3017,3018,1,0,0,0,3018,3020,1,0,0,0,3019,2987,1,0,0,0,3019,
        3013,1,0,0,0,3020,237,1,0,0,0,3021,3022,5,423,0,0,3022,3023,5,32,
        0,0,3023,3024,3,1410,705,0,3024,3025,5,33,0,0,3025,239,1,0,0,0,3026,
        3027,7,18,0,0,3027,241,1,0,0,0,3028,3029,5,183,0,0,3029,3030,3,386,
        193,0,3030,243,1,0,0,0,3031,3049,5,251,0,0,3032,3033,3,1384,692,
        0,3033,3035,5,405,0,0,3034,3036,3,434,217,0,3035,3034,1,0,0,0,3035,
        3036,1,0,0,0,3036,3050,1,0,0,0,3037,3047,3,1408,704,0,3038,3048,
        5,109,0,0,3039,3040,5,453,0,0,3040,3042,3,246,123,0,3041,3043,3,
        392,196,0,3042,3041,1,0,0,0,3042,3043,1,0,0,0,3043,3045,1,0,0,0,
        3044,3046,3,316,158,0,3045,3044,1,0,0,0,3045,3046,1,0,0,0,3046,3048,
        1,0,0,0,3047,3038,1,0,0,0,3047,3039,1,0,0,0,3048,3050,1,0,0,0,3049,
        3032,1,0,0,0,3049,3037,1,0,0,0,3050,245,1,0,0,0,3051,3062,7,19,0,
        0,3052,3059,3,1408,704,0,3053,3060,7,20,0,0,3054,3055,7,21,0,0,3055,
        3056,5,32,0,0,3056,3057,3,262,131,0,3057,3058,5,33,0,0,3058,3060,
        1,0,0,0,3059,3053,1,0,0,0,3059,3054,1,0,0,0,3060,3062,1,0,0,0,3061,
        3051,1,0,0,0,3061,3052,1,0,0,0,3062,247,1,0,0,0,3063,3065,5,274,
        0,0,3064,3066,3,250,125,0,3065,3064,1,0,0,0,3065,3066,1,0,0,0,3066,
        3068,1,0,0,0,3067,3069,5,264,0,0,3068,3067,1,0,0,0,3068,3069,1,0,
        0,0,3069,3071,1,0,0,0,3070,3072,5,279,0,0,3071,3070,1,0,0,0,3071,
        3072,1,0,0,0,3072,3073,1,0,0,0,3073,3075,3,1384,692,0,3074,3076,
        3,1318,659,0,3075,3074,1,0,0,0,3075,3076,1,0,0,0,3076,3087,1,0,0,
        0,3077,3079,3,252,126,0,3078,3080,3,264,132,0,3079,3078,1,0,0,0,
        3079,3080,1,0,0,0,3080,3088,1,0,0,0,3081,3082,5,519,0,0,3082,3084,
        3,1258,629,0,3083,3085,3,264,132,0,3084,3083,1,0,0,0,3084,3085,1,
        0,0,0,3085,3088,1,0,0,0,3086,3088,3,258,129,0,3087,3077,1,0,0,0,
        3087,3081,1,0,0,0,3087,3086,1,0,0,0,3088,3090,1,0,0,0,3089,3091,
        3,266,133,0,3090,3089,1,0,0,0,3090,3091,1,0,0,0,3091,249,1,0,0,0,
        3092,3093,7,22,0,0,3093,251,1,0,0,0,3094,3096,5,32,0,0,3095,3097,
        3,254,127,0,3096,3095,1,0,0,0,3096,3097,1,0,0,0,3097,3098,1,0,0,
        0,3098,3100,5,33,0,0,3099,3094,1,0,0,0,3099,3100,1,0,0,0,3100,3101,
        1,0,0,0,3101,3102,3,256,128,0,3102,253,1,0,0,0,3103,3108,3,1330,
        665,0,3104,3105,5,29,0,0,3105,3107,3,1330,665,0,3106,3104,1,0,0,
        0,3107,3110,1,0,0,0,3108,3106,1,0,0,0,3108,3109,1,0,0,0,3109,255,
        1,0,0,0,3110,3108,1,0,0,0,3111,3112,7,23,0,0,3112,3113,3,260,130,
        0,3113,257,1,0,0,0,3114,3125,3,302,151,0,3115,3125,3,306,153,0,3116,
        3118,5,32,0,0,3117,3119,3,254,127,0,3118,3117,1,0,0,0,3118,3119,
        1,0,0,0,3119,3120,1,0,0,0,3120,3122,5,33,0,0,3121,3116,1,0,0,0,3121,
        3122,1,0,0,0,3122,3123,1,0,0,0,3123,3125,3,100,50,0,3124,3114,1,
        0,0,0,3124,3115,1,0,0,0,3124,3121,1,0,0,0,3125,259,1,0,0,0,3126,
        3128,5,32,0,0,3127,3129,3,262,131,0,3128,3127,1,0,0,0,3128,3129,
        1,0,0,0,3129,3130,1,0,0,0,3130,3139,5,33,0,0,3131,3132,5,29,0,0,
        3132,3134,5,32,0,0,3133,3135,3,262,131,0,3134,3133,1,0,0,0,3134,
        3135,1,0,0,0,3135,3136,1,0,0,0,3136,3138,5,33,0,0,3137,3131,1,0,
        0,0,3138,3141,1,0,0,0,3139,3137,1,0,0,0,3139,3140,1,0,0,0,3140,261,
        1,0,0,0,3141,3139,1,0,0,0,3142,3145,3,912,456,0,3143,3145,5,166,
        0,0,3144,3142,1,0,0,0,3144,3143,1,0,0,0,3145,3153,1,0,0,0,3146,3149,
        5,29,0,0,3147,3150,3,912,456,0,3148,3150,5,166,0,0,3149,3147,1,0,
        0,0,3149,3148,1,0,0,0,3150,3152,1,0,0,0,3151,3146,1,0,0,0,3152,3155,
        1,0,0,0,3153,3151,1,0,0,0,3153,3154,1,0,0,0,3154,263,1,0,0,0,3155,
        3153,1,0,0,0,3156,3157,4,132,22,0,3157,3158,5,63,0,0,3158,3160,3,
        1408,704,0,3159,3161,3,1326,663,0,3160,3159,1,0,0,0,3160,3161,1,
        0,0,0,3161,265,1,0,0,0,3162,3163,5,401,0,0,3163,3164,5,187,0,0,3164,
        3165,5,295,0,0,3165,3166,5,623,0,0,3166,3167,3,1258,629,0,3167,267,
        1,0,0,0,3168,3169,5,311,0,0,3169,3171,3,270,135,0,3170,3172,3,272,
        136,0,3171,3170,1,0,0,0,3171,3172,1,0,0,0,3172,3174,1,0,0,0,3173,
        3175,3,274,137,0,3174,3173,1,0,0,0,3174,3175,1,0,0,0,3175,3177,1,
        0,0,0,3176,3178,5,312,0,0,3177,3176,1,0,0,0,3177,3178,1,0,0,0,3178,
        3180,1,0,0,0,3179,3181,3,276,138,0,3180,3179,1,0,0,0,3180,3181,1,
        0,0,0,3181,3182,1,0,0,0,3182,3184,3,1440,720,0,3183,3185,3,278,139,
        0,3184,3183,1,0,0,0,3184,3185,1,0,0,0,3185,3187,1,0,0,0,3186,3188,
        3,280,140,0,3187,3186,1,0,0,0,3187,3188,1,0,0,0,3188,3190,1,0,0,
        0,3189,3191,7,8,0,0,3190,3189,1,0,0,0,3190,3191,1,0,0,0,3191,3192,
        1,0,0,0,3192,3193,5,279,0,0,3193,3194,5,583,0,0,3194,3196,3,1384,
        692,0,3195,3197,3,1318,659,0,3196,3195,1,0,0,0,3196,3197,1,0,0,0,
        3197,3199,1,0,0,0,3198,3200,3,1262,631,0,3199,3198,1,0,0,0,3199,
        3200,1,0,0,0,3200,3202,1,0,0,0,3201,3203,3,282,141,0,3202,3201,1,
        0,0,0,3202,3203,1,0,0,0,3203,3205,1,0,0,0,3204,3206,3,1264,632,0,
        3205,3204,1,0,0,0,3205,3206,1,0,0,0,3206,3208,1,0,0,0,3207,3209,
        3,1268,634,0,3208,3207,1,0,0,0,3208,3209,1,0,0,0,3209,3210,1,0,0,
        0,3210,3212,3,284,142,0,3211,3213,3,292,146,0,3212,3211,1,0,0,0,
        3212,3213,1,0,0,0,3213,3215,1,0,0,0,3214,3216,3,294,147,0,3215,3214,
        1,0,0,0,3215,3216,1,0,0,0,3216,3218,1,0,0,0,3217,3219,3,290,145,
        0,3218,3217,1,0,0,0,3218,3219,1,0,0,0,3219,269,1,0,0,0,3220,3221,
        7,24,0,0,3221,271,1,0,0,0,3222,3223,7,25,0,0,3223,273,1,0,0,0,3224,
        3225,4,137,23,0,3225,3226,5,235,0,0,3226,275,1,0,0,0,3227,3231,5,
        269,0,0,3228,3229,4,138,24,0,3229,3231,7,26,0,0,3230,3227,1,0,0,
        0,3230,3228,1,0,0,0,3231,277,1,0,0,0,3232,3238,4,139,25,0,3233,3234,
        5,137,0,0,3234,3239,5,3,0,0,3235,3236,3,1406,703,0,3236,3237,5,3,
        0,0,3237,3239,1,0,0,0,3238,3233,1,0,0,0,3238,3235,1,0,0,0,3239,279,
        1,0,0,0,3240,3241,4,140,26,0,3241,3242,5,282,0,0,3242,3243,5,438,
        0,0,3243,3244,5,295,0,0,3244,3245,5,411,0,0,3245,281,1,0,0,0,3246,
        3247,5,500,0,0,3247,3248,5,262,0,0,3248,3249,5,89,0,0,3249,3250,
        3,1442,721,0,3250,283,1,0,0,0,3251,3252,5,264,0,0,3252,3253,5,3,
        0,0,3253,3255,7,27,0,0,3254,3251,1,0,0,0,3254,3255,1,0,0,0,3255,
        3257,1,0,0,0,3256,3258,3,286,143,0,3257,3256,1,0,0,0,3257,3258,1,
        0,0,0,3258,3261,1,0,0,0,3259,3260,5,519,0,0,3260,3262,3,1258,629,
        0,3261,3259,1,0,0,0,3261,3262,1,0,0,0,3262,285,1,0,0,0,3263,3265,
        5,32,0,0,3264,3266,3,288,144,0,3265,3264,1,0,0,0,3265,3266,1,0,0,
        0,3266,3267,1,0,0,0,3267,3268,5,33,0,0,3268,287,1,0,0,0,3269,3274,
        3,1328,664,0,3270,3271,5,39,0,0,3271,3274,3,1468,734,0,3272,3274,
        5,41,0,0,3273,3269,1,0,0,0,3273,3270,1,0,0,0,3273,3272,1,0,0,0,3274,
        3285,1,0,0,0,3275,3281,5,29,0,0,3276,3282,3,1328,664,0,3277,3278,
        5,39,0,0,3278,3282,3,1468,734,0,3279,3282,5,40,0,0,3280,3282,5,41,
        0,0,3281,3276,1,0,0,0,3281,3277,1,0,0,0,3281,3279,1,0,0,0,3281,3280,
        1,0,0,0,3282,3284,1,0,0,0,3283,3275,1,0,0,0,3284,3287,1,0,0,0,3285,
        3283,1,0,0,0,3285,3286,1,0,0,0,3286,289,1,0,0,0,3287,3285,1,0,0,
        0,3288,3289,4,145,27,0,3289,3290,5,56,0,0,3290,3291,5,6,0,0,3291,
        3292,5,804,0,0,3292,291,1,0,0,0,3293,3294,4,146,28,0,3294,3295,5,
        810,0,0,3295,3296,5,6,0,0,3296,3297,5,3,0,0,3297,293,1,0,0,0,3298,
        3299,4,147,29,0,3299,3300,5,358,0,0,3300,3301,5,6,0,0,3301,3302,
        3,1474,737,0,3302,295,1,0,0,0,3303,3305,5,475,0,0,3304,3306,7,28,
        0,0,3305,3304,1,0,0,0,3305,3306,1,0,0,0,3306,3308,1,0,0,0,3307,3309,
        5,279,0,0,3308,3307,1,0,0,0,3308,3309,1,0,0,0,3309,3310,1,0,0,0,
        3310,3312,3,1384,692,0,3311,3313,3,1318,659,0,3312,3311,1,0,0,0,
        3312,3313,1,0,0,0,3313,3318,1,0,0,0,3314,3319,3,252,126,0,3315,3316,
        5,519,0,0,3316,3319,3,1258,629,0,3317,3319,3,258,129,0,3318,3314,
        1,0,0,0,3318,3315,1,0,0,0,3318,3317,1,0,0,0,3319,297,1,0,0,0,3320,
        3322,3,302,151,0,3321,3323,3,378,189,0,3322,3321,1,0,0,0,3322,3323,
        1,0,0,0,3323,3326,1,0,0,0,3324,3326,3,300,150,0,3325,3320,1,0,0,
        0,3325,3324,1,0,0,0,3326,299,1,0,0,0,3327,3328,5,32,0,0,3328,3329,
        3,300,150,0,3329,3330,5,33,0,0,3330,3345,1,0,0,0,3331,3332,3,302,
        151,0,3332,3334,3,324,162,0,3333,3335,3,378,189,0,3334,3333,1,0,
        0,0,3334,3335,1,0,0,0,3335,3345,1,0,0,0,3336,3337,3,302,151,0,3337,
        3338,3,378,189,0,3338,3339,3,324,162,0,3339,3345,1,0,0,0,3340,3341,
        4,150,30,0,3341,3342,3,306,153,0,3342,3343,3,324,162,0,3343,3345,
        1,0,0,0,3344,3327,1,0,0,0,3344,3331,1,0,0,0,3344,3336,1,0,0,0,3344,
        3340,1,0,0,0,3345,301,1,0,0,0,3346,3348,3,354,177,0,3347,3346,1,
        0,0,0,3347,3348,1,0,0,0,3348,3349,1,0,0,0,3349,3351,3,304,152,0,
        3350,3352,3,362,181,0,3351,3350,1,0,0,0,3351,3352,1,0,0,0,3352,3354,
        1,0,0,0,3353,3355,3,316,158,0,3354,3353,1,0,0,0,3354,3355,1,0,0,
        0,3355,303,1,0,0,0,3356,3359,3,308,154,0,3357,3359,3,306,153,0,3358,
        3356,1,0,0,0,3358,3357,1,0,0,0,3359,3371,1,0,0,0,3360,3364,5,617,
        0,0,3361,3362,4,152,31,0,3362,3364,7,29,0,0,3363,3360,1,0,0,0,3363,
        3361,1,0,0,0,3364,3366,1,0,0,0,3365,3367,3,432,216,0,3366,3365,1,
        0,0,0,3366,3367,1,0,0,0,3367,3368,1,0,0,0,3368,3370,3,304,152,0,
        3369,3363,1,0,0,0,3370,3373,1,0,0,0,3371,3369,1,0,0,0,3371,3372,
        1,0,0,0,3372,305,1,0,0,0,3373,3371,1,0,0,0,3374,3377,5,32,0,0,3375,
        3378,3,306,153,0,3376,3378,3,100,50,0,3377,3375,1,0,0,0,3377,3376,
        1,0,0,0,3378,3379,1,0,0,0,3379,3380,5,33,0,0,3380,307,1,0,0,0,3381,
        3387,3,310,155,0,3382,3383,4,154,32,0,3383,3387,3,370,185,0,3384,
        3385,4,154,33,0,3385,3387,3,372,186,0,3386,3381,1,0,0,0,3386,3382,
        1,0,0,0,3386,3384,1,0,0,0,3387,309,1,0,0,0,3388,3392,5,511,0,0,3389,
        3391,3,376,188,0,3390,3389,1,0,0,0,3391,3394,1,0,0,0,3392,3390,1,
        0,0,0,3392,3393,1,0,0,0,3393,3395,1,0,0,0,3394,3392,1,0,0,0,3395,
        3397,3,386,193,0,3396,3398,3,324,162,0,3397,3396,1,0,0,0,3397,3398,
        1,0,0,0,3398,3400,1,0,0,0,3399,3401,3,366,183,0,3400,3399,1,0,0,
        0,3400,3401,1,0,0,0,3401,3403,1,0,0,0,3402,3404,3,392,196,0,3403,
        3402,1,0,0,0,3403,3404,1,0,0,0,3404,3406,1,0,0,0,3405,3407,3,358,
        179,0,3406,3405,1,0,0,0,3406,3407,1,0,0,0,3407,3409,1,0,0,0,3408,
        3410,3,328,164,0,3409,3408,1,0,0,0,3409,3410,1,0,0,0,3410,3412,1,
        0,0,0,3411,3413,3,332,166,0,3412,3411,1,0,0,0,3412,3413,1,0,0,0,
        3413,3415,1,0,0,0,3414,3416,3,330,165,0,3415,3414,1,0,0,0,3415,3416,
        1,0,0,0,3416,311,1,0,0,0,3417,3418,3,306,153,0,3418,313,1,0,0,0,
        3419,3420,7,30,0,0,3420,315,1,0,0,0,3421,3422,5,306,0,0,3422,3423,
        3,320,160,0,3423,317,1,0,0,0,3424,3425,5,306,0,0,3425,3426,3,322,
        161,0,3426,319,1,0,0,0,3427,3430,3,322,161,0,3428,3429,7,31,0,0,
        3429,3431,3,322,161,0,3430,3428,1,0,0,0,3430,3431,1,0,0,0,3431,321,
        1,0,0,0,3432,3435,3,1408,704,0,3433,3435,7,32,0,0,3434,3432,1,0,
        0,0,3434,3433,1,0,0,0,3435,323,1,0,0,0,3436,3464,5,279,0,0,3437,
        3438,5,414,0,0,3438,3440,3,1440,720,0,3439,3441,3,1262,631,0,3440,
        3439,1,0,0,0,3440,3441,1,0,0,0,3441,3443,1,0,0,0,3442,3444,3,1264,
        632,0,3443,3442,1,0,0,0,3443,3444,1,0,0,0,3444,3446,1,0,0,0,3445,
        3447,3,1268,634,0,3446,3445,1,0,0,0,3446,3447,1,0,0,0,3447,3465,
        1,0,0,0,3448,3449,5,186,0,0,3449,3465,3,1440,720,0,3450,3453,3,1468,
        734,0,3451,3453,3,988,494,0,3452,3450,1,0,0,0,3452,3451,1,0,0,0,
        3453,3461,1,0,0,0,3454,3457,5,29,0,0,3455,3458,3,1468,734,0,3456,
        3458,3,988,494,0,3457,3455,1,0,0,0,3457,3456,1,0,0,0,3458,3460,1,
        0,0,0,3459,3454,1,0,0,0,3460,3463,1,0,0,0,3461,3459,1,0,0,0,3461,
        3462,1,0,0,0,3462,3465,1,0,0,0,3463,3461,1,0,0,0,3464,3437,1,0,0,
        0,3464,3448,1,0,0,0,3464,3452,1,0,0,0,3465,325,1,0,0,0,3466,3467,
        5,440,0,0,3467,3473,5,32,0,0,3468,3471,5,3,0,0,3469,3470,5,29,0,
        0,3470,3472,5,3,0,0,3471,3469,1,0,0,0,3471,3472,1,0,0,0,3472,3474,
        1,0,0,0,3473,3468,1,0,0,0,3473,3474,1,0,0,0,3474,3475,1,0,0,0,3475,
        3476,5,33,0,0,3476,327,1,0,0,0,3477,3478,5,253,0,0,3478,3479,3,912,
        456,0,3479,329,1,0,0,0,3480,3481,4,165,34,0,3481,3482,5,812,0,0,
        3482,3483,3,912,456,0,3483,331,1,0,0,0,3484,3485,5,707,0,0,3485,
        3490,3,334,167,0,3486,3487,5,29,0,0,3487,3489,3,334,167,0,3488,3486,
        1,0,0,0,3489,3492,1,0,0,0,3490,3488,1,0,0,0,3490,3491,1,0,0,0,3491,
        333,1,0,0,0,3492,3490,1,0,0,0,3493,3494,3,1404,702,0,3494,3495,5,
        63,0,0,3495,3496,3,336,168,0,3496,335,1,0,0,0,3497,3498,5,32,0,0,
        3498,3499,3,338,169,0,3499,3500,5,33,0,0,3500,337,1,0,0,0,3501,3503,
        3,1404,702,0,3502,3501,1,0,0,0,3502,3503,1,0,0,0,3503,3507,1,0,0,
        0,3504,3505,5,423,0,0,3505,3506,5,89,0,0,3506,3508,3,1024,512,0,
        3507,3504,1,0,0,0,3507,3508,1,0,0,0,3508,3510,1,0,0,0,3509,3511,
        3,362,181,0,3510,3509,1,0,0,0,3510,3511,1,0,0,0,3511,3513,1,0,0,
        0,3512,3514,3,340,170,0,3513,3512,1,0,0,0,3513,3514,1,0,0,0,3514,
        339,1,0,0,0,3515,3516,3,342,171,0,3516,3518,3,344,172,0,3517,3519,
        3,352,176,0,3518,3517,1,0,0,0,3518,3519,1,0,0,0,3519,341,1,0,0,0,
        3520,3521,7,33,0,0,3521,343,1,0,0,0,3522,3525,3,346,173,0,3523,3525,
        3,348,174,0,3524,3522,1,0,0,0,3524,3523,1,0,0,0,3525,345,1,0,0,0,
        3526,3527,5,706,0,0,3527,3541,5,701,0,0,3528,3529,3,1424,712,0,3529,
        3530,5,701,0,0,3530,3541,1,0,0,0,3531,3532,5,43,0,0,3532,3541,5,
        701,0,0,3533,3534,5,278,0,0,3534,3535,3,912,456,0,3535,3536,3,1014,
        507,0,3536,3537,5,701,0,0,3537,3541,1,0,0,0,3538,3539,5,143,0,0,
        3539,3541,5,503,0,0,3540,3526,1,0,0,0,3540,3528,1,0,0,0,3540,3531,
        1,0,0,0,3540,3533,1,0,0,0,3540,3538,1,0,0,0,3541,347,1,0,0,0,3542,
        3543,5,75,0,0,3543,3544,3,350,175,0,3544,3545,5,61,0,0,3545,3546,
        3,350,175,0,3546,349,1,0,0,0,3547,3561,3,346,173,0,3548,3549,5,706,
        0,0,3549,3561,5,690,0,0,3550,3551,3,1424,712,0,3551,3552,5,690,0,
        0,3552,3561,1,0,0,0,3553,3554,5,43,0,0,3554,3561,5,690,0,0,3555,
        3556,5,278,0,0,3556,3557,3,912,456,0,3557,3558,3,1014,507,0,3558,
        3559,5,690,0,0,3559,3561,1,0,0,0,3560,3547,1,0,0,0,3560,3548,1,0,
        0,0,3560,3550,1,0,0,0,3560,3553,1,0,0,0,3560,3555,1,0,0,0,3561,351,
        1,0,0,0,3562,3569,5,688,0,0,3563,3564,5,143,0,0,3564,3570,5,503,
        0,0,3565,3570,5,249,0,0,3566,3570,5,705,0,0,3567,3568,5,392,0,0,
        3568,3570,5,698,0,0,3569,3563,1,0,0,0,3569,3565,1,0,0,0,3569,3566,
        1,0,0,0,3569,3567,1,0,0,0,3570,353,1,0,0,0,3571,3573,5,653,0,0,3572,
        3574,5,673,0,0,3573,3572,1,0,0,0,3573,3574,1,0,0,0,3574,3575,1,0,
        0,0,3575,3580,3,356,178,0,3576,3577,5,29,0,0,3577,3579,3,356,178,
        0,3578,3576,1,0,0,0,3579,3582,1,0,0,0,3580,3578,1,0,0,0,3580,3581,
        1,0,0,0,3581,355,1,0,0,0,3582,3580,1,0,0,0,3583,3585,3,1408,704,
        0,3584,3586,3,1326,663,0,3585,3584,1,0,0,0,3585,3586,1,0,0,0,3586,
        3587,1,0,0,0,3587,3588,5,63,0,0,3588,3589,3,312,156,0,3589,357,1,
        0,0,0,3590,3591,5,249,0,0,3591,3592,5,89,0,0,3592,3594,3,1024,512,
        0,3593,3595,3,360,180,0,3594,3593,1,0,0,0,3594,3595,1,0,0,0,3595,
        3605,1,0,0,0,3596,3597,4,179,35,0,3597,3598,5,249,0,0,3598,3599,
        5,89,0,0,3599,3600,7,34,0,0,3600,3601,5,32,0,0,3601,3602,3,1028,
        514,0,3602,3603,5,33,0,0,3603,3605,1,0,0,0,3604,3590,1,0,0,0,3604,
        3596,1,0,0,0,3605,359,1,0,0,0,3606,3607,5,653,0,0,3607,3608,5,497,
        0,0,3608,361,1,0,0,0,3609,3610,5,411,0,0,3610,3611,5,89,0,0,3611,
        3612,3,1024,512,0,3612,363,1,0,0,0,3613,3614,7,35,0,0,3614,365,1,
        0,0,0,3615,3618,5,235,0,0,3616,3619,5,185,0,0,3617,3619,3,368,184,
        0,3618,3616,1,0,0,0,3618,3617,1,0,0,0,3619,367,1,0,0,0,3620,3625,
        3,394,197,0,3621,3622,5,29,0,0,3622,3624,3,394,197,0,3623,3621,1,
        0,0,0,3624,3627,1,0,0,0,3625,3623,1,0,0,0,3625,3626,1,0,0,0,3626,
        369,1,0,0,0,3627,3625,1,0,0,0,3628,3629,5,635,0,0,3629,3634,3,374,
        187,0,3630,3631,5,29,0,0,3631,3633,3,374,187,0,3632,3630,1,0,0,0,
        3633,3636,1,0,0,0,3634,3632,1,0,0,0,3634,3635,1,0,0,0,3635,371,1,
        0,0,0,3636,3634,1,0,0,0,3637,3638,5,583,0,0,3638,3639,3,1384,692,
        0,3639,373,1,0,0,0,3640,3641,5,503,0,0,3641,3643,5,32,0,0,3642,3644,
        3,262,131,0,3643,3642,1,0,0,0,3643,3644,1,0,0,0,3644,3645,1,0,0,
        0,3645,3646,5,33,0,0,3646,375,1,0,0,0,3647,3650,3,314,157,0,3648,
        3650,5,545,0,0,3649,3647,1,0,0,0,3649,3648,1,0,0,0,3650,377,1,0,
        0,0,3651,3653,4,189,36,0,3652,3654,3,380,190,0,3653,3652,1,0,0,0,
        3654,3655,1,0,0,0,3655,3653,1,0,0,0,3655,3656,1,0,0,0,3656,379,1,
        0,0,0,3657,3658,5,232,0,0,3658,3661,3,382,191,0,3659,3660,5,676,
        0,0,3660,3662,3,1388,694,0,3661,3659,1,0,0,0,3661,3662,1,0,0,0,3662,
        3664,1,0,0,0,3663,3665,3,384,192,0,3664,3663,1,0,0,0,3664,3665,1,
        0,0,0,3665,3671,1,0,0,0,3666,3667,5,314,0,0,3667,3668,5,282,0,0,
        3668,3669,5,520,0,0,3669,3671,5,369,0,0,3670,3657,1,0,0,0,3670,3666,
        1,0,0,0,3671,381,1,0,0,0,3672,3673,7,36,0,0,3673,383,1,0,0,0,3674,
        3675,5,677,0,0,3675,3678,5,678,0,0,3676,3678,5,679,0,0,3677,3674,
        1,0,0,0,3677,3676,1,0,0,0,3678,385,1,0,0,0,3679,3682,3,388,194,0,
        3680,3682,5,16,0,0,3681,3679,1,0,0,0,3681,3680,1,0,0,0,3682,3687,
        1,0,0,0,3683,3684,5,29,0,0,3684,3686,3,388,194,0,3685,3683,1,0,0,
        0,3686,3689,1,0,0,0,3687,3685,1,0,0,0,3687,3688,1,0,0,0,3688,387,
        1,0,0,0,3689,3687,1,0,0,0,3690,3696,3,1336,668,0,3691,3693,3,912,
        456,0,3692,3694,3,390,195,0,3693,3692,1,0,0,0,3693,3694,1,0,0,0,
        3694,3696,1,0,0,0,3695,3690,1,0,0,0,3695,3691,1,0,0,0,3696,389,1,
        0,0,0,3697,3699,5,63,0,0,3698,3697,1,0,0,0,3698,3699,1,0,0,0,3699,
        3702,1,0,0,0,3700,3703,3,1408,704,0,3701,3703,3,1440,720,0,3702,
        3700,1,0,0,0,3702,3701,1,0,0,0,3703,391,1,0,0,0,3704,3705,5,651,
        0,0,3705,3706,3,912,456,0,3706,393,1,0,0,0,3707,3718,3,406,203,0,
        3708,3712,5,34,0,0,3709,3710,4,197,37,0,3710,3713,3,1408,704,0,3711,
        3713,5,740,0,0,3712,3709,1,0,0,0,3712,3711,1,0,0,0,3713,3714,1,0,
        0,0,3714,3715,3,396,198,0,3715,3716,5,35,0,0,3716,3718,1,0,0,0,3717,
        3707,1,0,0,0,3717,3708,1,0,0,0,3718,3722,1,0,0,0,3719,3721,3,398,
        199,0,3720,3719,1,0,0,0,3721,3724,1,0,0,0,3722,3720,1,0,0,0,3722,
        3723,1,0,0,0,3723,395,1,0,0,0,3724,3722,1,0,0,0,3725,3729,3,406,
        203,0,3726,3728,3,398,199,0,3727,3726,1,0,0,0,3728,3731,1,0,0,0,
        3729,3727,1,0,0,0,3729,3730,1,0,0,0,3730,397,1,0,0,0,3731,3729,1,
        0,0,0,3732,3733,3,402,201,0,3733,3738,3,394,197,0,3734,3735,5,401,
        0,0,3735,3739,3,912,456,0,3736,3737,5,630,0,0,3737,3739,3,1412,706,
        0,3738,3734,1,0,0,0,3738,3736,1,0,0,0,3738,3739,1,0,0,0,3739,3752,
        1,0,0,0,3740,3741,3,404,202,0,3741,3746,3,394,197,0,3742,3743,5,
        401,0,0,3743,3747,3,912,456,0,3744,3745,5,630,0,0,3745,3747,3,1412,
        706,0,3746,3742,1,0,0,0,3746,3744,1,0,0,0,3747,3752,1,0,0,0,3748,
        3749,3,400,200,0,3749,3750,3,406,203,0,3750,3752,1,0,0,0,3751,3732,
        1,0,0,0,3751,3740,1,0,0,0,3751,3748,1,0,0,0,3752,399,1,0,0,0,3753,
        3755,5,382,0,0,3754,3756,5,271,0,0,3755,3754,1,0,0,0,3755,3756,1,
        0,0,0,3756,3757,1,0,0,0,3757,3765,5,291,0,0,3758,3759,5,382,0,0,
        3759,3761,7,37,0,0,3760,3762,5,413,0,0,3761,3760,1,0,0,0,3761,3762,
        1,0,0,0,3762,3763,1,0,0,0,3763,3765,5,291,0,0,3764,3753,1,0,0,0,
        3764,3758,1,0,0,0,3765,401,1,0,0,0,3766,3768,7,38,0,0,3767,3766,
        1,0,0,0,3767,3768,1,0,0,0,3768,3769,1,0,0,0,3769,3772,5,291,0,0,
        3770,3772,5,565,0,0,3771,3767,1,0,0,0,3771,3770,1,0,0,0,3772,403,
        1,0,0,0,3773,3775,7,37,0,0,3774,3776,5,413,0,0,3775,3774,1,0,0,0,
        3775,3776,1,0,0,0,3776,3777,1,0,0,0,3777,3778,5,291,0,0,3778,405,
        1,0,0,0,3779,3786,3,408,204,0,3780,3786,3,410,205,0,3781,3786,3,
        412,206,0,3782,3786,3,414,207,0,3783,3784,4,203,38,0,3784,3786,3,
        416,208,0,3785,3779,1,0,0,0,3785,3780,1,0,0,0,3785,3781,1,0,0,0,
        3785,3782,1,0,0,0,3785,3783,1,0,0,0,3786,407,1,0,0,0,3787,3789,3,
        1384,692,0,3788,3790,3,1318,659,0,3789,3788,1,0,0,0,3789,3790,1,
        0,0,0,3790,3792,1,0,0,0,3791,3793,3,434,217,0,3792,3791,1,0,0,0,
        3792,3793,1,0,0,0,3793,3795,1,0,0,0,3794,3796,3,436,218,0,3795,3794,
        1,0,0,0,3795,3796,1,0,0,0,3796,3798,1,0,0,0,3797,3799,3,940,470,
        0,3798,3797,1,0,0,0,3798,3799,1,0,0,0,3799,409,1,0,0,0,3800,3803,
        5,32,0,0,3801,3804,3,408,204,0,3802,3804,3,410,205,0,3803,3801,1,
        0,0,0,3803,3802,1,0,0,0,3804,3805,1,0,0,0,3805,3806,5,33,0,0,3806,
        411,1,0,0,0,3807,3809,3,312,156,0,3808,3810,3,434,217,0,3809,3808,
        1,0,0,0,3809,3810,1,0,0,0,3810,3812,1,0,0,0,3811,3813,3,1326,663,
        0,3812,3811,1,0,0,0,3812,3813,1,0,0,0,3813,3824,1,0,0,0,3814,3815,
        4,206,39,0,3815,3816,5,734,0,0,3816,3818,3,312,156,0,3817,3819,3,
        434,217,0,3818,3817,1,0,0,0,3818,3819,1,0,0,0,3819,3821,1,0,0,0,
        3820,3822,3,1326,663,0,3821,3820,1,0,0,0,3821,3822,1,0,0,0,3822,
        3824,1,0,0,0,3823,3807,1,0,0,0,3823,3814,1,0,0,0,3824,413,1,0,0,
        0,3825,3828,5,32,0,0,3826,3829,3,368,184,0,3827,3829,3,414,207,0,
        3828,3826,1,0,0,0,3828,3827,1,0,0,0,3829,3830,1,0,0,0,3830,3831,
        5,33,0,0,3831,415,1,0,0,0,3832,3833,5,709,0,0,3833,3834,5,32,0,0,
        3834,3835,3,912,456,0,3835,3836,5,29,0,0,3836,3837,3,1440,720,0,
        3837,3838,3,418,209,0,3838,3840,5,33,0,0,3839,3841,3,434,217,0,3840,
        3839,1,0,0,0,3840,3841,1,0,0,0,3841,417,1,0,0,0,3842,3843,5,114,
        0,0,3843,3844,5,32,0,0,3844,3849,3,420,210,0,3845,3846,5,29,0,0,
        3846,3848,3,420,210,0,3847,3845,1,0,0,0,3848,3851,1,0,0,0,3849,3847,
        1,0,0,0,3849,3850,1,0,0,0,3850,3852,1,0,0,0,3851,3849,1,0,0,0,3852,
        3853,5,33,0,0,3853,419,1,0,0,0,3854,3855,3,1408,704,0,3855,3856,
        5,232,0,0,3856,3857,5,711,0,0,3857,3878,1,0,0,0,3858,3859,3,1408,
        704,0,3859,3862,3,1168,584,0,3860,3861,4,210,40,0,3861,3863,3,1250,
        625,0,3862,3860,1,0,0,0,3862,3863,1,0,0,0,3863,3865,1,0,0,0,3864,
        3866,5,209,0,0,3865,3864,1,0,0,0,3865,3866,1,0,0,0,3866,3867,1,0,
        0,0,3867,3868,5,712,0,0,3868,3870,3,1440,720,0,3869,3871,3,424,212,
        0,3870,3869,1,0,0,0,3870,3871,1,0,0,0,3871,3878,1,0,0,0,3872,3873,
        5,710,0,0,3873,3874,5,712,0,0,3874,3875,3,1440,720,0,3875,3876,3,
        418,209,0,3876,3878,1,0,0,0,3877,3854,1,0,0,0,3877,3858,1,0,0,0,
        3877,3872,1,0,0,0,3878,421,1,0,0,0,3879,3881,3,426,213,0,3880,3882,
        3,428,214,0,3881,3880,1,0,0,0,3881,3882,1,0,0,0,3882,3885,1,0,0,
        0,3883,3885,3,428,214,0,3884,3879,1,0,0,0,3884,3883,1,0,0,0,3885,
        423,1,0,0,0,3886,3891,3,422,211,0,3887,3888,3,428,214,0,3888,3889,
        3,426,213,0,3889,3891,1,0,0,0,3890,3886,1,0,0,0,3890,3887,1,0,0,
        0,3891,425,1,0,0,0,3892,3893,3,430,215,0,3893,3894,5,401,0,0,3894,
        3895,5,708,0,0,3895,427,1,0,0,0,3896,3897,3,430,215,0,3897,3898,
        5,401,0,0,3898,3899,5,200,0,0,3899,429,1,0,0,0,3900,3905,5,200,0,
        0,3901,3905,5,395,0,0,3902,3903,5,166,0,0,3903,3905,3,1440,720,0,
        3904,3900,1,0,0,0,3904,3901,1,0,0,0,3904,3902,1,0,0,0,3905,431,1,
        0,0,0,3906,3907,7,39,0,0,3907,433,1,0,0,0,3908,3912,5,63,0,0,3909,
        3910,4,217,41,0,3910,3912,5,6,0,0,3911,3908,1,0,0,0,3911,3909,1,
        0,0,0,3911,3912,1,0,0,0,3912,3913,1,0,0,0,3913,3914,3,1408,704,0,
        3914,435,1,0,0,0,3915,3920,3,438,219,0,3916,3917,5,29,0,0,3917,3919,
        3,438,219,0,3918,3916,1,0,0,0,3919,3922,1,0,0,0,3920,3918,1,0,0,
        0,3920,3921,1,0,0,0,3921,437,1,0,0,0,3922,3920,1,0,0,0,3923,3924,
        3,440,220,0,3924,3926,3,442,221,0,3925,3927,3,446,223,0,3926,3925,
        1,0,0,0,3926,3927,1,0,0,0,3927,3928,1,0,0,0,3928,3929,5,32,0,0,3929,
        3930,3,448,224,0,3930,3931,5,33,0,0,3931,3944,1,0,0,0,3932,3933,
        5,629,0,0,3933,3935,3,442,221,0,3934,3936,3,446,223,0,3935,3934,
        1,0,0,0,3935,3936,1,0,0,0,3936,3937,1,0,0,0,3937,3939,5,32,0,0,3938,
        3940,3,448,224,0,3939,3938,1,0,0,0,3939,3940,1,0,0,0,3940,3941,1,
        0,0,0,3941,3942,5,33,0,0,3942,3944,1,0,0,0,3943,3923,1,0,0,0,3943,
        3932,1,0,0,0,3944,439,1,0,0,0,3945,3946,7,40,0,0,3946,441,1,0,0,
        0,3947,3948,7,41,0,0,3948,443,1,0,0,0,3949,3950,5,438,0,0,3950,3956,
        5,295,0,0,3951,3953,5,618,0,0,3952,3954,3,442,221,0,3953,3952,1,
        0,0,0,3953,3954,1,0,0,0,3954,3956,1,0,0,0,3955,3949,1,0,0,0,3955,
        3951,1,0,0,0,3956,445,1,0,0,0,3957,3963,5,232,0,0,3958,3964,5,291,
        0,0,3959,3960,5,411,0,0,3960,3964,5,89,0,0,3961,3962,5,249,0,0,3962,
        3964,5,89,0,0,3963,3958,1,0,0,0,3963,3959,1,0,0,0,3963,3961,1,0,
        0,0,3964,447,1,0,0,0,3965,3970,3,450,225,0,3966,3967,5,29,0,0,3967,
        3969,3,450,225,0,3968,3966,1,0,0,0,3969,3972,1,0,0,0,3970,3968,1,
        0,0,0,3970,3971,1,0,0,0,3971,449,1,0,0,0,3972,3970,1,0,0,0,3973,
        3976,3,1408,704,0,3974,3976,5,438,0,0,3975,3973,1,0,0,0,3975,3974,
        1,0,0,0,3976,451,1,0,0,0,3977,3979,3,354,177,0,3978,3977,1,0,0,0,
        3978,3979,1,0,0,0,3979,3980,1,0,0,0,3980,3982,5,623,0,0,3981,3983,
        5,321,0,0,3982,3981,1,0,0,0,3982,3983,1,0,0,0,3983,3985,1,0,0,0,
        3984,3986,5,264,0,0,3985,3984,1,0,0,0,3985,3986,1,0,0,0,3986,3987,
        1,0,0,0,3987,3988,3,368,184,0,3988,3989,5,519,0,0,3989,3991,3,1258,
        629,0,3990,3992,3,392,196,0,3991,3990,1,0,0,0,3991,3992,1,0,0,0,
        3992,3994,1,0,0,0,3993,3995,3,362,181,0,3994,3993,1,0,0,0,3994,3995,
        1,0,0,0,3995,3997,1,0,0,0,3996,3998,3,318,159,0,3997,3996,1,0,0,
        0,3997,3998,1,0,0,0,3998,453,1,0,0,0,3999,4004,3,456,228,0,4000,
        4004,3,462,231,0,4001,4004,3,464,232,0,4002,4004,3,470,235,0,4003,
        3999,1,0,0,0,4003,4000,1,0,0,0,4003,4001,1,0,0,0,4003,4002,1,0,0,
        0,4004,455,1,0,0,0,4005,4006,5,553,0,0,4006,4010,5,601,0,0,4007,
        4009,3,460,230,0,4008,4007,1,0,0,0,4009,4012,1,0,0,0,4010,4008,1,
        0,0,0,4010,4011,1,0,0,0,4011,4031,1,0,0,0,4012,4010,1,0,0,0,4013,
        4015,5,120,0,0,4014,4016,5,655,0,0,4015,4014,1,0,0,0,4015,4016,1,
        0,0,0,4016,4022,1,0,0,0,4017,4019,5,61,0,0,4018,4020,5,392,0,0,4019,
        4018,1,0,0,0,4019,4020,1,0,0,0,4020,4021,1,0,0,0,4021,4023,5,98,
        0,0,4022,4017,1,0,0,0,4022,4023,1,0,0,0,4023,4028,1,0,0,0,4024,4026,
        5,392,0,0,4025,4024,1,0,0,0,4025,4026,1,0,0,0,4026,4027,1,0,0,0,
        4027,4029,5,467,0,0,4028,4025,1,0,0,0,4028,4029,1,0,0,0,4029,4031,
        1,0,0,0,4030,4005,1,0,0,0,4030,4013,1,0,0,0,4031,457,1,0,0,0,4032,
        4034,5,74,0,0,4033,4035,5,655,0,0,4034,4033,1,0,0,0,4034,4035,1,
        0,0,0,4035,459,1,0,0,0,4036,4037,5,653,0,0,4037,4038,5,128,0,0,4038,
        4042,5,529,0,0,4039,4040,5,453,0,0,4040,4042,7,42,0,0,4041,4036,
        1,0,0,0,4041,4039,1,0,0,0,4042,461,1,0,0,0,4043,4044,5,505,0,0,4044,
        4073,3,1408,704,0,4045,4047,5,496,0,0,4046,4048,5,655,0,0,4047,4046,
        1,0,0,0,4047,4048,1,0,0,0,4048,4067,1,0,0,0,4049,4051,5,599,0,0,
        4050,4052,5,505,0,0,4051,4050,1,0,0,0,4051,4052,1,0,0,0,4052,4053,
        1,0,0,0,4053,4068,3,1408,704,0,4054,4056,5,61,0,0,4055,4057,5,392,
        0,0,4056,4055,1,0,0,0,4056,4057,1,0,0,0,4057,4058,1,0,0,0,4058,4060,
        5,98,0,0,4059,4054,1,0,0,0,4059,4060,1,0,0,0,4060,4065,1,0,0,0,4061,
        4063,5,392,0,0,4062,4061,1,0,0,0,4062,4063,1,0,0,0,4063,4064,1,0,
        0,0,4064,4066,5,467,0,0,4065,4062,1,0,0,0,4065,4066,1,0,0,0,4066,
        4068,1,0,0,0,4067,4049,1,0,0,0,4067,4059,1,0,0,0,4068,4073,1,0,0,
        0,4069,4070,5,467,0,0,4070,4071,5,505,0,0,4071,4073,3,1408,704,0,
        4072,4043,1,0,0,0,4072,4045,1,0,0,0,4072,4069,1,0,0,0,4073,463,1,
        0,0,0,4074,4075,5,314,0,0,4075,4076,7,17,0,0,4076,4081,3,466,233,
        0,4077,4078,5,29,0,0,4078,4080,3,466,233,0,4079,4077,1,0,0,0,4080,
        4083,1,0,0,0,4081,4079,1,0,0,0,4081,4082,1,0,0,0,4082,4091,1,0,0,
        0,4083,4081,1,0,0,0,4084,4085,5,314,0,0,4085,4086,5,276,0,0,4086,
        4087,5,232,0,0,4087,4091,5,72,0,0,4088,4089,5,620,0,0,4089,4091,
        7,43,0,0,4090,4074,1,0,0,0,4090,4084,1,0,0,0,4090,4088,1,0,0,0,4091,
        465,1,0,0,0,4092,4094,3,1384,692,0,4093,4095,3,434,217,0,4094,4093,
        1,0,0,0,4094,4095,1,0,0,0,4095,4096,1,0,0,0,4096,4097,3,468,234,
        0,4097,467,1,0,0,0,4098,4100,5,453,0,0,4099,4101,5,312,0,0,4100,
        4099,1,0,0,0,4100,4101,1,0,0,0,4101,4107,1,0,0,0,4102,4104,5,321,
        0,0,4103,4102,1,0,0,0,4103,4104,1,0,0,0,4104,4105,1,0,0,0,4105,4107,
        5,657,0,0,4106,4098,1,0,0,0,4106,4103,1,0,0,0,4107,469,1,0,0,0,4108,
        4137,5,659,0,0,4109,4110,7,44,0,0,4110,4112,3,474,237,0,4111,4113,
        7,45,0,0,4112,4111,1,0,0,0,4112,4113,1,0,0,0,4113,4138,1,0,0,0,4114,
        4115,5,195,0,0,4115,4121,3,474,237,0,4116,4119,5,576,0,0,4117,4118,
        5,232,0,0,4118,4120,5,363,0,0,4119,4117,1,0,0,0,4119,4120,1,0,0,
        0,4120,4122,1,0,0,0,4121,4116,1,0,0,0,4121,4122,1,0,0,0,4122,4138,
        1,0,0,0,4123,4124,5,435,0,0,4124,4138,3,474,237,0,4125,4126,5,120,
        0,0,4126,4129,3,474,237,0,4127,4128,5,402,0,0,4128,4130,5,425,0,
        0,4129,4127,1,0,0,0,4129,4130,1,0,0,0,4130,4138,1,0,0,0,4131,4132,
        5,496,0,0,4132,4138,3,474,237,0,4133,4135,5,457,0,0,4134,4136,3,
        472,236,0,4135,4134,1,0,0,0,4135,4136,1,0,0,0,4136,4138,1,0,0,0,
        4137,4109,1,0,0,0,4137,4114,1,0,0,0,4137,4123,1,0,0,0,4137,4125,
        1,0,0,0,4137,4131,1,0,0,0,4137,4133,1,0,0,0,4138,471,1,0,0,0,4139,
        4140,5,136,0,0,4140,4141,5,660,0,0,4141,473,1,0,0,0,4142,4149,3,
        1442,721,0,4143,4144,5,29,0,0,4144,4147,3,1442,721,0,4145,4146,5,
        29,0,0,4146,4148,3,1420,710,0,4147,4145,1,0,0,0,4147,4148,1,0,0,
        0,4148,4150,1,0,0,0,4149,4143,1,0,0,0,4149,4150,1,0,0,0,4150,475,
        1,0,0,0,4151,4152,5,446,0,0,4152,4174,3,478,239,0,4153,4174,3,490,
        245,0,4154,4155,5,485,0,0,4155,4160,3,480,240,0,4156,4157,5,29,0,
        0,4157,4159,3,480,240,0,4158,4156,1,0,0,0,4159,4162,1,0,0,0,4160,
        4158,1,0,0,0,4160,4161,1,0,0,0,4161,4174,1,0,0,0,4162,4160,1,0,0,
        0,4163,4164,5,485,0,0,4164,4166,5,666,0,0,4165,4167,3,1238,619,0,
        4166,4165,1,0,0,0,4166,4167,1,0,0,0,4167,4174,1,0,0,0,4168,4174,
        3,576,288,0,4169,4174,3,578,289,0,4170,4174,3,562,281,0,4171,4174,
        3,486,243,0,4172,4174,3,594,297,0,4173,4151,1,0,0,0,4173,4153,1,
        0,0,0,4173,4154,1,0,0,0,4173,4163,1,0,0,0,4173,4168,1,0,0,0,4173,
        4169,1,0,0,0,4173,4170,1,0,0,0,4173,4171,1,0,0,0,4173,4172,1,0,0,
        0,4174,477,1,0,0,0,4175,4176,7,46,0,0,4176,4181,5,316,0,0,4177,4178,
        5,599,0,0,4178,4182,3,1446,723,0,4179,4180,5,73,0,0,4180,4182,3,
        912,456,0,4181,4177,1,0,0,0,4181,4179,1,0,0,0,4182,479,1,0,0,0,4183,
        4185,3,482,241,0,4184,4186,3,484,242,0,4185,4184,1,0,0,0,4185,4186,
        1,0,0,0,4186,4195,1,0,0,0,4187,4189,3,606,303,0,4188,4190,5,57,0,
        0,4189,4188,1,0,0,0,4189,4190,1,0,0,0,4190,4192,1,0,0,0,4191,4193,
        3,1032,516,0,4192,4191,1,0,0,0,4192,4193,1,0,0,0,4193,4195,1,0,0,
        0,4194,4183,1,0,0,0,4194,4187,1,0,0,0,4195,481,1,0,0,0,4196,4203,
        5,341,0,0,4197,4198,4,241,42,0,4198,4199,5,77,0,0,4199,4200,5,316,
        0,0,4200,4201,5,61,0,0,4201,4203,5,809,0,0,4202,4196,1,0,0,0,4202,
        4197,1,0,0,0,4203,483,1,0,0,0,4204,4205,5,599,0,0,4205,4206,3,1426,
        713,0,4206,485,1,0,0,0,4207,4211,5,311,0,0,4208,4212,5,153,0,0,4209,
        4210,5,583,0,0,4210,4212,3,1384,692,0,4211,4208,1,0,0,0,4211,4209,
        1,0,0,0,4212,4213,1,0,0,0,4213,4214,5,235,0,0,4214,4215,5,341,0,
        0,4215,487,1,0,0,0,4216,4221,5,341,0,0,4217,4218,4,244,43,0,4218,
        4219,5,476,0,0,4219,4221,5,533,0,0,4220,4216,1,0,0,0,4220,4217,1,
        0,0,0,4221,489,1,0,0,0,4222,4223,5,99,0,0,4223,4224,3,488,244,0,
        4224,4225,5,599,0,0,4225,4227,3,492,246,0,4226,4228,3,1032,516,0,
        4227,4226,1,0,0,0,4227,4228,1,0,0,0,4228,491,1,0,0,0,4229,4234,3,
        494,247,0,4230,4231,5,29,0,0,4231,4233,3,494,247,0,4232,4230,1,0,
        0,0,4233,4236,1,0,0,0,4234,4232,1,0,0,0,4234,4235,1,0,0,0,4235,493,
        1,0,0,0,4236,4234,1,0,0,0,4237,4238,3,498,249,0,4238,4239,5,6,0,
        0,4239,4240,3,1448,724,0,4240,4366,1,0,0,0,4241,4242,5,737,0,0,4242,
        4243,5,6,0,0,4243,4366,3,1448,724,0,4244,4245,3,500,250,0,4245,4246,
        5,6,0,0,4246,4247,3,1448,724,0,4247,4366,1,0,0,0,4248,4249,3,502,
        251,0,4249,4250,5,6,0,0,4250,4251,3,1448,724,0,4251,4366,1,0,0,0,
        4252,4253,3,504,252,0,4253,4254,5,6,0,0,4254,4255,3,1448,724,0,4255,
        4366,1,0,0,0,4256,4257,3,506,253,0,4257,4258,5,6,0,0,4258,4259,3,
        1420,710,0,4259,4366,1,0,0,0,4260,4261,3,508,254,0,4261,4262,5,6,
        0,0,4262,4263,3,1420,710,0,4263,4366,1,0,0,0,4264,4265,3,510,255,
        0,4265,4266,5,6,0,0,4266,4267,3,1420,710,0,4267,4366,1,0,0,0,4268,
        4269,3,512,256,0,4269,4270,5,6,0,0,4270,4271,3,1420,710,0,4271,4366,
        1,0,0,0,4272,4273,3,514,257,0,4273,4274,5,6,0,0,4274,4275,3,1420,
        710,0,4275,4366,1,0,0,0,4276,4277,3,516,258,0,4277,4278,5,6,0,0,
        4278,4279,3,1448,724,0,4279,4366,1,0,0,0,4280,4281,3,518,259,0,4281,
        4282,5,6,0,0,4282,4283,3,1448,724,0,4283,4366,1,0,0,0,4284,4285,
        3,530,265,0,4285,4286,5,6,0,0,4286,4287,3,1448,724,0,4287,4366,1,
        0,0,0,4288,4289,3,534,267,0,4289,4290,5,6,0,0,4290,4291,3,1448,724,
        0,4291,4366,1,0,0,0,4292,4293,3,532,266,0,4293,4294,5,6,0,0,4294,
        4295,3,552,276,0,4295,4366,1,0,0,0,4296,4297,3,520,260,0,4297,4298,
        5,6,0,0,4298,4299,3,1448,724,0,4299,4366,1,0,0,0,4300,4301,3,526,
        263,0,4301,4302,5,6,0,0,4302,4303,3,1448,724,0,4303,4366,1,0,0,0,
        4304,4305,3,528,264,0,4305,4306,5,6,0,0,4306,4307,3,1420,710,0,4307,
        4366,1,0,0,0,4308,4309,3,522,261,0,4309,4310,5,6,0,0,4310,4311,3,
        1446,723,0,4311,4366,1,0,0,0,4312,4313,3,524,262,0,4313,4314,5,6,
        0,0,4314,4315,3,1448,724,0,4315,4366,1,0,0,0,4316,4317,3,536,268,
        0,4317,4318,5,6,0,0,4318,4319,3,1448,724,0,4319,4366,1,0,0,0,4320,
        4321,3,538,269,0,4321,4322,5,6,0,0,4322,4323,3,1420,710,0,4323,4366,
        1,0,0,0,4324,4325,3,540,270,0,4325,4326,5,6,0,0,4326,4327,3,1420,
        710,0,4327,4366,1,0,0,0,4328,4329,5,265,0,0,4329,4330,5,6,0,0,4330,
        4366,3,560,280,0,4331,4332,3,542,271,0,4332,4333,5,6,0,0,4333,4334,
        3,1440,720,0,4334,4366,1,0,0,0,4335,4336,3,544,272,0,4336,4337,5,
        6,0,0,4337,4338,3,1420,710,0,4338,4366,1,0,0,0,4339,4340,3,496,248,
        0,4340,4341,5,6,0,0,4341,4342,3,1420,710,0,4342,4366,1,0,0,0,4343,
        4344,5,745,0,0,4344,4345,5,6,0,0,4345,4366,3,546,273,0,4346,4347,
        5,747,0,0,4347,4348,5,6,0,0,4348,4366,3,1420,710,0,4349,4350,5,750,
        0,0,4350,4351,5,6,0,0,4351,4366,3,548,274,0,4352,4353,4,247,44,0,
        4353,4354,5,759,0,0,4354,4355,5,6,0,0,4355,4366,3,1422,711,0,4356,
        4357,4,247,45,0,4357,4358,5,764,0,0,4358,4359,5,6,0,0,4359,4366,
        3,550,275,0,4360,4361,4,247,46,0,4361,4362,5,802,0,0,4362,4363,5,
        6,0,0,4363,4366,3,1422,711,0,4364,4366,3,554,277,0,4365,4237,1,0,
        0,0,4365,4241,1,0,0,0,4365,4244,1,0,0,0,4365,4248,1,0,0,0,4365,4252,
        1,0,0,0,4365,4256,1,0,0,0,4365,4260,1,0,0,0,4365,4264,1,0,0,0,4365,
        4268,1,0,0,0,4365,4272,1,0,0,0,4365,4276,1,0,0,0,4365,4280,1,0,0,
        0,4365,4284,1,0,0,0,4365,4288,1,0,0,0,4365,4292,1,0,0,0,4365,4296,
        1,0,0,0,4365,4300,1,0,0,0,4365,4304,1,0,0,0,4365,4308,1,0,0,0,4365,
        4312,1,0,0,0,4365,4316,1,0,0,0,4365,4320,1,0,0,0,4365,4324,1,0,0,
        0,4365,4328,1,0,0,0,4365,4331,1,0,0,0,4365,4335,1,0,0,0,4365,4339,
        1,0,0,0,4365,4343,1,0,0,0,4365,4346,1,0,0,0,4365,4349,1,0,0,0,4365,
        4352,1,0,0,0,4365,4356,1,0,0,0,4365,4360,1,0,0,0,4365,4364,1,0,0,
        0,4366,495,1,0,0,0,4367,4368,7,47,0,0,4368,497,1,0,0,0,4369,4370,
        7,48,0,0,4370,499,1,0,0,0,4371,4372,7,49,0,0,4372,501,1,0,0,0,4373,
        4374,7,50,0,0,4374,503,1,0,0,0,4375,4376,7,51,0,0,4376,505,1,0,0,
        0,4377,4378,7,52,0,0,4378,507,1,0,0,0,4379,4380,7,53,0,0,4380,509,
        1,0,0,0,4381,4382,7,54,0,0,4382,511,1,0,0,0,4383,4384,7,55,0,0,4384,
        513,1,0,0,0,4385,4386,7,56,0,0,4386,515,1,0,0,0,4387,4388,7,57,0,
        0,4388,517,1,0,0,0,4389,4390,7,58,0,0,4390,519,1,0,0,0,4391,4392,
        7,59,0,0,4392,521,1,0,0,0,4393,4394,7,60,0,0,4394,523,1,0,0,0,4395,
        4396,7,61,0,0,4396,525,1,0,0,0,4397,4398,7,62,0,0,4398,527,1,0,0,
        0,4399,4400,7,63,0,0,4400,529,1,0,0,0,4401,4402,7,64,0,0,4402,531,
        1,0,0,0,4403,4404,7,65,0,0,4404,533,1,0,0,0,4405,4406,7,66,0,0,4406,
        535,1,0,0,0,4407,4408,7,67,0,0,4408,537,1,0,0,0,4409,4410,7,68,0,
        0,4410,539,1,0,0,0,4411,4412,7,69,0,0,4412,541,1,0,0,0,4413,4414,
        7,70,0,0,4414,543,1,0,0,0,4415,4416,7,71,0,0,4416,545,1,0,0,0,4417,
        4420,3,1306,653,0,4418,4420,5,395,0,0,4419,4417,1,0,0,0,4419,4418,
        1,0,0,0,4420,547,1,0,0,0,4421,4422,7,72,0,0,4422,549,1,0,0,0,4423,
        4427,5,752,0,0,4424,4427,5,312,0,0,4425,4427,3,1440,720,0,4426,4423,
        1,0,0,0,4426,4424,1,0,0,0,4426,4425,1,0,0,0,4427,551,1,0,0,0,4428,
        4431,3,1448,724,0,4429,4431,5,395,0,0,4430,4428,1,0,0,0,4430,4429,
        1,0,0,0,4431,553,1,0,0,0,4432,4433,3,556,278,0,4433,4434,5,6,0,0,
        4434,4435,3,1448,724,0,4435,4447,1,0,0,0,4436,4437,3,558,279,0,4437,
        4438,5,6,0,0,4438,4439,3,1424,712,0,4439,4447,1,0,0,0,4440,4441,
        5,464,0,0,4441,4442,5,6,0,0,4442,4447,3,1448,724,0,4443,4444,5,465,
        0,0,4444,4445,5,6,0,0,4445,4447,3,1420,710,0,4446,4432,1,0,0,0,4446,
        4436,1,0,0,0,4446,4440,1,0,0,0,4446,4443,1,0,0,0,4447,555,1,0,0,
        0,4448,4449,7,73,0,0,4449,557,1,0,0,0,4450,4451,7,74,0,0,4451,559,
        1,0,0,0,4452,4461,5,32,0,0,4453,4458,3,1420,710,0,4454,4455,5,29,
        0,0,4455,4457,3,1420,710,0,4456,4454,1,0,0,0,4457,4460,1,0,0,0,4458,
        4456,1,0,0,0,4458,4459,1,0,0,0,4459,4462,1,0,0,0,4460,4458,1,0,0,
        0,4461,4453,1,0,0,0,4461,4462,1,0,0,0,4462,4463,1,0,0,0,4463,4464,
        5,33,0,0,4464,561,1,0,0,0,4465,4466,5,99,0,0,4466,4467,5,476,0,0,
        4467,4468,5,224,0,0,4468,4473,3,564,282,0,4469,4470,5,29,0,0,4470,
        4472,3,564,282,0,4471,4469,1,0,0,0,4472,4475,1,0,0,0,4473,4471,1,
        0,0,0,4473,4474,1,0,0,0,4474,4477,1,0,0,0,4475,4473,1,0,0,0,4476,
        4478,3,1032,516,0,4477,4476,1,0,0,0,4477,4478,1,0,0,0,4478,563,1,
        0,0,0,4479,4480,5,477,0,0,4480,4481,5,6,0,0,4481,4483,5,32,0,0,4482,
        4484,3,566,283,0,4483,4482,1,0,0,0,4483,4484,1,0,0,0,4484,4485,1,
        0,0,0,4485,4529,5,33,0,0,4486,4487,5,478,0,0,4487,4488,5,6,0,0,4488,
        4490,5,32,0,0,4489,4491,3,566,283,0,4490,4489,1,0,0,0,4490,4491,
        1,0,0,0,4491,4492,1,0,0,0,4492,4529,5,33,0,0,4493,4494,5,479,0,0,
        4494,4495,5,6,0,0,4495,4497,5,32,0,0,4496,4498,3,568,284,0,4497,
        4496,1,0,0,0,4497,4498,1,0,0,0,4498,4499,1,0,0,0,4499,4529,5,33,
        0,0,4500,4501,5,480,0,0,4501,4502,5,6,0,0,4502,4504,5,32,0,0,4503,
        4505,3,568,284,0,4504,4503,1,0,0,0,4504,4505,1,0,0,0,4505,4506,1,
        0,0,0,4506,4529,5,33,0,0,4507,4508,5,481,0,0,4508,4509,5,6,0,0,4509,
        4511,5,32,0,0,4510,4512,3,570,285,0,4511,4510,1,0,0,0,4511,4512,
        1,0,0,0,4512,4513,1,0,0,0,4513,4529,5,33,0,0,4514,4515,5,482,0,0,
        4515,4516,5,6,0,0,4516,4518,5,32,0,0,4517,4519,3,570,285,0,4518,
        4517,1,0,0,0,4518,4519,1,0,0,0,4519,4520,1,0,0,0,4520,4529,5,33,
        0,0,4521,4522,5,483,0,0,4522,4523,5,6,0,0,4523,4525,5,32,0,0,4524,
        4526,3,574,287,0,4525,4524,1,0,0,0,4525,4526,1,0,0,0,4526,4527,1,
        0,0,0,4527,4529,5,33,0,0,4528,4479,1,0,0,0,4528,4486,1,0,0,0,4528,
        4493,1,0,0,0,4528,4500,1,0,0,0,4528,4507,1,0,0,0,4528,4514,1,0,0,
        0,4528,4521,1,0,0,0,4529,565,1,0,0,0,4530,4535,3,1340,670,0,4531,
        4532,5,29,0,0,4532,4534,3,1340,670,0,4533,4531,1,0,0,0,4534,4537,
        1,0,0,0,4535,4533,1,0,0,0,4535,4536,1,0,0,0,4536,567,1,0,0,0,4537,
        4535,1,0,0,0,4538,4543,3,1380,690,0,4539,4540,5,29,0,0,4540,4542,
        3,1380,690,0,4541,4539,1,0,0,0,4542,4545,1,0,0,0,4543,4541,1,0,0,
        0,4543,4544,1,0,0,0,4544,569,1,0,0,0,4545,4543,1,0,0,0,4546,4551,
        3,572,286,0,4547,4548,5,29,0,0,4548,4550,3,572,286,0,4549,4547,1,
        0,0,0,4550,4553,1,0,0,0,4551,4549,1,0,0,0,4551,4552,1,0,0,0,4552,
        571,1,0,0,0,4553,4551,1,0,0,0,4554,4555,3,1448,724,0,4555,573,1,
        0,0,0,4556,4561,3,1254,627,0,4557,4558,5,29,0,0,4558,4560,3,1254,
        627,0,4559,4557,1,0,0,0,4560,4563,1,0,0,0,4561,4559,1,0,0,0,4561,
        4562,1,0,0,0,4562,575,1,0,0,0,4563,4561,1,0,0,0,4564,4565,5,553,
        0,0,4565,4567,3,606,303,0,4566,4568,3,590,295,0,4567,4566,1,0,0,
        0,4567,4568,1,0,0,0,4568,4571,1,0,0,0,4569,4570,5,622,0,0,4570,4572,
        3,580,290,0,4571,4569,1,0,0,0,4571,4572,1,0,0,0,4572,4574,1,0,0,
        0,4573,4575,3,582,291,0,4574,4573,1,0,0,0,4574,4575,1,0,0,0,4575,
        4577,1,0,0,0,4576,4578,3,584,292,0,4577,4576,1,0,0,0,4577,4578,1,
        0,0,0,4578,4580,1,0,0,0,4579,4581,3,586,293,0,4580,4579,1,0,0,0,
        4580,4581,1,0,0,0,4581,4583,1,0,0,0,4582,4584,3,588,294,0,4583,4582,
        1,0,0,0,4583,4584,1,0,0,0,4584,4586,1,0,0,0,4585,4587,3,1032,516,
        0,4586,4585,1,0,0,0,4586,4587,1,0,0,0,4587,577,1,0,0,0,4588,4589,
        5,562,0,0,4589,4591,3,606,303,0,4590,4592,3,590,295,0,4591,4590,
        1,0,0,0,4591,4592,1,0,0,0,4592,4594,1,0,0,0,4593,4595,3,1032,516,
        0,4594,4593,1,0,0,0,4594,4595,1,0,0,0,4595,579,1,0,0,0,4596,4602,
        3,554,277,0,4597,4598,7,75,0,0,4598,4599,5,6,0,0,4599,4602,3,1442,
        721,0,4600,4602,5,540,0,0,4601,4596,1,0,0,0,4601,4597,1,0,0,0,4601,
        4600,1,0,0,0,4602,4607,1,0,0,0,4603,4604,5,29,0,0,4604,4606,3,554,
        277,0,4605,4603,1,0,0,0,4606,4609,1,0,0,0,4607,4605,1,0,0,0,4607,
        4608,1,0,0,0,4608,581,1,0,0,0,4609,4607,1,0,0,0,4610,4611,5,627,
        0,0,4611,4612,5,6,0,0,4612,4613,3,1442,721,0,4613,583,1,0,0,0,4614,
        4615,5,424,0,0,4615,4616,5,6,0,0,4616,4617,3,1442,721,0,4617,585,
        1,0,0,0,4618,4619,5,167,0,0,4619,4620,5,6,0,0,4620,4621,3,1442,721,
        0,4621,587,1,0,0,0,4622,4623,5,427,0,0,4623,4624,5,6,0,0,4624,4625,
        3,1442,721,0,4625,589,1,0,0,0,4626,4631,3,592,296,0,4627,4628,5,
        29,0,0,4628,4630,3,592,296,0,4629,4627,1,0,0,0,4630,4633,1,0,0,0,
        4631,4629,1,0,0,0,4631,4632,1,0,0,0,4632,591,1,0,0,0,4633,4631,1,
        0,0,0,4634,4635,7,76,0,0,4635,593,1,0,0,0,4636,4638,5,553,0,0,4637,
        4639,3,596,298,0,4638,4637,1,0,0,0,4638,4639,1,0,0,0,4639,4642,1,
        0,0,0,4640,4642,5,562,0,0,4641,4636,1,0,0,0,4641,4640,1,0,0,0,4642,
        4643,1,0,0,0,4643,4644,5,242,0,0,4644,595,1,0,0,0,4645,4650,3,598,
        299,0,4646,4647,5,29,0,0,4647,4649,3,598,299,0,4648,4646,1,0,0,0,
        4649,4652,1,0,0,0,4650,4648,1,0,0,0,4650,4651,1,0,0,0,4651,597,1,
        0,0,0,4652,4650,1,0,0,0,4653,4657,3,600,300,0,4654,4657,3,602,301,
        0,4655,4657,3,604,302,0,4656,4653,1,0,0,0,4656,4654,1,0,0,0,4656,
        4655,1,0,0,0,4657,599,1,0,0,0,4658,4659,5,627,0,0,4659,4660,5,6,
        0,0,4660,4661,3,1448,724,0,4661,601,1,0,0,0,4662,4663,5,424,0,0,
        4663,4664,5,6,0,0,4664,4665,3,1448,724,0,4665,603,1,0,0,0,4666,4667,
        5,167,0,0,4667,4668,5,6,0,0,4668,4669,3,1448,724,0,4669,605,1,0,
        0,0,4670,4671,7,77,0,0,4671,607,1,0,0,0,4672,4673,5,435,0,0,4673,
        4674,3,1408,704,0,4674,4677,5,235,0,0,4675,4678,3,1446,723,0,4676,
        4678,3,988,494,0,4677,4675,1,0,0,0,4677,4676,1,0,0,0,4678,4684,1,
        0,0,0,4679,4684,3,610,305,0,4680,4681,7,78,0,0,4681,4682,5,435,0,
        0,4682,4684,3,1408,704,0,4683,4672,1,0,0,0,4683,4679,1,0,0,0,4683,
        4680,1,0,0,0,4684,609,1,0,0,0,4685,4686,5,208,0,0,4686,4689,3,1408,
        704,0,4687,4688,5,630,0,0,4688,4690,3,612,306,0,4689,4687,1,0,0,
        0,4689,4690,1,0,0,0,4690,611,1,0,0,0,4691,4696,3,988,494,0,4692,
        4693,5,29,0,0,4693,4695,3,988,494,0,4694,4692,1,0,0,0,4695,4698,
        1,0,0,0,4696,4694,1,0,0,0,4696,4697,1,0,0,0,4697,613,1,0,0,0,4698,
        4696,1,0,0,0,4699,4724,5,685,0,0,4700,4701,5,312,0,0,4701,4702,5,
        153,0,0,4702,4704,5,176,0,0,4703,4705,3,1478,739,0,4704,4703,1,0,
        0,0,4704,4705,1,0,0,0,4705,4706,1,0,0,0,4706,4725,3,1440,720,0,4707,
        4710,5,684,0,0,4708,4709,5,232,0,0,4709,4711,5,476,0,0,4710,4708,
        1,0,0,0,4710,4711,1,0,0,0,4711,4725,1,0,0,0,4712,4713,4,307,47,0,
        4713,4714,5,276,0,0,4714,4715,5,235,0,0,4715,4716,3,1308,654,0,4716,
        4717,5,31,0,0,4717,4718,3,1420,710,0,4718,4719,5,262,0,0,4719,4720,
        5,89,0,0,4720,4722,3,1440,720,0,4721,4723,3,616,308,0,4722,4721,
        1,0,0,0,4722,4723,1,0,0,0,4723,4725,1,0,0,0,4724,4700,1,0,0,0,4724,
        4707,1,0,0,0,4724,4712,1,0,0,0,4725,615,1,0,0,0,4726,4737,3,618,
        309,0,4727,4728,5,153,0,0,4728,4730,5,176,0,0,4729,4731,3,1478,739,
        0,4730,4729,1,0,0,0,4730,4731,1,0,0,0,4731,4732,1,0,0,0,4732,4734,
        3,1440,720,0,4733,4735,3,618,309,0,4734,4733,1,0,0,0,4734,4735,1,
        0,0,0,4735,4737,1,0,0,0,4736,4726,1,0,0,0,4736,4727,1,0,0,0,4737,
        617,1,0,0,0,4738,4740,5,484,0,0,4739,4741,5,392,0,0,4740,4739,1,
        0,0,0,4740,4741,1,0,0,0,4741,4742,1,0,0,0,4742,4743,5,549,0,0,4743,
        619,1,0,0,0,4744,4752,3,622,311,0,4745,4752,3,632,316,0,4746,4752,
        3,648,324,0,4747,4752,3,650,325,0,4748,4752,3,664,332,0,4749,4752,
        3,666,333,0,4750,4752,3,682,341,0,4751,4744,1,0,0,0,4751,4745,1,
        0,0,0,4751,4746,1,0,0,0,4751,4747,1,0,0,0,4751,4748,1,0,0,0,4751,
        4749,1,0,0,0,4751,4750,1,0,0,0,4752,621,1,0,0,0,4753,4754,5,58,0,
        0,4754,4756,5,627,0,0,4755,4757,3,1236,618,0,4756,4755,1,0,0,0,4756,
        4757,1,0,0,0,4757,4798,1,0,0,0,4758,4759,4,311,48,0,4759,4763,3,
        1274,637,0,4760,4761,4,311,49,0,4761,4763,3,624,312,0,4762,4758,
        1,0,0,0,4762,4760,1,0,0,0,4763,4764,1,0,0,0,4764,4765,3,634,317,
        0,4765,4799,1,0,0,0,4766,4783,3,630,315,0,4767,4770,3,1284,642,0,
        4768,4770,3,1282,641,0,4769,4767,1,0,0,0,4769,4768,1,0,0,0,4770,
        4772,1,0,0,0,4771,4773,3,1304,652,0,4772,4771,1,0,0,0,4772,4773,
        1,0,0,0,4773,4775,1,0,0,0,4774,4776,3,1296,648,0,4775,4774,1,0,0,
        0,4775,4776,1,0,0,0,4776,4784,1,0,0,0,4777,4778,5,178,0,0,4778,4779,
        5,736,0,0,4779,4784,5,424,0,0,4780,4782,3,1300,650,0,4781,4780,1,
        0,0,0,4781,4782,1,0,0,0,4782,4784,1,0,0,0,4783,4769,1,0,0,0,4783,
        4777,1,0,0,0,4783,4781,1,0,0,0,4784,4799,1,0,0,0,4785,4796,3,1308,
        654,0,4786,4787,5,166,0,0,4787,4791,5,667,0,0,4788,4792,5,57,0,0,
        4789,4792,5,389,0,0,4790,4792,3,684,342,0,4791,4788,1,0,0,0,4791,
        4789,1,0,0,0,4791,4790,1,0,0,0,4792,4797,1,0,0,0,4793,4795,3,1300,
        650,0,4794,4793,1,0,0,0,4794,4795,1,0,0,0,4795,4797,1,0,0,0,4796,
        4786,1,0,0,0,4796,4794,1,0,0,0,4797,4799,1,0,0,0,4798,4762,1,0,0,
        0,4798,4766,1,0,0,0,4798,4785,1,0,0,0,4799,623,1,0,0,0,4800,4805,
        3,626,313,0,4801,4802,5,29,0,0,4802,4804,3,626,313,0,4803,4801,1,
        0,0,0,4804,4807,1,0,0,0,4805,4803,1,0,0,0,4805,4806,1,0,0,0,4806,
        625,1,0,0,0,4807,4805,1,0,0,0,4808,4809,4,313,50,0,4809,4884,3,628,
        314,0,4810,4811,4,313,51,0,4811,4881,3,1308,654,0,4812,4821,3,1282,
        641,0,4813,4814,5,475,0,0,4814,4816,3,1440,720,0,4815,4817,3,1296,
        648,0,4816,4815,1,0,0,0,4816,4817,1,0,0,0,4817,4822,1,0,0,0,4818,
        4820,3,1296,648,0,4819,4818,1,0,0,0,4819,4820,1,0,0,0,4820,4822,
        1,0,0,0,4821,4813,1,0,0,0,4821,4819,1,0,0,0,4822,4882,1,0,0,0,4823,
        4832,3,1284,642,0,4824,4826,3,1296,648,0,4825,4824,1,0,0,0,4825,
        4826,1,0,0,0,4826,4833,1,0,0,0,4827,4828,5,475,0,0,4828,4830,3,1440,
        720,0,4829,4831,3,1296,648,0,4830,4829,1,0,0,0,4830,4831,1,0,0,0,
        4831,4833,1,0,0,0,4832,4825,1,0,0,0,4832,4827,1,0,0,0,4833,4882,
        1,0,0,0,4834,4882,3,1286,643,0,4835,4837,3,1288,644,0,4836,4838,
        3,1296,648,0,4837,4836,1,0,0,0,4837,4838,1,0,0,0,4838,4882,1,0,0,
        0,4839,4848,3,1290,645,0,4840,4841,5,475,0,0,4841,4843,3,1440,720,
        0,4842,4844,3,1296,648,0,4843,4842,1,0,0,0,4843,4844,1,0,0,0,4844,
        4849,1,0,0,0,4845,4847,3,1296,648,0,4846,4845,1,0,0,0,4846,4847,
        1,0,0,0,4847,4849,1,0,0,0,4848,4840,1,0,0,0,4848,4846,1,0,0,0,4849,
        4882,1,0,0,0,4850,4852,3,1292,646,0,4851,4853,3,1296,648,0,4852,
        4851,1,0,0,0,4852,4853,1,0,0,0,4853,4882,1,0,0,0,4854,4856,3,1298,
        649,0,4855,4854,1,0,0,0,4855,4856,1,0,0,0,4856,4882,1,0,0,0,4857,
        4858,5,51,0,0,4858,4859,3,1302,651,0,4859,4864,3,1280,640,0,4860,
        4861,5,51,0,0,4861,4862,3,1302,651,0,4862,4863,3,1280,640,0,4863,
        4865,1,0,0,0,4864,4860,1,0,0,0,4864,4865,1,0,0,0,4865,4882,1,0,0,
        0,4866,4867,5,371,0,0,4867,4868,3,1302,651,0,4868,4873,3,1280,640,
        0,4869,4870,5,371,0,0,4870,4871,3,1302,651,0,4871,4872,3,1280,640,
        0,4872,4874,1,0,0,0,4873,4869,1,0,0,0,4873,4874,1,0,0,0,4874,4882,
        1,0,0,0,4875,4876,5,184,0,0,4876,4879,3,1302,651,0,4877,4878,5,184,
        0,0,4878,4880,3,1302,651,0,4879,4877,1,0,0,0,4879,4880,1,0,0,0,4880,
        4882,1,0,0,0,4881,4812,1,0,0,0,4881,4823,1,0,0,0,4881,4834,1,0,0,
        0,4881,4835,1,0,0,0,4881,4839,1,0,0,0,4881,4850,1,0,0,0,4881,4855,
        1,0,0,0,4881,4857,1,0,0,0,4881,4866,1,0,0,0,4881,4875,1,0,0,0,4882,
        4884,1,0,0,0,4883,4808,1,0,0,0,4883,4810,1,0,0,0,4884,627,1,0,0,
        0,4885,4886,3,1308,654,0,4886,4887,5,262,0,0,4887,4907,5,89,0,0,
        4888,4889,3,1442,721,0,4889,4890,5,475,0,0,4890,4892,3,1442,721,
        0,4891,4893,3,1296,648,0,4892,4891,1,0,0,0,4892,4893,1,0,0,0,4893,
        4908,1,0,0,0,4894,4896,3,1442,721,0,4895,4897,3,1296,648,0,4896,
        4895,1,0,0,0,4896,4897,1,0,0,0,4897,4908,1,0,0,0,4898,4899,5,742,
        0,0,4899,4902,5,424,0,0,4900,4901,5,475,0,0,4901,4903,3,1442,721,
        0,4902,4900,1,0,0,0,4902,4903,1,0,0,0,4903,4905,1,0,0,0,4904,4906,
        3,1296,648,0,4905,4904,1,0,0,0,4905,4906,1,0,0,0,4906,4908,1,0,0,
        0,4907,4888,1,0,0,0,4907,4894,1,0,0,0,4907,4898,1,0,0,0,4908,4943,
        1,0,0,0,4909,4910,3,1308,654,0,4910,4911,5,262,0,0,4911,4912,5,653,
        0,0,4912,4936,3,1468,734,0,4913,4914,5,89,0,0,4914,4915,3,1442,721,
        0,4915,4916,5,475,0,0,4916,4918,3,1442,721,0,4917,4919,3,1296,648,
        0,4918,4917,1,0,0,0,4918,4919,1,0,0,0,4919,4937,1,0,0,0,4920,4921,
        5,63,0,0,4921,4923,3,1444,722,0,4922,4924,3,1296,648,0,4923,4922,
        1,0,0,0,4923,4924,1,0,0,0,4924,4937,1,0,0,0,4925,4926,5,89,0,0,4926,
        4928,3,1442,721,0,4927,4929,3,1296,648,0,4928,4927,1,0,0,0,4928,
        4929,1,0,0,0,4929,4937,1,0,0,0,4930,4931,5,89,0,0,4931,4932,5,742,
        0,0,4932,4934,5,424,0,0,4933,4935,3,1296,648,0,4934,4933,1,0,0,0,
        4934,4935,1,0,0,0,4935,4937,1,0,0,0,4936,4913,1,0,0,0,4936,4920,
        1,0,0,0,4936,4925,1,0,0,0,4936,4930,1,0,0,0,4936,4937,1,0,0,0,4937,
        4943,1,0,0,0,4938,4940,3,1308,654,0,4939,4941,3,1298,649,0,4940,
        4939,1,0,0,0,4940,4941,1,0,0,0,4941,4943,1,0,0,0,4942,4885,1,0,0,
        0,4942,4909,1,0,0,0,4942,4938,1,0,0,0,4943,629,1,0,0,0,4944,4945,
        5,627,0,0,4945,4946,3,1476,738,0,4946,631,1,0,0,0,4947,4948,5,139,
        0,0,4948,4950,5,627,0,0,4949,4951,3,1242,621,0,4950,4949,1,0,0,0,
        4950,4951,1,0,0,0,4951,4952,1,0,0,0,4952,4954,3,1274,637,0,4953,
        4955,3,638,319,0,4954,4953,1,0,0,0,4954,4955,1,0,0,0,4955,4956,1,
        0,0,0,4956,4957,3,634,317,0,4957,633,1,0,0,0,4958,4960,3,640,320,
        0,4959,4958,1,0,0,0,4959,4960,1,0,0,0,4960,4962,1,0,0,0,4961,4963,
        3,642,321,0,4962,4961,1,0,0,0,4962,4963,1,0,0,0,4963,4967,1,0,0,
        0,4964,4966,3,644,322,0,4965,4964,1,0,0,0,4966,4969,1,0,0,0,4967,
        4965,1,0,0,0,4967,4968,1,0,0,0,4968,4972,1,0,0,0,4969,4967,1,0,0,
        0,4970,4971,4,317,52,0,4971,4973,3,636,318,0,4972,4970,1,0,0,0,4972,
        4973,1,0,0,0,4973,635,1,0,0,0,4974,4975,5,756,0,0,4975,4979,3,1440,
        720,0,4976,4977,5,118,0,0,4977,4979,3,1440,720,0,4978,4974,1,0,0,
        0,4978,4976,1,0,0,0,4979,637,1,0,0,0,4980,4981,5,166,0,0,4981,4982,
        5,667,0,0,4982,4983,3,684,342,0,4983,639,1,0,0,0,4984,4987,5,484,
        0,0,4985,4988,3,676,338,0,4986,4988,7,79,0,0,4987,4985,1,0,0,0,4987,
        4986,1,0,0,0,4988,641,1,0,0,0,4989,4998,5,653,0,0,4990,4991,5,347,
        0,0,4991,4999,3,1420,710,0,4992,4993,5,351,0,0,4993,4999,3,1420,
        710,0,4994,4995,5,346,0,0,4995,4999,3,1420,710,0,4996,4997,5,352,
        0,0,4997,4999,3,1420,710,0,4998,4990,1,0,0,0,4998,4992,1,0,0,0,4998,
        4994,1,0,0,0,4998,4996,1,0,0,0,4999,5000,1,0,0,0,5000,4998,1,0,0,
        0,5000,5001,1,0,0,0,5001,643,1,0,0,0,5002,5003,5,49,0,0,5003,5043,
        7,80,0,0,5004,5033,5,424,0,0,5005,5012,5,212,0,0,5006,5007,5,278,
        0,0,5007,5008,3,1422,711,0,5008,5009,5,162,0,0,5009,5013,1,0,0,0,
        5010,5013,5,385,0,0,5011,5013,5,166,0,0,5012,5006,1,0,0,0,5012,5010,
        1,0,0,0,5012,5011,1,0,0,0,5012,5013,1,0,0,0,5013,5034,1,0,0,0,5014,
        5017,5,713,0,0,5015,5018,3,1422,711,0,5016,5018,5,166,0,0,5017,5015,
        1,0,0,0,5017,5016,1,0,0,0,5018,5034,1,0,0,0,5019,5020,5,714,0,0,
        5020,5025,5,278,0,0,5021,5022,3,1422,711,0,5022,5023,5,162,0,0,5023,
        5026,1,0,0,0,5024,5026,5,166,0,0,5025,5021,1,0,0,0,5025,5024,1,0,
        0,0,5026,5034,1,0,0,0,5027,5028,4,322,53,0,5028,5029,5,484,0,0,5029,
        5031,5,143,0,0,5030,5032,7,81,0,0,5031,5030,1,0,0,0,5031,5032,1,
        0,0,0,5032,5034,1,0,0,0,5033,5005,1,0,0,0,5033,5014,1,0,0,0,5033,
        5019,1,0,0,0,5033,5027,1,0,0,0,5034,5043,1,0,0,0,5035,5036,5,749,
        0,0,5036,5043,3,1422,711,0,5037,5040,5,748,0,0,5038,5041,3,1422,
        711,0,5039,5041,5,706,0,0,5040,5038,1,0,0,0,5040,5039,1,0,0,0,5041,
        5043,1,0,0,0,5042,5002,1,0,0,0,5042,5004,1,0,0,0,5042,5035,1,0,0,
        0,5042,5037,1,0,0,0,5043,645,1,0,0,0,5044,5050,1,0,0,0,5045,5046,
        5,756,0,0,5046,5050,3,1440,720,0,5047,5048,5,118,0,0,5048,5050,3,
        1440,720,0,5049,5044,1,0,0,0,5049,5045,1,0,0,0,5049,5047,1,0,0,0,
        5050,647,1,0,0,0,5051,5052,5,184,0,0,5052,5054,5,627,0,0,5053,5055,
        3,1236,618,0,5054,5053,1,0,0,0,5054,5055,1,0,0,0,5055,5056,1,0,0,
        0,5056,5057,3,1272,636,0,5057,649,1,0,0,0,5058,5100,5,247,0,0,5059,
        5060,3,670,335,0,5060,5061,5,599,0,0,5061,5065,3,1272,636,0,5062,
        5063,5,653,0,0,5063,5064,5,668,0,0,5064,5066,5,409,0,0,5065,5062,
        1,0,0,0,5065,5066,1,0,0,0,5066,5101,1,0,0,0,5067,5073,3,670,335,
        0,5068,5070,5,57,0,0,5069,5071,5,439,0,0,5070,5069,1,0,0,0,5070,
        5071,1,0,0,0,5071,5073,1,0,0,0,5072,5067,1,0,0,0,5072,5068,1,0,0,
        0,5073,5074,1,0,0,0,5074,5076,5,401,0,0,5075,5077,3,668,334,0,5076,
        5075,1,0,0,0,5076,5077,1,0,0,0,5077,5078,1,0,0,0,5078,5079,3,674,
        337,0,5079,5080,5,599,0,0,5080,5082,3,652,326,0,5081,5083,3,662,
        331,0,5082,5081,1,0,0,0,5082,5083,1,0,0,0,5083,5085,1,0,0,0,5084,
        5086,3,654,327,0,5085,5084,1,0,0,0,5085,5086,1,0,0,0,5086,5088,1,
        0,0,0,5087,5089,3,660,330,0,5088,5087,1,0,0,0,5088,5089,1,0,0,0,
        5089,5101,1,0,0,0,5090,5091,5,445,0,0,5091,5092,5,401,0,0,5092,5093,
        3,1308,654,0,5093,5094,5,599,0,0,5094,5098,3,652,326,0,5095,5096,
        5,653,0,0,5096,5097,5,247,0,0,5097,5099,5,409,0,0,5098,5095,1,0,
        0,0,5098,5099,1,0,0,0,5099,5101,1,0,0,0,5100,5059,1,0,0,0,5100,5072,
        1,0,0,0,5100,5090,1,0,0,0,5101,651,1,0,0,0,5102,5103,4,326,54,0,
        5103,5107,3,1274,637,0,5104,5105,4,326,55,0,5105,5107,3,1272,636,
        0,5106,5102,1,0,0,0,5106,5104,1,0,0,0,5107,653,1,0,0,0,5108,5109,
        5,653,0,0,5109,5110,3,680,340,0,5110,655,1,0,0,0,5111,5112,5,671,
        0,0,5112,5113,3,684,342,0,5113,657,1,0,0,0,5114,5115,5,653,0,0,5115,
        5123,5,667,0,0,5116,5124,3,684,342,0,5117,5119,5,57,0,0,5118,5120,
        3,656,328,0,5119,5118,1,0,0,0,5119,5120,1,0,0,0,5120,5124,1,0,0,
        0,5121,5124,5,389,0,0,5122,5124,5,166,0,0,5123,5116,1,0,0,0,5123,
        5117,1,0,0,0,5123,5121,1,0,0,0,5123,5122,1,0,0,0,5124,659,1,0,0,
        0,5125,5126,5,63,0,0,5126,5128,5,627,0,0,5127,5129,3,658,329,0,5128,
        5127,1,0,0,0,5128,5129,1,0,0,0,5129,661,1,0,0,0,5130,5131,4,331,
        56,0,5131,5132,3,640,320,0,5132,663,1,0,0,0,5133,5134,5,470,0,0,
        5134,5135,5,627,0,0,5135,5136,3,1308,654,0,5136,5137,5,599,0,0,5137,
        5145,3,1308,654,0,5138,5139,5,29,0,0,5139,5140,3,1308,654,0,5140,
        5141,5,599,0,0,5141,5142,3,1308,654,0,5142,5144,1,0,0,0,5143,5138,
        1,0,0,0,5144,5147,1,0,0,0,5145,5143,1,0,0,0,5145,5146,1,0,0,0,5146,
        665,1,0,0,0,5147,5145,1,0,0,0,5148,5151,5,494,0,0,5149,5150,4,333,
        57,0,5150,5152,3,1236,618,0,5151,5149,1,0,0,0,5151,5152,1,0,0,0,
        5152,5188,1,0,0,0,5153,5154,3,670,335,0,5154,5155,5,235,0,0,5155,
        5156,3,1272,636,0,5156,5189,1,0,0,0,5157,5158,3,670,335,0,5158,5160,
        5,401,0,0,5159,5161,3,668,334,0,5160,5159,1,0,0,0,5160,5161,1,0,
        0,0,5161,5162,1,0,0,0,5162,5163,3,674,337,0,5163,5164,5,235,0,0,
        5164,5165,3,1272,636,0,5165,5189,1,0,0,0,5166,5168,5,57,0,0,5167,
        5169,5,439,0,0,5168,5167,1,0,0,0,5168,5169,1,0,0,0,5169,5178,1,0,
        0,0,5170,5172,5,401,0,0,5171,5173,3,668,334,0,5172,5171,1,0,0,0,
        5172,5173,1,0,0,0,5173,5174,1,0,0,0,5174,5179,3,674,337,0,5175,5176,
        5,29,0,0,5176,5177,5,247,0,0,5177,5179,5,409,0,0,5178,5170,1,0,0,
        0,5178,5175,1,0,0,0,5179,5180,1,0,0,0,5180,5181,5,235,0,0,5181,5189,
        3,1272,636,0,5182,5183,5,445,0,0,5183,5184,5,401,0,0,5184,5185,3,
        1308,654,0,5185,5186,5,235,0,0,5186,5187,3,1272,636,0,5187,5189,
        1,0,0,0,5188,5153,1,0,0,0,5188,5157,1,0,0,0,5188,5166,1,0,0,0,5188,
        5182,1,0,0,0,5189,5192,1,0,0,0,5190,5191,4,333,58,0,5191,5193,3,
        1244,622,0,5192,5190,1,0,0,0,5192,5193,1,0,0,0,5193,667,1,0,0,0,
        5194,5195,7,82,0,0,5195,669,1,0,0,0,5196,5201,3,672,336,0,5197,5198,
        5,29,0,0,5198,5200,3,672,336,0,5199,5197,1,0,0,0,5200,5203,1,0,0,
        0,5201,5199,1,0,0,0,5201,5202,1,0,0,0,5202,671,1,0,0,0,5203,5201,
        1,0,0,0,5204,5206,3,1472,736,0,5205,5207,3,1326,663,0,5206,5205,
        1,0,0,0,5206,5207,1,0,0,0,5207,5215,1,0,0,0,5208,5212,3,1472,736,
        0,5209,5213,5,40,0,0,5210,5211,5,39,0,0,5211,5213,3,1468,734,0,5212,
        5209,1,0,0,0,5212,5210,1,0,0,0,5213,5215,1,0,0,0,5214,5204,1,0,0,
        0,5214,5208,1,0,0,0,5215,5247,1,0,0,0,5216,5218,7,83,0,0,5217,5219,
        3,1326,663,0,5218,5217,1,0,0,0,5218,5219,1,0,0,0,5219,5247,1,0,0,
        0,5220,5247,7,84,0,0,5221,5222,5,247,0,0,5222,5247,5,409,0,0,5223,
        5224,5,521,0,0,5224,5247,5,151,0,0,5225,5229,5,139,0,0,5226,5227,
        5,586,0,0,5227,5230,5,581,0,0,5228,5230,7,85,0,0,5229,5226,1,0,0,
        0,5229,5228,1,0,0,0,5229,5230,1,0,0,0,5230,5247,1,0,0,0,5231,5232,
        5,314,0,0,5232,5247,5,581,0,0,5233,5236,5,476,0,0,5234,5237,5,108,
        0,0,5235,5237,3,606,303,0,5236,5234,1,0,0,0,5236,5235,1,0,0,0,5237,
        5247,1,0,0,0,5238,5239,5,521,0,0,5239,5247,5,644,0,0,5240,5242,5,
        58,0,0,5241,5243,5,499,0,0,5242,5241,1,0,0,0,5242,5243,1,0,0,0,5243,
        5247,1,0,0,0,5244,5245,7,86,0,0,5245,5247,5,667,0,0,5246,5214,1,
        0,0,0,5246,5216,1,0,0,0,5246,5220,1,0,0,0,5246,5221,1,0,0,0,5246,
        5223,1,0,0,0,5246,5225,1,0,0,0,5246,5231,1,0,0,0,5246,5233,1,0,0,
        0,5246,5238,1,0,0,0,5246,5240,1,0,0,0,5246,5244,1,0,0,0,5247,673,
        1,0,0,0,5248,5251,5,16,0,0,5249,5250,5,28,0,0,5250,5252,5,16,0,0,
        5251,5249,1,0,0,0,5251,5252,1,0,0,0,5252,5265,1,0,0,0,5253,5256,
        3,1340,670,0,5254,5255,5,28,0,0,5255,5257,5,16,0,0,5256,5254,1,0,
        0,0,5256,5257,1,0,0,0,5257,5265,1,0,0,0,5258,5265,3,1384,692,0,5259,
        5260,4,337,59,0,5260,5261,3,1340,670,0,5261,5262,5,28,0,0,5262,5263,
        3,1384,692,0,5263,5265,1,0,0,0,5264,5248,1,0,0,0,5264,5253,1,0,0,
        0,5264,5258,1,0,0,0,5264,5259,1,0,0,0,5265,675,1,0,0,0,5266,5273,
        3,678,339,0,5267,5269,5,61,0,0,5268,5267,1,0,0,0,5268,5269,1,0,0,
        0,5269,5270,1,0,0,0,5270,5272,3,678,339,0,5271,5268,1,0,0,0,5272,
        5275,1,0,0,0,5273,5271,1,0,0,0,5273,5274,1,0,0,0,5274,677,1,0,0,
        0,5275,5273,1,0,0,0,5276,5277,5,106,0,0,5277,5283,3,1442,721,0,5278,
        5279,5,289,0,0,5279,5283,3,1442,721,0,5280,5281,5,569,0,0,5281,5283,
        3,1442,721,0,5282,5276,1,0,0,0,5282,5278,1,0,0,0,5282,5280,1,0,0,
        0,5283,679,1,0,0,0,5284,5285,5,247,0,0,5285,5298,5,409,0,0,5286,
        5295,4,340,60,0,5287,5288,5,347,0,0,5288,5296,3,1420,710,0,5289,
        5290,5,351,0,0,5290,5296,3,1420,710,0,5291,5292,5,346,0,0,5292,5296,
        3,1420,710,0,5293,5294,5,352,0,0,5294,5296,3,1420,710,0,5295,5287,
        1,0,0,0,5295,5289,1,0,0,0,5295,5291,1,0,0,0,5295,5293,1,0,0,0,5296,
        5298,1,0,0,0,5297,5284,1,0,0,0,5297,5286,1,0,0,0,5298,681,1,0,0,
        0,5299,5300,5,519,0,0,5300,5301,5,667,0,0,5301,5323,3,684,342,0,
        5302,5303,5,519,0,0,5303,5304,5,667,0,0,5304,5323,7,87,0,0,5305,
        5306,5,519,0,0,5306,5307,5,166,0,0,5307,5311,5,667,0,0,5308,5312,
        3,684,342,0,5309,5312,5,389,0,0,5310,5312,5,57,0,0,5311,5308,1,0,
        0,0,5311,5309,1,0,0,0,5311,5310,1,0,0,0,5312,5313,1,0,0,0,5313,5314,
        5,599,0,0,5314,5323,3,684,342,0,5315,5316,5,519,0,0,5316,5317,5,
        667,0,0,5317,5320,5,57,0,0,5318,5319,5,671,0,0,5319,5321,3,684,342,
        0,5320,5318,1,0,0,0,5320,5321,1,0,0,0,5321,5323,1,0,0,0,5322,5299,
        1,0,0,0,5322,5302,1,0,0,0,5322,5305,1,0,0,0,5322,5315,1,0,0,0,5323,
        683,1,0,0,0,5324,5329,3,686,343,0,5325,5326,5,29,0,0,5326,5328,3,
        686,343,0,5327,5325,1,0,0,0,5328,5331,1,0,0,0,5329,5327,1,0,0,0,
        5329,5330,1,0,0,0,5330,685,1,0,0,0,5331,5329,1,0,0,0,5332,5334,3,
        1472,736,0,5333,5335,3,988,494,0,5334,5333,1,0,0,0,5334,5335,1,0,
        0,0,5335,687,1,0,0,0,5336,5338,5,60,0,0,5337,5339,3,1316,658,0,5338,
        5337,1,0,0,0,5338,5339,1,0,0,0,5339,5340,1,0,0,0,5340,5341,5,583,
        0,0,5341,5343,3,1386,693,0,5342,5344,3,696,348,0,5343,5342,1,0,0,
        0,5343,5344,1,0,0,0,5344,5379,1,0,0,0,5345,5346,5,105,0,0,5346,5347,
        5,583,0,0,5347,5351,3,1386,693,0,5348,5350,3,698,349,0,5349,5348,
        1,0,0,0,5350,5353,1,0,0,0,5351,5349,1,0,0,0,5351,5352,1,0,0,0,5352,
        5379,1,0,0,0,5353,5351,1,0,0,0,5354,5355,5,104,0,0,5355,5356,5,583,
        0,0,5356,5358,3,1386,693,0,5357,5359,7,88,0,0,5358,5357,1,0,0,0,
        5358,5359,1,0,0,0,5359,5379,1,0,0,0,5360,5362,5,406,0,0,5361,5363,
        3,1316,658,0,5362,5361,1,0,0,0,5362,5363,1,0,0,0,5363,5364,1,0,0,
        0,5364,5365,5,583,0,0,5365,5379,3,1386,693,0,5366,5368,5,472,0,0,
        5367,5369,3,1316,658,0,5368,5367,1,0,0,0,5368,5369,1,0,0,0,5369,
        5370,1,0,0,0,5370,5371,5,583,0,0,5371,5375,3,1386,693,0,5372,5374,
        3,700,350,0,5373,5372,1,0,0,0,5374,5377,1,0,0,0,5375,5373,1,0,0,
        0,5375,5376,1,0,0,0,5376,5379,1,0,0,0,5377,5375,1,0,0,0,5378,5336,
        1,0,0,0,5378,5345,1,0,0,0,5378,5354,1,0,0,0,5378,5360,1,0,0,0,5378,
        5366,1,0,0,0,5379,689,1,0,0,0,5380,5381,4,345,61,0,5381,5382,7,89,
        0,0,5382,5383,5,623,0,0,5383,691,1,0,0,0,5384,5386,3,694,347,0,5385,
        5384,1,0,0,0,5385,5386,1,0,0,0,5386,5388,1,0,0,0,5387,5389,3,690,
        345,0,5388,5387,1,0,0,0,5388,5389,1,0,0,0,5389,5395,1,0,0,0,5390,
        5391,4,346,62,0,5391,5392,5,630,0,0,5392,5393,5,153,0,0,5393,5395,
        3,1440,720,0,5394,5385,1,0,0,0,5394,5390,1,0,0,0,5395,693,1,0,0,
        0,5396,5397,4,347,63,0,5397,5398,5,653,0,0,5398,5399,5,3,0,0,5399,
        5400,5,683,0,0,5400,695,1,0,0,0,5401,5402,5,623,0,0,5402,5403,5,
        682,0,0,5403,5404,5,401,0,0,5404,5405,3,1410,705,0,5405,5406,3,692,
        346,0,5406,5412,1,0,0,0,5407,5408,5,184,0,0,5408,5409,5,682,0,0,
        5409,5410,5,401,0,0,5410,5412,3,1410,705,0,5411,5401,1,0,0,0,5411,
        5407,1,0,0,0,5412,697,1,0,0,0,5413,5414,5,232,0,0,5414,5417,5,624,
        0,0,5415,5417,7,90,0,0,5416,5413,1,0,0,0,5416,5415,1,0,0,0,5417,
        699,1,0,0,0,5418,5419,7,91,0,0,5419,701,1,0,0,0,5420,5432,5,616,
        0,0,5421,5422,5,428,0,0,5422,5433,3,1398,699,0,5423,5424,5,672,0,
        0,5424,5429,3,1400,700,0,5425,5426,5,29,0,0,5426,5428,3,1400,700,
        0,5427,5425,1,0,0,0,5428,5431,1,0,0,0,5429,5427,1,0,0,0,5429,5430,
        1,0,0,0,5430,5433,1,0,0,0,5431,5429,1,0,0,0,5432,5421,1,0,0,0,5432,
        5423,1,0,0,0,5433,703,1,0,0,0,5434,5445,5,277,0,0,5435,5436,5,428,
        0,0,5436,5437,3,1408,704,0,5437,5438,5,531,0,0,5438,5439,3,1440,
        720,0,5439,5446,1,0,0,0,5440,5441,5,672,0,0,5441,5443,3,1450,725,
        0,5442,5444,3,712,356,0,5443,5442,1,0,0,0,5443,5444,1,0,0,0,5444,
        5446,1,0,0,0,5445,5435,1,0,0,0,5445,5440,1,0,0,0,5446,705,1,0,0,
        0,5447,5448,7,92,0,0,5448,707,1,0,0,0,5449,5452,3,912,456,0,5450,
        5452,5,401,0,0,5451,5449,1,0,0,0,5451,5450,1,0,0,0,5452,709,1,0,
        0,0,5453,5454,3,706,353,0,5454,5455,3,994,497,0,5455,5456,3,1478,
        739,0,5456,5457,3,708,354,0,5457,711,1,0,0,0,5458,5459,4,356,64,
        0,5459,5460,5,519,0,0,5460,5465,3,710,355,0,5461,5462,5,29,0,0,5462,
        5464,3,710,355,0,5463,5461,1,0,0,0,5464,5467,1,0,0,0,5465,5463,1,
        0,0,0,5465,5466,1,0,0,0,5466,713,1,0,0,0,5467,5465,1,0,0,0,5468,
        5469,5,519,0,0,5469,5470,3,716,358,0,5470,715,1,0,0,0,5471,5472,
        3,726,363,0,5472,5473,3,724,362,0,5473,5522,1,0,0,0,5474,5475,5,
        601,0,0,5475,5522,3,718,359,0,5476,5477,3,1480,740,0,5477,5478,3,
        732,366,0,5478,5522,1,0,0,0,5479,5482,5,424,0,0,5480,5481,5,232,
        0,0,5481,5483,3,1308,654,0,5482,5480,1,0,0,0,5482,5483,1,0,0,0,5483,
        5484,1,0,0,0,5484,5505,3,1478,739,0,5485,5487,3,1442,721,0,5486,
        5488,3,1304,652,0,5487,5486,1,0,0,0,5487,5488,1,0,0,0,5488,5490,
        1,0,0,0,5489,5491,3,1296,648,0,5490,5489,1,0,0,0,5490,5491,1,0,0,
        0,5491,5506,1,0,0,0,5492,5494,3,1442,721,0,5493,5495,3,1304,652,
        0,5494,5493,1,0,0,0,5494,5495,1,0,0,0,5495,5497,1,0,0,0,5496,5498,
        3,1296,648,0,5497,5496,1,0,0,0,5497,5498,1,0,0,0,5498,5506,1,0,0,
        0,5499,5500,4,358,65,0,5500,5501,5,424,0,0,5501,5502,5,32,0,0,5502,
        5503,3,1442,721,0,5503,5504,5,33,0,0,5504,5506,1,0,0,0,5505,5485,
        1,0,0,0,5505,5492,1,0,0,0,5505,5499,1,0,0,0,5506,5522,1,0,0,0,5507,
        5508,4,358,66,0,5508,5511,5,424,0,0,5509,5510,5,232,0,0,5510,5512,
        3,1308,654,0,5511,5509,1,0,0,0,5511,5512,1,0,0,0,5512,5513,1,0,0,
        0,5513,5514,5,599,0,0,5514,5516,5,742,0,0,5515,5517,3,1304,652,0,
        5516,5515,1,0,0,0,5516,5517,1,0,0,0,5517,5519,1,0,0,0,5518,5520,
        3,1296,648,0,5519,5518,1,0,0,0,5519,5520,1,0,0,0,5520,5522,1,0,0,
        0,5521,5471,1,0,0,0,5521,5474,1,0,0,0,5521,5476,1,0,0,0,5521,5479,
        1,0,0,0,5521,5507,1,0,0,0,5522,717,1,0,0,0,5523,5525,3,720,360,0,
        5524,5526,3,722,361,0,5525,5524,1,0,0,0,5525,5526,1,0,0,0,5526,5533,
        1,0,0,0,5527,5530,3,722,361,0,5528,5529,5,29,0,0,5529,5531,3,720,
        360,0,5530,5528,1,0,0,0,5530,5531,1,0,0,0,5531,5533,1,0,0,0,5532,
        5523,1,0,0,0,5532,5527,1,0,0,0,5533,719,1,0,0,0,5534,5535,5,453,
        0,0,5535,5536,7,42,0,0,5536,721,1,0,0,0,5537,5538,5,288,0,0,5538,
        5544,5,304,0,0,5539,5540,5,473,0,0,5540,5545,5,453,0,0,5541,5542,
        5,453,0,0,5542,5545,7,93,0,0,5543,5545,5,514,0,0,5544,5539,1,0,0,
        0,5544,5541,1,0,0,0,5544,5543,1,0,0,0,5545,723,1,0,0,0,5546,5547,
        5,29,0,0,5547,5549,3,728,364,0,5548,5546,1,0,0,0,5549,5552,1,0,0,
        0,5550,5548,1,0,0,0,5550,5551,1,0,0,0,5551,725,1,0,0,0,5552,5550,
        1,0,0,0,5553,5554,3,994,497,0,5554,5555,3,1478,739,0,5555,5556,3,
        736,368,0,5556,5583,1,0,0,0,5557,5583,3,1262,631,0,5558,5559,3,988,
        494,0,5559,5560,3,1478,739,0,5560,5561,3,912,456,0,5561,5583,1,0,
        0,0,5562,5564,5,41,0,0,5563,5565,3,1484,742,0,5564,5563,1,0,0,0,
        5564,5565,1,0,0,0,5565,5566,1,0,0,0,5566,5567,3,994,497,0,5567,5568,
        3,1478,739,0,5568,5569,3,736,368,0,5569,5583,1,0,0,0,5570,5580,5,
        379,0,0,5571,5572,3,1478,739,0,5572,5573,3,912,456,0,5573,5581,1,
        0,0,0,5574,5576,3,1190,595,0,5575,5577,3,1250,625,0,5576,5575,1,
        0,0,0,5576,5577,1,0,0,0,5577,5581,1,0,0,0,5578,5579,4,363,67,0,5579,
        5581,5,166,0,0,5580,5571,1,0,0,0,5580,5574,1,0,0,0,5580,5578,1,0,
        0,0,5581,5583,1,0,0,0,5582,5553,1,0,0,0,5582,5557,1,0,0,0,5582,5558,
        1,0,0,0,5582,5562,1,0,0,0,5582,5570,1,0,0,0,5583,727,1,0,0,0,5584,
        5585,3,1480,740,0,5585,5586,3,994,497,0,5586,5587,3,1478,739,0,5587,
        5588,3,736,368,0,5588,5591,1,0,0,0,5589,5591,3,726,363,0,5590,5584,
        1,0,0,0,5590,5589,1,0,0,0,5591,729,1,0,0,0,5592,5594,5,41,0,0,5593,
        5595,3,1484,742,0,5594,5593,1,0,0,0,5594,5595,1,0,0,0,5595,5596,
        1,0,0,0,5596,5597,3,994,497,0,5597,731,1,0,0,0,5598,5599,3,734,367,
        0,5599,5600,3,724,362,0,5600,5604,1,0,0,0,5601,5602,5,601,0,0,5602,
        5604,3,718,359,0,5603,5598,1,0,0,0,5603,5601,1,0,0,0,5604,733,1,
        0,0,0,5605,5606,3,994,497,0,5606,5607,3,1478,739,0,5607,5608,3,736,
        368,0,5608,735,1,0,0,0,5609,5617,3,912,456,0,5610,5617,5,166,0,0,
        5611,5617,5,401,0,0,5612,5617,5,57,0,0,5613,5617,5,77,0,0,5614,5617,
        5,503,0,0,5615,5617,5,718,0,0,5616,5609,1,0,0,0,5616,5610,1,0,0,
        0,5616,5611,1,0,0,0,5616,5612,1,0,0,0,5616,5613,1,0,0,0,5616,5614,
        1,0,0,0,5616,5615,1,0,0,0,5617,737,1,0,0,0,5618,5619,5,521,0,0,5619,
        5621,5,151,0,0,5620,5622,3,1312,656,0,5621,5620,1,0,0,0,5621,5622,
        1,0,0,0,5622,739,1,0,0,0,5623,5625,5,521,0,0,5624,5626,3,830,415,
        0,5625,5624,1,0,0,0,5625,5626,1,0,0,0,5626,5627,1,0,0,0,5627,5629,
        5,581,0,0,5628,5630,3,836,418,0,5629,5628,1,0,0,0,5629,5630,1,0,
        0,0,5630,5632,1,0,0,0,5631,5633,3,1312,656,0,5632,5631,1,0,0,0,5632,
        5633,1,0,0,0,5633,741,1,0,0,0,5634,5636,5,521,0,0,5635,5637,5,236,
        0,0,5636,5635,1,0,0,0,5636,5637,1,0,0,0,5637,5638,1,0,0,0,5638,5640,
        5,602,0,0,5639,5641,3,836,418,0,5640,5639,1,0,0,0,5640,5641,1,0,
        0,0,5641,5643,1,0,0,0,5642,5644,3,1312,656,0,5643,5642,1,0,0,0,5643,
        5644,1,0,0,0,5644,743,1,0,0,0,5645,5646,5,521,0,0,5646,5648,5,204,
        0,0,5647,5649,3,836,418,0,5648,5647,1,0,0,0,5648,5649,1,0,0,0,5649,
        5651,1,0,0,0,5650,5652,3,1312,656,0,5651,5650,1,0,0,0,5651,5652,
        1,0,0,0,5652,745,1,0,0,0,5653,5654,5,521,0,0,5654,5655,5,583,0,0,
        5655,5657,5,557,0,0,5656,5658,3,836,418,0,5657,5656,1,0,0,0,5657,
        5658,1,0,0,0,5658,5660,1,0,0,0,5659,5661,3,1312,656,0,5660,5659,
        1,0,0,0,5660,5661,1,0,0,0,5661,747,1,0,0,0,5662,5663,5,521,0,0,5663,
        5664,5,405,0,0,5664,5666,5,581,0,0,5665,5667,3,836,418,0,5666,5665,
        1,0,0,0,5666,5667,1,0,0,0,5667,5669,1,0,0,0,5668,5670,3,1312,656,
        0,5669,5668,1,0,0,0,5669,5670,1,0,0,0,5670,749,1,0,0,0,5671,5672,
        4,375,68,0,5672,5673,5,521,0,0,5673,5674,5,807,0,0,5674,5675,3,4,
        2,0,5675,751,1,0,0,0,5676,5677,5,521,0,0,5677,5678,5,426,0,0,5678,
        753,1,0,0,0,5679,5680,5,521,0,0,5680,5681,5,198,0,0,5681,5682,3,
        832,416,0,5682,5683,5,316,0,0,5683,755,1,0,0,0,5684,5685,5,521,0,
        0,5685,5686,5,198,0,0,5686,5687,3,832,416,0,5687,5688,5,377,0,0,
        5688,757,1,0,0,0,5689,5690,5,521,0,0,5690,5691,5,198,0,0,5691,5692,
        3,832,416,0,5692,5693,5,557,0,0,5693,759,1,0,0,0,5694,5696,5,521,
        0,0,5695,5697,3,830,415,0,5696,5695,1,0,0,0,5696,5697,1,0,0,0,5697,
        5698,1,0,0,0,5698,5699,5,114,0,0,5699,5700,7,94,0,0,5700,5702,3,
        1384,692,0,5701,5703,3,836,418,0,5702,5701,1,0,0,0,5702,5703,1,0,
        0,0,5703,5705,1,0,0,0,5704,5706,3,1312,656,0,5705,5704,1,0,0,0,5705,
        5706,1,0,0,0,5706,761,1,0,0,0,5707,5708,5,521,0,0,5708,5709,7,46,
        0,0,5709,5710,5,316,0,0,5710,763,1,0,0,0,5711,5712,5,521,0,0,5712,
        5713,5,77,0,0,5713,5714,5,808,0,0,5714,5715,5,557,0,0,5715,765,1,
        0,0,0,5716,5721,5,521,0,0,5717,5718,3,606,303,0,5718,5719,5,257,
        0,0,5719,5722,1,0,0,0,5720,5722,5,763,0,0,5721,5717,1,0,0,0,5721,
        5720,1,0,0,0,5722,767,1,0,0,0,5723,5724,5,521,0,0,5724,5725,5,78,
        0,0,5725,5728,5,204,0,0,5726,5727,5,282,0,0,5727,5729,3,1442,721,
        0,5728,5726,1,0,0,0,5728,5729,1,0,0,0,5729,5732,1,0,0,0,5730,5731,
        5,235,0,0,5731,5733,3,1424,712,0,5732,5730,1,0,0,0,5732,5733,1,0,
        0,0,5733,5735,1,0,0,0,5734,5736,3,316,158,0,5735,5734,1,0,0,0,5735,
        5736,1,0,0,0,5736,5738,1,0,0,0,5737,5739,3,1032,516,0,5738,5737,
        1,0,0,0,5738,5739,1,0,0,0,5739,769,1,0,0,0,5740,5741,5,521,0,0,5741,
        5742,5,463,0,0,5742,5745,5,204,0,0,5743,5744,5,282,0,0,5744,5746,
        3,1442,721,0,5745,5743,1,0,0,0,5745,5746,1,0,0,0,5746,5749,1,0,0,
        0,5747,5748,5,235,0,0,5748,5750,3,1424,712,0,5749,5747,1,0,0,0,5749,
        5750,1,0,0,0,5750,5752,1,0,0,0,5751,5753,3,316,158,0,5752,5751,1,
        0,0,0,5752,5753,1,0,0,0,5753,5755,1,0,0,0,5754,5756,3,1032,516,0,
        5755,5754,1,0,0,0,5755,5756,1,0,0,0,5756,771,1,0,0,0,5757,5759,5,
        521,0,0,5758,5760,5,215,0,0,5759,5758,1,0,0,0,5759,5760,1,0,0,0,
        5760,5761,1,0,0,0,5761,5762,7,95,0,0,5762,5763,3,834,417,0,5763,
        5765,3,1384,692,0,5764,5766,3,836,418,0,5765,5764,1,0,0,0,5765,5766,
        1,0,0,0,5766,5768,1,0,0,0,5767,5769,3,392,196,0,5768,5767,1,0,0,
        0,5768,5769,1,0,0,0,5769,773,1,0,0,0,5770,5772,5,521,0,0,5771,5773,
        5,563,0,0,5772,5771,1,0,0,0,5772,5773,1,0,0,0,5773,5774,1,0,0,0,
        5774,5775,5,197,0,0,5775,775,1,0,0,0,5776,5777,5,521,0,0,5777,5778,
        5,137,0,0,5778,5779,5,32,0,0,5779,5780,5,16,0,0,5780,5781,5,33,0,
        0,5781,5782,5,647,0,0,5782,777,1,0,0,0,5783,5784,5,521,0,0,5784,
        5785,5,137,0,0,5785,5786,5,32,0,0,5786,5787,5,16,0,0,5787,5788,5,
        33,0,0,5788,5789,5,201,0,0,5789,779,1,0,0,0,5790,5791,5,521,0,0,
        5791,5793,5,647,0,0,5792,5794,3,316,158,0,5793,5792,1,0,0,0,5793,
        5794,1,0,0,0,5794,781,1,0,0,0,5795,5796,5,521,0,0,5796,5798,5,201,
        0,0,5797,5799,3,316,158,0,5798,5797,1,0,0,0,5798,5799,1,0,0,0,5799,
        783,1,0,0,0,5800,5801,5,521,0,0,5801,5802,5,444,0,0,5802,785,1,0,
        0,0,5803,5804,5,521,0,0,5804,5806,5,443,0,0,5805,5807,3,838,419,
        0,5806,5805,1,0,0,0,5806,5807,1,0,0,0,5807,5811,1,0,0,0,5808,5809,
        5,232,0,0,5809,5810,5,448,0,0,5810,5812,5,3,0,0,5811,5808,1,0,0,
        0,5811,5812,1,0,0,0,5812,5814,1,0,0,0,5813,5815,3,316,158,0,5814,
        5813,1,0,0,0,5814,5815,1,0,0,0,5815,787,1,0,0,0,5816,5818,5,521,
        0,0,5817,5819,3,1480,740,0,5818,5817,1,0,0,0,5818,5819,1,0,0,0,5819,
        5820,1,0,0,0,5820,5822,5,557,0,0,5821,5823,3,1312,656,0,5822,5821,
        1,0,0,0,5822,5823,1,0,0,0,5823,789,1,0,0,0,5824,5826,5,521,0,0,5825,
        5827,5,236,0,0,5826,5825,1,0,0,0,5826,5827,1,0,0,0,5827,5828,1,0,
        0,0,5828,5829,5,442,0,0,5829,791,1,0,0,0,5830,5832,5,521,0,0,5831,
        5833,3,1480,740,0,5832,5831,1,0,0,0,5832,5833,1,0,0,0,5833,5834,
        1,0,0,0,5834,5836,5,639,0,0,5835,5837,3,1312,656,0,5836,5835,1,0,
        0,0,5836,5837,1,0,0,0,5837,793,1,0,0,0,5838,5839,5,521,0,0,5839,
        5841,3,1008,504,0,5840,5842,3,1312,656,0,5841,5840,1,0,0,0,5841,
        5842,1,0,0,0,5842,795,1,0,0,0,5843,5844,5,521,0,0,5844,5846,5,113,
        0,0,5845,5847,3,1312,656,0,5846,5845,1,0,0,0,5846,5847,1,0,0,0,5847,
        797,1,0,0,0,5848,5849,5,521,0,0,5849,5850,5,439,0,0,5850,799,1,0,
        0,0,5851,5852,5,521,0,0,5852,5859,5,248,0,0,5853,5854,5,232,0,0,
        5854,5857,3,1308,654,0,5855,5856,5,630,0,0,5856,5858,3,1272,636,
        0,5857,5855,1,0,0,0,5857,5858,1,0,0,0,5858,5860,1,0,0,0,5859,5853,
        1,0,0,0,5859,5860,1,0,0,0,5860,801,1,0,0,0,5861,5862,5,521,0,0,5862,
        5863,5,139,0,0,5863,5865,5,150,0,0,5864,5866,3,1242,621,0,5865,5864,
        1,0,0,0,5865,5866,1,0,0,0,5866,5867,1,0,0,0,5867,5868,3,1340,670,
        0,5868,803,1,0,0,0,5869,5870,5,521,0,0,5870,5871,5,139,0,0,5871,
        5872,5,583,0,0,5872,5873,3,1384,692,0,5873,805,1,0,0,0,5874,5875,
        5,521,0,0,5875,5876,5,139,0,0,5876,5877,5,644,0,0,5877,5878,3,1356,
        678,0,5878,807,1,0,0,0,5879,5880,5,521,0,0,5880,5881,5,341,0,0,5881,
        5882,5,557,0,0,5882,809,1,0,0,0,5883,5884,5,521,0,0,5884,5885,3,
        606,303,0,5885,5887,5,557,0,0,5886,5888,3,1032,516,0,5887,5886,1,
        0,0,0,5887,5888,1,0,0,0,5888,811,1,0,0,0,5889,5890,5,521,0,0,5890,
        5891,5,139,0,0,5891,5892,5,440,0,0,5892,5893,3,1344,672,0,5893,813,
        1,0,0,0,5894,5895,5,521,0,0,5895,5896,5,139,0,0,5896,5897,5,238,
        0,0,5897,5898,3,1348,674,0,5898,815,1,0,0,0,5899,5900,5,521,0,0,
        5900,5901,5,139,0,0,5901,5902,5,603,0,0,5902,5903,3,1352,676,0,5903,
        817,1,0,0,0,5904,5905,5,521,0,0,5905,5906,5,139,0,0,5906,5907,5,
        440,0,0,5907,5909,5,557,0,0,5908,5910,3,1312,656,0,5909,5908,1,0,
        0,0,5909,5910,1,0,0,0,5910,819,1,0,0,0,5911,5912,5,521,0,0,5912,
        5913,5,139,0,0,5913,5914,5,238,0,0,5914,5916,5,557,0,0,5915,5917,
        3,1312,656,0,5916,5915,1,0,0,0,5916,5917,1,0,0,0,5917,821,1,0,0,
        0,5918,5919,5,521,0,0,5919,5920,5,139,0,0,5920,5921,5,440,0,0,5921,
        5922,5,111,0,0,5922,5923,3,1344,672,0,5923,823,1,0,0,0,5924,5925,
        5,521,0,0,5925,5926,5,139,0,0,5926,5927,5,238,0,0,5927,5928,5,111,
        0,0,5928,5929,3,1348,674,0,5929,825,1,0,0,0,5930,5931,5,521,0,0,
        5931,5932,5,139,0,0,5932,5933,5,205,0,0,5933,5934,3,1368,684,0,5934,
        827,1,0,0,0,5935,5936,5,521,0,0,5936,5937,5,139,0,0,5937,5938,5,
        627,0,0,5938,5939,3,1308,654,0,5939,829,1,0,0,0,5940,5946,5,236,
        0,0,5941,5943,5,215,0,0,5942,5944,5,236,0,0,5943,5942,1,0,0,0,5943,
        5944,1,0,0,0,5944,5946,1,0,0,0,5945,5940,1,0,0,0,5945,5941,1,0,0,
        0,5946,831,1,0,0,0,5947,5950,3,1376,688,0,5948,5950,5,57,0,0,5949,
        5947,1,0,0,0,5949,5948,1,0,0,0,5950,833,1,0,0,0,5951,5952,7,94,0,
        0,5952,835,1,0,0,0,5953,5954,3,834,417,0,5954,5955,3,1408,704,0,
        5955,837,1,0,0,0,5956,5961,3,840,420,0,5957,5958,5,29,0,0,5958,5960,
        3,840,420,0,5959,5957,1,0,0,0,5960,5963,1,0,0,0,5961,5959,1,0,0,
        0,5961,5962,1,0,0,0,5962,839,1,0,0,0,5963,5961,1,0,0,0,5964,5965,
        5,84,0,0,5965,5972,5,285,0,0,5966,5967,5,134,0,0,5967,5972,5,578,
        0,0,5968,5969,5,418,0,0,5969,5972,5,220,0,0,5970,5972,7,96,0,0,5971,
        5964,1,0,0,0,5971,5966,1,0,0,0,5971,5968,1,0,0,0,5971,5970,1,0,0,
        0,5972,841,1,0,0,0,5973,5974,5,78,0,0,5974,6010,3,1446,723,0,5975,
        5976,5,91,0,0,5976,5977,5,268,0,0,5977,5978,3,844,422,0,5978,5981,
        5,282,0,0,5979,5982,3,1408,704,0,5980,5982,5,166,0,0,5981,5979,1,
        0,0,0,5981,5980,1,0,0,0,5982,6010,1,0,0,0,5983,5985,5,228,0,0,5984,
        5986,3,1316,658,0,5985,5984,1,0,0,0,5985,5986,1,0,0,0,5986,5996,
        1,0,0,0,5987,5997,3,862,431,0,5988,5993,3,858,429,0,5989,5990,5,
        29,0,0,5990,5992,3,858,429,0,5991,5989,1,0,0,0,5992,5995,1,0,0,0,
        5993,5991,1,0,0,0,5993,5994,1,0,0,0,5994,5997,1,0,0,0,5995,5993,
        1,0,0,0,5996,5987,1,0,0,0,5996,5988,1,0,0,0,5997,6010,1,0,0,0,5998,
        6000,5,296,0,0,5999,6001,7,97,0,0,6000,5999,1,0,0,0,6000,6001,1,
        0,0,0,6001,6002,1,0,0,0,6002,6010,3,912,456,0,6003,6004,5,311,0,
        0,6004,6005,5,268,0,0,6005,6006,5,279,0,0,6006,6007,5,91,0,0,6007,
        6010,3,866,433,0,6008,6010,5,522,0,0,6009,5973,1,0,0,0,6009,5975,
        1,0,0,0,6009,5983,1,0,0,0,6009,5998,1,0,0,0,6009,6003,1,0,0,0,6009,
        6008,1,0,0,0,6010,843,1,0,0,0,6011,6014,3,846,423,0,6012,6014,3,
        850,425,0,6013,6011,1,0,0,0,6013,6012,1,0,0,0,6014,845,1,0,0,0,6015,
        6020,3,848,424,0,6016,6017,5,29,0,0,6017,6019,3,848,424,0,6018,6016,
        1,0,0,0,6019,6022,1,0,0,0,6020,6018,1,0,0,0,6020,6021,1,0,0,0,6021,
        847,1,0,0,0,6022,6020,1,0,0,0,6023,6025,3,1384,692,0,6024,6026,3,
        852,426,0,6025,6024,1,0,0,0,6025,6026,1,0,0,0,6026,849,1,0,0,0,6027,
        6028,3,1384,692,0,6028,6029,5,423,0,0,6029,6030,5,32,0,0,6030,6031,
        3,56,28,0,6031,6033,5,33,0,0,6032,6034,3,852,426,0,6033,6032,1,0,
        0,0,6033,6034,1,0,0,0,6034,851,1,0,0,0,6035,6036,3,442,221,0,6036,
        6038,5,32,0,0,6037,6039,3,856,428,0,6038,6037,1,0,0,0,6038,6039,
        1,0,0,0,6039,6040,1,0,0,0,6040,6041,5,33,0,0,6041,853,1,0,0,0,6042,
        6045,3,1408,704,0,6043,6045,5,438,0,0,6044,6042,1,0,0,0,6044,6043,
        1,0,0,0,6045,855,1,0,0,0,6046,6051,3,854,427,0,6047,6048,5,29,0,
        0,6048,6050,3,854,427,0,6049,6047,1,0,0,0,6050,6053,1,0,0,0,6051,
        6049,1,0,0,0,6051,6052,1,0,0,0,6052,857,1,0,0,0,6053,6051,1,0,0,
        0,6054,6066,7,98,0,0,6055,6057,3,860,430,0,6056,6055,1,0,0,0,6056,
        6057,1,0,0,0,6057,6058,1,0,0,0,6058,6066,5,316,0,0,6059,6060,5,462,
        0,0,6060,6062,5,316,0,0,6061,6063,3,1032,516,0,6062,6061,1,0,0,0,
        6062,6063,1,0,0,0,6063,6066,1,0,0,0,6064,6066,5,407,0,0,6065,6054,
        1,0,0,0,6065,6056,1,0,0,0,6065,6059,1,0,0,0,6065,6064,1,0,0,0,6066,
        859,1,0,0,0,6067,6068,7,99,0,0,6068,861,1,0,0,0,6069,6077,7,17,0,
        0,6070,6071,5,653,0,0,6071,6072,5,453,0,0,6072,6078,5,314,0,0,6073,
        6075,3,1410,705,0,6074,6076,3,864,432,0,6075,6074,1,0,0,0,6075,6076,
        1,0,0,0,6076,6078,1,0,0,0,6077,6070,1,0,0,0,6077,6073,1,0,0,0,6077,
        6078,1,0,0,0,6078,863,1,0,0,0,6079,6080,5,232,0,0,6080,6085,5,214,
        0,0,6081,6082,5,653,0,0,6082,6083,5,453,0,0,6083,6085,5,314,0,0,
        6084,6079,1,0,0,0,6084,6081,1,0,0,0,6085,865,1,0,0,0,6086,6087,3,
        1384,692,0,6087,6089,3,872,436,0,6088,6090,3,852,426,0,6089,6088,
        1,0,0,0,6089,6090,1,0,0,0,6090,6093,1,0,0,0,6091,6092,5,264,0,0,
        6092,6094,5,300,0,0,6093,6091,1,0,0,0,6093,6094,1,0,0,0,6094,6097,
        1,0,0,0,6095,6097,3,868,434,0,6096,6086,1,0,0,0,6096,6095,1,0,0,
        0,6097,867,1,0,0,0,6098,6103,3,870,435,0,6099,6100,5,29,0,0,6100,
        6102,3,870,435,0,6101,6099,1,0,0,0,6102,6105,1,0,0,0,6103,6101,1,
        0,0,0,6103,6104,1,0,0,0,6104,869,1,0,0,0,6105,6103,1,0,0,0,6106,
        6108,3,1384,692,0,6107,6109,3,852,426,0,6108,6107,1,0,0,0,6108,6109,
        1,0,0,0,6109,6112,1,0,0,0,6110,6111,5,264,0,0,6111,6113,5,300,0,
        0,6112,6110,1,0,0,0,6112,6113,1,0,0,0,6113,871,1,0,0,0,6114,6115,
        5,423,0,0,6115,6116,5,32,0,0,6116,6117,3,56,28,0,6117,6118,5,33,
        0,0,6118,873,1,0,0,0,6119,6124,3,876,438,0,6120,6124,3,886,443,0,
        6121,6124,3,888,444,0,6122,6124,3,892,446,0,6123,6119,1,0,0,0,6123,
        6120,1,0,0,0,6123,6121,1,0,0,0,6123,6122,1,0,0,0,6124,875,1,0,0,
        0,6125,6126,5,139,0,0,6126,6127,5,717,0,0,6127,6128,5,249,0,0,6128,
        6129,3,1408,704,0,6129,6131,5,608,0,0,6130,6132,3,1478,739,0,6131,
        6130,1,0,0,0,6131,6132,1,0,0,0,6132,6133,1,0,0,0,6133,6135,7,100,
        0,0,6134,6136,3,878,439,0,6135,6134,1,0,0,0,6135,6136,1,0,0,0,6136,
        6138,1,0,0,0,6137,6139,3,882,441,0,6138,6137,1,0,0,0,6138,6139,1,
        0,0,0,6139,6141,1,0,0,0,6140,6142,3,884,442,0,6141,6140,1,0,0,0,
        6141,6142,1,0,0,0,6142,877,1,0,0,0,6143,6145,5,719,0,0,6144,6146,
        3,1478,739,0,6145,6144,1,0,0,0,6145,6146,1,0,0,0,6146,6147,1,0,0,
        0,6147,6154,3,880,440,0,6148,6150,5,29,0,0,6149,6148,1,0,0,0,6149,
        6150,1,0,0,0,6150,6151,1,0,0,0,6151,6153,3,880,440,0,6152,6149,1,
        0,0,0,6153,6156,1,0,0,0,6154,6152,1,0,0,0,6154,6155,1,0,0,0,6155,
        879,1,0,0,0,6156,6154,1,0,0,0,6157,6160,5,3,0,0,6158,6159,5,15,0,
        0,6159,6161,5,3,0,0,6160,6158,1,0,0,0,6160,6161,1,0,0,0,6161,881,
        1,0,0,0,6162,6164,5,716,0,0,6163,6165,3,1478,739,0,6164,6163,1,0,
        0,0,6164,6165,1,0,0,0,6165,6166,1,0,0,0,6166,6167,5,3,0,0,6167,883,
        1,0,0,0,6168,6169,7,7,0,0,6169,885,1,0,0,0,6170,6171,5,58,0,0,6171,
        6172,5,717,0,0,6172,6173,5,249,0,0,6173,6175,3,1402,701,0,6174,6176,
        3,878,439,0,6175,6174,1,0,0,0,6175,6176,1,0,0,0,6176,6178,1,0,0,
        0,6177,6179,3,882,441,0,6178,6177,1,0,0,0,6178,6179,1,0,0,0,6179,
        6181,1,0,0,0,6180,6182,3,884,442,0,6181,6180,1,0,0,0,6181,6182,1,
        0,0,0,6182,6184,1,0,0,0,6183,6185,5,230,0,0,6184,6183,1,0,0,0,6184,
        6185,1,0,0,0,6185,887,1,0,0,0,6186,6187,5,519,0,0,6187,6188,5,717,
        0,0,6188,6189,5,249,0,0,6189,6192,3,1408,704,0,6190,6191,5,232,0,
        0,6191,6193,3,890,445,0,6192,6190,1,0,0,0,6192,6193,1,0,0,0,6193,
        889,1,0,0,0,6194,6201,3,1422,711,0,6195,6197,5,29,0,0,6196,6195,
        1,0,0,0,6196,6197,1,0,0,0,6197,6198,1,0,0,0,6198,6200,3,1422,711,
        0,6199,6196,1,0,0,0,6200,6203,1,0,0,0,6201,6199,1,0,0,0,6201,6202,
        1,0,0,0,6202,891,1,0,0,0,6203,6201,1,0,0,0,6204,6205,5,184,0,0,6205,
        6206,5,717,0,0,6206,6207,5,249,0,0,6207,6209,3,1402,701,0,6208,6210,
        5,230,0,0,6209,6208,1,0,0,0,6209,6210,1,0,0,0,6210,893,1,0,0,0,6211,
        6218,3,896,448,0,6212,6218,3,898,449,0,6213,6218,3,906,453,0,6214,
        6218,3,908,454,0,6215,6216,4,447,69,0,6216,6218,3,910,455,0,6217,
        6211,1,0,0,0,6217,6212,1,0,0,0,6217,6213,1,0,0,0,6217,6214,1,0,0,
        0,6217,6215,1,0,0,0,6218,895,1,0,0,0,6219,6220,7,101,0,0,6220,6223,
        3,1384,692,0,6221,6224,3,1442,721,0,6222,6224,3,1328,664,0,6223,
        6221,1,0,0,0,6223,6222,1,0,0,0,6223,6224,1,0,0,0,6224,897,1,0,0,
        0,6225,6227,7,101,0,0,6226,6228,3,900,450,0,6227,6226,1,0,0,0,6227,
        6228,1,0,0,0,6228,6233,1,0,0,0,6229,6230,4,449,70,0,6230,6231,5,
        232,0,0,6231,6232,5,150,0,0,6232,6234,3,1468,734,0,6233,6229,1,0,
        0,0,6233,6234,1,0,0,0,6234,6235,1,0,0,0,6235,6236,3,902,451,0,6236,
        899,1,0,0,0,6237,6238,5,233,0,0,6238,6239,5,6,0,0,6239,6242,3,1468,
        734,0,6240,6241,4,450,71,0,6241,6243,3,904,452,0,6242,6240,1,0,0,
        0,6242,6243,1,0,0,0,6243,6254,1,0,0,0,6244,6245,4,450,72,0,6245,
        6254,5,215,0,0,6246,6247,4,450,73,0,6247,6254,5,60,0,0,6248,6249,
        4,450,74,0,6249,6250,5,60,0,0,6250,6251,5,233,0,0,6251,6252,5,6,
        0,0,6252,6254,3,1468,734,0,6253,6237,1,0,0,0,6253,6244,1,0,0,0,6253,
        6246,1,0,0,0,6253,6248,1,0,0,0,6254,901,1,0,0,0,6255,6264,3,298,
        149,0,6256,6264,3,236,118,0,6257,6264,3,248,124,0,6258,6264,3,296,
        148,0,6259,6264,3,452,226,0,6260,6261,5,232,0,0,6261,6262,5,127,
        0,0,6262,6264,3,1422,711,0,6263,6255,1,0,0,0,6263,6256,1,0,0,0,6263,
        6257,1,0,0,0,6263,6258,1,0,0,0,6263,6259,1,0,0,0,6263,6260,1,0,0,
        0,6264,903,1,0,0,0,6265,6266,5,279,0,0,6266,6267,5,39,0,0,6267,6268,
        3,1468,734,0,6268,905,1,0,0,0,6269,6270,5,254,0,0,6270,6271,3,1468,
        734,0,6271,907,1,0,0,0,6272,6273,5,629,0,0,6273,6274,3,1340,670,
        0,6274,909,1,0,0,0,6275,6276,5,722,0,0,6276,911,1,0,0,0,6277,6278,
        6,456,-1,0,6278,6284,3,914,457,0,6279,6281,5,287,0,0,6280,6282,3,
        1010,505,0,6281,6280,1,0,0,0,6281,6282,1,0,0,0,6282,6283,1,0,0,0,
        6283,6285,7,102,0,0,6284,6279,1,0,0,0,6284,6285,1,0,0,0,6285,6289,
        1,0,0,0,6286,6287,5,390,0,0,6287,6289,3,912,456,4,6288,6277,1,0,
        0,0,6288,6286,1,0,0,0,6289,6301,1,0,0,0,6290,6291,10,3,0,0,6291,
        6292,7,103,0,0,6292,6300,3,912,456,4,6293,6294,10,2,0,0,6294,6295,
        5,662,0,0,6295,6300,3,912,456,3,6296,6297,10,1,0,0,6297,6298,7,104,
        0,0,6298,6300,3,912,456,2,6299,6290,1,0,0,0,6299,6293,1,0,0,0,6299,
        6296,1,0,0,0,6300,6303,1,0,0,0,6301,6299,1,0,0,0,6301,6302,1,0,0,
        0,6302,913,1,0,0,0,6303,6301,1,0,0,0,6304,6305,6,457,-1,0,6305,6306,
        3,918,459,0,6306,6324,1,0,0,0,6307,6308,10,3,0,0,6308,6310,5,287,
        0,0,6309,6311,3,1010,505,0,6310,6309,1,0,0,0,6310,6311,1,0,0,0,6311,
        6312,1,0,0,0,6312,6323,5,395,0,0,6313,6314,10,2,0,0,6314,6315,3,
        916,458,0,6315,6316,3,918,459,0,6316,6323,1,0,0,0,6317,6318,10,1,
        0,0,6318,6319,3,916,458,0,6319,6320,7,105,0,0,6320,6321,3,312,156,
        0,6321,6323,1,0,0,0,6322,6307,1,0,0,0,6322,6313,1,0,0,0,6322,6317,
        1,0,0,0,6323,6326,1,0,0,0,6324,6322,1,0,0,0,6324,6325,1,0,0,0,6325,
        915,1,0,0,0,6326,6324,1,0,0,0,6327,6328,7,106,0,0,6328,917,1,0,0,
        0,6329,6343,3,922,461,0,6330,6332,3,1010,505,0,6331,6330,1,0,0,0,
        6331,6332,1,0,0,0,6332,6333,1,0,0,0,6333,6344,3,920,460,0,6334,6335,
        4,459,81,0,6335,6337,5,741,0,0,6336,6338,5,676,0,0,6337,6336,1,0,
        0,0,6337,6338,1,0,0,0,6338,6339,1,0,0,0,6339,6344,3,1022,511,0,6340,
        6341,5,532,0,0,6341,6342,5,305,0,0,6342,6344,3,922,461,0,6343,6331,
        1,0,0,0,6343,6334,1,0,0,0,6343,6340,1,0,0,0,6343,6344,1,0,0,0,6344,
        919,1,0,0,0,6345,6351,5,282,0,0,6346,6352,3,312,156,0,6347,6348,
        5,32,0,0,6348,6349,3,1006,503,0,6349,6350,5,33,0,0,6350,6352,1,0,
        0,0,6351,6346,1,0,0,0,6351,6347,1,0,0,0,6352,6367,1,0,0,0,6353,6354,
        5,75,0,0,6354,6355,3,922,461,0,6355,6356,5,61,0,0,6356,6357,3,918,
        459,0,6357,6367,1,0,0,0,6358,6359,5,305,0,0,6359,6362,3,924,462,
        0,6360,6361,5,203,0,0,6361,6363,3,924,462,0,6362,6360,1,0,0,0,6362,
        6363,1,0,0,0,6363,6367,1,0,0,0,6364,6365,5,461,0,0,6365,6367,3,922,
        461,0,6366,6345,1,0,0,0,6366,6353,1,0,0,0,6366,6358,1,0,0,0,6366,
        6364,1,0,0,0,6367,921,1,0,0,0,6368,6369,6,461,-1,0,6369,6370,3,924,
        462,0,6370,6397,1,0,0,0,6371,6372,10,7,0,0,6372,6373,5,25,0,0,6373,
        6396,3,922,461,8,6374,6375,10,6,0,0,6375,6376,7,107,0,0,6376,6396,
        3,922,461,7,6377,6378,10,5,0,0,6378,6379,7,108,0,0,6379,6396,3,922,
        461,6,6380,6381,10,3,0,0,6381,6382,7,109,0,0,6382,6396,3,922,461,
        4,6383,6384,10,2,0,0,6384,6385,5,24,0,0,6385,6396,3,922,461,3,6386,
        6387,10,1,0,0,6387,6388,5,27,0,0,6388,6396,3,922,461,2,6389,6390,
        10,4,0,0,6390,6391,7,108,0,0,6391,6392,5,278,0,0,6392,6393,3,912,
        456,0,6393,6394,3,1014,507,0,6394,6396,1,0,0,0,6395,6371,1,0,0,0,
        6395,6374,1,0,0,0,6395,6377,1,0,0,0,6395,6380,1,0,0,0,6395,6383,
        1,0,0,0,6395,6386,1,0,0,0,6395,6389,1,0,0,0,6396,6399,1,0,0,0,6397,
        6395,1,0,0,0,6397,6398,1,0,0,0,6398,923,1,0,0,0,6399,6397,1,0,0,
        0,6400,6401,6,462,-1,0,6401,6403,3,1328,664,0,6402,6404,3,928,464,
        0,6403,6402,1,0,0,0,6403,6404,1,0,0,0,6404,6523,1,0,0,0,6405,6523,
        3,962,481,0,6406,6523,3,982,491,0,6407,6523,3,1434,717,0,6408,6523,
        5,43,0,0,6409,6523,3,992,496,0,6410,6523,3,990,495,0,6411,6523,3,
        930,465,0,6412,6523,3,932,466,0,6413,6523,3,934,467,0,6414,6415,
        7,110,0,0,6415,6523,3,924,462,15,6416,6417,3,1012,506,0,6417,6418,
        3,924,462,14,6418,6523,1,0,0,0,6419,6421,5,503,0,0,6420,6419,1,0,
        0,0,6420,6421,1,0,0,0,6421,6422,1,0,0,0,6422,6423,5,32,0,0,6423,
        6424,3,1006,503,0,6424,6425,5,33,0,0,6425,6523,1,0,0,0,6426,6428,
        5,209,0,0,6427,6426,1,0,0,0,6427,6428,1,0,0,0,6428,6429,1,0,0,0,
        6429,6523,3,312,156,0,6430,6431,5,34,0,0,6431,6432,3,1408,704,0,
        6432,6433,3,912,456,0,6433,6434,5,35,0,0,6434,6523,1,0,0,0,6435,
        6436,5,345,0,0,6436,6437,3,956,478,0,6437,6438,5,54,0,0,6438,6439,
        5,32,0,0,6439,6441,3,922,461,0,6440,6442,3,960,480,0,6441,6440,1,
        0,0,0,6441,6442,1,0,0,0,6442,6443,1,0,0,0,6443,6444,5,33,0,0,6444,
        6523,1,0,0,0,6445,6446,5,77,0,0,6446,6523,3,924,462,9,6447,6448,
        5,96,0,0,6448,6449,5,32,0,0,6449,6452,3,912,456,0,6450,6451,5,67,
        0,0,6451,6453,5,312,0,0,6452,6450,1,0,0,0,6452,6453,1,0,0,0,6453,
        6454,1,0,0,0,6454,6455,5,63,0,0,6455,6457,3,1004,502,0,6456,6458,
        3,926,463,0,6457,6456,1,0,0,0,6457,6458,1,0,0,0,6458,6459,1,0,0,
        0,6459,6460,5,33,0,0,6460,6523,1,0,0,0,6461,6462,5,96,0,0,6462,6463,
        5,32,0,0,6463,6464,3,912,456,0,6464,6465,5,67,0,0,6465,6466,5,595,
        0,0,6466,6468,5,760,0,0,6467,6469,5,278,0,0,6468,6467,1,0,0,0,6468,
        6469,1,0,0,0,6469,6470,1,0,0,0,6470,6471,3,1440,720,0,6471,6472,
        5,63,0,0,6472,6473,5,154,0,0,6473,6474,3,1186,593,0,6474,6475,5,
        33,0,0,6475,6523,1,0,0,0,6476,6478,5,95,0,0,6477,6479,3,912,456,
        0,6478,6477,1,0,0,0,6478,6479,1,0,0,0,6479,6483,1,0,0,0,6480,6481,
        3,998,499,0,6481,6482,3,1000,500,0,6482,6484,1,0,0,0,6483,6480,1,
        0,0,0,6484,6485,1,0,0,0,6485,6483,1,0,0,0,6485,6486,1,0,0,0,6486,
        6488,1,0,0,0,6487,6489,3,1002,501,0,6488,6487,1,0,0,0,6488,6489,
        1,0,0,0,6489,6490,1,0,0,0,6490,6491,5,195,0,0,6491,6523,1,0,0,0,
        6492,6493,5,136,0,0,6493,6494,5,32,0,0,6494,6495,3,912,456,0,6495,
        6496,5,29,0,0,6496,6497,3,1004,502,0,6497,6498,5,33,0,0,6498,6523,
        1,0,0,0,6499,6500,5,136,0,0,6500,6501,5,32,0,0,6501,6502,3,912,456,
        0,6502,6503,5,630,0,0,6503,6504,3,1190,595,0,6504,6505,5,33,0,0,
        6505,6523,1,0,0,0,6506,6507,5,166,0,0,6507,6508,5,32,0,0,6508,6509,
        3,1416,708,0,6509,6510,5,33,0,0,6510,6523,1,0,0,0,6511,6512,5,635,
        0,0,6512,6513,5,32,0,0,6513,6514,3,1416,708,0,6514,6515,5,33,0,0,
        6515,6523,1,0,0,0,6516,6517,5,278,0,0,6517,6518,3,912,456,0,6518,
        6519,3,1014,507,0,6519,6520,5,14,0,0,6520,6521,3,912,456,0,6521,
        6523,1,0,0,0,6522,6400,1,0,0,0,6522,6405,1,0,0,0,6522,6406,1,0,0,
        0,6522,6407,1,0,0,0,6522,6408,1,0,0,0,6522,6409,1,0,0,0,6522,6410,
        1,0,0,0,6522,6411,1,0,0,0,6522,6412,1,0,0,0,6522,6413,1,0,0,0,6522,
        6414,1,0,0,0,6522,6416,1,0,0,0,6522,6420,1,0,0,0,6522,6427,1,0,0,
        0,6522,6430,1,0,0,0,6522,6435,1,0,0,0,6522,6445,1,0,0,0,6522,6447,
        1,0,0,0,6522,6461,1,0,0,0,6522,6476,1,0,0,0,6522,6492,1,0,0,0,6522,
        6499,1,0,0,0,6522,6506,1,0,0,0,6522,6511,1,0,0,0,6522,6516,1,0,0,
        0,6523,6532,1,0,0,0,6524,6525,10,16,0,0,6525,6526,5,2,0,0,6526,6531,
        3,924,462,17,6527,6528,10,24,0,0,6528,6529,5,112,0,0,6529,6531,3,
        1468,734,0,6530,6524,1,0,0,0,6530,6527,1,0,0,0,6531,6534,1,0,0,0,
        6532,6530,1,0,0,0,6532,6533,1,0,0,0,6533,925,1,0,0,0,6534,6532,1,
        0,0,0,6535,6536,4,463,91,0,6536,6537,5,739,0,0,6537,927,1,0,0,0,
        6538,6539,5,37,0,0,6539,6543,3,1440,720,0,6540,6541,5,38,0,0,6541,
        6543,3,1440,720,0,6542,6538,1,0,0,0,6542,6540,1,0,0,0,6543,929,1,
        0,0,0,6544,6545,5,71,0,0,6545,6547,5,32,0,0,6546,6548,5,180,0,0,
        6547,6546,1,0,0,0,6547,6548,1,0,0,0,6548,6549,1,0,0,0,6549,6550,
        3,954,477,0,6550,6552,5,33,0,0,6551,6553,3,942,471,0,6552,6551,1,
        0,0,0,6552,6553,1,0,0,0,6553,6630,1,0,0,0,6554,6555,7,111,0,0,6555,
        6556,5,32,0,0,6556,6557,3,954,477,0,6557,6559,5,33,0,0,6558,6560,
        3,942,471,0,6559,6558,1,0,0,0,6559,6560,1,0,0,0,6560,6630,1,0,0,
        0,6561,6630,3,952,476,0,6562,6563,5,792,0,0,6563,6565,5,32,0,0,6564,
        6566,5,180,0,0,6565,6564,1,0,0,0,6565,6566,1,0,0,0,6566,6567,1,0,
        0,0,6567,6568,3,954,477,0,6568,6570,5,33,0,0,6569,6571,3,942,471,
        0,6570,6569,1,0,0,0,6570,6571,1,0,0,0,6571,6630,1,0,0,0,6572,6573,
        5,137,0,0,6573,6581,5,32,0,0,6574,6576,5,57,0,0,6575,6574,1,0,0,
        0,6575,6576,1,0,0,0,6576,6577,1,0,0,0,6577,6582,5,16,0,0,6578,6582,
        3,954,477,0,6579,6580,5,180,0,0,6580,6582,3,1006,503,0,6581,6575,
        1,0,0,0,6581,6578,1,0,0,0,6581,6579,1,0,0,0,6582,6583,1,0,0,0,6583,
        6585,5,33,0,0,6584,6586,3,942,471,0,6585,6584,1,0,0,0,6585,6586,
        1,0,0,0,6586,6630,1,0,0,0,6587,6588,7,112,0,0,6588,6590,5,32,0,0,
        6589,6591,5,180,0,0,6590,6589,1,0,0,0,6590,6591,1,0,0,0,6591,6592,
        1,0,0,0,6592,6593,3,954,477,0,6593,6595,5,33,0,0,6594,6596,3,942,
        471,0,6595,6594,1,0,0,0,6595,6596,1,0,0,0,6596,6630,1,0,0,0,6597,
        6598,7,113,0,0,6598,6599,5,32,0,0,6599,6600,3,954,477,0,6600,6602,
        5,33,0,0,6601,6603,3,942,471,0,6602,6601,1,0,0,0,6602,6603,1,0,0,
        0,6603,6630,1,0,0,0,6604,6605,5,574,0,0,6605,6606,5,32,0,0,6606,
        6607,5,180,0,0,6607,6608,3,954,477,0,6608,6610,5,33,0,0,6609,6611,
        3,942,471,0,6610,6609,1,0,0,0,6610,6611,1,0,0,0,6611,6630,1,0,0,
        0,6612,6613,5,250,0,0,6613,6615,5,32,0,0,6614,6616,5,180,0,0,6615,
        6614,1,0,0,0,6615,6616,1,0,0,0,6616,6617,1,0,0,0,6617,6619,3,1006,
        503,0,6618,6620,3,362,181,0,6619,6618,1,0,0,0,6619,6620,1,0,0,0,
        6620,6623,1,0,0,0,6621,6622,5,513,0,0,6622,6624,3,1442,721,0,6623,
        6621,1,0,0,0,6623,6624,1,0,0,0,6624,6625,1,0,0,0,6625,6627,5,33,
        0,0,6626,6628,3,942,471,0,6627,6626,1,0,0,0,6627,6628,1,0,0,0,6628,
        6630,1,0,0,0,6629,6544,1,0,0,0,6629,6554,1,0,0,0,6629,6561,1,0,0,
        0,6629,6562,1,0,0,0,6629,6572,1,0,0,0,6629,6587,1,0,0,0,6629,6597,
        1,0,0,0,6629,6604,1,0,0,0,6629,6612,1,0,0,0,6630,931,1,0,0,0,6631,
        6632,5,680,0,0,6632,6633,5,32,0,0,6633,6634,3,1006,503,0,6634,6635,
        5,33,0,0,6635,933,1,0,0,0,6636,6637,7,114,0,0,6637,6638,3,1476,738,
        0,6638,6639,3,942,471,0,6639,6686,1,0,0,0,6640,6647,5,696,0,0,6641,
        6642,5,32,0,0,6642,6643,3,946,473,0,6643,6644,5,33,0,0,6644,6648,
        1,0,0,0,6645,6646,4,467,92,0,6646,6648,3,1022,511,0,6647,6641,1,
        0,0,0,6647,6645,1,0,0,0,6648,6649,1,0,0,0,6649,6650,3,942,471,0,
        6650,6686,1,0,0,0,6651,6652,7,115,0,0,6652,6653,5,32,0,0,6653,6655,
        3,912,456,0,6654,6656,3,944,472,0,6655,6654,1,0,0,0,6655,6656,1,
        0,0,0,6656,6657,1,0,0,0,6657,6659,5,33,0,0,6658,6660,3,950,475,0,
        6659,6658,1,0,0,0,6659,6660,1,0,0,0,6660,6661,1,0,0,0,6661,6662,
        3,942,471,0,6662,6686,1,0,0,0,6663,6664,7,116,0,0,6664,6666,3,1020,
        510,0,6665,6667,3,950,475,0,6666,6665,1,0,0,0,6666,6667,1,0,0,0,
        6667,6668,1,0,0,0,6668,6669,3,942,471,0,6669,6686,1,0,0,0,6670,6671,
        5,695,0,0,6671,6672,5,32,0,0,6672,6673,3,912,456,0,6673,6674,5,29,
        0,0,6674,6675,3,924,462,0,6675,6678,5,33,0,0,6676,6677,5,235,0,0,
        6677,6679,7,117,0,0,6678,6676,1,0,0,0,6678,6679,1,0,0,0,6679,6681,
        1,0,0,0,6680,6682,3,950,475,0,6681,6680,1,0,0,0,6681,6682,1,0,0,
        0,6682,6683,1,0,0,0,6683,6684,3,942,471,0,6684,6686,1,0,0,0,6685,
        6636,1,0,0,0,6685,6640,1,0,0,0,6685,6651,1,0,0,0,6685,6663,1,0,0,
        0,6685,6670,1,0,0,0,6686,935,1,0,0,0,6687,6688,7,118,0,0,6688,937,
        1,0,0,0,6689,6694,3,1424,712,0,6690,6691,5,39,0,0,6691,6694,3,1468,
        734,0,6692,6694,5,43,0,0,6693,6689,1,0,0,0,6693,6690,1,0,0,0,6693,
        6692,1,0,0,0,6694,939,1,0,0,0,6695,6696,4,470,93,0,6696,6697,5,816,
        0,0,6697,6698,3,936,468,0,6698,6699,5,32,0,0,6699,6700,3,938,469,
        0,6700,6701,5,33,0,0,6701,941,1,0,0,0,6702,6705,5,699,0,0,6703,6706,
        3,1404,702,0,6704,6706,3,336,168,0,6705,6703,1,0,0,0,6705,6704,1,
        0,0,0,6706,943,1,0,0,0,6707,6712,5,29,0,0,6708,6713,3,1424,712,0,
        6709,6713,5,43,0,0,6710,6711,4,472,94,0,6711,6713,3,946,473,0,6712,
        6708,1,0,0,0,6712,6709,1,0,0,0,6712,6710,1,0,0,0,6713,6716,1,0,0,
        0,6714,6715,5,29,0,0,6715,6717,3,912,456,0,6716,6714,1,0,0,0,6716,
        6717,1,0,0,0,6717,945,1,0,0,0,6718,6721,3,1458,729,0,6719,6721,3,
        948,474,0,6720,6718,1,0,0,0,6720,6719,1,0,0,0,6721,947,1,0,0,0,6722,
        6727,5,43,0,0,6723,6727,3,1408,704,0,6724,6725,5,39,0,0,6725,6727,
        3,1468,734,0,6726,6722,1,0,0,0,6726,6723,1,0,0,0,6726,6724,1,0,0,
        0,6727,949,1,0,0,0,6728,6729,7,119,0,0,6729,6730,5,697,0,0,6730,
        951,1,0,0,0,6731,6732,5,675,0,0,6732,6733,5,32,0,0,6733,6734,3,954,
        477,0,6734,6736,5,33,0,0,6735,6737,3,942,471,0,6736,6735,1,0,0,0,
        6736,6737,1,0,0,0,6737,6748,1,0,0,0,6738,6739,5,674,0,0,6739,6740,
        5,32,0,0,6740,6741,3,954,477,0,6741,6742,5,29,0,0,6742,6743,3,954,
        477,0,6743,6745,5,33,0,0,6744,6746,3,942,471,0,6745,6744,1,0,0,0,
        6745,6746,1,0,0,0,6746,6748,1,0,0,0,6747,6731,1,0,0,0,6747,6738,
        1,0,0,0,6748,953,1,0,0,0,6749,6751,5,57,0,0,6750,6749,1,0,0,0,6750,
        6751,1,0,0,0,6751,6752,1,0,0,0,6752,6753,3,912,456,0,6753,955,1,
        0,0,0,6754,6760,3,958,479,0,6755,6756,5,32,0,0,6756,6757,3,958,479,
        0,6757,6758,5,33,0,0,6758,6760,1,0,0,0,6759,6754,1,0,0,0,6759,6755,
        1,0,0,0,6760,957,1,0,0,0,6761,6766,3,1416,708,0,6762,6763,5,29,0,
        0,6763,6765,3,1416,708,0,6764,6762,1,0,0,0,6765,6768,1,0,0,0,6766,
        6764,1,0,0,0,6766,6767,1,0,0,0,6767,959,1,0,0,0,6768,6766,1,0,0,
        0,6769,6770,5,282,0,0,6770,6771,5,85,0,0,6771,6785,5,369,0,0,6772,
        6773,5,282,0,0,6773,6774,5,382,0,0,6774,6775,5,297,0,0,6775,6779,
        5,369,0,0,6776,6777,5,653,0,0,6777,6778,5,448,0,0,6778,6780,5,211,
        0,0,6779,6776,1,0,0,0,6779,6780,1,0,0,0,6780,6785,1,0,0,0,6781,6782,
        5,653,0,0,6782,6783,5,448,0,0,6783,6785,5,211,0,0,6784,6769,1,0,
        0,0,6784,6772,1,0,0,0,6784,6781,1,0,0,0,6785,961,1,0,0,0,6786,6787,
        5,103,0,0,6787,6788,5,32,0,0,6788,6791,3,1006,503,0,6789,6790,5,
        630,0,0,6790,6792,3,1190,595,0,6791,6789,1,0,0,0,6791,6792,1,0,0,
        0,6792,6793,1,0,0,0,6793,6794,5,33,0,0,6794,7070,1,0,0,0,6795,6797,
        5,146,0,0,6796,6798,3,1476,738,0,6797,6796,1,0,0,0,6797,6798,1,0,
        0,0,6798,7070,1,0,0,0,6799,6800,5,157,0,0,6800,7070,3,1020,510,0,
        6801,6802,5,162,0,0,6802,7070,3,1020,510,0,6803,6804,5,261,0,0,6804,
        7070,3,1020,510,0,6805,6806,5,274,0,0,6806,6807,5,32,0,0,6807,6808,
        3,912,456,0,6808,6809,5,29,0,0,6809,6810,3,912,456,0,6810,6811,5,
        29,0,0,6811,6812,3,912,456,0,6812,6813,5,29,0,0,6813,6814,3,912,
        456,0,6814,6815,5,33,0,0,6815,7070,1,0,0,0,6816,6817,5,278,0,0,6817,
        6818,5,32,0,0,6818,6821,3,912,456,0,6819,6820,5,29,0,0,6820,6822,
        3,912,456,0,6821,6819,1,0,0,0,6822,6823,1,0,0,0,6823,6821,1,0,0,
        0,6823,6824,1,0,0,0,6824,6825,1,0,0,0,6825,6826,5,33,0,0,6826,7070,
        1,0,0,0,6827,6828,5,754,0,0,6828,6829,5,32,0,0,6829,6830,3,924,462,
        0,6830,6831,5,29,0,0,6831,6833,3,1446,723,0,6832,6834,3,964,482,
        0,6833,6832,1,0,0,0,6833,6834,1,0,0,0,6834,6835,1,0,0,0,6835,6836,
        3,422,211,0,6836,6837,5,33,0,0,6837,7070,1,0,0,0,6838,6839,5,302,
        0,0,6839,6840,5,32,0,0,6840,6841,3,912,456,0,6841,6842,5,29,0,0,
        6842,6843,3,912,456,0,6843,6844,5,33,0,0,6844,7070,1,0,0,0,6845,
        6846,5,366,0,0,6846,7070,3,1020,510,0,6847,6848,5,373,0,0,6848,7070,
        3,1020,510,0,6849,6850,5,495,0,0,6850,6851,5,32,0,0,6851,6852,3,
        912,456,0,6852,6853,5,29,0,0,6853,6854,3,912,456,0,6854,6855,5,33,
        0,0,6855,7070,1,0,0,0,6856,6857,5,509,0,0,6857,7070,3,1020,510,0,
        6858,6859,5,595,0,0,6859,7070,3,1020,510,0,6860,6861,5,592,0,0,6861,
        6862,5,32,0,0,6862,6865,3,912,456,0,6863,6864,5,29,0,0,6864,6866,
        3,912,456,0,6865,6863,1,0,0,0,6865,6866,1,0,0,0,6866,6867,1,0,0,
        0,6867,6868,5,33,0,0,6868,7070,1,0,0,0,6869,7070,3,978,489,0,6870,
        7070,3,630,315,0,6871,6872,5,635,0,0,6872,7070,3,1020,510,0,6873,
        6874,5,664,0,0,6874,7070,3,1020,510,0,6875,6876,7,120,0,0,6876,6877,
        5,32,0,0,6877,6878,3,912,456,0,6878,6884,5,29,0,0,6879,6885,3,912,
        456,0,6880,6881,5,278,0,0,6881,6882,3,912,456,0,6882,6883,3,1014,
        507,0,6883,6885,1,0,0,0,6884,6879,1,0,0,0,6884,6880,1,0,0,0,6885,
        6886,1,0,0,0,6886,6887,5,33,0,0,6887,7070,1,0,0,0,6888,6890,5,142,
        0,0,6889,6891,3,1476,738,0,6890,6889,1,0,0,0,6890,6891,1,0,0,0,6891,
        7070,1,0,0,0,6892,6894,5,149,0,0,6893,6895,3,968,484,0,6894,6893,
        1,0,0,0,6894,6895,1,0,0,0,6895,7070,1,0,0,0,6896,6897,7,121,0,0,
        6897,6898,5,32,0,0,6898,6899,3,912,456,0,6899,6900,5,29,0,0,6900,
        6901,5,278,0,0,6901,6902,3,912,456,0,6902,6903,3,1014,507,0,6903,
        6904,5,33,0,0,6904,7070,1,0,0,0,6905,6906,5,217,0,0,6906,6907,5,
        32,0,0,6907,6908,3,1014,507,0,6908,6909,5,235,0,0,6909,6910,3,912,
        456,0,6910,6911,5,33,0,0,6911,7070,1,0,0,0,6912,6913,5,245,0,0,6913,
        6914,5,32,0,0,6914,6915,3,976,488,0,6915,6916,5,29,0,0,6916,6917,
        3,912,456,0,6917,6918,5,33,0,0,6918,7070,1,0,0,0,6919,6920,4,481,
        95,0,6920,6921,5,808,0,0,6921,6922,5,32,0,0,6922,6925,3,912,456,
        0,6923,6924,5,29,0,0,6924,6926,3,912,456,0,6925,6923,1,0,0,0,6925,
        6926,1,0,0,0,6926,6927,1,0,0,0,6927,6928,5,33,0,0,6928,7070,1,0,
        0,0,6929,6931,5,391,0,0,6930,6932,3,968,484,0,6931,6930,1,0,0,0,
        6931,6932,1,0,0,0,6932,7070,1,0,0,0,6933,6934,5,432,0,0,6934,6935,
        5,32,0,0,6935,6936,3,922,461,0,6936,6937,5,282,0,0,6937,6938,3,912,
        456,0,6938,6939,5,33,0,0,6939,7070,1,0,0,0,6940,7070,3,980,490,0,
        6941,6943,5,579,0,0,6942,6944,3,968,484,0,6943,6942,1,0,0,0,6943,
        6944,1,0,0,0,6944,7070,1,0,0,0,6945,6946,7,122,0,0,6946,6947,5,32,
        0,0,6947,6948,3,1016,508,0,6948,6949,5,29,0,0,6949,6950,3,912,456,
        0,6950,6951,5,29,0,0,6951,6952,3,912,456,0,6952,6953,5,33,0,0,6953,
        7070,1,0,0,0,6954,6956,5,631,0,0,6955,6957,3,1476,738,0,6956,6955,
        1,0,0,0,6956,6957,1,0,0,0,6957,7070,1,0,0,0,6958,6960,5,633,0,0,
        6959,6961,3,968,484,0,6960,6959,1,0,0,0,6960,6961,1,0,0,0,6961,7070,
        1,0,0,0,6962,6964,5,632,0,0,6963,6965,3,968,484,0,6964,6963,1,0,
        0,0,6964,6965,1,0,0,0,6965,7070,1,0,0,0,6966,6967,5,65,0,0,6967,
        7070,3,1020,510,0,6968,6969,5,102,0,0,6969,7070,3,1020,510,0,6970,
        6971,5,110,0,0,6971,7070,3,1018,509,0,6972,6973,5,113,0,0,6973,7070,
        3,1020,510,0,6974,6975,5,150,0,0,6975,7070,3,1476,738,0,6976,6977,
        5,263,0,0,6977,6978,5,32,0,0,6978,6979,3,912,456,0,6979,6980,5,29,
        0,0,6980,6981,3,912,456,0,6981,6982,5,29,0,0,6982,6983,3,912,456,
        0,6983,6984,5,33,0,0,6984,7070,1,0,0,0,6985,6986,5,233,0,0,6986,
        6987,5,32,0,0,6987,6988,3,912,456,0,6988,6989,5,29,0,0,6989,6992,
        3,912,456,0,6990,6991,5,29,0,0,6991,6993,3,912,456,0,6992,6990,1,
        0,0,0,6992,6993,1,0,0,0,6993,6994,1,0,0,0,6994,6995,5,33,0,0,6995,
        7070,1,0,0,0,6996,6997,5,361,0,0,6997,7070,3,1020,510,0,6998,6999,
        5,372,0,0,6999,7000,5,32,0,0,7000,7001,3,912,456,0,7001,7002,5,29,
        0,0,7002,7003,3,912,456,0,7003,7004,5,33,0,0,7004,7070,1,0,0,0,7005,
        7006,4,481,96,0,7006,7007,5,424,0,0,7007,7070,3,1020,510,0,7008,
        7009,5,447,0,0,7009,7070,3,1020,510,0,7010,7011,5,474,0,0,7011,7012,
        5,32,0,0,7012,7013,3,912,456,0,7013,7014,5,29,0,0,7014,7015,3,912,
        456,0,7015,7016,5,33,0,0,7016,7070,1,0,0,0,7017,7018,5,475,0,0,7018,
        7019,5,32,0,0,7019,7020,3,912,456,0,7020,7021,5,29,0,0,7021,7022,
        3,912,456,0,7022,7023,5,29,0,0,7023,7024,3,912,456,0,7024,7025,5,
        33,0,0,7025,7070,1,0,0,0,7026,7027,5,493,0,0,7027,7070,3,1020,510,
        0,7028,7029,5,501,0,0,7029,7070,3,1476,738,0,7030,7031,5,606,0,0,
        7031,7032,5,32,0,0,7032,7033,3,912,456,0,7033,7034,5,29,0,0,7034,
        7035,3,912,456,0,7035,7036,5,33,0,0,7036,7070,1,0,0,0,7037,7038,
        5,648,0,0,7038,7039,5,32,0,0,7039,7042,3,912,456,0,7040,7041,5,29,
        0,0,7041,7043,3,912,456,0,7042,7040,1,0,0,0,7042,7043,1,0,0,0,7043,
        7044,1,0,0,0,7044,7045,5,33,0,0,7045,7070,1,0,0,0,7046,7047,5,649,
        0,0,7047,7048,5,32,0,0,7048,7064,3,912,456,0,7049,7050,5,63,0,0,
        7050,7051,5,103,0,0,7051,7053,3,1184,592,0,7052,7049,1,0,0,0,7052,
        7053,1,0,0,0,7053,7065,1,0,0,0,7054,7055,5,63,0,0,7055,7056,5,77,
        0,0,7056,7065,3,1184,592,0,7057,7058,5,29,0,0,7058,7059,3,1420,710,
        0,7059,7060,5,29,0,0,7060,7061,3,1420,710,0,7061,7062,5,29,0,0,7062,
        7063,3,1420,710,0,7063,7065,1,0,0,0,7064,7052,1,0,0,0,7064,7054,
        1,0,0,0,7064,7057,1,0,0,0,7065,7066,1,0,0,0,7066,7067,5,33,0,0,7067,
        7070,1,0,0,0,7068,7070,3,966,483,0,7069,6786,1,0,0,0,7069,6795,1,
        0,0,0,7069,6799,1,0,0,0,7069,6801,1,0,0,0,7069,6803,1,0,0,0,7069,
        6805,1,0,0,0,7069,6816,1,0,0,0,7069,6827,1,0,0,0,7069,6838,1,0,0,
        0,7069,6845,1,0,0,0,7069,6847,1,0,0,0,7069,6849,1,0,0,0,7069,6856,
        1,0,0,0,7069,6858,1,0,0,0,7069,6860,1,0,0,0,7069,6869,1,0,0,0,7069,
        6870,1,0,0,0,7069,6871,1,0,0,0,7069,6873,1,0,0,0,7069,6875,1,0,0,
        0,7069,6888,1,0,0,0,7069,6892,1,0,0,0,7069,6896,1,0,0,0,7069,6905,
        1,0,0,0,7069,6912,1,0,0,0,7069,6919,1,0,0,0,7069,6929,1,0,0,0,7069,
        6933,1,0,0,0,7069,6940,1,0,0,0,7069,6941,1,0,0,0,7069,6945,1,0,0,
        0,7069,6954,1,0,0,0,7069,6958,1,0,0,0,7069,6962,1,0,0,0,7069,6966,
        1,0,0,0,7069,6968,1,0,0,0,7069,6970,1,0,0,0,7069,6972,1,0,0,0,7069,
        6974,1,0,0,0,7069,6976,1,0,0,0,7069,6985,1,0,0,0,7069,6996,1,0,0,
        0,7069,6998,1,0,0,0,7069,7005,1,0,0,0,7069,7008,1,0,0,0,7069,7010,
        1,0,0,0,7069,7017,1,0,0,0,7069,7026,1,0,0,0,7069,7028,1,0,0,0,7069,
        7030,1,0,0,0,7069,7037,1,0,0,0,7069,7046,1,0,0,0,7069,7068,1,0,0,
        0,7070,963,1,0,0,0,7071,7072,5,753,0,0,7072,7073,3,1004,502,0,7073,
        965,1,0,0,0,7074,7075,5,243,0,0,7075,7077,5,32,0,0,7076,7078,3,1006,
        503,0,7077,7076,1,0,0,0,7077,7078,1,0,0,0,7078,7079,1,0,0,0,7079,
        7098,5,33,0,0,7080,7081,5,309,0,0,7081,7098,3,1018,509,0,7082,7083,
        5,374,0,0,7083,7098,3,1018,509,0,7084,7085,5,375,0,0,7085,7098,3,
        1018,509,0,7086,7087,5,376,0,0,7087,7098,3,1018,509,0,7088,7089,
        5,429,0,0,7089,7090,5,32,0,0,7090,7091,3,912,456,0,7091,7092,5,29,
        0,0,7092,7093,3,912,456,0,7093,7094,5,33,0,0,7094,7098,1,0,0,0,7095,
        7096,5,430,0,0,7096,7098,3,1018,509,0,7097,7074,1,0,0,0,7097,7080,
        1,0,0,0,7097,7082,1,0,0,0,7097,7084,1,0,0,0,7097,7086,1,0,0,0,7097,
        7088,1,0,0,0,7097,7095,1,0,0,0,7098,967,1,0,0,0,7099,7101,5,32,0,
        0,7100,7102,3,970,485,0,7101,7100,1,0,0,0,7101,7102,1,0,0,0,7102,
        7103,1,0,0,0,7103,7104,5,33,0,0,7104,969,1,0,0,0,7105,7106,5,3,0,
        0,7106,971,1,0,0,0,7107,7120,5,304,0,0,7108,7109,3,1422,711,0,7109,
        7110,5,15,0,0,7110,7111,3,1422,711,0,7111,7121,1,0,0,0,7112,7117,
        3,974,487,0,7113,7114,5,29,0,0,7114,7116,3,974,487,0,7115,7113,1,
        0,0,0,7116,7119,1,0,0,0,7117,7115,1,0,0,0,7117,7118,1,0,0,0,7118,
        7121,1,0,0,0,7119,7117,1,0,0,0,7120,7108,1,0,0,0,7120,7112,1,0,0,
        0,7121,973,1,0,0,0,7122,7128,3,1422,711,0,7123,7125,7,35,0,0,7124,
        7126,5,493,0,0,7125,7124,1,0,0,0,7125,7126,1,0,0,0,7126,7129,1,0,
        0,0,7127,7129,5,493,0,0,7128,7123,1,0,0,0,7128,7127,1,0,0,0,7128,
        7129,1,0,0,0,7129,975,1,0,0,0,7130,7131,7,123,0,0,7131,977,1,0,0,
        0,7132,7133,5,604,0,0,7133,7157,5,32,0,0,7134,7137,3,912,456,0,7135,
        7136,5,235,0,0,7136,7138,3,912,456,0,7137,7135,1,0,0,0,7137,7138,
        1,0,0,0,7138,7158,1,0,0,0,7139,7141,5,299,0,0,7140,7142,3,912,456,
        0,7141,7140,1,0,0,0,7141,7142,1,0,0,0,7142,7143,1,0,0,0,7143,7144,
        5,235,0,0,7144,7158,3,912,456,0,7145,7147,5,600,0,0,7146,7148,3,
        912,456,0,7147,7146,1,0,0,0,7147,7148,1,0,0,0,7148,7149,1,0,0,0,
        7149,7150,5,235,0,0,7150,7158,3,912,456,0,7151,7153,5,87,0,0,7152,
        7154,3,912,456,0,7153,7152,1,0,0,0,7153,7154,1,0,0,0,7154,7155,1,
        0,0,0,7155,7156,5,235,0,0,7156,7158,3,912,456,0,7157,7134,1,0,0,
        0,7157,7139,1,0,0,0,7157,7145,1,0,0,0,7157,7151,1,0,0,0,7158,7159,
        1,0,0,0,7159,7160,5,33,0,0,7160,979,1,0,0,0,7161,7162,5,573,0,0,
        7162,7163,5,32,0,0,7163,7176,3,912,456,0,7164,7165,5,29,0,0,7165,
        7168,3,912,456,0,7166,7167,5,29,0,0,7167,7169,3,912,456,0,7168,7166,
        1,0,0,0,7168,7169,1,0,0,0,7169,7177,1,0,0,0,7170,7171,5,235,0,0,
        7171,7174,3,912,456,0,7172,7173,5,232,0,0,7173,7175,3,912,456,0,
        7174,7172,1,0,0,0,7174,7175,1,0,0,0,7175,7177,1,0,0,0,7176,7164,
        1,0,0,0,7176,7170,1,0,0,0,7177,7178,1,0,0,0,7178,7179,5,33,0,0,7179,
        981,1,0,0,0,7180,7181,3,1406,703,0,7181,7183,5,32,0,0,7182,7184,
        3,984,492,0,7183,7182,1,0,0,0,7183,7184,1,0,0,0,7184,7185,1,0,0,
        0,7185,7186,5,33,0,0,7186,7195,1,0,0,0,7187,7188,3,1414,707,0,7188,
        7190,5,32,0,0,7189,7191,3,1006,503,0,7190,7189,1,0,0,0,7190,7191,
        1,0,0,0,7191,7192,1,0,0,0,7192,7193,5,33,0,0,7193,7195,1,0,0,0,7194,
        7180,1,0,0,0,7194,7187,1,0,0,0,7195,983,1,0,0,0,7196,7201,3,986,
        493,0,7197,7198,5,29,0,0,7198,7200,3,986,493,0,7199,7197,1,0,0,0,
        7200,7203,1,0,0,0,7201,7199,1,0,0,0,7201,7202,1,0,0,0,7202,985,1,
        0,0,0,7203,7201,1,0,0,0,7204,7206,3,912,456,0,7205,7207,3,390,195,
        0,7206,7205,1,0,0,0,7206,7207,1,0,0,0,7207,987,1,0,0,0,7208,7209,
        5,39,0,0,7209,7212,3,1468,734,0,7210,7212,5,40,0,0,7211,7208,1,0,
        0,0,7211,7210,1,0,0,0,7212,989,1,0,0,0,7213,7214,3,988,494,0,7214,
        7215,5,7,0,0,7215,7216,3,912,456,0,7216,991,1,0,0,0,7217,7224,3,
        988,494,0,7218,7220,5,41,0,0,7219,7221,3,1482,741,0,7220,7219,1,
        0,0,0,7220,7221,1,0,0,0,7221,7222,1,0,0,0,7222,7224,3,996,498,0,
        7223,7217,1,0,0,0,7223,7218,1,0,0,0,7224,993,1,0,0,0,7225,7227,3,
        1408,704,0,7226,7228,3,1418,709,0,7227,7226,1,0,0,0,7227,7228,1,
        0,0,0,7228,7235,1,0,0,0,7229,7230,4,497,97,0,7230,7232,3,1470,735,
        0,7231,7233,3,1418,709,0,7232,7231,1,0,0,0,7232,7233,1,0,0,0,7233,
        7235,1,0,0,0,7234,7225,1,0,0,0,7234,7229,1,0,0,0,7235,7239,1,0,0,
        0,7236,7237,5,166,0,0,7237,7239,3,1418,709,0,7238,7234,1,0,0,0,7238,
        7236,1,0,0,0,7239,995,1,0,0,0,7240,7242,3,1468,734,0,7241,7243,3,
        1418,709,0,7242,7241,1,0,0,0,7242,7243,1,0,0,0,7243,997,1,0,0,0,
        7244,7245,5,650,0,0,7245,7246,3,912,456,0,7246,999,1,0,0,0,7247,
        7248,5,591,0,0,7248,7249,3,912,456,0,7249,1001,1,0,0,0,7250,7251,
        5,190,0,0,7251,7252,3,912,456,0,7252,1003,1,0,0,0,7253,7255,5,77,
        0,0,7254,7256,3,1174,587,0,7255,7254,1,0,0,0,7255,7256,1,0,0,0,7256,
        7302,1,0,0,0,7257,7259,5,103,0,0,7258,7260,3,1174,587,0,7259,7258,
        1,0,0,0,7259,7260,1,0,0,0,7260,7262,1,0,0,0,7261,7263,3,1178,589,
        0,7262,7261,1,0,0,0,7262,7263,1,0,0,0,7263,7302,1,0,0,0,7264,7266,
        3,1170,585,0,7265,7267,3,1174,587,0,7266,7265,1,0,0,0,7266,7267,
        1,0,0,0,7267,7302,1,0,0,0,7268,7270,5,524,0,0,7269,7271,5,280,0,
        0,7270,7269,1,0,0,0,7270,7271,1,0,0,0,7271,7302,1,0,0,0,7272,7274,
        5,621,0,0,7273,7275,5,280,0,0,7274,7273,1,0,0,0,7274,7275,1,0,0,
        0,7275,7302,1,0,0,0,7276,7302,5,157,0,0,7277,7278,4,502,98,0,7278,
        7302,5,664,0,0,7279,7281,5,595,0,0,7280,7282,3,1186,593,0,7281,7280,
        1,0,0,0,7281,7282,1,0,0,0,7282,7302,1,0,0,0,7283,7285,5,154,0,0,
        7284,7286,3,1186,593,0,7285,7284,1,0,0,0,7285,7286,1,0,0,0,7286,
        7302,1,0,0,0,7287,7289,5,164,0,0,7288,7290,3,1462,731,0,7289,7288,
        1,0,0,0,7289,7290,1,0,0,0,7290,7302,1,0,0,0,7291,7302,5,292,0,0,
        7292,7293,4,502,99,0,7293,7302,3,1172,586,0,7294,7295,4,502,100,
        0,7295,7297,5,227,0,0,7296,7298,3,1464,732,0,7297,7296,1,0,0,0,7297,
        7298,1,0,0,0,7298,7302,1,0,0,0,7299,7300,4,502,101,0,7300,7302,7,
        124,0,0,7301,7253,1,0,0,0,7301,7257,1,0,0,0,7301,7264,1,0,0,0,7301,
        7268,1,0,0,0,7301,7272,1,0,0,0,7301,7276,1,0,0,0,7301,7277,1,0,0,
        0,7301,7279,1,0,0,0,7301,7283,1,0,0,0,7301,7287,1,0,0,0,7301,7291,
        1,0,0,0,7301,7292,1,0,0,0,7301,7294,1,0,0,0,7301,7299,1,0,0,0,7302,
        1005,1,0,0,0,7303,7308,3,912,456,0,7304,7305,5,29,0,0,7305,7307,
        3,912,456,0,7306,7304,1,0,0,0,7307,7310,1,0,0,0,7308,7306,1,0,0,
        0,7308,7309,1,0,0,0,7309,1007,1,0,0,0,7310,7308,1,0,0,0,7311,7312,
        5,103,0,0,7312,7315,5,519,0,0,7313,7315,5,102,0,0,7314,7311,1,0,
        0,0,7314,7313,1,0,0,0,7315,1009,1,0,0,0,7316,7317,7,125,0,0,7317,
        1011,1,0,0,0,7318,7319,7,126,0,0,7319,1013,1,0,0,0,7320,7323,3,1016,
        508,0,7321,7323,7,127,0,0,7322,7320,1,0,0,0,7322,7321,1,0,0,0,7323,
        1015,1,0,0,0,7324,7325,7,128,0,0,7325,1017,1,0,0,0,7326,7327,5,32,
        0,0,7327,7328,3,1006,503,0,7328,7329,5,33,0,0,7329,1019,1,0,0,0,
        7330,7331,5,32,0,0,7331,7332,3,912,456,0,7332,7333,5,33,0,0,7333,
        1021,1,0,0,0,7334,7335,5,32,0,0,7335,7336,3,924,462,0,7336,7337,
        5,33,0,0,7337,1023,1,0,0,0,7338,7343,3,1026,513,0,7339,7340,5,29,
        0,0,7340,7342,3,1026,513,0,7341,7339,1,0,0,0,7342,7345,1,0,0,0,7343,
        7341,1,0,0,0,7343,7344,1,0,0,0,7344,1025,1,0,0,0,7345,7343,1,0,0,
        0,7346,7348,3,912,456,0,7347,7349,3,364,182,0,7348,7347,1,0,0,0,
        7348,7349,1,0,0,0,7349,1027,1,0,0,0,7350,7355,3,1030,515,0,7351,
        7352,5,29,0,0,7352,7354,3,1030,515,0,7353,7351,1,0,0,0,7354,7357,
        1,0,0,0,7355,7353,1,0,0,0,7355,7356,1,0,0,0,7356,1029,1,0,0,0,7357,
        7355,1,0,0,0,7358,7359,3,912,456,0,7359,1031,1,0,0,0,7360,7361,5,
        232,0,0,7361,7362,5,101,0,0,7362,7363,3,1448,724,0,7363,1033,1,0,
        0,0,7364,7378,3,4,2,0,7365,7378,3,1036,518,0,7366,7378,3,1038,519,
        0,7367,7378,3,1046,523,0,7368,7378,3,1050,525,0,7369,7378,3,1052,
        526,0,7370,7378,3,1058,529,0,7371,7378,3,1060,530,0,7372,7378,3,
        1088,544,0,7373,7378,3,1086,543,0,7374,7378,3,1106,553,0,7375,7378,
        3,1110,555,0,7376,7378,3,1108,554,0,7377,7364,1,0,0,0,7377,7365,
        1,0,0,0,7377,7366,1,0,0,0,7377,7367,1,0,0,0,7377,7368,1,0,0,0,7377,
        7369,1,0,0,0,7377,7370,1,0,0,0,7377,7371,1,0,0,0,7377,7372,1,0,0,
        0,7377,7373,1,0,0,0,7377,7374,1,0,0,0,7377,7375,1,0,0,0,7377,7376,
        1,0,0,0,7378,1035,1,0,0,0,7379,7380,5,492,0,0,7380,7381,3,912,456,
        0,7381,1037,1,0,0,0,7382,7383,5,263,0,0,7383,7384,3,1040,520,0,7384,
        7385,5,195,0,0,7385,7386,5,263,0,0,7386,1039,1,0,0,0,7387,7388,3,
        912,456,0,7388,7393,3,1042,521,0,7389,7390,5,191,0,0,7390,7394,3,
        1040,520,0,7391,7392,5,190,0,0,7392,7394,3,1044,522,0,7393,7389,
        1,0,0,0,7393,7391,1,0,0,0,7393,7394,1,0,0,0,7394,1041,1,0,0,0,7395,
        7396,5,591,0,0,7396,7397,3,1044,522,0,7397,1043,1,0,0,0,7398,7399,
        3,1034,517,0,7399,7400,5,30,0,0,7400,7402,1,0,0,0,7401,7398,1,0,
        0,0,7402,7403,1,0,0,0,7403,7401,1,0,0,0,7403,7404,1,0,0,0,7404,1045,
        1,0,0,0,7405,7407,5,95,0,0,7406,7408,3,912,456,0,7407,7406,1,0,0,
        0,7407,7408,1,0,0,0,7408,7412,1,0,0,0,7409,7410,3,998,499,0,7410,
        7411,3,1042,521,0,7411,7413,1,0,0,0,7412,7409,1,0,0,0,7413,7414,
        1,0,0,0,7414,7412,1,0,0,0,7414,7415,1,0,0,0,7415,7417,1,0,0,0,7416,
        7418,3,1048,524,0,7417,7416,1,0,0,0,7417,7418,1,0,0,0,7418,7419,
        1,0,0,0,7419,7420,5,195,0,0,7420,7421,5,95,0,0,7421,1047,1,0,0,0,
        7422,7423,5,190,0,0,7423,7424,3,1044,522,0,7424,1049,1,0,0,0,7425,
        7426,3,1054,527,0,7426,7428,3,1056,528,0,7427,7429,3,1394,697,0,
        7428,7427,1,0,0,0,7428,7429,1,0,0,0,7429,1051,1,0,0,0,7430,7431,
        3,1056,528,0,7431,1053,1,0,0,0,7432,7433,3,1392,696,0,7433,7434,
        5,31,0,0,7434,1055,1,0,0,0,7435,7437,5,74,0,0,7436,7438,3,1068,534,
        0,7437,7436,1,0,0,0,7437,7438,1,0,0,0,7438,7440,1,0,0,0,7439,7441,
        3,1044,522,0,7440,7439,1,0,0,0,7440,7441,1,0,0,0,7441,7442,1,0,0,
        0,7442,7443,5,195,0,0,7443,1057,1,0,0,0,7444,7445,3,1054,527,0,7445,
        7447,3,1060,530,0,7446,7448,3,1394,697,0,7447,7446,1,0,0,0,7447,
        7448,1,0,0,0,7448,1059,1,0,0,0,7449,7453,3,1062,531,0,7450,7453,
        3,1064,532,0,7451,7453,3,1066,533,0,7452,7449,1,0,0,0,7452,7450,
        1,0,0,0,7452,7451,1,0,0,0,7453,1061,1,0,0,0,7454,7455,5,320,0,0,
        7455,7456,3,1044,522,0,7456,7457,5,195,0,0,7457,7458,5,320,0,0,7458,
        1063,1,0,0,0,7459,7460,5,652,0,0,7460,7461,3,912,456,0,7461,7462,
        5,183,0,0,7462,7463,3,1044,522,0,7463,7464,5,195,0,0,7464,7465,5,
        652,0,0,7465,1065,1,0,0,0,7466,7467,5,474,0,0,7467,7468,3,1044,522,
        0,7468,7469,5,622,0,0,7469,7470,3,912,456,0,7470,7471,5,195,0,0,
        7471,7472,5,474,0,0,7472,1067,1,0,0,0,7473,7474,3,1070,535,0,7474,
        7475,5,30,0,0,7475,7477,1,0,0,0,7476,7473,1,0,0,0,7477,7478,1,0,
        0,0,7478,7476,1,0,0,0,7478,7479,1,0,0,0,7479,1069,1,0,0,0,7480,7485,
        3,1072,536,0,7481,7485,3,1074,537,0,7482,7485,3,1080,540,0,7483,
        7485,3,1084,542,0,7484,7480,1,0,0,0,7484,7481,1,0,0,0,7484,7482,
        1,0,0,0,7484,7483,1,0,0,0,7485,1071,1,0,0,0,7486,7487,5,165,0,0,
        7487,7488,3,1410,705,0,7488,7490,3,1168,584,0,7489,7491,3,1250,625,
        0,7490,7489,1,0,0,0,7490,7491,1,0,0,0,7491,7494,1,0,0,0,7492,7493,
        5,166,0,0,7493,7495,3,912,456,0,7494,7492,1,0,0,0,7494,7495,1,0,
        0,0,7495,1073,1,0,0,0,7496,7497,5,165,0,0,7497,7498,3,1408,704,0,
        7498,7499,5,126,0,0,7499,7500,5,232,0,0,7500,7501,3,1076,538,0,7501,
        1075,1,0,0,0,7502,7505,3,1420,710,0,7503,7505,3,1078,539,0,7504,
        7502,1,0,0,0,7504,7503,1,0,0,0,7505,1077,1,0,0,0,7506,7508,5,537,
        0,0,7507,7509,5,636,0,0,7508,7507,1,0,0,0,7508,7509,1,0,0,0,7509,
        7510,1,0,0,0,7510,7511,3,1446,723,0,7511,1079,1,0,0,0,7512,7513,
        5,165,0,0,7513,7514,7,129,0,0,7514,7515,5,251,0,0,7515,7516,5,232,
        0,0,7516,7521,3,1082,541,0,7517,7518,5,29,0,0,7518,7520,3,1082,541,
        0,7519,7517,1,0,0,0,7520,7523,1,0,0,0,7521,7519,1,0,0,0,7521,7522,
        1,0,0,0,7522,7524,1,0,0,0,7523,7521,1,0,0,0,7524,7525,3,1034,517,
        0,7525,1081,1,0,0,0,7526,7534,3,1076,538,0,7527,7534,3,1408,704,
        0,7528,7534,5,538,0,0,7529,7530,3,1010,505,0,7530,7531,5,234,0,0,
        7531,7534,1,0,0,0,7532,7534,5,536,0,0,7533,7526,1,0,0,0,7533,7527,
        1,0,0,0,7533,7528,1,0,0,0,7533,7529,1,0,0,0,7533,7532,1,0,0,0,7534,
        1083,1,0,0,0,7535,7536,5,165,0,0,7536,7537,3,1408,704,0,7537,7538,
        5,147,0,0,7538,7539,5,232,0,0,7539,7540,3,298,149,0,7540,1085,1,
        0,0,0,7541,7542,5,290,0,0,7542,7543,3,1394,697,0,7543,1087,1,0,0,
        0,7544,7545,5,301,0,0,7545,7546,3,1394,697,0,7546,1089,1,0,0,0,7547,
        7549,5,239,0,0,7548,7550,7,130,0,0,7549,7548,1,0,0,0,7549,7550,1,
        0,0,0,7550,7551,1,0,0,0,7551,7570,5,175,0,0,7552,7557,3,1094,547,
        0,7553,7554,5,29,0,0,7554,7556,3,1094,547,0,7555,7553,1,0,0,0,7556,
        7559,1,0,0,0,7557,7555,1,0,0,0,7557,7558,1,0,0,0,7558,7571,1,0,0,
        0,7559,7557,1,0,0,0,7560,7561,5,126,0,0,7561,7562,3,1092,546,0,7562,
        7567,3,1096,548,0,7563,7564,5,29,0,0,7564,7566,3,1096,548,0,7565,
        7563,1,0,0,0,7566,7569,1,0,0,0,7567,7565,1,0,0,0,7567,7568,1,0,0,
        0,7568,7571,1,0,0,0,7569,7567,1,0,0,0,7570,7552,1,0,0,0,7570,7560,
        1,0,0,0,7571,1091,1,0,0,0,7572,7576,3,1432,716,0,7573,7576,3,992,
        496,0,7574,7576,3,1414,707,0,7575,7572,1,0,0,0,7575,7573,1,0,0,0,
        7575,7574,1,0,0,0,7576,1093,1,0,0,0,7577,7580,3,988,494,0,7578,7580,
        3,1408,704,0,7579,7577,1,0,0,0,7579,7578,1,0,0,0,7580,7581,1,0,0,
        0,7581,7582,5,6,0,0,7582,7583,7,131,0,0,7583,1095,1,0,0,0,7584,7587,
        3,988,494,0,7585,7587,3,1408,704,0,7586,7584,1,0,0,0,7586,7585,1,
        0,0,0,7587,7588,1,0,0,0,7588,7591,5,6,0,0,7589,7592,3,1098,549,0,
        7590,7592,5,490,0,0,7591,7589,1,0,0,0,7591,7590,1,0,0,0,7592,1097,
        1,0,0,0,7593,7594,7,132,0,0,7594,1099,1,0,0,0,7595,7598,5,523,0,
        0,7596,7599,3,1408,704,0,7597,7599,3,1078,539,0,7598,7596,1,0,0,
        0,7598,7597,1,0,0,0,7599,7609,1,0,0,0,7600,7601,5,519,0,0,7601,7606,
        3,1104,552,0,7602,7603,5,29,0,0,7603,7605,3,1104,552,0,7604,7602,
        1,0,0,0,7605,7608,1,0,0,0,7606,7604,1,0,0,0,7606,7607,1,0,0,0,7607,
        7610,1,0,0,0,7608,7606,1,0,0,0,7609,7600,1,0,0,0,7609,7610,1,0,0,
        0,7610,1101,1,0,0,0,7611,7614,5,486,0,0,7612,7615,3,1408,704,0,7613,
        7615,3,1078,539,0,7614,7612,1,0,0,0,7614,7613,1,0,0,0,7614,7615,
        1,0,0,0,7615,7625,1,0,0,0,7616,7617,5,519,0,0,7617,7622,3,1104,552,
        0,7618,7619,5,29,0,0,7619,7621,3,1104,552,0,7620,7618,1,0,0,0,7621,
        7624,1,0,0,0,7622,7620,1,0,0,0,7622,7623,1,0,0,0,7623,7626,1,0,0,
        0,7624,7622,1,0,0,0,7625,7616,1,0,0,0,7625,7626,1,0,0,0,7626,1103,
        1,0,0,0,7627,7628,3,1098,549,0,7628,7629,5,6,0,0,7629,7630,3,1092,
        546,0,7630,1105,1,0,0,0,7631,7632,5,405,0,0,7632,7633,3,1408,704,
        0,7633,1107,1,0,0,0,7634,7635,5,109,0,0,7635,7636,3,1408,704,0,7636,
        1109,1,0,0,0,7637,7642,5,221,0,0,7638,7640,5,387,0,0,7639,7638,1,
        0,0,0,7639,7640,1,0,0,0,7640,7641,1,0,0,0,7641,7643,5,235,0,0,7642,
        7639,1,0,0,0,7642,7643,1,0,0,0,7643,7644,1,0,0,0,7644,7645,3,1408,
        704,0,7645,7646,5,279,0,0,7646,7647,3,1410,705,0,7647,1111,1,0,0,
        0,7648,7649,5,67,0,0,7649,7662,3,912,456,0,7650,7651,5,206,0,0,7651,
        7652,3,912,456,0,7652,7655,3,1014,507,0,7653,7654,5,552,0,0,7654,
        7656,3,912,456,0,7655,7653,1,0,0,0,7655,7656,1,0,0,0,7656,7659,1,
        0,0,0,7657,7658,5,196,0,0,7658,7660,3,912,456,0,7659,7657,1,0,0,
        0,7659,7660,1,0,0,0,7660,7662,1,0,0,0,7661,7648,1,0,0,0,7661,7650,
        1,0,0,0,7662,1113,1,0,0,0,7663,7664,3,1322,661,0,7664,7666,3,1126,
        563,0,7665,7667,3,1116,558,0,7666,7665,1,0,0,0,7666,7667,1,0,0,0,
        7667,1115,1,0,0,0,7668,7669,4,558,102,0,7669,7672,3,1118,559,0,7670,
        7672,3,1140,570,0,7671,7668,1,0,0,0,7671,7670,1,0,0,0,7672,1117,
        1,0,0,0,7673,7674,5,105,0,0,7674,7675,3,1020,510,0,7675,1119,1,0,
        0,0,7676,7678,4,560,103,0,7677,7679,5,390,0,0,7678,7677,1,0,0,0,
        7678,7679,1,0,0,0,7679,7680,1,0,0,0,7680,7681,5,738,0,0,7681,1121,
        1,0,0,0,7682,7684,7,41,0,0,7683,7685,3,122,61,0,7684,7683,1,0,0,
        0,7684,7685,1,0,0,0,7685,7686,1,0,0,0,7686,7690,3,1148,574,0,7687,
        7689,3,1154,577,0,7688,7687,1,0,0,0,7689,7692,1,0,0,0,7690,7688,
        1,0,0,0,7690,7691,1,0,0,0,7691,7757,1,0,0,0,7692,7690,1,0,0,0,7693,
        7695,5,237,0,0,7694,7696,3,442,221,0,7695,7694,1,0,0,0,7695,7696,
        1,0,0,0,7696,7698,1,0,0,0,7697,7699,3,1332,666,0,7698,7697,1,0,0,
        0,7698,7699,1,0,0,0,7699,7700,1,0,0,0,7700,7704,3,1148,574,0,7701,
        7703,3,1162,581,0,7702,7701,1,0,0,0,7703,7706,1,0,0,0,7704,7702,
        1,0,0,0,7704,7705,1,0,0,0,7705,7757,1,0,0,0,7706,7704,1,0,0,0,7707,
        7709,5,534,0,0,7708,7710,3,442,221,0,7709,7708,1,0,0,0,7709,7710,
        1,0,0,0,7710,7712,1,0,0,0,7711,7713,3,1332,666,0,7712,7711,1,0,0,
        0,7712,7713,1,0,0,0,7713,7714,1,0,0,0,7714,7718,3,1148,574,0,7715,
        7717,3,1164,582,0,7716,7715,1,0,0,0,7717,7720,1,0,0,0,7718,7716,
        1,0,0,0,7718,7719,1,0,0,0,7719,7757,1,0,0,0,7720,7718,1,0,0,0,7721,
        7723,3,1124,562,0,7722,7721,1,0,0,0,7722,7723,1,0,0,0,7723,7754,
        1,0,0,0,7724,7725,5,438,0,0,7725,7731,5,295,0,0,7726,7728,5,618,
        0,0,7727,7729,3,442,221,0,7728,7727,1,0,0,0,7728,7729,1,0,0,0,7729,
        7731,1,0,0,0,7730,7724,1,0,0,0,7730,7726,1,0,0,0,7731,7733,1,0,0,
        0,7732,7734,3,122,61,0,7733,7732,1,0,0,0,7733,7734,1,0,0,0,7734,
        7735,1,0,0,0,7735,7739,3,1148,574,0,7736,7738,3,1154,577,0,7737,
        7736,1,0,0,0,7738,7741,1,0,0,0,7739,7737,1,0,0,0,7739,7740,1,0,0,
        0,7740,7755,1,0,0,0,7741,7739,1,0,0,0,7742,7743,5,231,0,0,7743,7745,
        5,295,0,0,7744,7746,3,1332,666,0,7745,7744,1,0,0,0,7745,7746,1,0,
        0,0,7746,7747,1,0,0,0,7747,7748,3,1144,572,0,7748,7749,3,1140,570,
        0,7749,7755,1,0,0,0,7750,7752,3,1118,559,0,7751,7753,3,1120,560,
        0,7752,7751,1,0,0,0,7752,7753,1,0,0,0,7753,7755,1,0,0,0,7754,7730,
        1,0,0,0,7754,7742,1,0,0,0,7754,7750,1,0,0,0,7755,7757,1,0,0,0,7756,
        7682,1,0,0,0,7756,7693,1,0,0,0,7756,7707,1,0,0,0,7756,7722,1,0,0,
        0,7757,1123,1,0,0,0,7758,7760,5,129,0,0,7759,7761,3,1408,704,0,7760,
        7759,1,0,0,0,7760,7761,1,0,0,0,7761,1125,1,0,0,0,7762,7787,3,1168,
        584,0,7763,7765,3,1128,564,0,7764,7763,1,0,0,0,7765,7768,1,0,0,0,
        7766,7764,1,0,0,0,7766,7767,1,0,0,0,7767,7788,1,0,0,0,7768,7766,
        1,0,0,0,7769,7771,3,1250,625,0,7770,7769,1,0,0,0,7770,7771,1,0,0,
        0,7771,7774,1,0,0,0,7772,7773,5,241,0,0,7773,7775,5,59,0,0,7774,
        7772,1,0,0,0,7774,7775,1,0,0,0,7775,7776,1,0,0,0,7776,7777,5,63,
        0,0,7777,7779,3,1020,510,0,7778,7780,7,133,0,0,7779,7778,1,0,0,0,
        7779,7780,1,0,0,0,7780,7784,1,0,0,0,7781,7783,3,1128,564,0,7782,
        7781,1,0,0,0,7783,7786,1,0,0,0,7784,7782,1,0,0,0,7784,7785,1,0,0,
        0,7785,7788,1,0,0,0,7786,7784,1,0,0,0,7787,7766,1,0,0,0,7787,7770,
        1,0,0,0,7788,1127,1,0,0,0,7789,7791,5,390,0,0,7790,7789,1,0,0,0,
        7790,7791,1,0,0,0,7791,7792,1,0,0,0,7792,7851,3,1456,728,0,7793,
        7794,4,564,104,0,7794,7795,5,390,0,0,7795,7851,5,728,0,0,7796,7800,
        5,166,0,0,7797,7801,3,1136,568,0,7798,7799,4,564,105,0,7799,7801,
        3,1020,510,0,7800,7797,1,0,0,0,7800,7798,1,0,0,0,7801,7851,1,0,0,
        0,7802,7803,5,401,0,0,7803,7804,5,623,0,0,7804,7806,5,391,0,0,7805,
        7807,3,968,484,0,7806,7805,1,0,0,0,7806,7807,1,0,0,0,7807,7851,1,
        0,0,0,7808,7851,5,69,0,0,7809,7810,5,515,0,0,7810,7811,5,166,0,0,
        7811,7851,5,636,0,0,7812,7814,5,438,0,0,7813,7812,1,0,0,0,7813,7814,
        1,0,0,0,7814,7815,1,0,0,0,7815,7851,5,295,0,0,7816,7818,5,618,0,
        0,7817,7819,5,295,0,0,7818,7817,1,0,0,0,7818,7819,1,0,0,0,7819,7851,
        1,0,0,0,7820,7821,5,118,0,0,7821,7851,3,1446,723,0,7822,7851,3,1250,
        625,0,7823,7824,5,117,0,0,7824,7851,3,1130,565,0,7825,7826,5,563,
        0,0,7826,7851,3,1132,566,0,7827,7828,5,715,0,0,7828,7851,3,1426,
        713,0,7829,7831,4,564,106,0,7830,7832,3,1124,562,0,7831,7830,1,0,
        0,0,7831,7832,1,0,0,0,7832,7833,1,0,0,0,7833,7851,3,1118,559,0,7834,
        7835,4,564,107,0,7835,7851,3,1120,560,0,7836,7837,4,564,108,0,7837,
        7839,5,757,0,0,7838,7840,5,6,0,0,7839,7838,1,0,0,0,7839,7840,1,0,
        0,0,7840,7841,1,0,0,0,7841,7851,3,1486,743,0,7842,7843,4,564,109,
        0,7843,7845,5,758,0,0,7844,7846,5,6,0,0,7845,7844,1,0,0,0,7845,7846,
        1,0,0,0,7846,7847,1,0,0,0,7847,7851,3,1486,743,0,7848,7849,4,564,
        110,0,7849,7851,3,1158,579,0,7850,7790,1,0,0,0,7850,7793,1,0,0,0,
        7850,7796,1,0,0,0,7850,7802,1,0,0,0,7850,7808,1,0,0,0,7850,7809,
        1,0,0,0,7850,7813,1,0,0,0,7850,7816,1,0,0,0,7850,7820,1,0,0,0,7850,
        7822,1,0,0,0,7850,7823,1,0,0,0,7850,7825,1,0,0,0,7850,7827,1,0,0,
        0,7850,7829,1,0,0,0,7850,7834,1,0,0,0,7850,7836,1,0,0,0,7850,7842,
        1,0,0,0,7850,7848,1,0,0,0,7851,1129,1,0,0,0,7852,7853,7,134,0,0,
        7853,1131,1,0,0,0,7854,7855,7,135,0,0,7855,1133,1,0,0,0,7856,7857,
        5,391,0,0,7857,7858,3,1188,594,0,7858,1135,1,0,0,0,7859,7862,3,1134,
        567,0,7860,7862,3,1430,715,0,7861,7859,1,0,0,0,7861,7860,1,0,0,0,
        7862,1137,1,0,0,0,7863,7865,5,618,0,0,7864,7866,5,295,0,0,7865,7864,
        1,0,0,0,7865,7866,1,0,0,0,7866,7878,1,0,0,0,7867,7868,5,118,0,0,
        7868,7878,3,1442,721,0,7869,7871,3,1010,505,0,7870,7869,1,0,0,0,
        7870,7871,1,0,0,0,7871,7872,1,0,0,0,7872,7878,5,395,0,0,7873,7875,
        5,438,0,0,7874,7873,1,0,0,0,7874,7875,1,0,0,0,7875,7876,1,0,0,0,
        7876,7878,5,295,0,0,7877,7863,1,0,0,0,7877,7867,1,0,0,0,7877,7870,
        1,0,0,0,7877,7874,1,0,0,0,7878,1139,1,0,0,0,7879,7880,5,460,0,0,
        7880,7882,3,1384,692,0,7881,7883,3,1412,706,0,7882,7881,1,0,0,0,
        7882,7883,1,0,0,0,7883,7886,1,0,0,0,7884,7885,5,345,0,0,7885,7887,
        7,136,0,0,7886,7884,1,0,0,0,7886,7887,1,0,0,0,7887,7904,1,0,0,0,
        7888,7889,5,401,0,0,7889,7890,5,623,0,0,7890,7894,3,1142,571,0,7891,
        7892,5,401,0,0,7892,7893,5,171,0,0,7893,7895,3,1142,571,0,7894,7891,
        1,0,0,0,7894,7895,1,0,0,0,7895,7905,1,0,0,0,7896,7897,5,401,0,0,
        7897,7898,5,171,0,0,7898,7902,3,1142,571,0,7899,7900,5,401,0,0,7900,
        7901,5,623,0,0,7901,7903,3,1142,571,0,7902,7899,1,0,0,0,7902,7903,
        1,0,0,0,7903,7905,1,0,0,0,7904,7888,1,0,0,0,7904,7896,1,0,0,0,7904,
        7905,1,0,0,0,7905,1141,1,0,0,0,7906,7914,7,2,0,0,7907,7908,5,519,
        0,0,7908,7914,3,1456,728,0,7909,7910,5,519,0,0,7910,7914,5,166,0,
        0,7911,7912,5,392,0,0,7912,7914,5,50,0,0,7913,7906,1,0,0,0,7913,
        7907,1,0,0,0,7913,7909,1,0,0,0,7913,7911,1,0,0,0,7914,1143,1,0,0,
        0,7915,7916,5,32,0,0,7916,7921,3,1146,573,0,7917,7918,5,29,0,0,7918,
        7920,3,1146,573,0,7919,7917,1,0,0,0,7920,7923,1,0,0,0,7921,7919,
        1,0,0,0,7921,7922,1,0,0,0,7922,7924,1,0,0,0,7923,7921,1,0,0,0,7924,
        7925,5,33,0,0,7925,1145,1,0,0,0,7926,7928,3,1408,704,0,7927,7929,
        3,1174,587,0,7928,7927,1,0,0,0,7928,7929,1,0,0,0,7929,7931,1,0,0,
        0,7930,7932,3,364,182,0,7931,7930,1,0,0,0,7931,7932,1,0,0,0,7932,
        1147,1,0,0,0,7933,7934,5,32,0,0,7934,7939,3,1150,575,0,7935,7936,
        5,29,0,0,7936,7938,3,1150,575,0,7937,7935,1,0,0,0,7938,7941,1,0,
        0,0,7939,7937,1,0,0,0,7939,7940,1,0,0,0,7940,7942,1,0,0,0,7941,7939,
        1,0,0,0,7942,7943,5,33,0,0,7943,1149,1,0,0,0,7944,7951,3,1146,573,
        0,7945,7946,4,575,111,0,7946,7948,3,1020,510,0,7947,7949,3,364,182,
        0,7948,7947,1,0,0,0,7948,7949,1,0,0,0,7949,7951,1,0,0,0,7950,7944,
        1,0,0,0,7950,7945,1,0,0,0,7951,1151,1,0,0,0,7952,7953,7,137,0,0,
        7953,1153,1,0,0,0,7954,7957,3,1156,578,0,7955,7957,3,1160,580,0,
        7956,7954,1,0,0,0,7956,7955,1,0,0,0,7957,1155,1,0,0,0,7958,7960,
        5,294,0,0,7959,7961,5,6,0,0,7960,7959,1,0,0,0,7960,7961,1,0,0,0,
        7961,7962,1,0,0,0,7962,7979,3,1420,710,0,7963,7964,5,118,0,0,7964,
        7979,3,1446,723,0,7965,7979,3,1158,579,0,7966,7967,4,578,112,0,7967,
        7969,5,757,0,0,7968,7970,5,6,0,0,7969,7968,1,0,0,0,7969,7970,1,0,
        0,0,7970,7971,1,0,0,0,7971,7979,3,1486,743,0,7972,7973,4,578,113,
        0,7973,7975,5,758,0,0,7974,7976,5,6,0,0,7975,7974,1,0,0,0,7975,7976,
        1,0,0,0,7976,7977,1,0,0,0,7977,7979,3,1486,743,0,7978,7958,1,0,0,
        0,7978,7963,1,0,0,0,7978,7965,1,0,0,0,7978,7966,1,0,0,0,7978,7972,
        1,0,0,0,7979,1157,1,0,0,0,7980,7981,7,138,0,0,7981,1159,1,0,0,0,
        7982,7983,7,139,0,0,7983,7984,3,1152,576,0,7984,1161,1,0,0,0,7985,
        7990,3,1156,578,0,7986,7987,5,653,0,0,7987,7988,5,419,0,0,7988,7990,
        3,1408,704,0,7989,7985,1,0,0,0,7989,7986,1,0,0,0,7990,1163,1,0,0,
        0,7991,7992,3,1156,578,0,7992,1165,1,0,0,0,7993,7994,3,1168,584,
        0,7994,7995,5,0,0,1,7995,1167,1,0,0,0,7996,7998,7,140,0,0,7997,7999,
        3,1174,587,0,7998,7997,1,0,0,0,7998,7999,1,0,0,0,7999,8001,1,0,0,
        0,8000,8002,3,1176,588,0,8001,8000,1,0,0,0,8001,8002,1,0,0,0,8002,
        8143,1,0,0,0,8003,8009,5,455,0,0,8004,8006,5,182,0,0,8005,8007,5,
        434,0,0,8006,8005,1,0,0,0,8006,8007,1,0,0,0,8007,8009,1,0,0,0,8008,
        8003,1,0,0,0,8008,8004,1,0,0,0,8009,8011,1,0,0,0,8010,8012,3,1466,
        733,0,8011,8010,1,0,0,0,8011,8012,1,0,0,0,8012,8014,1,0,0,0,8013,
        8015,3,1176,588,0,8014,8013,1,0,0,0,8014,8015,1,0,0,0,8015,8143,
        1,0,0,0,8016,8018,7,141,0,0,8017,8019,3,1462,731,0,8018,8017,1,0,
        0,0,8018,8019,1,0,0,0,8019,8021,1,0,0,0,8020,8022,3,1176,588,0,8021,
        8020,1,0,0,0,8021,8022,1,0,0,0,8022,8143,1,0,0,0,8023,8025,5,81,
        0,0,8024,8026,3,1174,587,0,8025,8024,1,0,0,0,8025,8026,1,0,0,0,8026,
        8143,1,0,0,0,8027,8143,7,142,0,0,8028,8030,5,103,0,0,8029,8031,3,
        1174,587,0,8030,8029,1,0,0,0,8030,8031,1,0,0,0,8031,8033,1,0,0,0,
        8032,8034,3,1178,589,0,8033,8032,1,0,0,0,8033,8034,1,0,0,0,8034,
        8143,1,0,0,0,8035,8037,3,1170,585,0,8036,8038,3,1174,587,0,8037,
        8036,1,0,0,0,8037,8038,1,0,0,0,8038,8040,1,0,0,0,8039,8041,5,77,
        0,0,8040,8039,1,0,0,0,8040,8041,1,0,0,0,8041,8143,1,0,0,0,8042,8044,
        5,77,0,0,8043,8045,3,1174,587,0,8044,8043,1,0,0,0,8044,8045,1,0,
        0,0,8045,8143,1,0,0,0,8046,8047,5,103,0,0,8047,8050,5,641,0,0,8048,
        8050,5,638,0,0,8049,8046,1,0,0,0,8049,8048,1,0,0,0,8050,8051,1,0,
        0,0,8051,8053,3,1174,587,0,8052,8054,3,1178,589,0,8053,8052,1,0,
        0,0,8053,8054,1,0,0,0,8054,8143,1,0,0,0,8055,8056,5,381,0,0,8056,
        8066,5,638,0,0,8057,8066,5,398,0,0,8058,8059,5,383,0,0,8059,8066,
        5,638,0,0,8060,8061,5,381,0,0,8061,8062,5,103,0,0,8062,8066,5,641,
        0,0,8063,8064,5,383,0,0,8064,8066,5,641,0,0,8065,8055,1,0,0,0,8065,
        8057,1,0,0,0,8065,8058,1,0,0,0,8065,8060,1,0,0,0,8065,8063,1,0,0,
        0,8066,8067,1,0,0,0,8067,8069,3,1174,587,0,8068,8070,5,77,0,0,8069,
        8068,1,0,0,0,8069,8070,1,0,0,0,8070,8143,1,0,0,0,8071,8072,5,637,
        0,0,8072,8143,3,1174,587,0,8073,8075,5,664,0,0,8074,8076,3,1174,
        587,0,8075,8074,1,0,0,0,8075,8076,1,0,0,0,8076,8078,1,0,0,0,8077,
        8079,3,1176,588,0,8078,8077,1,0,0,0,8078,8079,1,0,0,0,8079,8143,
        1,0,0,0,8080,8143,5,157,0,0,8081,8083,5,595,0,0,8082,8084,3,1186,
        593,0,8083,8082,1,0,0,0,8083,8084,1,0,0,0,8084,8143,1,0,0,0,8085,
        8087,5,592,0,0,8086,8088,3,1186,593,0,8087,8086,1,0,0,0,8087,8088,
        1,0,0,0,8088,8143,1,0,0,0,8089,8091,5,154,0,0,8090,8092,3,1186,593,
        0,8091,8090,1,0,0,0,8091,8092,1,0,0,0,8092,8143,1,0,0,0,8093,8143,
        5,596,0,0,8094,8096,5,83,0,0,8095,8097,3,1174,587,0,8096,8095,1,
        0,0,0,8096,8097,1,0,0,0,8097,8143,1,0,0,0,8098,8143,7,143,0,0,8099,
        8100,5,319,0,0,8100,8143,5,637,0,0,8101,8105,5,319,0,0,8102,8103,
        5,103,0,0,8103,8106,5,641,0,0,8104,8106,5,638,0,0,8105,8102,1,0,
        0,0,8105,8104,1,0,0,0,8105,8106,1,0,0,0,8106,8108,1,0,0,0,8107,8109,
        3,1178,589,0,8108,8107,1,0,0,0,8108,8109,1,0,0,0,8109,8143,1,0,0,
        0,8110,8112,5,598,0,0,8111,8113,3,1178,589,0,8112,8111,1,0,0,0,8112,
        8113,1,0,0,0,8113,8143,1,0,0,0,8114,8116,5,589,0,0,8115,8117,3,1174,
        587,0,8116,8115,1,0,0,0,8116,8117,1,0,0,0,8117,8119,1,0,0,0,8118,
        8120,3,1178,589,0,8119,8118,1,0,0,0,8119,8120,1,0,0,0,8120,8143,
        1,0,0,0,8121,8123,5,356,0,0,8122,8124,3,1178,589,0,8123,8122,1,0,
        0,0,8123,8124,1,0,0,0,8124,8143,1,0,0,0,8125,8127,5,318,0,0,8126,
        8128,3,1178,589,0,8127,8126,1,0,0,0,8127,8128,1,0,0,0,8128,8143,
        1,0,0,0,8129,8130,5,199,0,0,8130,8132,3,1438,719,0,8131,8133,3,1178,
        589,0,8132,8131,1,0,0,0,8132,8133,1,0,0,0,8133,8143,1,0,0,0,8134,
        8135,5,519,0,0,8135,8137,3,1438,719,0,8136,8138,3,1178,589,0,8137,
        8136,1,0,0,0,8137,8138,1,0,0,0,8138,8143,1,0,0,0,8139,8143,5,515,
        0,0,8140,8143,5,292,0,0,8141,8143,7,144,0,0,8142,7996,1,0,0,0,8142,
        8008,1,0,0,0,8142,8016,1,0,0,0,8142,8023,1,0,0,0,8142,8027,1,0,0,
        0,8142,8028,1,0,0,0,8142,8035,1,0,0,0,8142,8042,1,0,0,0,8142,8049,
        1,0,0,0,8142,8065,1,0,0,0,8142,8071,1,0,0,0,8142,8073,1,0,0,0,8142,
        8080,1,0,0,0,8142,8081,1,0,0,0,8142,8085,1,0,0,0,8142,8089,1,0,0,
        0,8142,8093,1,0,0,0,8142,8094,1,0,0,0,8142,8098,1,0,0,0,8142,8099,
        1,0,0,0,8142,8101,1,0,0,0,8142,8110,1,0,0,0,8142,8114,1,0,0,0,8142,
        8121,1,0,0,0,8142,8125,1,0,0,0,8142,8129,1,0,0,0,8142,8134,1,0,0,
        0,8142,8139,1,0,0,0,8142,8140,1,0,0,0,8142,8141,1,0,0,0,8143,1169,
        1,0,0,0,8144,8148,5,383,0,0,8145,8146,5,381,0,0,8146,8148,5,103,
        0,0,8147,8144,1,0,0,0,8147,8145,1,0,0,0,8148,1171,1,0,0,0,8149,8155,
        5,455,0,0,8150,8152,5,182,0,0,8151,8153,5,434,0,0,8152,8151,1,0,
        0,0,8152,8153,1,0,0,0,8153,8155,1,0,0,0,8154,8149,1,0,0,0,8154,8150,
        1,0,0,0,8155,1173,1,0,0,0,8156,8159,5,32,0,0,8157,8160,3,1426,713,
        0,8158,8160,5,46,0,0,8159,8157,1,0,0,0,8159,8158,1,0,0,0,8160,8161,
        1,0,0,0,8161,8162,5,33,0,0,8162,1175,1,0,0,0,8163,8165,7,145,0,0,
        8164,8163,1,0,0,0,8165,8166,1,0,0,0,8166,8164,1,0,0,0,8166,8167,
        1,0,0,0,8167,1177,1,0,0,0,8168,8183,3,1180,590,0,8169,8183,3,1182,
        591,0,8170,8183,5,90,0,0,8171,8172,3,1008,504,0,8172,8174,3,1190,
        595,0,8173,8175,5,77,0,0,8174,8173,1,0,0,0,8174,8175,1,0,0,0,8175,
        8183,1,0,0,0,8176,8180,5,77,0,0,8177,8178,3,1008,504,0,8178,8179,
        3,1190,595,0,8179,8181,1,0,0,0,8180,8177,1,0,0,0,8180,8181,1,0,0,
        0,8181,8183,1,0,0,0,8182,8168,1,0,0,0,8182,8169,1,0,0,0,8182,8170,
        1,0,0,0,8182,8171,1,0,0,0,8182,8176,1,0,0,0,8183,1179,1,0,0,0,8184,
        8186,5,65,0,0,8185,8187,5,77,0,0,8186,8185,1,0,0,0,8186,8187,1,0,
        0,0,8187,8191,1,0,0,0,8188,8189,5,77,0,0,8189,8191,5,65,0,0,8190,
        8184,1,0,0,0,8190,8188,1,0,0,0,8191,1181,1,0,0,0,8192,8194,5,615,
        0,0,8193,8195,5,77,0,0,8194,8193,1,0,0,0,8194,8195,1,0,0,0,8195,
        8199,1,0,0,0,8196,8197,5,77,0,0,8197,8199,5,615,0,0,8198,8192,1,
        0,0,0,8198,8196,1,0,0,0,8199,1183,1,0,0,0,8200,8201,5,32,0,0,8201,
        8202,3,1422,711,0,8202,8203,5,33,0,0,8203,1185,1,0,0,0,8204,8205,
        5,32,0,0,8205,8206,5,3,0,0,8206,8207,5,33,0,0,8207,1187,1,0,0,0,
        8208,8214,1,0,0,0,8209,8214,3,1476,738,0,8210,8211,5,32,0,0,8211,
        8212,5,3,0,0,8212,8214,5,33,0,0,8213,8208,1,0,0,0,8213,8209,1,0,
        0,0,8213,8210,1,0,0,0,8214,1189,1,0,0,0,8215,8220,3,1468,734,0,8216,
        8220,5,77,0,0,8217,8218,4,595,114,0,8218,8220,5,166,0,0,8219,8215,
        1,0,0,0,8219,8216,1,0,0,0,8219,8217,1,0,0,0,8220,1191,1,0,0,0,8221,
        8227,3,1468,734,0,8222,8223,4,596,115,0,8223,8227,5,166,0,0,8224,
        8225,4,596,116,0,8225,8227,5,77,0,0,8226,8221,1,0,0,0,8226,8222,
        1,0,0,0,8226,8224,1,0,0,0,8227,1193,1,0,0,0,8228,8235,3,1202,601,
        0,8229,8231,5,29,0,0,8230,8229,1,0,0,0,8230,8231,1,0,0,0,8231,8232,
        1,0,0,0,8232,8234,3,1202,601,0,8233,8230,1,0,0,0,8234,8237,1,0,0,
        0,8235,8233,1,0,0,0,8235,8236,1,0,0,0,8236,1195,1,0,0,0,8237,8235,
        1,0,0,0,8238,8240,3,1194,597,0,8239,8241,3,1198,599,0,8240,8239,
        1,0,0,0,8240,8241,1,0,0,0,8241,8244,1,0,0,0,8242,8244,3,1198,599,
        0,8243,8238,1,0,0,0,8243,8242,1,0,0,0,8244,1197,1,0,0,0,8245,8247,
        3,1212,606,0,8246,8248,3,94,47,0,8247,8246,1,0,0,0,8247,8248,1,0,
        0,0,8248,8251,1,0,0,0,8249,8251,3,94,47,0,8250,8245,1,0,0,0,8250,
        8249,1,0,0,0,8251,1199,1,0,0,0,8252,8254,3,1202,601,0,8253,8252,
        1,0,0,0,8254,8255,1,0,0,0,8255,8253,1,0,0,0,8255,8256,1,0,0,0,8256,
        1201,1,0,0,0,8257,8259,5,198,0,0,8258,8260,5,6,0,0,8259,8258,1,0,
        0,0,8259,8260,1,0,0,0,8260,8261,1,0,0,0,8261,8398,3,1376,688,0,8262,
        8263,4,601,117,0,8263,8265,5,729,0,0,8264,8266,3,1478,739,0,8265,
        8264,1,0,0,0,8265,8266,1,0,0,0,8266,8269,1,0,0,0,8267,8270,5,395,
        0,0,8268,8270,3,1468,734,0,8269,8267,1,0,0,0,8269,8268,1,0,0,0,8270,
        8398,1,0,0,0,8271,8273,5,348,0,0,8272,8274,5,6,0,0,8273,8272,1,0,
        0,0,8273,8274,1,0,0,0,8274,8275,1,0,0,0,8275,8398,3,1424,712,0,8276,
        8278,5,367,0,0,8277,8279,5,6,0,0,8278,8277,1,0,0,0,8278,8279,1,0,
        0,0,8279,8280,1,0,0,0,8280,8398,3,1424,712,0,8281,8283,5,70,0,0,
        8282,8284,5,6,0,0,8283,8282,1,0,0,0,8283,8284,1,0,0,0,8284,8285,
        1,0,0,0,8285,8398,3,1424,712,0,8286,8288,5,424,0,0,8287,8289,5,6,
        0,0,8288,8287,1,0,0,0,8288,8289,1,0,0,0,8289,8290,1,0,0,0,8290,8398,
        3,1440,720,0,8291,8293,5,118,0,0,8292,8294,5,6,0,0,8293,8292,1,0,
        0,0,8293,8294,1,0,0,0,8294,8295,1,0,0,0,8295,8398,3,1440,720,0,8296,
        8298,5,124,0,0,8297,8299,5,6,0,0,8298,8297,1,0,0,0,8298,8299,1,0,
        0,0,8299,8300,1,0,0,0,8300,8398,3,1442,721,0,8301,8303,5,194,0,0,
        8302,8304,5,6,0,0,8303,8302,1,0,0,0,8303,8304,1,0,0,0,8304,8305,
        1,0,0,0,8305,8398,3,1442,721,0,8306,8308,5,69,0,0,8307,8309,5,6,
        0,0,8308,8307,1,0,0,0,8308,8309,1,0,0,0,8309,8310,1,0,0,0,8310,8398,
        3,1424,712,0,8311,8313,5,417,0,0,8312,8314,5,6,0,0,8313,8312,1,0,
        0,0,8313,8314,1,0,0,0,8314,8315,1,0,0,0,8315,8398,3,1204,602,0,8316,
        8318,7,146,0,0,8317,8319,5,6,0,0,8318,8317,1,0,0,0,8318,8319,1,0,
        0,0,8319,8320,1,0,0,0,8320,8398,3,1204,602,0,8321,8323,7,147,0,0,
        8322,8324,5,6,0,0,8323,8322,1,0,0,0,8323,8324,1,0,0,0,8324,8325,
        1,0,0,0,8325,8398,3,1420,710,0,8326,8328,5,170,0,0,8327,8329,5,6,
        0,0,8328,8327,1,0,0,0,8328,8329,1,0,0,0,8329,8330,1,0,0,0,8330,8398,
        3,1420,710,0,8331,8333,5,502,0,0,8332,8334,5,6,0,0,8333,8332,1,0,
        0,0,8333,8334,1,0,0,0,8334,8335,1,0,0,0,8335,8398,7,148,0,0,8336,
        8338,5,617,0,0,8337,8339,5,6,0,0,8338,8337,1,0,0,0,8338,8339,1,0,
        0,0,8339,8340,1,0,0,0,8340,8341,5,32,0,0,8341,8342,3,1386,693,0,
        8342,8343,5,33,0,0,8343,8398,1,0,0,0,8344,8398,3,1210,605,0,8345,
        8398,3,1206,603,0,8346,8348,5,275,0,0,8347,8349,5,6,0,0,8348,8347,
        1,0,0,0,8348,8349,1,0,0,0,8349,8350,1,0,0,0,8350,8398,7,149,0,0,
        8351,8352,5,153,0,0,8352,8354,5,176,0,0,8353,8355,5,6,0,0,8354,8353,
        1,0,0,0,8354,8355,1,0,0,0,8355,8356,1,0,0,0,8356,8398,3,1442,721,
        0,8357,8358,5,268,0,0,8358,8360,5,176,0,0,8359,8361,5,6,0,0,8360,
        8359,1,0,0,0,8360,8361,1,0,0,0,8361,8362,1,0,0,0,8362,8398,3,1442,
        721,0,8363,8365,5,582,0,0,8364,8366,5,6,0,0,8365,8364,1,0,0,0,8365,
        8366,1,0,0,0,8366,8367,1,0,0,0,8367,8398,3,1408,704,0,8368,8369,
        5,563,0,0,8369,8398,7,150,0,0,8370,8372,5,127,0,0,8371,8373,5,6,
        0,0,8372,8371,1,0,0,0,8372,8373,1,0,0,0,8373,8374,1,0,0,0,8374,8398,
        3,1442,721,0,8375,8377,5,294,0,0,8376,8378,5,6,0,0,8377,8376,1,0,
        0,0,8377,8378,1,0,0,0,8378,8379,1,0,0,0,8379,8398,3,1424,712,0,8380,
        8381,4,601,118,0,8381,8382,5,553,0,0,8382,8398,5,601,0,0,8383,8384,
        4,601,119,0,8384,8386,5,757,0,0,8385,8387,5,6,0,0,8386,8385,1,0,
        0,0,8386,8387,1,0,0,0,8387,8388,1,0,0,0,8388,8398,3,1486,743,0,8389,
        8390,4,601,120,0,8390,8392,5,758,0,0,8391,8393,5,6,0,0,8392,8391,
        1,0,0,0,8392,8393,1,0,0,0,8393,8394,1,0,0,0,8394,8398,3,1486,743,
        0,8395,8396,4,601,121,0,8396,8398,3,154,77,0,8397,8257,1,0,0,0,8397,
        8262,1,0,0,0,8397,8271,1,0,0,0,8397,8276,1,0,0,0,8397,8281,1,0,0,
        0,8397,8286,1,0,0,0,8397,8291,1,0,0,0,8397,8296,1,0,0,0,8397,8301,
        1,0,0,0,8397,8306,1,0,0,0,8397,8311,1,0,0,0,8397,8316,1,0,0,0,8397,
        8321,1,0,0,0,8397,8326,1,0,0,0,8397,8331,1,0,0,0,8397,8336,1,0,0,
        0,8397,8344,1,0,0,0,8397,8345,1,0,0,0,8397,8346,1,0,0,0,8397,8351,
        1,0,0,0,8397,8357,1,0,0,0,8397,8363,1,0,0,0,8397,8368,1,0,0,0,8397,
        8370,1,0,0,0,8397,8375,1,0,0,0,8397,8380,1,0,0,0,8397,8383,1,0,0,
        0,8397,8389,1,0,0,0,8397,8395,1,0,0,0,8398,1203,1,0,0,0,8399,8402,
        3,1420,710,0,8400,8402,5,166,0,0,8401,8399,1,0,0,0,8401,8400,1,0,
        0,0,8402,1205,1,0,0,0,8403,8405,5,166,0,0,8404,8403,1,0,0,0,8404,
        8405,1,0,0,0,8405,8406,1,0,0,0,8406,8408,5,112,0,0,8407,8409,5,6,
        0,0,8408,8407,1,0,0,0,8408,8409,1,0,0,0,8409,8410,1,0,0,0,8410,8411,
        3,1192,596,0,8411,1207,1,0,0,0,8412,8414,5,166,0,0,8413,8412,1,0,
        0,0,8413,8414,1,0,0,0,8414,8415,1,0,0,0,8415,8417,5,194,0,0,8416,
        8418,5,6,0,0,8417,8416,1,0,0,0,8417,8418,1,0,0,0,8418,8419,1,0,0,
        0,8419,8420,3,1440,720,0,8420,1209,1,0,0,0,8421,8423,5,166,0,0,8422,
        8421,1,0,0,0,8422,8423,1,0,0,0,8423,8424,1,0,0,0,8424,8426,3,1008,
        504,0,8425,8427,5,6,0,0,8426,8425,1,0,0,0,8426,8427,1,0,0,0,8427,
        8428,1,0,0,0,8428,8429,3,1190,595,0,8429,1211,1,0,0,0,8430,8431,
        5,423,0,0,8431,8432,5,89,0,0,8432,8435,3,1214,607,0,8433,8434,5,
        422,0,0,8434,8436,3,1422,711,0,8435,8433,1,0,0,0,8435,8436,1,0,0,
        0,8436,8438,1,0,0,0,8437,8439,3,1216,608,0,8438,8437,1,0,0,0,8438,
        8439,1,0,0,0,8439,8441,1,0,0,0,8440,8442,3,1220,610,0,8441,8440,
        1,0,0,0,8441,8442,1,0,0,0,8442,1213,1,0,0,0,8443,8445,5,307,0,0,
        8444,8443,1,0,0,0,8444,8445,1,0,0,0,8445,8446,1,0,0,0,8446,8448,
        5,295,0,0,8447,8449,3,1218,609,0,8448,8447,1,0,0,0,8448,8449,1,0,
        0,0,8449,8450,1,0,0,0,8450,8452,5,32,0,0,8451,8453,3,1410,705,0,
        8452,8451,1,0,0,0,8452,8453,1,0,0,0,8453,8454,1,0,0,0,8454,8477,
        5,33,0,0,8455,8457,5,307,0,0,8456,8455,1,0,0,0,8456,8457,1,0,0,0,
        8457,8458,1,0,0,0,8458,8459,5,252,0,0,8459,8460,5,32,0,0,8460,8461,
        3,922,461,0,8461,8462,5,33,0,0,8462,8477,1,0,0,0,8463,8474,7,151,
        0,0,8464,8465,5,32,0,0,8465,8466,3,922,461,0,8466,8467,5,33,0,0,
        8467,8475,1,0,0,0,8468,8469,5,114,0,0,8469,8471,5,32,0,0,8470,8472,
        3,1410,705,0,8471,8470,1,0,0,0,8471,8472,1,0,0,0,8472,8473,1,0,0,
        0,8473,8475,5,33,0,0,8474,8464,1,0,0,0,8474,8468,1,0,0,0,8475,8477,
        1,0,0,0,8476,8444,1,0,0,0,8476,8456,1,0,0,0,8476,8463,1,0,0,0,8477,
        1215,1,0,0,0,8478,8479,5,571,0,0,8479,8481,5,89,0,0,8480,8482,5,
        307,0,0,8481,8480,1,0,0,0,8481,8482,1,0,0,0,8482,8493,1,0,0,0,8483,
        8484,5,252,0,0,8484,8485,5,32,0,0,8485,8486,3,922,461,0,8486,8487,
        5,33,0,0,8487,8494,1,0,0,0,8488,8490,5,295,0,0,8489,8491,3,1218,
        609,0,8490,8489,1,0,0,0,8490,8491,1,0,0,0,8491,8492,1,0,0,0,8492,
        8494,3,1412,706,0,8493,8483,1,0,0,0,8493,8488,1,0,0,0,8494,8497,
        1,0,0,0,8495,8496,5,570,0,0,8496,8498,3,1422,711,0,8497,8495,1,0,
        0,0,8497,8498,1,0,0,0,8498,1217,1,0,0,0,8499,8500,5,56,0,0,8500,
        8501,5,6,0,0,8501,8502,3,1422,711,0,8502,1219,1,0,0,0,8503,8504,
        5,32,0,0,8504,8509,3,1222,611,0,8505,8506,5,29,0,0,8506,8508,3,1222,
        611,0,8507,8505,1,0,0,0,8508,8511,1,0,0,0,8509,8507,1,0,0,0,8509,
        8510,1,0,0,0,8510,8512,1,0,0,0,8511,8509,1,0,0,0,8512,8513,5,33,
        0,0,8513,1221,1,0,0,0,8514,8515,5,423,0,0,8515,8526,3,1408,704,0,
        8516,8517,5,635,0,0,8517,8518,5,303,0,0,8518,8521,5,590,0,0,8519,
        8522,3,1230,615,0,8520,8522,5,353,0,0,8521,8519,1,0,0,0,8521,8520,
        1,0,0,0,8522,8527,1,0,0,0,8523,8524,5,635,0,0,8524,8525,5,282,0,
        0,8525,8527,3,1224,612,0,8526,8516,1,0,0,0,8526,8523,1,0,0,0,8526,
        8527,1,0,0,0,8527,8531,1,0,0,0,8528,8530,3,1226,613,0,8529,8528,
        1,0,0,0,8530,8533,1,0,0,0,8531,8529,1,0,0,0,8531,8532,1,0,0,0,8532,
        8545,1,0,0,0,8533,8531,1,0,0,0,8534,8535,5,32,0,0,8535,8540,3,1228,
        614,0,8536,8537,5,29,0,0,8537,8539,3,1228,614,0,8538,8536,1,0,0,
        0,8539,8542,1,0,0,0,8540,8538,1,0,0,0,8540,8541,1,0,0,0,8541,8543,
        1,0,0,0,8542,8540,1,0,0,0,8543,8544,5,33,0,0,8544,8546,1,0,0,0,8545,
        8534,1,0,0,0,8545,8546,1,0,0,0,8546,1223,1,0,0,0,8547,8560,3,1230,
        615,0,8548,8549,5,32,0,0,8549,8554,3,1230,615,0,8550,8551,5,29,0,
        0,8551,8553,3,1230,615,0,8552,8550,1,0,0,0,8553,8556,1,0,0,0,8554,
        8552,1,0,0,0,8554,8555,1,0,0,0,8555,8557,1,0,0,0,8556,8554,1,0,0,
        0,8557,8558,5,33,0,0,8558,8560,1,0,0,0,8559,8547,1,0,0,0,8559,8548,
        1,0,0,0,8560,1225,1,0,0,0,8561,8563,5,582,0,0,8562,8564,5,6,0,0,
        8563,8562,1,0,0,0,8563,8564,1,0,0,0,8564,8565,1,0,0,0,8565,8596,
        3,1408,704,0,8566,8568,5,563,0,0,8567,8566,1,0,0,0,8567,8568,1,0,
        0,0,8568,8569,1,0,0,0,8569,8571,5,198,0,0,8570,8572,5,6,0,0,8571,
        8570,1,0,0,0,8571,8572,1,0,0,0,8572,8573,1,0,0,0,8573,8596,3,1376,
        688,0,8574,8576,5,388,0,0,8575,8577,5,6,0,0,8576,8575,1,0,0,0,8576,
        8577,1,0,0,0,8577,8578,1,0,0,0,8578,8596,3,1422,711,0,8579,8581,
        7,152,0,0,8580,8582,5,6,0,0,8581,8580,1,0,0,0,8581,8582,1,0,0,0,
        8582,8583,1,0,0,0,8583,8596,3,1422,711,0,8584,8585,7,153,0,0,8585,
        8587,5,176,0,0,8586,8588,5,6,0,0,8587,8586,1,0,0,0,8587,8588,1,0,
        0,0,8588,8589,1,0,0,0,8589,8596,3,1446,723,0,8590,8592,5,118,0,0,
        8591,8593,5,6,0,0,8592,8591,1,0,0,0,8592,8593,1,0,0,0,8593,8594,
        1,0,0,0,8594,8596,3,1446,723,0,8595,8561,1,0,0,0,8595,8567,1,0,0,
        0,8595,8574,1,0,0,0,8595,8579,1,0,0,0,8595,8584,1,0,0,0,8595,8590,
        1,0,0,0,8596,1227,1,0,0,0,8597,8598,5,571,0,0,8598,8602,3,1468,734,
        0,8599,8601,3,1226,613,0,8600,8599,1,0,0,0,8601,8604,1,0,0,0,8602,
        8600,1,0,0,0,8602,8603,1,0,0,0,8603,1229,1,0,0,0,8604,8602,1,0,0,
        0,8605,8606,5,32,0,0,8606,8611,3,1232,616,0,8607,8608,5,29,0,0,8608,
        8610,3,1232,616,0,8609,8607,1,0,0,0,8610,8613,1,0,0,0,8611,8609,
        1,0,0,0,8611,8612,1,0,0,0,8612,8614,1,0,0,0,8613,8611,1,0,0,0,8614,
        8615,5,33,0,0,8615,1231,1,0,0,0,8616,8619,3,922,461,0,8617,8619,
        5,353,0,0,8618,8616,1,0,0,0,8618,8617,1,0,0,0,8619,1233,1,0,0,0,
        8620,8621,5,168,0,0,8621,8622,5,6,0,0,8622,8623,3,1308,654,0,8623,
        1235,1,0,0,0,8624,8625,5,263,0,0,8625,8626,5,209,0,0,8626,1237,1,
        0,0,0,8627,8628,3,1236,618,0,8628,8629,3,1240,620,0,8629,1239,1,
        0,0,0,8630,8638,3,1408,704,0,8631,8635,4,620,122,0,8632,8636,3,1414,
        707,0,8633,8634,5,166,0,0,8634,8636,3,1418,709,0,8635,8632,1,0,0,
        0,8635,8633,1,0,0,0,8636,8638,1,0,0,0,8637,8630,1,0,0,0,8637,8631,
        1,0,0,0,8638,1241,1,0,0,0,8639,8640,5,263,0,0,8640,8641,3,1010,505,
        0,8641,8642,5,209,0,0,8642,1243,1,0,0,0,8643,8644,5,264,0,0,8644,
        8645,5,619,0,0,8645,8646,5,627,0,0,8646,1245,1,0,0,0,8647,8649,7,
        154,0,0,8648,8647,1,0,0,0,8648,8649,1,0,0,0,8649,8650,1,0,0,0,8650,
        8651,3,1248,624,0,8651,1247,1,0,0,0,8652,8653,3,1390,695,0,8653,
        8654,3,1252,626,0,8654,1249,1,0,0,0,8655,8656,5,112,0,0,8656,8657,
        3,1192,596,0,8657,1251,1,0,0,0,8658,8660,3,1168,584,0,8659,8661,
        3,1250,625,0,8660,8659,1,0,0,0,8660,8661,1,0,0,0,8661,1253,1,0,0,
        0,8662,8663,5,32,0,0,8663,8664,3,1340,670,0,8664,8665,5,29,0,0,8665,
        8666,3,1340,670,0,8666,8667,5,33,0,0,8667,1255,1,0,0,0,8668,8673,
        3,1356,678,0,8669,8670,5,29,0,0,8670,8672,3,1356,678,0,8671,8669,
        1,0,0,0,8672,8675,1,0,0,0,8673,8671,1,0,0,0,8673,8674,1,0,0,0,8674,
        1257,1,0,0,0,8675,8673,1,0,0,0,8676,8681,3,1260,630,0,8677,8678,
        5,29,0,0,8678,8680,3,1260,630,0,8679,8677,1,0,0,0,8680,8683,1,0,
        0,0,8681,8679,1,0,0,0,8681,8682,1,0,0,0,8682,1259,1,0,0,0,8683,8681,
        1,0,0,0,8684,8685,3,1328,664,0,8685,8688,5,6,0,0,8686,8689,3,912,
        456,0,8687,8689,5,166,0,0,8688,8686,1,0,0,0,8688,8687,1,0,0,0,8689,
        1261,1,0,0,0,8690,8691,3,1008,504,0,8691,8692,3,1190,595,0,8692,
        1263,1,0,0,0,8693,8695,5,114,0,0,8694,8696,3,1266,633,0,8695,8694,
        1,0,0,0,8696,8697,1,0,0,0,8697,8695,1,0,0,0,8697,8698,1,0,0,0,8698,
        1265,1,0,0,0,8699,8700,5,588,0,0,8700,8701,5,89,0,0,8701,8712,3,
        1442,721,0,8702,8704,5,410,0,0,8703,8702,1,0,0,0,8703,8704,1,0,0,
        0,8704,8705,1,0,0,0,8705,8706,5,193,0,0,8706,8707,5,89,0,0,8707,
        8712,3,1442,721,0,8708,8709,5,202,0,0,8709,8710,5,89,0,0,8710,8712,
        3,1442,721,0,8711,8699,1,0,0,0,8711,8703,1,0,0,0,8711,8708,1,0,0,
        0,8712,1267,1,0,0,0,8713,8715,5,308,0,0,8714,8716,3,1270,635,0,8715,
        8714,1,0,0,0,8716,8717,1,0,0,0,8717,8715,1,0,0,0,8717,8718,1,0,0,
        0,8718,1269,1,0,0,0,8719,8720,7,155,0,0,8720,8721,5,89,0,0,8721,
        8722,3,1442,721,0,8722,1271,1,0,0,0,8723,8728,3,1308,654,0,8724,
        8725,5,29,0,0,8725,8727,3,1308,654,0,8726,8724,1,0,0,0,8727,8730,
        1,0,0,0,8728,8726,1,0,0,0,8728,8729,1,0,0,0,8729,1273,1,0,0,0,8730,
        8728,1,0,0,0,8731,8736,3,1276,638,0,8732,8733,5,29,0,0,8733,8735,
        3,1276,638,0,8734,8732,1,0,0,0,8735,8738,1,0,0,0,8736,8734,1,0,0,
        0,8736,8737,1,0,0,0,8737,1275,1,0,0,0,8738,8736,1,0,0,0,8739,8749,
        3,1308,654,0,8740,8742,3,1280,640,0,8741,8743,3,1278,639,0,8742,
        8741,1,0,0,0,8742,8743,1,0,0,0,8743,8750,1,0,0,0,8744,8746,3,1286,
        643,0,8745,8747,3,1294,647,0,8746,8745,1,0,0,0,8746,8747,1,0,0,0,
        8747,8750,1,0,0,0,8748,8750,3,1278,639,0,8749,8740,1,0,0,0,8749,
        8744,1,0,0,0,8749,8748,1,0,0,0,8749,8750,1,0,0,0,8750,1277,1,0,0,
        0,8751,8752,5,61,0,0,8752,8755,3,1280,640,0,8753,8754,5,61,0,0,8754,
        8756,3,1280,640,0,8755,8753,1,0,0,0,8755,8756,1,0,0,0,8756,1279,
        1,0,0,0,8757,8764,3,1282,641,0,8758,8764,3,1284,642,0,8759,8764,
        3,1286,643,0,8760,8764,3,1288,644,0,8761,8764,3,1290,645,0,8762,
        8764,3,1292,646,0,8763,8757,1,0,0,0,8763,8758,1,0,0,0,8763,8759,
        1,0,0,0,8763,8760,1,0,0,0,8763,8761,1,0,0,0,8763,8762,1,0,0,0,8764,
        1281,1,0,0,0,8765,8766,5,262,0,0,8766,8767,5,89,0,0,8767,8768,3,
        1440,720,0,8768,1283,1,0,0,0,8769,8770,5,262,0,0,8770,8771,5,89,
        0,0,8771,8772,5,742,0,0,8772,8773,5,424,0,0,8773,1285,1,0,0,0,8774,
        8775,5,262,0,0,8775,8776,5,653,0,0,8776,8777,3,1468,734,0,8777,1287,
        1,0,0,0,8778,8779,5,262,0,0,8779,8780,5,653,0,0,8780,8781,3,1468,
        734,0,8781,8782,5,63,0,0,8782,8783,3,1444,722,0,8783,1289,1,0,0,
        0,8784,8785,5,262,0,0,8785,8786,5,653,0,0,8786,8787,3,1468,734,0,
        8787,8788,5,89,0,0,8788,8789,3,1440,720,0,8789,1291,1,0,0,0,8790,
        8791,5,262,0,0,8791,8792,5,653,0,0,8792,8793,3,1468,734,0,8793,8794,
        5,89,0,0,8794,8795,5,742,0,0,8795,8796,5,424,0,0,8796,1293,1,0,0,
        0,8797,8798,5,800,0,0,8798,8802,5,794,0,0,8799,8803,3,1284,642,0,
        8800,8803,3,1288,644,0,8801,8803,3,1282,641,0,8802,8799,1,0,0,0,
        8802,8800,1,0,0,0,8802,8801,1,0,0,0,8803,1295,1,0,0,0,8804,8805,
        5,735,0,0,8805,8806,5,143,0,0,8806,8807,5,424,0,0,8807,1297,1,0,
        0,0,8808,8809,5,178,0,0,8809,8810,5,736,0,0,8810,8811,5,424,0,0,
        8811,1299,1,0,0,0,8812,8813,3,1302,651,0,8813,8814,5,797,0,0,8814,
        8815,5,798,0,0,8815,8828,1,0,0,0,8816,8817,3,1302,651,0,8817,8818,
        5,799,0,0,8818,8828,1,0,0,0,8819,8820,3,1302,651,0,8820,8821,5,796,
        0,0,8821,8822,5,798,0,0,8822,8823,5,519,0,0,8823,8824,5,801,0,0,
        8824,8825,5,63,0,0,8825,8826,3,1444,722,0,8826,8828,1,0,0,0,8827,
        8812,1,0,0,0,8827,8816,1,0,0,0,8827,8819,1,0,0,0,8828,1301,1,0,0,
        0,8829,8830,3,1452,726,0,8830,8831,5,795,0,0,8831,1303,1,0,0,0,8832,
        8833,5,475,0,0,8833,8834,3,1442,721,0,8834,1305,1,0,0,0,8835,8837,
        3,1468,734,0,8836,8838,3,988,494,0,8837,8836,1,0,0,0,8837,8838,1,
        0,0,0,8838,1307,1,0,0,0,8839,8845,3,1306,653,0,8840,8842,5,146,0,
        0,8841,8843,3,1476,738,0,8842,8841,1,0,0,0,8842,8843,1,0,0,0,8843,
        8845,1,0,0,0,8844,8839,1,0,0,0,8844,8840,1,0,0,0,8845,1309,1,0,0,
        0,8846,8847,5,305,0,0,8847,8848,3,1440,720,0,8848,1311,1,0,0,0,8849,
        8852,3,1310,655,0,8850,8852,3,392,196,0,8851,8849,1,0,0,0,8851,8850,
        1,0,0,0,8852,1313,1,0,0,0,8853,8854,7,156,0,0,8854,1315,1,0,0,0,
        8855,8856,7,157,0,0,8856,1317,1,0,0,0,8857,8858,5,423,0,0,8858,8859,
        3,1412,706,0,8859,1319,1,0,0,0,8860,8866,3,1418,709,0,8861,8863,
        3,1414,707,0,8862,8864,3,1418,709,0,8863,8862,1,0,0,0,8863,8864,
        1,0,0,0,8864,8866,1,0,0,0,8865,8860,1,0,0,0,8865,8861,1,0,0,0,8866,
        1321,1,0,0,0,8867,8868,3,1408,704,0,8868,1323,1,0,0,0,8869,8870,
        3,1408,704,0,8870,1325,1,0,0,0,8871,8872,5,32,0,0,8872,8877,3,1324,
        662,0,8873,8874,5,29,0,0,8874,8876,3,1324,662,0,8875,8873,1,0,0,
        0,8876,8879,1,0,0,0,8877,8875,1,0,0,0,8877,8878,1,0,0,0,8878,8880,
        1,0,0,0,8879,8877,1,0,0,0,8880,8881,5,33,0,0,8881,1327,1,0,0,0,8882,
        8883,3,1320,660,0,8883,1329,1,0,0,0,8884,8887,3,1328,664,0,8885,
        8887,3,1336,668,0,8886,8884,1,0,0,0,8886,8885,1,0,0,0,8887,1331,
        1,0,0,0,8888,8889,3,1408,704,0,8889,1333,1,0,0,0,8890,8891,3,1320,
        660,0,8891,1335,1,0,0,0,8892,8893,3,1408,704,0,8893,8897,5,28,0,
        0,8894,8895,3,1408,704,0,8895,8896,5,28,0,0,8896,8898,1,0,0,0,8897,
        8894,1,0,0,0,8897,8898,1,0,0,0,8898,8899,1,0,0,0,8899,8900,5,16,
        0,0,8900,1337,1,0,0,0,8901,8902,3,1408,704,0,8902,1339,1,0,0,0,8903,
        8904,3,1408,704,0,8904,1341,1,0,0,0,8905,8906,3,1414,707,0,8906,
        1343,1,0,0,0,8907,8908,3,1414,707,0,8908,1345,1,0,0,0,8909,8910,
        3,1414,707,0,8910,1347,1,0,0,0,8911,8912,3,1414,707,0,8912,1349,
        1,0,0,0,8913,8914,3,1414,707,0,8914,1351,1,0,0,0,8915,8916,3,1414,
        707,0,8916,1353,1,0,0,0,8917,8920,3,1414,707,0,8918,8920,3,1418,
        709,0,8919,8917,1,0,0,0,8919,8918,1,0,0,0,8920,1355,1,0,0,0,8921,
        8924,3,1414,707,0,8922,8924,3,1418,709,0,8923,8921,1,0,0,0,8923,
        8922,1,0,0,0,8924,1357,1,0,0,0,8925,8926,3,1408,704,0,8926,1359,
        1,0,0,0,8927,8928,3,1408,704,0,8928,1361,1,0,0,0,8929,8930,3,1408,
        704,0,8930,1363,1,0,0,0,8931,8932,3,1408,704,0,8932,1365,1,0,0,0,
        8933,8934,3,1414,707,0,8934,1367,1,0,0,0,8935,8936,3,1414,707,0,
        8936,1369,1,0,0,0,8937,8938,3,1408,704,0,8938,1371,1,0,0,0,8939,
        8940,3,1468,734,0,8940,1373,1,0,0,0,8941,8942,3,1468,734,0,8942,
        1375,1,0,0,0,8943,8944,3,1468,734,0,8944,1377,1,0,0,0,8945,8948,
        3,1414,707,0,8946,8948,3,1418,709,0,8947,8945,1,0,0,0,8947,8946,
        1,0,0,0,8948,1379,1,0,0,0,8949,8950,3,1340,670,0,8950,8951,3,1418,
        709,0,8951,1381,1,0,0,0,8952,8960,3,1408,704,0,8953,8954,5,28,0,
        0,8954,8961,5,16,0,0,8955,8958,3,1418,709,0,8956,8957,5,28,0,0,8957,
        8959,5,16,0,0,8958,8956,1,0,0,0,8958,8959,1,0,0,0,8959,8961,1,0,
        0,0,8960,8953,1,0,0,0,8960,8955,1,0,0,0,8960,8961,1,0,0,0,8961,1383,
        1,0,0,0,8962,8965,3,1414,707,0,8963,8965,3,1418,709,0,8964,8962,
        1,0,0,0,8964,8963,1,0,0,0,8965,1385,1,0,0,0,8966,8971,3,1384,692,
        0,8967,8968,5,29,0,0,8968,8970,3,1384,692,0,8969,8967,1,0,0,0,8970,
        8973,1,0,0,0,8971,8969,1,0,0,0,8971,8972,1,0,0,0,8972,1387,1,0,0,
        0,8973,8971,1,0,0,0,8974,8979,3,1382,691,0,8975,8976,5,29,0,0,8976,
        8978,3,1382,691,0,8977,8975,1,0,0,0,8978,8981,1,0,0,0,8979,8977,
        1,0,0,0,8979,8980,1,0,0,0,8980,1389,1,0,0,0,8981,8979,1,0,0,0,8982,
        8983,3,1408,704,0,8983,1391,1,0,0,0,8984,8987,3,1406,703,0,8985,
        8987,3,1494,747,0,8986,8984,1,0,0,0,8986,8985,1,0,0,0,8987,1393,
        1,0,0,0,8988,8989,3,1392,696,0,8989,1395,1,0,0,0,8990,8993,3,1406,
        703,0,8991,8993,3,1500,750,0,8992,8990,1,0,0,0,8992,8991,1,0,0,0,
        8993,1397,1,0,0,0,8994,8995,3,1408,704,0,8995,1399,1,0,0,0,8996,
        8997,3,1440,720,0,8997,1401,1,0,0,0,8998,8999,3,1408,704,0,8999,
        1403,1,0,0,0,9000,9001,3,1408,704,0,9001,1405,1,0,0,0,9002,9006,
        7,158,0,0,9003,9004,4,703,123,0,9004,9006,5,824,0,0,9005,9002,1,
        0,0,0,9005,9003,1,0,0,0,9006,1407,1,0,0,0,9007,9010,3,1406,703,0,
        9008,9010,3,1488,744,0,9009,9007,1,0,0,0,9009,9008,1,0,0,0,9010,
        1409,1,0,0,0,9011,9016,3,1408,704,0,9012,9013,5,29,0,0,9013,9015,
        3,1408,704,0,9014,9012,1,0,0,0,9015,9018,1,0,0,0,9016,9014,1,0,0,
        0,9016,9017,1,0,0,0,9017,1411,1,0,0,0,9018,9016,1,0,0,0,9019,9020,
        5,32,0,0,9020,9021,3,1410,705,0,9021,9022,5,33,0,0,9022,1413,1,0,
        0,0,9023,9025,3,1408,704,0,9024,9026,3,1418,709,0,9025,9024,1,0,
        0,0,9025,9026,1,0,0,0,9026,1415,1,0,0,0,9027,9032,3,1408,704,0,9028,
        9030,3,1418,709,0,9029,9031,3,1418,709,0,9030,9029,1,0,0,0,9030,
        9031,1,0,0,0,9031,9033,1,0,0,0,9032,9028,1,0,0,0,9032,9033,1,0,0,
        0,9033,1417,1,0,0,0,9034,9035,5,28,0,0,9035,9036,3,1408,704,0,9036,
        1419,1,0,0,0,9037,9038,7,159,0,0,9038,1421,1,0,0,0,9039,9040,7,160,
        0,0,9040,1423,1,0,0,0,9041,9042,7,161,0,0,9042,1425,1,0,0,0,9043,
        9049,5,3,0,0,9044,9045,4,713,124,0,9045,9049,5,44,0,0,9046,9049,
        5,5,0,0,9047,9049,5,4,0,0,9048,9043,1,0,0,0,9048,9044,1,0,0,0,9048,
        9046,1,0,0,0,9048,9047,1,0,0,0,9049,1427,1,0,0,0,9050,9056,3,1432,
        716,0,9051,9052,5,14,0,0,9052,9056,3,1420,710,0,9053,9054,5,15,0,
        0,9054,9056,3,1420,710,0,9055,9050,1,0,0,0,9055,9051,1,0,0,0,9055,
        9053,1,0,0,0,9056,1429,1,0,0,0,9057,9061,3,1428,714,0,9058,9059,
        4,715,125,0,9059,9061,3,1436,718,0,9060,9057,1,0,0,0,9060,9058,1,
        0,0,0,9061,1431,1,0,0,0,9062,9072,3,1446,723,0,9063,9072,3,1452,
        726,0,9064,9072,3,1460,730,0,9065,9072,3,1456,728,0,9066,9072,3,
        1454,727,0,9067,9069,5,819,0,0,9068,9067,1,0,0,0,9068,9069,1,0,0,
        0,9069,9070,1,0,0,0,9070,9072,7,162,0,0,9071,9062,1,0,0,0,9071,9063,
        1,0,0,0,9071,9064,1,0,0,0,9071,9065,1,0,0,0,9071,9066,1,0,0,0,9071,
        9068,1,0,0,0,9072,1433,1,0,0,0,9073,9077,3,1432,716,0,9074,9075,
        4,717,126,0,9075,9077,3,1436,718,0,9076,9073,1,0,0,0,9076,9074,1,
        0,0,0,9077,1435,1,0,0,0,9078,9079,5,395,0,0,9079,1437,1,0,0,0,9080,
        9081,5,32,0,0,9081,9086,3,1442,721,0,9082,9083,5,29,0,0,9083,9085,
        3,1442,721,0,9084,9082,1,0,0,0,9085,9088,1,0,0,0,9086,9084,1,0,0,
        0,9086,9087,1,0,0,0,9087,9089,1,0,0,0,9088,9086,1,0,0,0,9089,9090,
        5,33,0,0,9090,1439,1,0,0,0,9091,9095,5,825,0,0,9092,9093,4,720,127,
        0,9093,9095,5,824,0,0,9094,9091,1,0,0,0,9094,9092,1,0,0,0,9095,1441,
        1,0,0,0,9096,9100,3,1440,720,0,9097,9100,5,44,0,0,9098,9100,5,45,
        0,0,9099,9096,1,0,0,0,9099,9097,1,0,0,0,9099,9098,1,0,0,0,9100,1443,
        1,0,0,0,9101,9105,3,1440,720,0,9102,9103,4,722,128,0,9103,9105,5,
        44,0,0,9104,9101,1,0,0,0,9104,9102,1,0,0,0,9105,1445,1,0,0,0,9106,
        9108,5,819,0,0,9107,9106,1,0,0,0,9107,9108,1,0,0,0,9108,9109,1,0,
        0,0,9109,9112,3,1440,720,0,9110,9112,5,822,0,0,9111,9107,1,0,0,0,
        9111,9110,1,0,0,0,9112,9116,1,0,0,0,9113,9115,3,1440,720,0,9114,
        9113,1,0,0,0,9115,9118,1,0,0,0,9116,9114,1,0,0,0,9116,9117,1,0,0,
        0,9117,1447,1,0,0,0,9118,9116,1,0,0,0,9119,9120,3,1440,720,0,9120,
        1449,1,0,0,0,9121,9126,3,1440,720,0,9122,9123,5,29,0,0,9123,9125,
        3,1440,720,0,9124,9122,1,0,0,0,9125,9128,1,0,0,0,9126,9124,1,0,0,
        0,9126,9127,1,0,0,0,9127,1451,1,0,0,0,9128,9126,1,0,0,0,9129,9133,
        3,1458,729,0,9130,9133,5,46,0,0,9131,9133,5,47,0,0,9132,9129,1,0,
        0,0,9132,9130,1,0,0,0,9132,9131,1,0,0,0,9133,1453,1,0,0,0,9134,9135,
        7,163,0,0,9135,1455,1,0,0,0,9136,9137,7,164,0,0,9137,1457,1,0,0,
        0,9138,9139,7,165,0,0,9139,1459,1,0,0,0,9140,9141,5,157,0,0,9141,
        9147,5,825,0,0,9142,9143,5,595,0,0,9143,9147,5,825,0,0,9144,9145,
        5,592,0,0,9145,9147,5,825,0,0,9146,9140,1,0,0,0,9146,9142,1,0,0,
        0,9146,9144,1,0,0,0,9147,1461,1,0,0,0,9148,9151,3,1174,587,0,9149,
        9151,3,1466,733,0,9150,9148,1,0,0,0,9150,9149,1,0,0,0,9151,1463,
        1,0,0,0,9152,9153,3,1466,733,0,9153,1465,1,0,0,0,9154,9155,5,32,
        0,0,9155,9156,5,3,0,0,9156,9157,5,29,0,0,9157,9158,5,3,0,0,9158,
        9159,5,33,0,0,9159,1467,1,0,0,0,9160,9163,3,1408,704,0,9161,9163,
        3,1440,720,0,9162,9160,1,0,0,0,9162,9161,1,0,0,0,9163,1469,1,0,0,
        0,9164,9167,3,1406,703,0,9165,9167,3,1502,751,0,9166,9164,1,0,0,
        0,9166,9165,1,0,0,0,9167,1471,1,0,0,0,9168,9171,3,1396,698,0,9169,
        9171,3,1440,720,0,9170,9168,1,0,0,0,9170,9169,1,0,0,0,9171,1473,
        1,0,0,0,9172,9175,3,1426,713,0,9173,9175,3,1406,703,0,9174,9172,
        1,0,0,0,9174,9173,1,0,0,0,9175,1475,1,0,0,0,9176,9177,5,32,0,0,9177,
        9178,5,33,0,0,9178,1477,1,0,0,0,9179,9180,7,166,0,0,9180,1479,1,
        0,0,0,9181,9182,7,167,0,0,9182,1481,1,0,0,0,9183,9184,5,246,0,0,
        9184,9190,5,28,0,0,9185,9186,5,312,0,0,9186,9190,5,28,0,0,9187,9188,
        5,516,0,0,9188,9190,5,28,0,0,9189,9183,1,0,0,0,9189,9185,1,0,0,0,
        9189,9187,1,0,0,0,9190,1483,1,0,0,0,9191,9192,7,167,0,0,9192,9193,
        5,28,0,0,9193,1485,1,0,0,0,9194,9195,3,1440,720,0,9195,1487,1,0,
        0,0,9196,9203,4,744,129,0,9197,9204,3,1494,747,0,9198,9204,3,1506,
        753,0,9199,9204,5,208,0,0,9200,9204,5,522,0,0,9201,9202,4,744,130,
        0,9202,9204,5,722,0,0,9203,9197,1,0,0,0,9203,9198,1,0,0,0,9203,9199,
        1,0,0,0,9203,9200,1,0,0,0,9203,9201,1,0,0,0,9204,9213,1,0,0,0,9205,
        9211,3,1498,749,0,9206,9211,3,1490,745,0,9207,9211,3,1492,746,0,
        9208,9211,3,1496,748,0,9209,9211,3,1504,752,0,9210,9205,1,0,0,0,
        9210,9206,1,0,0,0,9210,9207,1,0,0,0,9210,9208,1,0,0,0,9210,9209,
        1,0,0,0,9211,9213,1,0,0,0,9212,9196,1,0,0,0,9212,9210,1,0,0,0,9213,
        1489,1,0,0,0,9214,9215,7,168,0,0,9215,1491,1,0,0,0,9216,9217,7,169,
        0,0,9217,1493,1,0,0,0,9218,9229,4,747,131,0,9219,9230,3,1508,754,
        0,9220,9230,5,205,0,0,9221,9230,5,222,0,0,9222,9230,5,389,0,0,9223,
        9230,5,441,0,0,9224,9230,5,445,0,0,9225,9230,5,468,0,0,9226,9230,
        5,476,0,0,9227,9230,5,717,0,0,9228,9230,5,575,0,0,9229,9219,1,0,
        0,0,9229,9220,1,0,0,0,9229,9221,1,0,0,0,9229,9222,1,0,0,0,9229,9223,
        1,0,0,0,9229,9224,1,0,0,0,9229,9225,1,0,0,0,9229,9226,1,0,0,0,9229,
        9227,1,0,0,0,9229,9228,1,0,0,0,9230,9237,1,0,0,0,9231,9235,3,1498,
        749,0,9232,9235,3,1496,748,0,9233,9235,3,1504,752,0,9234,9231,1,
        0,0,0,9234,9232,1,0,0,0,9234,9233,1,0,0,0,9235,9237,1,0,0,0,9236,
        9218,1,0,0,0,9236,9234,1,0,0,0,9237,1495,1,0,0,0,9238,9239,7,170,
        0,0,9239,1497,1,0,0,0,9240,9246,7,171,0,0,9241,9242,4,749,132,0,
        9242,9246,7,172,0,0,9243,9244,4,749,133,0,9244,9246,7,173,0,0,9245,
        9240,1,0,0,0,9245,9241,1,0,0,0,9245,9243,1,0,0,0,9246,1499,1,0,0,
        0,9247,9250,4,750,134,0,9248,9251,3,1508,754,0,9249,9251,3,1506,
        753,0,9250,9248,1,0,0,0,9250,9249,1,0,0,0,9251,9258,1,0,0,0,9252,
        9256,3,1498,749,0,9253,9256,3,1492,746,0,9254,9256,3,1504,752,0,
        9255,9252,1,0,0,0,9255,9253,1,0,0,0,9255,9254,1,0,0,0,9256,9258,
        1,0,0,0,9257,9247,1,0,0,0,9257,9255,1,0,0,0,9258,1501,1,0,0,0,9259,
        9264,3,1498,749,0,9260,9264,3,1490,745,0,9261,9264,3,1492,746,0,
        9262,9264,3,1496,748,0,9263,9259,1,0,0,0,9263,9260,1,0,0,0,9263,
        9261,1,0,0,0,9263,9262,1,0,0,0,9264,1503,1,0,0,0,9265,9266,7,167,
        0,0,9266,1505,1,0,0,0,9267,9268,7,174,0,0,9268,1507,1,0,0,0,9269,
        9273,7,175,0,0,9270,9271,4,754,135,0,9271,9273,5,668,0,0,9272,9269,
        1,0,0,0,9272,9270,1,0,0,0,9273,1509,1,0,0,0,1176,1513,1520,1600,
        1608,1613,1623,1630,1636,1639,1642,1649,1654,1657,1662,1668,1670,
        1674,1678,1687,1691,1696,1702,1709,1714,1719,1726,1729,1735,1738,
        1745,1755,1760,1765,1773,1779,1783,1788,1797,1803,1809,1815,1824,
        1830,1839,1851,1855,1861,1865,1871,1875,1880,1883,1889,1895,1901,
        1905,1910,1914,1918,1934,1942,1950,1957,1984,1999,2002,2008,2013,
        2019,2024,2028,2033,2037,2041,2045,2049,2053,2055,2065,2073,2080,
        2088,2092,2097,2104,2109,2114,2124,2128,2133,2136,2139,2142,2149,
        2156,2160,2185,2187,2195,2197,2217,2221,2227,2234,2237,2241,2248,
        2251,2260,2267,2272,2275,2280,2286,2289,2293,2299,2302,2307,2311,
        2320,2323,2329,2336,2342,2345,2349,2358,2361,2369,2375,2379,2389,
        2392,2397,2405,2420,2423,2426,2431,2437,2447,2457,2460,2463,2467,
        2475,2488,2492,2497,2506,2523,2542,2551,2554,2562,2569,2571,2578,
        2583,2597,2601,2607,2613,2619,2625,2631,2636,2640,2648,2654,2660,
        2666,2671,2674,2677,2686,2689,2700,2704,2715,2723,2727,2736,2739,
        2745,2747,2751,2758,2771,2778,2784,2787,2804,2823,2827,2833,2839,
        2845,2850,2857,2864,2869,2872,2876,2880,2885,2889,2893,2899,2904,
        2907,2911,2917,2921,2925,2933,2941,2950,2959,2972,2975,2978,2984,
        2992,2997,3000,3003,3006,3009,3011,3017,3019,3035,3042,3045,3047,
        3049,3059,3061,3065,3068,3071,3075,3079,3084,3087,3090,3096,3099,
        3108,3118,3121,3124,3128,3134,3139,3144,3149,3153,3160,3171,3174,
        3177,3180,3184,3187,3190,3196,3199,3202,3205,3208,3212,3215,3218,
        3230,3238,3254,3257,3261,3265,3273,3281,3285,3305,3308,3312,3318,
        3322,3325,3334,3344,3347,3351,3354,3358,3363,3366,3371,3377,3386,
        3392,3397,3400,3403,3406,3409,3412,3415,3430,3434,3440,3443,3446,
        3452,3457,3461,3464,3471,3473,3490,3502,3507,3510,3513,3518,3524,
        3540,3560,3569,3573,3580,3585,3594,3604,3618,3625,3634,3643,3649,
        3655,3661,3664,3670,3677,3681,3687,3693,3695,3698,3702,3712,3717,
        3722,3729,3738,3746,3751,3755,3761,3764,3767,3771,3775,3785,3789,
        3792,3795,3798,3803,3809,3812,3818,3821,3823,3828,3840,3849,3862,
        3865,3870,3877,3881,3884,3890,3904,3911,3920,3926,3935,3939,3943,
        3953,3955,3963,3970,3975,3978,3982,3985,3991,3994,3997,4003,4010,
        4015,4019,4022,4025,4028,4030,4034,4041,4047,4051,4056,4059,4062,
        4065,4067,4072,4081,4090,4094,4100,4103,4106,4112,4119,4121,4129,
        4135,4137,4147,4149,4160,4166,4173,4181,4185,4189,4192,4194,4202,
        4211,4220,4227,4234,4365,4419,4426,4430,4446,4458,4461,4473,4477,
        4483,4490,4497,4504,4511,4518,4525,4528,4535,4543,4551,4561,4567,
        4571,4574,4577,4580,4583,4586,4591,4594,4601,4607,4631,4638,4641,
        4650,4656,4677,4683,4689,4696,4704,4710,4722,4724,4730,4734,4736,
        4740,4751,4756,4762,4769,4772,4775,4781,4783,4791,4794,4796,4798,
        4805,4816,4819,4821,4825,4830,4832,4837,4843,4846,4848,4852,4855,
        4864,4873,4879,4881,4883,4892,4896,4902,4905,4907,4918,4923,4928,
        4934,4936,4940,4942,4950,4954,4959,4962,4967,4972,4978,4987,4998,
        5000,5012,5017,5025,5031,5033,5040,5042,5049,5054,5065,5070,5072,
        5076,5082,5085,5088,5098,5100,5106,5119,5123,5128,5145,5151,5160,
        5168,5172,5178,5188,5192,5201,5206,5212,5214,5218,5229,5236,5242,
        5246,5251,5256,5264,5268,5273,5282,5295,5297,5311,5320,5322,5329,
        5334,5338,5343,5351,5358,5362,5368,5375,5378,5385,5388,5394,5411,
        5416,5429,5432,5443,5445,5451,5465,5482,5487,5490,5494,5497,5505,
        5511,5516,5519,5521,5525,5530,5532,5544,5550,5564,5576,5580,5582,
        5590,5594,5603,5616,5621,5625,5629,5632,5636,5640,5643,5648,5651,
        5657,5660,5666,5669,5696,5702,5705,5721,5728,5732,5735,5738,5745,
        5749,5752,5755,5759,5765,5768,5772,5793,5798,5806,5811,5814,5818,
        5822,5826,5832,5836,5841,5846,5857,5859,5865,5887,5909,5916,5943,
        5945,5949,5961,5971,5981,5985,5993,5996,6000,6009,6013,6020,6025,
        6033,6038,6044,6051,6056,6062,6065,6075,6077,6084,6089,6093,6096,
        6103,6108,6112,6123,6131,6135,6138,6141,6145,6149,6154,6160,6164,
        6175,6178,6181,6184,6192,6196,6201,6209,6217,6223,6227,6233,6242,
        6253,6263,6281,6284,6288,6299,6301,6310,6322,6324,6331,6337,6343,
        6351,6362,6366,6395,6397,6403,6420,6427,6441,6452,6457,6468,6478,
        6485,6488,6522,6530,6532,6542,6547,6552,6559,6565,6570,6575,6581,
        6585,6590,6595,6602,6610,6615,6619,6623,6627,6629,6647,6655,6659,
        6666,6678,6681,6685,6693,6705,6712,6716,6720,6726,6736,6745,6747,
        6750,6759,6766,6779,6784,6791,6797,6823,6833,6865,6884,6890,6894,
        6925,6931,6943,6956,6960,6964,6992,7042,7052,7064,7069,7077,7097,
        7101,7117,7120,7125,7128,7137,7141,7147,7153,7157,7168,7174,7176,
        7183,7190,7194,7201,7206,7211,7220,7223,7227,7232,7234,7238,7242,
        7255,7259,7262,7266,7270,7274,7281,7285,7289,7297,7301,7308,7314,
        7322,7343,7348,7355,7377,7393,7403,7407,7414,7417,7428,7437,7440,
        7447,7452,7478,7484,7490,7494,7504,7508,7521,7533,7549,7557,7567,
        7570,7575,7579,7586,7591,7598,7606,7609,7614,7622,7625,7639,7642,
        7655,7659,7661,7666,7671,7678,7684,7690,7695,7698,7704,7709,7712,
        7718,7722,7728,7730,7733,7739,7745,7752,7754,7756,7760,7766,7770,
        7774,7779,7784,7787,7790,7800,7806,7813,7818,7831,7839,7845,7850,
        7861,7865,7870,7874,7877,7882,7886,7894,7902,7904,7913,7921,7928,
        7931,7939,7948,7950,7956,7960,7969,7975,7978,7989,7998,8001,8006,
        8008,8011,8014,8018,8021,8025,8030,8033,8037,8040,8044,8049,8053,
        8065,8069,8075,8078,8083,8087,8091,8096,8105,8108,8112,8116,8119,
        8123,8127,8132,8137,8142,8147,8152,8154,8159,8166,8174,8180,8182,
        8186,8190,8194,8198,8213,8219,8226,8230,8235,8240,8243,8247,8250,
        8255,8259,8265,8269,8273,8278,8283,8288,8293,8298,8303,8308,8313,
        8318,8323,8328,8333,8338,8348,8354,8360,8365,8372,8377,8386,8392,
        8397,8401,8404,8408,8413,8417,8422,8426,8435,8438,8441,8444,8448,
        8452,8456,8471,8474,8476,8481,8490,8493,8497,8509,8521,8526,8531,
        8540,8545,8554,8559,8563,8567,8571,8576,8581,8587,8592,8595,8602,
        8611,8618,8635,8637,8648,8660,8673,8681,8688,8697,8703,8711,8717,
        8728,8736,8742,8746,8749,8755,8763,8802,8827,8837,8842,8844,8851,
        8863,8865,8877,8886,8897,8919,8923,8947,8958,8960,8964,8971,8979,
        8986,8992,9005,9009,9016,9025,9030,9032,9048,9055,9060,9068,9071,
        9076,9086,9094,9099,9104,9107,9111,9116,9126,9132,9146,9150,9162,
        9166,9170,9174,9189,9203,9210,9212,9229,9234,9236,9245,9250,9255,
        9257,9263,9272
    ]

class MySQLParser ( MySQLParserBase ):

    grammarFileName = "MySQLParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'='", "':='", "'<=>'", "'>='", 
                     "'>'", "'<='", "'<'", "'!='", "'+'", "'-'", "'*'", 
                     "'/'", "'%'", "'!'", "'~'", "'<<'", "'>>'", "'&&'", 
                     "'&'", "'^'", "'||'", "'|'", "'.'", "','", "';'", "':'", 
                     "'('", "')'", "'{'", "'}'", "'_'", "'->'", "'->>'", 
                     "'@'", "<INVALID>", "'@@'", "'\\N'", "'?'", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'<>'" ]

    symbolicNames = [ "<INVALID>", "NOT2_SYMBOL", "CONCAT_PIPES_SYMBOL", 
                      "INT_NUMBER", "LONG_NUMBER", "ULONGLONG_NUMBER", "EQUAL_OPERATOR", 
                      "ASSIGN_OPERATOR", "NULL_SAFE_EQUAL_OPERATOR", "GREATER_OR_EQUAL_OPERATOR", 
                      "GREATER_THAN_OPERATOR", "LESS_OR_EQUAL_OPERATOR", 
                      "LESS_THAN_OPERATOR", "NOT_EQUAL_OPERATOR", "PLUS_OPERATOR", 
                      "MINUS_OPERATOR", "MULT_OPERATOR", "DIV_OPERATOR", 
                      "MOD_OPERATOR", "LOGICAL_NOT_OPERATOR", "BITWISE_NOT_OPERATOR", 
                      "SHIFT_LEFT_OPERATOR", "SHIFT_RIGHT_OPERATOR", "LOGICAL_AND_OPERATOR", 
                      "BITWISE_AND_OPERATOR", "BITWISE_XOR_OPERATOR", "LOGICAL_OR_OPERATOR", 
                      "BITWISE_OR_OPERATOR", "DOT_SYMBOL", "COMMA_SYMBOL", 
                      "SEMICOLON_SYMBOL", "COLON_SYMBOL", "OPEN_PAR_SYMBOL", 
                      "CLOSE_PAR_SYMBOL", "OPEN_CURLY_SYMBOL", "CLOSE_CURLY_SYMBOL", 
                      "UNDERLINE_SYMBOL", "JSON_SEPARATOR_SYMBOL", "JSON_UNQUOTED_SEPARATOR_SYMBOL", 
                      "AT_SIGN_SYMBOL", "AT_TEXT_SUFFIX", "AT_AT_SIGN_SYMBOL", 
                      "NULL2_SYMBOL", "PARAM_MARKER", "HEX_NUMBER", "BIN_NUMBER", 
                      "DECIMAL_NUMBER", "FLOAT_NUMBER", "ACCESSIBLE_SYMBOL", 
                      "ACCOUNT_SYMBOL", "ACTION_SYMBOL", "ADD_SYMBOL", "ADDDATE_SYMBOL", 
                      "AFTER_SYMBOL", "AGAINST_SYMBOL", "AGGREGATE_SYMBOL", 
                      "ALGORITHM_SYMBOL", "ALL_SYMBOL", "ALTER_SYMBOL", 
                      "ALWAYS_SYMBOL", "ANALYZE_SYMBOL", "AND_SYMBOL", "ANY_SYMBOL", 
                      "AS_SYMBOL", "ASC_SYMBOL", "ASCII_SYMBOL", "ASENSITIVE_SYMBOL", 
                      "AT_SYMBOL", "AUTOEXTEND_SIZE_SYMBOL", "AUTO_INCREMENT_SYMBOL", 
                      "AVG_ROW_LENGTH_SYMBOL", "AVG_SYMBOL", "BACKUP_SYMBOL", 
                      "BEFORE_SYMBOL", "BEGIN_SYMBOL", "BETWEEN_SYMBOL", 
                      "BIGINT_SYMBOL", "BINARY_SYMBOL", "BINLOG_SYMBOL", 
                      "BIT_AND_SYMBOL", "BIT_OR_SYMBOL", "BIT_SYMBOL", "BIT_XOR_SYMBOL", 
                      "BLOB_SYMBOL", "BLOCK_SYMBOL", "BOOLEAN_SYMBOL", "BOOL_SYMBOL", 
                      "BOTH_SYMBOL", "BTREE_SYMBOL", "BY_SYMBOL", "BYTE_SYMBOL", 
                      "CACHE_SYMBOL", "CALL_SYMBOL", "CASCADE_SYMBOL", "CASCADED_SYMBOL", 
                      "CASE_SYMBOL", "CAST_SYMBOL", "CATALOG_NAME_SYMBOL", 
                      "CHAIN_SYMBOL", "CHANGE_SYMBOL", "CHANGED_SYMBOL", 
                      "CHANNEL_SYMBOL", "CHARSET_SYMBOL", "CHAR_SYMBOL", 
                      "CHECKSUM_SYMBOL", "CHECK_SYMBOL", "CIPHER_SYMBOL", 
                      "CLASS_ORIGIN_SYMBOL", "CLIENT_SYMBOL", "CLOSE_SYMBOL", 
                      "COALESCE_SYMBOL", "CODE_SYMBOL", "COLLATE_SYMBOL", 
                      "COLLATION_SYMBOL", "COLUMNS_SYMBOL", "COLUMN_SYMBOL", 
                      "COLUMN_NAME_SYMBOL", "COLUMN_FORMAT_SYMBOL", "COMMENT_SYMBOL", 
                      "COMMITTED_SYMBOL", "COMMIT_SYMBOL", "COMPACT_SYMBOL", 
                      "COMPLETION_SYMBOL", "COMPRESSED_SYMBOL", "COMPRESSION_SYMBOL", 
                      "CONCURRENT_SYMBOL", "CONDITION_SYMBOL", "CONNECTION_SYMBOL", 
                      "CONSISTENT_SYMBOL", "CONSTRAINT_SYMBOL", "CONSTRAINT_CATALOG_SYMBOL", 
                      "CONSTRAINT_NAME_SYMBOL", "CONSTRAINT_SCHEMA_SYMBOL", 
                      "CONTAINS_SYMBOL", "CONTEXT_SYMBOL", "CONTINUE_SYMBOL", 
                      "CONVERT_SYMBOL", "COUNT_SYMBOL", "CPU_SYMBOL", "CREATE_SYMBOL", 
                      "CROSS_SYMBOL", "CUBE_SYMBOL", "CURDATE_SYMBOL", "CURRENT_SYMBOL", 
                      "CURRENT_DATE_SYMBOL", "CURRENT_TIME_SYMBOL", "CURRENT_USER_SYMBOL", 
                      "CURSOR_SYMBOL", "CURSOR_NAME_SYMBOL", "CURTIME_SYMBOL", 
                      "DATABASE_SYMBOL", "DATABASES_SYMBOL", "DATAFILE_SYMBOL", 
                      "DATA_SYMBOL", "DATETIME_SYMBOL", "DATE_ADD_SYMBOL", 
                      "DATE_SUB_SYMBOL", "DATE_SYMBOL", "DAY_HOUR_SYMBOL", 
                      "DAY_MICROSECOND_SYMBOL", "DAY_MINUTE_SYMBOL", "DAY_SECOND_SYMBOL", 
                      "DAY_SYMBOL", "DEALLOCATE_SYMBOL", "DECIMAL_SYMBOL", 
                      "DECLARE_SYMBOL", "DEFAULT_SYMBOL", "DEFAULT_AUTH_SYMBOL", 
                      "DEFINER_SYMBOL", "DELAYED_SYMBOL", "DELAY_KEY_WRITE_SYMBOL", 
                      "DELETE_SYMBOL", "DESC_SYMBOL", "DESCRIBE_SYMBOL", 
                      "DETERMINISTIC_SYMBOL", "DIAGNOSTICS_SYMBOL", "DIRECTORY_SYMBOL", 
                      "DISABLE_SYMBOL", "DISCARD_SYMBOL", "DISK_SYMBOL", 
                      "DISTINCT_SYMBOL", "DIV_SYMBOL", "DOUBLE_SYMBOL", 
                      "DO_SYMBOL", "DROP_SYMBOL", "DUAL_SYMBOL", "DUMPFILE_SYMBOL", 
                      "DUPLICATE_SYMBOL", "DYNAMIC_SYMBOL", "EACH_SYMBOL", 
                      "ELSE_SYMBOL", "ELSEIF_SYMBOL", "ENABLE_SYMBOL", "ENCLOSED_SYMBOL", 
                      "ENCRYPTION_SYMBOL", "END_SYMBOL", "ENDS_SYMBOL", 
                      "ENGINES_SYMBOL", "ENGINE_SYMBOL", "ENUM_SYMBOL", 
                      "ERROR_SYMBOL", "ERRORS_SYMBOL", "ESCAPED_SYMBOL", 
                      "ESCAPE_SYMBOL", "EVENTS_SYMBOL", "EVENT_SYMBOL", 
                      "EVERY_SYMBOL", "EXCHANGE_SYMBOL", "EXECUTE_SYMBOL", 
                      "EXISTS_SYMBOL", "EXIT_SYMBOL", "EXPANSION_SYMBOL", 
                      "EXPIRE_SYMBOL", "EXPLAIN_SYMBOL", "EXPORT_SYMBOL", 
                      "EXTENDED_SYMBOL", "EXTENT_SIZE_SYMBOL", "EXTRACT_SYMBOL", 
                      "FALSE_SYMBOL", "FAST_SYMBOL", "FAULTS_SYMBOL", "FETCH_SYMBOL", 
                      "FILE_SYMBOL", "FILE_BLOCK_SIZE_SYMBOL", "FILTER_SYMBOL", 
                      "FIRST_SYMBOL", "FIXED_SYMBOL", "FLOAT_SYMBOL", "FLUSH_SYMBOL", 
                      "FOLLOWS_SYMBOL", "FORCE_SYMBOL", "FOREIGN_SYMBOL", 
                      "FOR_SYMBOL", "FORMAT_SYMBOL", "FOUND_SYMBOL", "FROM_SYMBOL", 
                      "FULL_SYMBOL", "FULLTEXT_SYMBOL", "FUNCTION_SYMBOL", 
                      "GET_SYMBOL", "GENERAL_SYMBOL", "GENERATED_SYMBOL", 
                      "GROUP_REPLICATION_SYMBOL", "GEOMETRYCOLLECTION_SYMBOL", 
                      "GEOMETRY_SYMBOL", "GET_FORMAT_SYMBOL", "GLOBAL_SYMBOL", 
                      "GRANT_SYMBOL", "GRANTS_SYMBOL", "GROUP_SYMBOL", "GROUP_CONCAT_SYMBOL", 
                      "HANDLER_SYMBOL", "HASH_SYMBOL", "HAVING_SYMBOL", 
                      "HELP_SYMBOL", "HIGH_PRIORITY_SYMBOL", "HOST_SYMBOL", 
                      "HOSTS_SYMBOL", "HOUR_MICROSECOND_SYMBOL", "HOUR_MINUTE_SYMBOL", 
                      "HOUR_SECOND_SYMBOL", "HOUR_SYMBOL", "IDENTIFIED_SYMBOL", 
                      "IF_SYMBOL", "IGNORE_SYMBOL", "IGNORE_SERVER_IDS_SYMBOL", 
                      "IMPORT_SYMBOL", "INDEXES_SYMBOL", "INDEX_SYMBOL", 
                      "INFILE_SYMBOL", "INITIAL_SIZE_SYMBOL", "INNER_SYMBOL", 
                      "INOUT_SYMBOL", "INSENSITIVE_SYMBOL", "INSERT_SYMBOL", 
                      "INSERT_METHOD_SYMBOL", "INSTANCE_SYMBOL", "INSTALL_SYMBOL", 
                      "INTERVAL_SYMBOL", "INTO_SYMBOL", "INT_SYMBOL", "INVOKER_SYMBOL", 
                      "IN_SYMBOL", "IO_AFTER_GTIDS_SYMBOL", "IO_BEFORE_GTIDS_SYMBOL", 
                      "IO_SYMBOL", "IPC_SYMBOL", "IS_SYMBOL", "ISOLATION_SYMBOL", 
                      "ISSUER_SYMBOL", "ITERATE_SYMBOL", "JOIN_SYMBOL", 
                      "JSON_SYMBOL", "KEYS_SYMBOL", "KEY_BLOCK_SIZE_SYMBOL", 
                      "KEY_SYMBOL", "KILL_SYMBOL", "LANGUAGE_SYMBOL", "LAST_SYMBOL", 
                      "LEADING_SYMBOL", "LEAVES_SYMBOL", "LEAVE_SYMBOL", 
                      "LEFT_SYMBOL", "LESS_SYMBOL", "LEVEL_SYMBOL", "LIKE_SYMBOL", 
                      "LIMIT_SYMBOL", "LINEAR_SYMBOL", "LINES_SYMBOL", "LINESTRING_SYMBOL", 
                      "LIST_SYMBOL", "LOAD_SYMBOL", "LOCAL_SYMBOL", "LOCKS_SYMBOL", 
                      "LOCK_SYMBOL", "LOGFILE_SYMBOL", "LOGS_SYMBOL", "LONGBLOB_SYMBOL", 
                      "LONGTEXT_SYMBOL", "LONG_SYMBOL", "LOOP_SYMBOL", "LOW_PRIORITY_SYMBOL", 
                      "MASTER_AUTO_POSITION_SYMBOL", "MASTER_BIND_SYMBOL", 
                      "MASTER_CONNECT_RETRY_SYMBOL", "MASTER_DELAY_SYMBOL", 
                      "MASTER_HOST_SYMBOL", "MASTER_LOG_FILE_SYMBOL", "MASTER_LOG_POS_SYMBOL", 
                      "MASTER_PASSWORD_SYMBOL", "MASTER_PORT_SYMBOL", "MASTER_RETRY_COUNT_SYMBOL", 
                      "MASTER_SSL_CAPATH_SYMBOL", "MASTER_SSL_CA_SYMBOL", 
                      "MASTER_SSL_CERT_SYMBOL", "MASTER_SSL_CIPHER_SYMBOL", 
                      "MASTER_SSL_CRL_SYMBOL", "MASTER_SSL_CRLPATH_SYMBOL", 
                      "MASTER_SSL_KEY_SYMBOL", "MASTER_SSL_SYMBOL", "MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL", 
                      "MASTER_SYMBOL", "MASTER_TLS_VERSION_SYMBOL", "MASTER_USER_SYMBOL", 
                      "MASTER_HEARTBEAT_PERIOD_SYMBOL", "MATCH_SYMBOL", 
                      "MAX_CONNECTIONS_PER_HOUR_SYMBOL", "MAX_QUERIES_PER_HOUR_SYMBOL", 
                      "MAX_ROWS_SYMBOL", "MAX_SIZE_SYMBOL", "MAX_SYMBOL", 
                      "MAX_UPDATES_PER_HOUR_SYMBOL", "MAX_USER_CONNECTIONS_SYMBOL", 
                      "MAXVALUE_SYMBOL", "MEDIUMBLOB_SYMBOL", "MEDIUMINT_SYMBOL", 
                      "MEDIUMTEXT_SYMBOL", "MEDIUM_SYMBOL", "MEMORY_SYMBOL", 
                      "MERGE_SYMBOL", "MESSAGE_TEXT_SYMBOL", "MICROSECOND_SYMBOL", 
                      "MID_SYMBOL", "MIGRATE_SYMBOL", "MINUTE_MICROSECOND_SYMBOL", 
                      "MINUTE_SECOND_SYMBOL", "MINUTE_SYMBOL", "MIN_ROWS_SYMBOL", 
                      "MIN_SYMBOL", "MODE_SYMBOL", "MODIFIES_SYMBOL", "MODIFY_SYMBOL", 
                      "MOD_SYMBOL", "MONTH_SYMBOL", "MULTILINESTRING_SYMBOL", 
                      "MULTIPOINT_SYMBOL", "MULTIPOLYGON_SYMBOL", "MUTEX_SYMBOL", 
                      "MYSQL_ERRNO_SYMBOL", "NAMES_SYMBOL", "NAME_SYMBOL", 
                      "NATIONAL_SYMBOL", "NATURAL_SYMBOL", "NCHAR_SYMBOL", 
                      "NDBCLUSTER_SYMBOL", "NEVER_SYMBOL", "NEW_SYMBOL", 
                      "NEXT_SYMBOL", "NODEGROUP_SYMBOL", "NONE_SYMBOL", 
                      "NOT_SYMBOL", "NOW_SYMBOL", "NO_SYMBOL", "NO_WAIT_SYMBOL", 
                      "NO_WRITE_TO_BINLOG_SYMBOL", "NULL_SYMBOL", "NUMBER_SYMBOL", 
                      "NUMERIC_SYMBOL", "NVARCHAR_SYMBOL", "OFFLINE_SYMBOL", 
                      "OFFSET_SYMBOL", "ON_SYMBOL", "ONE_SYMBOL", "ONLINE_SYMBOL", 
                      "ONLY_SYMBOL", "OPEN_SYMBOL", "OPTIMIZE_SYMBOL", "OPTIMIZER_COSTS_SYMBOL", 
                      "OPTIONS_SYMBOL", "OPTION_SYMBOL", "OPTIONALLY_SYMBOL", 
                      "ORDER_SYMBOL", "OR_SYMBOL", "OUTER_SYMBOL", "OUTFILE_SYMBOL", 
                      "OUT_SYMBOL", "OWNER_SYMBOL", "PACK_KEYS_SYMBOL", 
                      "PAGE_SYMBOL", "PARSER_SYMBOL", "PARTIAL_SYMBOL", 
                      "PARTITIONING_SYMBOL", "PARTITIONS_SYMBOL", "PARTITION_SYMBOL", 
                      "PASSWORD_SYMBOL", "PHASE_SYMBOL", "PLUGINS_SYMBOL", 
                      "PLUGIN_DIR_SYMBOL", "PLUGIN_SYMBOL", "POINT_SYMBOL", 
                      "POLYGON_SYMBOL", "PORT_SYMBOL", "POSITION_SYMBOL", 
                      "PRECEDES_SYMBOL", "PRECISION_SYMBOL", "PREPARE_SYMBOL", 
                      "PRESERVE_SYMBOL", "PREV_SYMBOL", "PRIMARY_SYMBOL", 
                      "PRIVILEGES_SYMBOL", "PROCEDURE_SYMBOL", "PROCESS_SYMBOL", 
                      "PROCESSLIST_SYMBOL", "PROFILE_SYMBOL", "PROFILES_SYMBOL", 
                      "PROXY_SYMBOL", "PURGE_SYMBOL", "QUARTER_SYMBOL", 
                      "QUERY_SYMBOL", "QUICK_SYMBOL", "RANGE_SYMBOL", "READS_SYMBOL", 
                      "READ_ONLY_SYMBOL", "READ_SYMBOL", "READ_WRITE_SYMBOL", 
                      "REAL_SYMBOL", "REBUILD_SYMBOL", "RECOVER_SYMBOL", 
                      "REDO_BUFFER_SIZE_SYMBOL", "REDUNDANT_SYMBOL", "REFERENCES_SYMBOL", 
                      "REGEXP_SYMBOL", "RELAY_SYMBOL", "RELAYLOG_SYMBOL", 
                      "RELAY_LOG_FILE_SYMBOL", "RELAY_LOG_POS_SYMBOL", "RELAY_THREAD_SYMBOL", 
                      "RELEASE_SYMBOL", "RELOAD_SYMBOL", "REMOVE_SYMBOL", 
                      "RENAME_SYMBOL", "REORGANIZE_SYMBOL", "REPAIR_SYMBOL", 
                      "REPEATABLE_SYMBOL", "REPEAT_SYMBOL", "REPLACE_SYMBOL", 
                      "REPLICATION_SYMBOL", "REPLICATE_DO_DB_SYMBOL", "REPLICATE_IGNORE_DB_SYMBOL", 
                      "REPLICATE_DO_TABLE_SYMBOL", "REPLICATE_IGNORE_TABLE_SYMBOL", 
                      "REPLICATE_WILD_DO_TABLE_SYMBOL", "REPLICATE_WILD_IGNORE_TABLE_SYMBOL", 
                      "REPLICATE_REWRITE_DB_SYMBOL", "REQUIRE_SYMBOL", "RESET_SYMBOL", 
                      "RESIGNAL_SYMBOL", "RESTORE_SYMBOL", "RESTRICT_SYMBOL", 
                      "RESUME_SYMBOL", "RETURNED_SQLSTATE_SYMBOL", "RETURNS_SYMBOL", 
                      "RETURN_SYMBOL", "REVERSE_SYMBOL", "REVOKE_SYMBOL", 
                      "RIGHT_SYMBOL", "ROLLBACK_SYMBOL", "ROLLUP_SYMBOL", 
                      "ROTATE_SYMBOL", "ROUTINE_SYMBOL", "ROWS_SYMBOL", 
                      "ROW_COUNT_SYMBOL", "ROW_FORMAT_SYMBOL", "ROW_SYMBOL", 
                      "RTREE_SYMBOL", "SAVEPOINT_SYMBOL", "SCHEDULE_SYMBOL", 
                      "SCHEMA_NAME_SYMBOL", "SECOND_MICROSECOND_SYMBOL", 
                      "SECOND_SYMBOL", "SECURITY_SYMBOL", "SELECT_SYMBOL", 
                      "SENSITIVE_SYMBOL", "SEPARATOR_SYMBOL", "SERIALIZABLE_SYMBOL", 
                      "SERIAL_SYMBOL", "SESSION_SYMBOL", "SERVER_SYMBOL", 
                      "SESSION_USER_SYMBOL", "SET_SYMBOL", "SHARE_SYMBOL", 
                      "SHOW_SYMBOL", "SHUTDOWN_SYMBOL", "SIGNAL_SYMBOL", 
                      "SIGNED_SYMBOL", "SIMPLE_SYMBOL", "SLAVE_SYMBOL", 
                      "SLOW_SYMBOL", "SMALLINT_SYMBOL", "SNAPSHOT_SYMBOL", 
                      "SOCKET_SYMBOL", "SONAME_SYMBOL", "SOUNDS_SYMBOL", 
                      "SOURCE_SYMBOL", "SPATIAL_SYMBOL", "SPECIFIC_SYMBOL", 
                      "SQLEXCEPTION_SYMBOL", "SQLSTATE_SYMBOL", "SQLWARNING_SYMBOL", 
                      "SQL_AFTER_GTIDS_SYMBOL", "SQL_AFTER_MTS_GAPS_SYMBOL", 
                      "SQL_BEFORE_GTIDS_SYMBOL", "SQL_BIG_RESULT_SYMBOL", 
                      "SQL_BUFFER_RESULT_SYMBOL", "SQL_CALC_FOUND_ROWS_SYMBOL", 
                      "SQL_NO_CACHE_SYMBOL", "SQL_SMALL_RESULT_SYMBOL", 
                      "SQL_SYMBOL", "SQL_THREAD_SYMBOL", "SSL_SYMBOL", "STACKED_SYMBOL", 
                      "STARTING_SYMBOL", "STARTS_SYMBOL", "START_SYMBOL", 
                      "STATS_AUTO_RECALC_SYMBOL", "STATS_PERSISTENT_SYMBOL", 
                      "STATS_SAMPLE_PAGES_SYMBOL", "STATUS_SYMBOL", "STDDEV_SAMP_SYMBOL", 
                      "STDDEV_SYMBOL", "STDDEV_POP_SYMBOL", "STD_SYMBOL", 
                      "STOP_SYMBOL", "STORAGE_SYMBOL", "STORED_SYMBOL", 
                      "STRAIGHT_JOIN_SYMBOL", "STRING_SYMBOL", "SUBCLASS_ORIGIN_SYMBOL", 
                      "SUBDATE_SYMBOL", "SUBJECT_SYMBOL", "SUBPARTITIONS_SYMBOL", 
                      "SUBPARTITION_SYMBOL", "SUBSTR_SYMBOL", "SUBSTRING_SYMBOL", 
                      "SUM_SYMBOL", "SUPER_SYMBOL", "SUSPEND_SYMBOL", "SWAPS_SYMBOL", 
                      "SWITCHES_SYMBOL", "SYSDATE_SYMBOL", "SYSTEM_USER_SYMBOL", 
                      "TABLES_SYMBOL", "TABLESPACE_SYMBOL", "TABLE_SYMBOL", 
                      "TABLE_CHECKSUM_SYMBOL", "TABLE_NAME_SYMBOL", "TEMPORARY_SYMBOL", 
                      "TEMPTABLE_SYMBOL", "TERMINATED_SYMBOL", "TEXT_SYMBOL", 
                      "THAN_SYMBOL", "THEN_SYMBOL", "TIMESTAMP_SYMBOL", 
                      "TIMESTAMPADD_SYMBOL", "TIMESTAMPDIFF_SYMBOL", "TIME_SYMBOL", 
                      "TINYBLOB_SYMBOL", "TINYINT_SYMBOL", "TINYTEXT_SYMBOL", 
                      "TO_SYMBOL", "TRAILING_SYMBOL", "TRANSACTION_SYMBOL", 
                      "TRIGGERS_SYMBOL", "TRIGGER_SYMBOL", "TRIM_SYMBOL", 
                      "TRUE_SYMBOL", "TRUNCATE_SYMBOL", "TYPES_SYMBOL", 
                      "TYPE_SYMBOL", "UDF_RETURNS_SYMBOL", "UNCOMMITTED_SYMBOL", 
                      "UNDEFINED_SYMBOL", "UNDOFILE_SYMBOL", "UNDO_BUFFER_SIZE_SYMBOL", 
                      "UNDO_SYMBOL", "UNICODE_SYMBOL", "UNINSTALL_SYMBOL", 
                      "UNION_SYMBOL", "UNIQUE_SYMBOL", "UNKNOWN_SYMBOL", 
                      "UNLOCK_SYMBOL", "UNSIGNED_SYMBOL", "UNTIL_SYMBOL", 
                      "UPDATE_SYMBOL", "UPGRADE_SYMBOL", "USAGE_SYMBOL", 
                      "USER_RESOURCES_SYMBOL", "USER_SYMBOL", "USE_FRM_SYMBOL", 
                      "USE_SYMBOL", "USING_SYMBOL", "UTC_DATE_SYMBOL", "UTC_TIMESTAMP_SYMBOL", 
                      "UTC_TIME_SYMBOL", "VALIDATION_SYMBOL", "VALUES_SYMBOL", 
                      "VALUE_SYMBOL", "VARBINARY_SYMBOL", "VARCHAR_SYMBOL", 
                      "VARIABLES_SYMBOL", "VARIANCE_SYMBOL", "VARYING_SYMBOL", 
                      "VAR_POP_SYMBOL", "VAR_SAMP_SYMBOL", "VIEW_SYMBOL", 
                      "VIRTUAL_SYMBOL", "WAIT_SYMBOL", "WARNINGS_SYMBOL", 
                      "WEEK_SYMBOL", "WEIGHT_STRING_SYMBOL", "WHEN_SYMBOL", 
                      "WHERE_SYMBOL", "WHILE_SYMBOL", "WITH_SYMBOL", "WITHOUT_SYMBOL", 
                      "WORK_SYMBOL", "WRAPPER_SYMBOL", "WRITE_SYMBOL", "X509_SYMBOL", 
                      "XA_SYMBOL", "XID_SYMBOL", "XML_SYMBOL", "XOR_SYMBOL", 
                      "YEAR_MONTH_SYMBOL", "YEAR_SYMBOL", "ZEROFILL_SYMBOL", 
                      "PERSIST_SYMBOL", "ROLE_SYMBOL", "ADMIN_SYMBOL", "INVISIBLE_SYMBOL", 
                      "VISIBLE_SYMBOL", "EXCEPT_SYMBOL", "COMPONENT_SYMBOL", 
                      "RECURSIVE_SYMBOL", "JSON_OBJECTAGG_SYMBOL", "JSON_ARRAYAGG_SYMBOL", 
                      "OF_SYMBOL", "SKIP_SYMBOL", "LOCKED_SYMBOL", "NOWAIT_SYMBOL", 
                      "GROUPING_SYMBOL", "PERSIST_ONLY_SYMBOL", "HISTOGRAM_SYMBOL", 
                      "BUCKETS_SYMBOL", "REMOTE_SYMBOL", "CLONE_SYMBOL", 
                      "CUME_DIST_SYMBOL", "DENSE_RANK_SYMBOL", "EXCLUDE_SYMBOL", 
                      "FIRST_VALUE_SYMBOL", "FOLLOWING_SYMBOL", "GROUPS_SYMBOL", 
                      "LAG_SYMBOL", "LAST_VALUE_SYMBOL", "LEAD_SYMBOL", 
                      "NTH_VALUE_SYMBOL", "NTILE_SYMBOL", "NULLS_SYMBOL", 
                      "OTHERS_SYMBOL", "OVER_SYMBOL", "PERCENT_RANK_SYMBOL", 
                      "PRECEDING_SYMBOL", "RANK_SYMBOL", "RESPECT_SYMBOL", 
                      "ROW_NUMBER_SYMBOL", "TIES_SYMBOL", "UNBOUNDED_SYMBOL", 
                      "WINDOW_SYMBOL", "EMPTY_SYMBOL", "JSON_TABLE_SYMBOL", 
                      "NESTED_SYMBOL", "ORDINALITY_SYMBOL", "PATH_SYMBOL", 
                      "HISTORY_SYMBOL", "REUSE_SYMBOL", "SRID_SYMBOL", "THREAD_PRIORITY_SYMBOL", 
                      "RESOURCE_SYMBOL", "SYSTEM_SYMBOL", "VCPU_SYMBOL", 
                      "MASTER_PUBLIC_KEY_PATH_SYMBOL", "GET_MASTER_PUBLIC_KEY_SYMBOL", 
                      "RESTART_SYMBOL", "DEFINITION_SYMBOL", "DESCRIPTION_SYMBOL", 
                      "ORGANIZATION_SYMBOL", "REFERENCE_SYMBOL", "OPTIONAL_SYMBOL", 
                      "SECONDARY_SYMBOL", "SECONDARY_ENGINE_SYMBOL", "SECONDARY_LOAD_SYMBOL", 
                      "SECONDARY_UNLOAD_SYMBOL", "ACTIVE_SYMBOL", "INACTIVE_SYMBOL", 
                      "LATERAL_SYMBOL", "RETAIN_SYMBOL", "OLD_SYMBOL", "NETWORK_NAMESPACE_SYMBOL", 
                      "ENFORCED_SYMBOL", "ARRAY_SYMBOL", "OJ_SYMBOL", "MEMBER_SYMBOL", 
                      "RANDOM_SYMBOL", "MASTER_COMPRESSION_ALGORITHM_SYMBOL", 
                      "MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL", "PRIVILEGE_CHECKS_USER_SYMBOL", 
                      "MASTER_TLS_CIPHERSUITES_SYMBOL", "REQUIRE_ROW_FORMAT_SYMBOL", 
                      "PASSWORD_LOCK_TIME_SYMBOL", "FAILED_LOGIN_ATTEMPTS_SYMBOL", 
                      "REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL", "STREAM_SYMBOL", 
                      "OFF_SYMBOL", "RETURNING_SYMBOL", "JSON_VALUE_SYMBOL", 
                      "TLS_SYMBOL", "ATTRIBUTE_SYMBOL", "ENGINE_ATTRIBUTE_SYMBOL", 
                      "SECONDARY_ENGINE_ATTRIBUTE_SYMBOL", "SOURCE_CONNECTION_AUTO_FAILOVER_SYMBOL", 
                      "ZONE_SYMBOL", "GRAMMAR_SELECTOR_DERIVED_EXPR", "REPLICA_SYMBOL", 
                      "REPLICAS_SYMBOL", "ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_SYMBOL", 
                      "GET_SOURCE_PUBLIC_KEY_SYMBOL", "SOURCE_AUTO_POSITION_SYMBOL", 
                      "SOURCE_BIND_SYMBOL", "SOURCE_COMPRESSION_ALGORITHM_SYMBOL", 
                      "SOURCE_CONNECT_RETRY_SYMBOL", "SOURCE_DELAY_SYMBOL", 
                      "SOURCE_HEARTBEAT_PERIOD_SYMBOL", "SOURCE_HOST_SYMBOL", 
                      "SOURCE_LOG_FILE_SYMBOL", "SOURCE_LOG_POS_SYMBOL", 
                      "SOURCE_PASSWORD_SYMBOL", "SOURCE_PORT_SYMBOL", "SOURCE_PUBLIC_KEY_PATH_SYMBOL", 
                      "SOURCE_RETRY_COUNT_SYMBOL", "SOURCE_SSL_SYMBOL", 
                      "SOURCE_SSL_CA_SYMBOL", "SOURCE_SSL_CAPATH_SYMBOL", 
                      "SOURCE_SSL_CERT_SYMBOL", "SOURCE_SSL_CIPHER_SYMBOL", 
                      "SOURCE_SSL_CRL_SYMBOL", "SOURCE_SSL_CRLPATH_SYMBOL", 
                      "SOURCE_SSL_KEY_SYMBOL", "SOURCE_SSL_VERIFY_SERVER_CERT_SYMBOL", 
                      "SOURCE_TLS_CIPHERSUITES_SYMBOL", "SOURCE_TLS_VERSION_SYMBOL", 
                      "SOURCE_USER_SYMBOL", "SOURCE_ZSTD_COMPRESSION_LEVEL_SYMBOL", 
                      "ST_COLLECT_SYMBOL", "KEYRING_SYMBOL", "AUTHENTICATION_SYMBOL", 
                      "FACTOR_SYMBOL", "FINISH_SYMBOL", "INITIATE_SYMBOL", 
                      "REGISTRATION_SYMBOL", "UNREGISTER_SYMBOL", "INITIAL_SYMBOL", 
                      "CHALLENGE_RESPONSE_SYMBOL", "GTID_ONLY_SYMBOL", "INTERSECT_SYMBOL", 
                      "BULK_SYMBOL", "URL_SYMBOL", "GENERATE_SYMBOL", "PARSE_TREE_SYMBOL", 
                      "LOG_SYMBOL", "GTIDS_SYMBOL", "PARALLEL_SYMBOL", "S3_SYMBOL", 
                      "QUALIFY_SYMBOL", "AUTO_SYMBOL", "MANUAL_SYMBOL", 
                      "BERNOULLI_SYMBOL", "TABLESAMPLE_SYMBOL", "WHITESPACE", 
                      "INVALID_INPUT", "UNDERSCORE_CHARSET", "DOLLAR_QUOTED_STRING_TEXT", 
                      "IDENTIFIER", "NCHAR_TEXT", "BACK_TICK_QUOTED_ID", 
                      "DOUBLE_QUOTED_TEXT", "SINGLE_QUOTED_TEXT", "VERSION_COMMENT_START", 
                      "MYSQL_COMMENT_START", "VERSION_COMMENT_END", "BLOCK_COMMENT", 
                      "INVALID_BLOCK_COMMENT", "POUND_COMMENT", "DASHDASH_COMMENT", 
                      "NOT_EQUAL2_OPERATOR" ]

    RULE_queries = 0
    RULE_query = 1
    RULE_simpleStatement = 2
    RULE_alterStatement = 3
    RULE_alterDatabase = 4
    RULE_alterDatabaseOption = 5
    RULE_alterEvent = 6
    RULE_alterLogfileGroup = 7
    RULE_alterLogfileGroupOptions = 8
    RULE_alterLogfileGroupOption = 9
    RULE_alterServer = 10
    RULE_alterTable = 11
    RULE_alterTableActions = 12
    RULE_alterCommandList = 13
    RULE_alterCommandsModifierList = 14
    RULE_standaloneAlterCommands = 15
    RULE_alterPartition = 16
    RULE_alterList = 17
    RULE_alterCommandsModifier = 18
    RULE_alterListItem = 19
    RULE_place = 20
    RULE_restrict = 21
    RULE_alterOrderList = 22
    RULE_alterAlgorithmOption = 23
    RULE_alterLockOption = 24
    RULE_indexLockAndAlgorithm = 25
    RULE_withValidation = 26
    RULE_removePartitioning = 27
    RULE_allOrPartitionNameList = 28
    RULE_alterTablespace = 29
    RULE_alterUndoTablespace = 30
    RULE_undoTableSpaceOptions = 31
    RULE_undoTableSpaceOption = 32
    RULE_alterTablespaceOptions = 33
    RULE_alterTablespaceOption = 34
    RULE_changeTablespaceOption = 35
    RULE_alterView = 36
    RULE_viewTail = 37
    RULE_viewQueryBlock = 38
    RULE_viewCheckOption = 39
    RULE_alterInstanceStatement = 40
    RULE_createStatement = 41
    RULE_createDatabase = 42
    RULE_createDatabaseOption = 43
    RULE_createTable = 44
    RULE_tableElementList = 45
    RULE_tableElement = 46
    RULE_duplicateAsQe = 47
    RULE_asCreateQueryExpression = 48
    RULE_queryExpressionOrParens = 49
    RULE_queryExpressionWithOptLockingClauses = 50
    RULE_createRoutine = 51
    RULE_createProcedure = 52
    RULE_routineString = 53
    RULE_storedRoutineBody = 54
    RULE_createFunction = 55
    RULE_createUdf = 56
    RULE_routineCreateOption = 57
    RULE_routineAlterOptions = 58
    RULE_routineOption = 59
    RULE_createIndex = 60
    RULE_indexNameAndType = 61
    RULE_createIndexTarget = 62
    RULE_createLogfileGroup = 63
    RULE_logfileGroupOptions = 64
    RULE_logfileGroupOption = 65
    RULE_createServer = 66
    RULE_serverOptions = 67
    RULE_serverOption = 68
    RULE_createTablespace = 69
    RULE_createUndoTablespace = 70
    RULE_tsDataFileName = 71
    RULE_tsDataFile = 72
    RULE_tablespaceOptions = 73
    RULE_tablespaceOption = 74
    RULE_tsOptionInitialSize = 75
    RULE_tsOptionUndoRedoBufferSize = 76
    RULE_tsOptionAutoextendSize = 77
    RULE_tsOptionMaxSize = 78
    RULE_tsOptionExtentSize = 79
    RULE_tsOptionNodegroup = 80
    RULE_tsOptionEngine = 81
    RULE_tsOptionWait = 82
    RULE_tsOptionComment = 83
    RULE_tsOptionFileblockSize = 84
    RULE_tsOptionEncryption = 85
    RULE_tsOptionEngineAttribute = 86
    RULE_createView = 87
    RULE_viewReplaceOrAlgorithm = 88
    RULE_viewAlgorithm = 89
    RULE_viewSuid = 90
    RULE_createTrigger = 91
    RULE_triggerFollowsPrecedesClause = 92
    RULE_createEvent = 93
    RULE_createRole = 94
    RULE_createSpatialReference = 95
    RULE_srsAttribute = 96
    RULE_dropStatement = 97
    RULE_dropDatabase = 98
    RULE_dropEvent = 99
    RULE_dropFunction = 100
    RULE_dropProcedure = 101
    RULE_dropIndex = 102
    RULE_dropLogfileGroup = 103
    RULE_dropLogfileGroupOption = 104
    RULE_dropServer = 105
    RULE_dropTable = 106
    RULE_dropTableSpace = 107
    RULE_dropTrigger = 108
    RULE_dropView = 109
    RULE_dropRole = 110
    RULE_dropSpatialReference = 111
    RULE_dropUndoTablespace = 112
    RULE_renameTableStatement = 113
    RULE_renamePair = 114
    RULE_truncateTableStatement = 115
    RULE_importStatement = 116
    RULE_callStatement = 117
    RULE_deleteStatement = 118
    RULE_partitionDelete = 119
    RULE_deleteStatementOption = 120
    RULE_doStatement = 121
    RULE_handlerStatement = 122
    RULE_handlerReadOrScan = 123
    RULE_insertStatement = 124
    RULE_insertLockOption = 125
    RULE_insertFromConstructor = 126
    RULE_fields = 127
    RULE_insertValues = 128
    RULE_insertQueryExpression = 129
    RULE_valueList = 130
    RULE_values = 131
    RULE_valuesReference = 132
    RULE_insertUpdateList = 133
    RULE_loadStatement = 134
    RULE_dataOrXml = 135
    RULE_loadDataLock = 136
    RULE_loadFrom = 137
    RULE_loadSourceType = 138
    RULE_sourceCount = 139
    RULE_sourceOrder = 140
    RULE_xmlRowsIdentifiedBy = 141
    RULE_loadDataFileTail = 142
    RULE_loadDataFileTargetList = 143
    RULE_fieldOrVariableList = 144
    RULE_loadAlgorithm = 145
    RULE_loadParallel = 146
    RULE_loadMemory = 147
    RULE_replaceStatement = 148
    RULE_selectStatement = 149
    RULE_selectStatementWithInto = 150
    RULE_queryExpression = 151
    RULE_queryExpressionBody = 152
    RULE_queryExpressionParens = 153
    RULE_queryPrimary = 154
    RULE_querySpecification = 155
    RULE_subquery = 156
    RULE_querySpecOption = 157
    RULE_limitClause = 158
    RULE_simpleLimitClause = 159
    RULE_limitOptions = 160
    RULE_limitOption = 161
    RULE_intoClause = 162
    RULE_procedureAnalyseClause = 163
    RULE_havingClause = 164
    RULE_qualifyClause = 165
    RULE_windowClause = 166
    RULE_windowDefinition = 167
    RULE_windowSpec = 168
    RULE_windowSpecDetails = 169
    RULE_windowFrameClause = 170
    RULE_windowFrameUnits = 171
    RULE_windowFrameExtent = 172
    RULE_windowFrameStart = 173
    RULE_windowFrameBetween = 174
    RULE_windowFrameBound = 175
    RULE_windowFrameExclusion = 176
    RULE_withClause = 177
    RULE_commonTableExpression = 178
    RULE_groupByClause = 179
    RULE_olapOption = 180
    RULE_orderClause = 181
    RULE_direction = 182
    RULE_fromClause = 183
    RULE_tableReferenceList = 184
    RULE_tableValueConstructor = 185
    RULE_explicitTable = 186
    RULE_rowValueExplicit = 187
    RULE_selectOption = 188
    RULE_lockingClauseList = 189
    RULE_lockingClause = 190
    RULE_lockStrengh = 191
    RULE_lockedRowAction = 192
    RULE_selectItemList = 193
    RULE_selectItem = 194
    RULE_selectAlias = 195
    RULE_whereClause = 196
    RULE_tableReference = 197
    RULE_escapedTableReference = 198
    RULE_joinedTable = 199
    RULE_naturalJoinType = 200
    RULE_innerJoinType = 201
    RULE_outerJoinType = 202
    RULE_tableFactor = 203
    RULE_singleTable = 204
    RULE_singleTableParens = 205
    RULE_derivedTable = 206
    RULE_tableReferenceListParens = 207
    RULE_tableFunction = 208
    RULE_columnsClause = 209
    RULE_jtColumn = 210
    RULE_onEmptyOrError = 211
    RULE_onEmptyOrErrorJsonTable = 212
    RULE_onEmpty = 213
    RULE_onError = 214
    RULE_jsonOnResponse = 215
    RULE_unionOption = 216
    RULE_tableAlias = 217
    RULE_indexHintList = 218
    RULE_indexHint = 219
    RULE_indexHintType = 220
    RULE_keyOrIndex = 221
    RULE_constraintKeyType = 222
    RULE_indexHintClause = 223
    RULE_indexList = 224
    RULE_indexListElement = 225
    RULE_updateStatement = 226
    RULE_transactionOrLockingStatement = 227
    RULE_transactionStatement = 228
    RULE_beginWork = 229
    RULE_startTransactionOptionList = 230
    RULE_savepointStatement = 231
    RULE_lockStatement = 232
    RULE_lockItem = 233
    RULE_lockOption = 234
    RULE_xaStatement = 235
    RULE_xaConvert = 236
    RULE_xid = 237
    RULE_replicationStatement = 238
    RULE_purgeOptions = 239
    RULE_resetOption = 240
    RULE_masterOrBinaryLogsAndGtids = 241
    RULE_sourceResetOptions = 242
    RULE_replicationLoad = 243
    RULE_changeReplicationSource = 244
    RULE_changeSource = 245
    RULE_sourceDefinitions = 246
    RULE_sourceDefinition = 247
    RULE_changeReplicationSourceAutoPosition = 248
    RULE_changeReplicationSourceHost = 249
    RULE_changeReplicationSourceBind = 250
    RULE_changeReplicationSourceUser = 251
    RULE_changeReplicationSourcePassword = 252
    RULE_changeReplicationSourcePort = 253
    RULE_changeReplicationSourceConnectRetry = 254
    RULE_changeReplicationSourceRetryCount = 255
    RULE_changeReplicationSourceDelay = 256
    RULE_changeReplicationSourceSSL = 257
    RULE_changeReplicationSourceSSLCA = 258
    RULE_changeReplicationSourceSSLCApath = 259
    RULE_changeReplicationSourceSSLCipher = 260
    RULE_changeReplicationSourceSSLCLR = 261
    RULE_changeReplicationSourceSSLCLRpath = 262
    RULE_changeReplicationSourceSSLKey = 263
    RULE_changeReplicationSourceSSLVerifyServerCert = 264
    RULE_changeReplicationSourceTLSVersion = 265
    RULE_changeReplicationSourceTLSCiphersuites = 266
    RULE_changeReplicationSourceSSLCert = 267
    RULE_changeReplicationSourcePublicKey = 268
    RULE_changeReplicationSourceGetSourcePublicKey = 269
    RULE_changeReplicationSourceHeartbeatPeriod = 270
    RULE_changeReplicationSourceCompressionAlgorithm = 271
    RULE_changeReplicationSourceZstdCompressionLevel = 272
    RULE_privilegeCheckDef = 273
    RULE_tablePrimaryKeyCheckDef = 274
    RULE_assignGtidsToAnonymousTransactionsDefinition = 275
    RULE_sourceTlsCiphersuitesDef = 276
    RULE_sourceFileDef = 277
    RULE_sourceLogFile = 278
    RULE_sourceLogPos = 279
    RULE_serverIdList = 280
    RULE_changeReplication = 281
    RULE_filterDefinition = 282
    RULE_filterDbList = 283
    RULE_filterTableList = 284
    RULE_filterStringList = 285
    RULE_filterWildDbTableString = 286
    RULE_filterDbPairList = 287
    RULE_startReplicaStatement = 288
    RULE_stopReplicaStatement = 289
    RULE_replicaUntil = 290
    RULE_userOption = 291
    RULE_passwordOption = 292
    RULE_defaultAuthOption = 293
    RULE_pluginDirOption = 294
    RULE_replicaThreadOptions = 295
    RULE_replicaThreadOption = 296
    RULE_groupReplication = 297
    RULE_groupReplicationStartOptions = 298
    RULE_groupReplicationStartOption = 299
    RULE_groupReplicationUser = 300
    RULE_groupReplicationPassword = 301
    RULE_groupReplicationPluginAuth = 302
    RULE_replica = 303
    RULE_preparedStatement = 304
    RULE_executeStatement = 305
    RULE_executeVarList = 306
    RULE_cloneStatement = 307
    RULE_dataDirSSL = 308
    RULE_ssl = 309
    RULE_accountManagementStatement = 310
    RULE_alterUserStatement = 311
    RULE_alterUserList = 312
    RULE_alterUser = 313
    RULE_oldAlterUser = 314
    RULE_userFunction = 315
    RULE_createUserStatement = 316
    RULE_createUserTail = 317
    RULE_userAttributes = 318
    RULE_defaultRoleClause = 319
    RULE_requireClause = 320
    RULE_connectOptions = 321
    RULE_accountLockPasswordExpireOptions = 322
    RULE_userAttribute = 323
    RULE_dropUserStatement = 324
    RULE_grantStatement = 325
    RULE_grantTargetList = 326
    RULE_grantOptions = 327
    RULE_exceptRoleList = 328
    RULE_withRoles = 329
    RULE_grantAs = 330
    RULE_versionedRequireClause = 331
    RULE_renameUserStatement = 332
    RULE_revokeStatement = 333
    RULE_aclType = 334
    RULE_roleOrPrivilegesList = 335
    RULE_roleOrPrivilege = 336
    RULE_grantIdentifier = 337
    RULE_requireList = 338
    RULE_requireListElement = 339
    RULE_grantOption = 340
    RULE_setRoleStatement = 341
    RULE_roleList = 342
    RULE_role = 343
    RULE_tableAdministrationStatement = 344
    RULE_histogramAutoUpdate = 345
    RULE_histogramUpdateParam = 346
    RULE_histogramNumBuckets = 347
    RULE_histogram = 348
    RULE_checkOption = 349
    RULE_repairType = 350
    RULE_uninstallStatement = 351
    RULE_installStatement = 352
    RULE_installOptionType = 353
    RULE_installSetRvalue = 354
    RULE_installSetValue = 355
    RULE_installSetValueList = 356
    RULE_setStatement = 357
    RULE_startOptionValueList = 358
    RULE_transactionCharacteristics = 359
    RULE_transactionAccessMode = 360
    RULE_isolationLevel = 361
    RULE_optionValueListContinued = 362
    RULE_optionValueNoOptionType = 363
    RULE_optionValue = 364
    RULE_setSystemVariable = 365
    RULE_startOptionValueListFollowingOptionType = 366
    RULE_optionValueFollowingOptionType = 367
    RULE_setExprOrDefault = 368
    RULE_showDatabasesStatement = 369
    RULE_showTablesStatement = 370
    RULE_showTriggersStatement = 371
    RULE_showEventsStatement = 372
    RULE_showTableStatusStatement = 373
    RULE_showOpenTablesStatement = 374
    RULE_showParseTreeStatement = 375
    RULE_showPluginsStatement = 376
    RULE_showEngineLogsStatement = 377
    RULE_showEngineMutexStatement = 378
    RULE_showEngineStatusStatement = 379
    RULE_showColumnsStatement = 380
    RULE_showBinaryLogsStatement = 381
    RULE_showBinaryLogStatusStatement = 382
    RULE_showReplicasStatement = 383
    RULE_showBinlogEventsStatement = 384
    RULE_showRelaylogEventsStatement = 385
    RULE_showKeysStatement = 386
    RULE_showEnginesStatement = 387
    RULE_showCountWarningsStatement = 388
    RULE_showCountErrorsStatement = 389
    RULE_showWarningsStatement = 390
    RULE_showErrorsStatement = 391
    RULE_showProfilesStatement = 392
    RULE_showProfileStatement = 393
    RULE_showStatusStatement = 394
    RULE_showProcessListStatement = 395
    RULE_showVariablesStatement = 396
    RULE_showCharacterSetStatement = 397
    RULE_showCollationStatement = 398
    RULE_showPrivilegesStatement = 399
    RULE_showGrantsStatement = 400
    RULE_showCreateDatabaseStatement = 401
    RULE_showCreateTableStatement = 402
    RULE_showCreateViewStatement = 403
    RULE_showMasterStatusStatement = 404
    RULE_showReplicaStatusStatement = 405
    RULE_showCreateProcedureStatement = 406
    RULE_showCreateFunctionStatement = 407
    RULE_showCreateTriggerStatement = 408
    RULE_showCreateProcedureStatusStatement = 409
    RULE_showCreateFunctionStatusStatement = 410
    RULE_showCreateProcedureCodeStatement = 411
    RULE_showCreateFunctionCodeStatement = 412
    RULE_showCreateEventStatement = 413
    RULE_showCreateUserStatement = 414
    RULE_showCommandType = 415
    RULE_engineOrAll = 416
    RULE_fromOrIn = 417
    RULE_inDb = 418
    RULE_profileDefinitions = 419
    RULE_profileDefinition = 420
    RULE_otherAdministrativeStatement = 421
    RULE_keyCacheListOrParts = 422
    RULE_keyCacheList = 423
    RULE_assignToKeycache = 424
    RULE_assignToKeycachePartition = 425
    RULE_cacheKeyList = 426
    RULE_keyUsageElement = 427
    RULE_keyUsageList = 428
    RULE_flushOption = 429
    RULE_logType = 430
    RULE_flushTables = 431
    RULE_flushTablesOptions = 432
    RULE_preloadTail = 433
    RULE_preloadList = 434
    RULE_preloadKeys = 435
    RULE_adminPartition = 436
    RULE_resourceGroupManagement = 437
    RULE_createResourceGroup = 438
    RULE_resourceGroupVcpuList = 439
    RULE_vcpuNumOrRange = 440
    RULE_resourceGroupPriority = 441
    RULE_resourceGroupEnableDisable = 442
    RULE_alterResourceGroup = 443
    RULE_setResourceGroup = 444
    RULE_threadIdList = 445
    RULE_dropResourceGroup = 446
    RULE_utilityStatement = 447
    RULE_describeStatement = 448
    RULE_explainStatement = 449
    RULE_explainOptions = 450
    RULE_explainableStatement = 451
    RULE_explainInto = 452
    RULE_helpCommand = 453
    RULE_useCommand = 454
    RULE_restartServer = 455
    RULE_expr = 456
    RULE_boolPri = 457
    RULE_compOp = 458
    RULE_predicate = 459
    RULE_predicateOperations = 460
    RULE_bitExpr = 461
    RULE_simpleExpr = 462
    RULE_arrayCast = 463
    RULE_jsonOperator = 464
    RULE_sumExpr = 465
    RULE_groupingOperation = 466
    RULE_windowFunctionCall = 467
    RULE_samplingMethod = 468
    RULE_samplingPercentage = 469
    RULE_tablesampleClause = 470
    RULE_windowingClause = 471
    RULE_leadLagInfo = 472
    RULE_stableInteger = 473
    RULE_paramOrVar = 474
    RULE_nullTreatment = 475
    RULE_jsonFunction = 476
    RULE_inSumExpr = 477
    RULE_identListArg = 478
    RULE_identList = 479
    RULE_fulltextOptions = 480
    RULE_runtimeFunctionCall = 481
    RULE_returningType = 482
    RULE_geometryFunction = 483
    RULE_timeFunctionParameters = 484
    RULE_fractionalPrecision = 485
    RULE_weightStringLevels = 486
    RULE_weightStringLevelListItem = 487
    RULE_dateTimeTtype = 488
    RULE_trimFunction = 489
    RULE_substringFunction = 490
    RULE_functionCall = 491
    RULE_udfExprList = 492
    RULE_udfExpr = 493
    RULE_userVariable = 494
    RULE_inExpressionUserVariableAssignment = 495
    RULE_rvalueSystemOrUserVariable = 496
    RULE_lvalueVariable = 497
    RULE_rvalueSystemVariable = 498
    RULE_whenExpression = 499
    RULE_thenExpression = 500
    RULE_elseExpression = 501
    RULE_castType = 502
    RULE_exprList = 503
    RULE_charset = 504
    RULE_notRule = 505
    RULE_not2Rule = 506
    RULE_interval = 507
    RULE_intervalTimeStamp = 508
    RULE_exprListWithParentheses = 509
    RULE_exprWithParentheses = 510
    RULE_simpleExprWithParentheses = 511
    RULE_orderList = 512
    RULE_orderExpression = 513
    RULE_groupList = 514
    RULE_groupingExpression = 515
    RULE_channel = 516
    RULE_compoundStatement = 517
    RULE_returnStatement = 518
    RULE_ifStatement = 519
    RULE_ifBody = 520
    RULE_thenStatement = 521
    RULE_compoundStatementList = 522
    RULE_caseStatement = 523
    RULE_elseStatement = 524
    RULE_labeledBlock = 525
    RULE_unlabeledBlock = 526
    RULE_label = 527
    RULE_beginEndBlock = 528
    RULE_labeledControl = 529
    RULE_unlabeledControl = 530
    RULE_loopBlock = 531
    RULE_whileDoBlock = 532
    RULE_repeatUntilBlock = 533
    RULE_spDeclarations = 534
    RULE_spDeclaration = 535
    RULE_variableDeclaration = 536
    RULE_conditionDeclaration = 537
    RULE_spCondition = 538
    RULE_sqlstate = 539
    RULE_handlerDeclaration = 540
    RULE_handlerCondition = 541
    RULE_cursorDeclaration = 542
    RULE_iterateStatement = 543
    RULE_leaveStatement = 544
    RULE_getDiagnosticsStatement = 545
    RULE_signalAllowedExpr = 546
    RULE_statementInformationItem = 547
    RULE_conditionInformationItem = 548
    RULE_signalInformationItemName = 549
    RULE_signalStatement = 550
    RULE_resignalStatement = 551
    RULE_signalInformationItem = 552
    RULE_cursorOpen = 553
    RULE_cursorClose = 554
    RULE_cursorFetch = 555
    RULE_schedule = 556
    RULE_columnDefinition = 557
    RULE_checkOrReferences = 558
    RULE_checkConstraint = 559
    RULE_constraintEnforcement = 560
    RULE_tableConstraintDef = 561
    RULE_constraintName = 562
    RULE_fieldDefinition = 563
    RULE_columnAttribute = 564
    RULE_columnFormat = 565
    RULE_storageMedia = 566
    RULE_now = 567
    RULE_nowOrSignedLiteral = 568
    RULE_gcolAttribute = 569
    RULE_references = 570
    RULE_deleteOption = 571
    RULE_keyList = 572
    RULE_keyPart = 573
    RULE_keyListWithExpression = 574
    RULE_keyPartOrExpression = 575
    RULE_indexType = 576
    RULE_indexOption = 577
    RULE_commonIndexOption = 578
    RULE_visibility = 579
    RULE_indexTypeClause = 580
    RULE_fulltextIndexOption = 581
    RULE_spatialIndexOption = 582
    RULE_dataTypeDefinition = 583
    RULE_dataType = 584
    RULE_nchar = 585
    RULE_realType = 586
    RULE_fieldLength = 587
    RULE_fieldOptions = 588
    RULE_charsetWithOptBinary = 589
    RULE_ascii = 590
    RULE_unicode = 591
    RULE_wsNumCodepoints = 592
    RULE_typeDatetimePrecision = 593
    RULE_functionDatetimePrecision = 594
    RULE_charsetName = 595
    RULE_collationName = 596
    RULE_createTableOptions = 597
    RULE_createTableOptionsEtc = 598
    RULE_createPartitioningEtc = 599
    RULE_createTableOptionsSpaceSeparated = 600
    RULE_createTableOption = 601
    RULE_ternaryOption = 602
    RULE_defaultCollation = 603
    RULE_defaultEncryption = 604
    RULE_defaultCharset = 605
    RULE_partitionClause = 606
    RULE_partitionTypeDef = 607
    RULE_subPartitions = 608
    RULE_partitionKeyAlgorithm = 609
    RULE_partitionDefinitions = 610
    RULE_partitionDefinition = 611
    RULE_partitionValuesIn = 612
    RULE_partitionOption = 613
    RULE_subpartitionDefinition = 614
    RULE_partitionValueItemListParen = 615
    RULE_partitionValueItem = 616
    RULE_definerClause = 617
    RULE_ifExists = 618
    RULE_ifExistsIdentifier = 619
    RULE_persistedVariableIdentifier = 620
    RULE_ifNotExists = 621
    RULE_ignoreUnknownUser = 622
    RULE_procedureParameter = 623
    RULE_functionParameter = 624
    RULE_collate = 625
    RULE_typeWithOptCollate = 626
    RULE_schemaIdentifierPair = 627
    RULE_viewRefList = 628
    RULE_updateList = 629
    RULE_updateElement = 630
    RULE_charsetClause = 631
    RULE_fieldsClause = 632
    RULE_fieldTerm = 633
    RULE_linesClause = 634
    RULE_lineTerm = 635
    RULE_userList = 636
    RULE_createUserList = 637
    RULE_createUser = 638
    RULE_createUserWithMfa = 639
    RULE_identification = 640
    RULE_identifiedByPassword = 641
    RULE_identifiedByRandomPassword = 642
    RULE_identifiedWithPlugin = 643
    RULE_identifiedWithPluginAsAuth = 644
    RULE_identifiedWithPluginByPassword = 645
    RULE_identifiedWithPluginByRandomPassword = 646
    RULE_initialAuth = 647
    RULE_retainCurrentPassword = 648
    RULE_discardOldPassword = 649
    RULE_userRegistration = 650
    RULE_factor = 651
    RULE_replacePassword = 652
    RULE_userIdentifierOrText = 653
    RULE_user = 654
    RULE_likeClause = 655
    RULE_likeOrWhere = 656
    RULE_onlineOption = 657
    RULE_noWriteToBinLog = 658
    RULE_usePartition = 659
    RULE_fieldIdentifier = 660
    RULE_columnName = 661
    RULE_columnInternalRef = 662
    RULE_columnInternalRefList = 663
    RULE_columnRef = 664
    RULE_insertIdentifier = 665
    RULE_indexName = 666
    RULE_indexRef = 667
    RULE_tableWild = 668
    RULE_schemaName = 669
    RULE_schemaRef = 670
    RULE_procedureName = 671
    RULE_procedureRef = 672
    RULE_functionName = 673
    RULE_functionRef = 674
    RULE_triggerName = 675
    RULE_triggerRef = 676
    RULE_viewName = 677
    RULE_viewRef = 678
    RULE_tablespaceName = 679
    RULE_tablespaceRef = 680
    RULE_logfileGroupName = 681
    RULE_logfileGroupRef = 682
    RULE_eventName = 683
    RULE_eventRef = 684
    RULE_udfName = 685
    RULE_serverName = 686
    RULE_serverRef = 687
    RULE_engineRef = 688
    RULE_tableName = 689
    RULE_filterTableRef = 690
    RULE_tableRefWithWildcard = 691
    RULE_tableRef = 692
    RULE_tableRefList = 693
    RULE_tableAliasRefList = 694
    RULE_parameterName = 695
    RULE_labelIdentifier = 696
    RULE_labelRef = 697
    RULE_roleIdentifier = 698
    RULE_pluginRef = 699
    RULE_componentRef = 700
    RULE_resourceGroupRef = 701
    RULE_windowName = 702
    RULE_pureIdentifier = 703
    RULE_identifier = 704
    RULE_identifierList = 705
    RULE_identifierListWithParentheses = 706
    RULE_qualifiedIdentifier = 707
    RULE_simpleIdentifier = 708
    RULE_dotIdentifier = 709
    RULE_ulong_number = 710
    RULE_real_ulong_number = 711
    RULE_ulonglongNumber = 712
    RULE_real_ulonglong_number = 713
    RULE_signedLiteral = 714
    RULE_signedLiteralOrNull = 715
    RULE_literal = 716
    RULE_literalOrNull = 717
    RULE_nullAsLiteral = 718
    RULE_stringList = 719
    RULE_textStringLiteral = 720
    RULE_textString = 721
    RULE_textStringHash = 722
    RULE_textLiteral = 723
    RULE_textStringNoLinebreak = 724
    RULE_textStringLiteralList = 725
    RULE_numLiteral = 726
    RULE_boolLiteral = 727
    RULE_nullLiteral = 728
    RULE_int64Literal = 729
    RULE_temporalLiteral = 730
    RULE_floatOptions = 731
    RULE_standardFloatOptions = 732
    RULE_precision = 733
    RULE_textOrIdentifier = 734
    RULE_lValueIdentifier = 735
    RULE_roleIdentifierOrText = 736
    RULE_sizeNumber = 737
    RULE_parentheses = 738
    RULE_equal = 739
    RULE_optionType = 740
    RULE_rvalueSystemVariableType = 741
    RULE_setVarIdentType = 742
    RULE_jsonAttribute = 743
    RULE_identifierKeyword = 744
    RULE_identifierKeywordsAmbiguous1RolesAndLabels = 745
    RULE_identifierKeywordsAmbiguous2Labels = 746
    RULE_labelKeyword = 747
    RULE_identifierKeywordsAmbiguous3Roles = 748
    RULE_identifierKeywordsUnambiguous = 749
    RULE_roleKeyword = 750
    RULE_lValueKeyword = 751
    RULE_identifierKeywordsAmbiguous4SystemVariables = 752
    RULE_roleOrIdentifierKeyword = 753
    RULE_roleOrLabelKeyword = 754

    ruleNames =  [ "queries", "query", "simpleStatement", "alterStatement", 
                   "alterDatabase", "alterDatabaseOption", "alterEvent", 
                   "alterLogfileGroup", "alterLogfileGroupOptions", "alterLogfileGroupOption", 
                   "alterServer", "alterTable", "alterTableActions", "alterCommandList", 
                   "alterCommandsModifierList", "standaloneAlterCommands", 
                   "alterPartition", "alterList", "alterCommandsModifier", 
                   "alterListItem", "place", "restrict", "alterOrderList", 
                   "alterAlgorithmOption", "alterLockOption", "indexLockAndAlgorithm", 
                   "withValidation", "removePartitioning", "allOrPartitionNameList", 
                   "alterTablespace", "alterUndoTablespace", "undoTableSpaceOptions", 
                   "undoTableSpaceOption", "alterTablespaceOptions", "alterTablespaceOption", 
                   "changeTablespaceOption", "alterView", "viewTail", "viewQueryBlock", 
                   "viewCheckOption", "alterInstanceStatement", "createStatement", 
                   "createDatabase", "createDatabaseOption", "createTable", 
                   "tableElementList", "tableElement", "duplicateAsQe", 
                   "asCreateQueryExpression", "queryExpressionOrParens", 
                   "queryExpressionWithOptLockingClauses", "createRoutine", 
                   "createProcedure", "routineString", "storedRoutineBody", 
                   "createFunction", "createUdf", "routineCreateOption", 
                   "routineAlterOptions", "routineOption", "createIndex", 
                   "indexNameAndType", "createIndexTarget", "createLogfileGroup", 
                   "logfileGroupOptions", "logfileGroupOption", "createServer", 
                   "serverOptions", "serverOption", "createTablespace", 
                   "createUndoTablespace", "tsDataFileName", "tsDataFile", 
                   "tablespaceOptions", "tablespaceOption", "tsOptionInitialSize", 
                   "tsOptionUndoRedoBufferSize", "tsOptionAutoextendSize", 
                   "tsOptionMaxSize", "tsOptionExtentSize", "tsOptionNodegroup", 
                   "tsOptionEngine", "tsOptionWait", "tsOptionComment", 
                   "tsOptionFileblockSize", "tsOptionEncryption", "tsOptionEngineAttribute", 
                   "createView", "viewReplaceOrAlgorithm", "viewAlgorithm", 
                   "viewSuid", "createTrigger", "triggerFollowsPrecedesClause", 
                   "createEvent", "createRole", "createSpatialReference", 
                   "srsAttribute", "dropStatement", "dropDatabase", "dropEvent", 
                   "dropFunction", "dropProcedure", "dropIndex", "dropLogfileGroup", 
                   "dropLogfileGroupOption", "dropServer", "dropTable", 
                   "dropTableSpace", "dropTrigger", "dropView", "dropRole", 
                   "dropSpatialReference", "dropUndoTablespace", "renameTableStatement", 
                   "renamePair", "truncateTableStatement", "importStatement", 
                   "callStatement", "deleteStatement", "partitionDelete", 
                   "deleteStatementOption", "doStatement", "handlerStatement", 
                   "handlerReadOrScan", "insertStatement", "insertLockOption", 
                   "insertFromConstructor", "fields", "insertValues", "insertQueryExpression", 
                   "valueList", "values", "valuesReference", "insertUpdateList", 
                   "loadStatement", "dataOrXml", "loadDataLock", "loadFrom", 
                   "loadSourceType", "sourceCount", "sourceOrder", "xmlRowsIdentifiedBy", 
                   "loadDataFileTail", "loadDataFileTargetList", "fieldOrVariableList", 
                   "loadAlgorithm", "loadParallel", "loadMemory", "replaceStatement", 
                   "selectStatement", "selectStatementWithInto", "queryExpression", 
                   "queryExpressionBody", "queryExpressionParens", "queryPrimary", 
                   "querySpecification", "subquery", "querySpecOption", 
                   "limitClause", "simpleLimitClause", "limitOptions", "limitOption", 
                   "intoClause", "procedureAnalyseClause", "havingClause", 
                   "qualifyClause", "windowClause", "windowDefinition", 
                   "windowSpec", "windowSpecDetails", "windowFrameClause", 
                   "windowFrameUnits", "windowFrameExtent", "windowFrameStart", 
                   "windowFrameBetween", "windowFrameBound", "windowFrameExclusion", 
                   "withClause", "commonTableExpression", "groupByClause", 
                   "olapOption", "orderClause", "direction", "fromClause", 
                   "tableReferenceList", "tableValueConstructor", "explicitTable", 
                   "rowValueExplicit", "selectOption", "lockingClauseList", 
                   "lockingClause", "lockStrengh", "lockedRowAction", "selectItemList", 
                   "selectItem", "selectAlias", "whereClause", "tableReference", 
                   "escapedTableReference", "joinedTable", "naturalJoinType", 
                   "innerJoinType", "outerJoinType", "tableFactor", "singleTable", 
                   "singleTableParens", "derivedTable", "tableReferenceListParens", 
                   "tableFunction", "columnsClause", "jtColumn", "onEmptyOrError", 
                   "onEmptyOrErrorJsonTable", "onEmpty", "onError", "jsonOnResponse", 
                   "unionOption", "tableAlias", "indexHintList", "indexHint", 
                   "indexHintType", "keyOrIndex", "constraintKeyType", "indexHintClause", 
                   "indexList", "indexListElement", "updateStatement", "transactionOrLockingStatement", 
                   "transactionStatement", "beginWork", "startTransactionOptionList", 
                   "savepointStatement", "lockStatement", "lockItem", "lockOption", 
                   "xaStatement", "xaConvert", "xid", "replicationStatement", 
                   "purgeOptions", "resetOption", "masterOrBinaryLogsAndGtids", 
                   "sourceResetOptions", "replicationLoad", "changeReplicationSource", 
                   "changeSource", "sourceDefinitions", "sourceDefinition", 
                   "changeReplicationSourceAutoPosition", "changeReplicationSourceHost", 
                   "changeReplicationSourceBind", "changeReplicationSourceUser", 
                   "changeReplicationSourcePassword", "changeReplicationSourcePort", 
                   "changeReplicationSourceConnectRetry", "changeReplicationSourceRetryCount", 
                   "changeReplicationSourceDelay", "changeReplicationSourceSSL", 
                   "changeReplicationSourceSSLCA", "changeReplicationSourceSSLCApath", 
                   "changeReplicationSourceSSLCipher", "changeReplicationSourceSSLCLR", 
                   "changeReplicationSourceSSLCLRpath", "changeReplicationSourceSSLKey", 
                   "changeReplicationSourceSSLVerifyServerCert", "changeReplicationSourceTLSVersion", 
                   "changeReplicationSourceTLSCiphersuites", "changeReplicationSourceSSLCert", 
                   "changeReplicationSourcePublicKey", "changeReplicationSourceGetSourcePublicKey", 
                   "changeReplicationSourceHeartbeatPeriod", "changeReplicationSourceCompressionAlgorithm", 
                   "changeReplicationSourceZstdCompressionLevel", "privilegeCheckDef", 
                   "tablePrimaryKeyCheckDef", "assignGtidsToAnonymousTransactionsDefinition", 
                   "sourceTlsCiphersuitesDef", "sourceFileDef", "sourceLogFile", 
                   "sourceLogPos", "serverIdList", "changeReplication", 
                   "filterDefinition", "filterDbList", "filterTableList", 
                   "filterStringList", "filterWildDbTableString", "filterDbPairList", 
                   "startReplicaStatement", "stopReplicaStatement", "replicaUntil", 
                   "userOption", "passwordOption", "defaultAuthOption", 
                   "pluginDirOption", "replicaThreadOptions", "replicaThreadOption", 
                   "groupReplication", "groupReplicationStartOptions", "groupReplicationStartOption", 
                   "groupReplicationUser", "groupReplicationPassword", "groupReplicationPluginAuth", 
                   "replica", "preparedStatement", "executeStatement", "executeVarList", 
                   "cloneStatement", "dataDirSSL", "ssl", "accountManagementStatement", 
                   "alterUserStatement", "alterUserList", "alterUser", "oldAlterUser", 
                   "userFunction", "createUserStatement", "createUserTail", 
                   "userAttributes", "defaultRoleClause", "requireClause", 
                   "connectOptions", "accountLockPasswordExpireOptions", 
                   "userAttribute", "dropUserStatement", "grantStatement", 
                   "grantTargetList", "grantOptions", "exceptRoleList", 
                   "withRoles", "grantAs", "versionedRequireClause", "renameUserStatement", 
                   "revokeStatement", "aclType", "roleOrPrivilegesList", 
                   "roleOrPrivilege", "grantIdentifier", "requireList", 
                   "requireListElement", "grantOption", "setRoleStatement", 
                   "roleList", "role", "tableAdministrationStatement", "histogramAutoUpdate", 
                   "histogramUpdateParam", "histogramNumBuckets", "histogram", 
                   "checkOption", "repairType", "uninstallStatement", "installStatement", 
                   "installOptionType", "installSetRvalue", "installSetValue", 
                   "installSetValueList", "setStatement", "startOptionValueList", 
                   "transactionCharacteristics", "transactionAccessMode", 
                   "isolationLevel", "optionValueListContinued", "optionValueNoOptionType", 
                   "optionValue", "setSystemVariable", "startOptionValueListFollowingOptionType", 
                   "optionValueFollowingOptionType", "setExprOrDefault", 
                   "showDatabasesStatement", "showTablesStatement", "showTriggersStatement", 
                   "showEventsStatement", "showTableStatusStatement", "showOpenTablesStatement", 
                   "showParseTreeStatement", "showPluginsStatement", "showEngineLogsStatement", 
                   "showEngineMutexStatement", "showEngineStatusStatement", 
                   "showColumnsStatement", "showBinaryLogsStatement", "showBinaryLogStatusStatement", 
                   "showReplicasStatement", "showBinlogEventsStatement", 
                   "showRelaylogEventsStatement", "showKeysStatement", "showEnginesStatement", 
                   "showCountWarningsStatement", "showCountErrorsStatement", 
                   "showWarningsStatement", "showErrorsStatement", "showProfilesStatement", 
                   "showProfileStatement", "showStatusStatement", "showProcessListStatement", 
                   "showVariablesStatement", "showCharacterSetStatement", 
                   "showCollationStatement", "showPrivilegesStatement", 
                   "showGrantsStatement", "showCreateDatabaseStatement", 
                   "showCreateTableStatement", "showCreateViewStatement", 
                   "showMasterStatusStatement", "showReplicaStatusStatement", 
                   "showCreateProcedureStatement", "showCreateFunctionStatement", 
                   "showCreateTriggerStatement", "showCreateProcedureStatusStatement", 
                   "showCreateFunctionStatusStatement", "showCreateProcedureCodeStatement", 
                   "showCreateFunctionCodeStatement", "showCreateEventStatement", 
                   "showCreateUserStatement", "showCommandType", "engineOrAll", 
                   "fromOrIn", "inDb", "profileDefinitions", "profileDefinition", 
                   "otherAdministrativeStatement", "keyCacheListOrParts", 
                   "keyCacheList", "assignToKeycache", "assignToKeycachePartition", 
                   "cacheKeyList", "keyUsageElement", "keyUsageList", "flushOption", 
                   "logType", "flushTables", "flushTablesOptions", "preloadTail", 
                   "preloadList", "preloadKeys", "adminPartition", "resourceGroupManagement", 
                   "createResourceGroup", "resourceGroupVcpuList", "vcpuNumOrRange", 
                   "resourceGroupPriority", "resourceGroupEnableDisable", 
                   "alterResourceGroup", "setResourceGroup", "threadIdList", 
                   "dropResourceGroup", "utilityStatement", "describeStatement", 
                   "explainStatement", "explainOptions", "explainableStatement", 
                   "explainInto", "helpCommand", "useCommand", "restartServer", 
                   "expr", "boolPri", "compOp", "predicate", "predicateOperations", 
                   "bitExpr", "simpleExpr", "arrayCast", "jsonOperator", 
                   "sumExpr", "groupingOperation", "windowFunctionCall", 
                   "samplingMethod", "samplingPercentage", "tablesampleClause", 
                   "windowingClause", "leadLagInfo", "stableInteger", "paramOrVar", 
                   "nullTreatment", "jsonFunction", "inSumExpr", "identListArg", 
                   "identList", "fulltextOptions", "runtimeFunctionCall", 
                   "returningType", "geometryFunction", "timeFunctionParameters", 
                   "fractionalPrecision", "weightStringLevels", "weightStringLevelListItem", 
                   "dateTimeTtype", "trimFunction", "substringFunction", 
                   "functionCall", "udfExprList", "udfExpr", "userVariable", 
                   "inExpressionUserVariableAssignment", "rvalueSystemOrUserVariable", 
                   "lvalueVariable", "rvalueSystemVariable", "whenExpression", 
                   "thenExpression", "elseExpression", "castType", "exprList", 
                   "charset", "notRule", "not2Rule", "interval", "intervalTimeStamp", 
                   "exprListWithParentheses", "exprWithParentheses", "simpleExprWithParentheses", 
                   "orderList", "orderExpression", "groupList", "groupingExpression", 
                   "channel", "compoundStatement", "returnStatement", "ifStatement", 
                   "ifBody", "thenStatement", "compoundStatementList", "caseStatement", 
                   "elseStatement", "labeledBlock", "unlabeledBlock", "label", 
                   "beginEndBlock", "labeledControl", "unlabeledControl", 
                   "loopBlock", "whileDoBlock", "repeatUntilBlock", "spDeclarations", 
                   "spDeclaration", "variableDeclaration", "conditionDeclaration", 
                   "spCondition", "sqlstate", "handlerDeclaration", "handlerCondition", 
                   "cursorDeclaration", "iterateStatement", "leaveStatement", 
                   "getDiagnosticsStatement", "signalAllowedExpr", "statementInformationItem", 
                   "conditionInformationItem", "signalInformationItemName", 
                   "signalStatement", "resignalStatement", "signalInformationItem", 
                   "cursorOpen", "cursorClose", "cursorFetch", "schedule", 
                   "columnDefinition", "checkOrReferences", "checkConstraint", 
                   "constraintEnforcement", "tableConstraintDef", "constraintName", 
                   "fieldDefinition", "columnAttribute", "columnFormat", 
                   "storageMedia", "now", "nowOrSignedLiteral", "gcolAttribute", 
                   "references", "deleteOption", "keyList", "keyPart", "keyListWithExpression", 
                   "keyPartOrExpression", "indexType", "indexOption", "commonIndexOption", 
                   "visibility", "indexTypeClause", "fulltextIndexOption", 
                   "spatialIndexOption", "dataTypeDefinition", "dataType", 
                   "nchar", "realType", "fieldLength", "fieldOptions", "charsetWithOptBinary", 
                   "ascii", "unicode", "wsNumCodepoints", "typeDatetimePrecision", 
                   "functionDatetimePrecision", "charsetName", "collationName", 
                   "createTableOptions", "createTableOptionsEtc", "createPartitioningEtc", 
                   "createTableOptionsSpaceSeparated", "createTableOption", 
                   "ternaryOption", "defaultCollation", "defaultEncryption", 
                   "defaultCharset", "partitionClause", "partitionTypeDef", 
                   "subPartitions", "partitionKeyAlgorithm", "partitionDefinitions", 
                   "partitionDefinition", "partitionValuesIn", "partitionOption", 
                   "subpartitionDefinition", "partitionValueItemListParen", 
                   "partitionValueItem", "definerClause", "ifExists", "ifExistsIdentifier", 
                   "persistedVariableIdentifier", "ifNotExists", "ignoreUnknownUser", 
                   "procedureParameter", "functionParameter", "collate", 
                   "typeWithOptCollate", "schemaIdentifierPair", "viewRefList", 
                   "updateList", "updateElement", "charsetClause", "fieldsClause", 
                   "fieldTerm", "linesClause", "lineTerm", "userList", "createUserList", 
                   "createUser", "createUserWithMfa", "identification", 
                   "identifiedByPassword", "identifiedByRandomPassword", 
                   "identifiedWithPlugin", "identifiedWithPluginAsAuth", 
                   "identifiedWithPluginByPassword", "identifiedWithPluginByRandomPassword", 
                   "initialAuth", "retainCurrentPassword", "discardOldPassword", 
                   "userRegistration", "factor", "replacePassword", "userIdentifierOrText", 
                   "user", "likeClause", "likeOrWhere", "onlineOption", 
                   "noWriteToBinLog", "usePartition", "fieldIdentifier", 
                   "columnName", "columnInternalRef", "columnInternalRefList", 
                   "columnRef", "insertIdentifier", "indexName", "indexRef", 
                   "tableWild", "schemaName", "schemaRef", "procedureName", 
                   "procedureRef", "functionName", "functionRef", "triggerName", 
                   "triggerRef", "viewName", "viewRef", "tablespaceName", 
                   "tablespaceRef", "logfileGroupName", "logfileGroupRef", 
                   "eventName", "eventRef", "udfName", "serverName", "serverRef", 
                   "engineRef", "tableName", "filterTableRef", "tableRefWithWildcard", 
                   "tableRef", "tableRefList", "tableAliasRefList", "parameterName", 
                   "labelIdentifier", "labelRef", "roleIdentifier", "pluginRef", 
                   "componentRef", "resourceGroupRef", "windowName", "pureIdentifier", 
                   "identifier", "identifierList", "identifierListWithParentheses", 
                   "qualifiedIdentifier", "simpleIdentifier", "dotIdentifier", 
                   "ulong_number", "real_ulong_number", "ulonglongNumber", 
                   "real_ulonglong_number", "signedLiteral", "signedLiteralOrNull", 
                   "literal", "literalOrNull", "nullAsLiteral", "stringList", 
                   "textStringLiteral", "textString", "textStringHash", 
                   "textLiteral", "textStringNoLinebreak", "textStringLiteralList", 
                   "numLiteral", "boolLiteral", "nullLiteral", "int64Literal", 
                   "temporalLiteral", "floatOptions", "standardFloatOptions", 
                   "precision", "textOrIdentifier", "lValueIdentifier", 
                   "roleIdentifierOrText", "sizeNumber", "parentheses", 
                   "equal", "optionType", "rvalueSystemVariableType", "setVarIdentType", 
                   "jsonAttribute", "identifierKeyword", "identifierKeywordsAmbiguous1RolesAndLabels", 
                   "identifierKeywordsAmbiguous2Labels", "labelKeyword", 
                   "identifierKeywordsAmbiguous3Roles", "identifierKeywordsUnambiguous", 
                   "roleKeyword", "lValueKeyword", "identifierKeywordsAmbiguous4SystemVariables", 
                   "roleOrIdentifierKeyword", "roleOrLabelKeyword" ]

    EOF = Token.EOF
    NOT2_SYMBOL=1
    CONCAT_PIPES_SYMBOL=2
    INT_NUMBER=3
    LONG_NUMBER=4
    ULONGLONG_NUMBER=5
    EQUAL_OPERATOR=6
    ASSIGN_OPERATOR=7
    NULL_SAFE_EQUAL_OPERATOR=8
    GREATER_OR_EQUAL_OPERATOR=9
    GREATER_THAN_OPERATOR=10
    LESS_OR_EQUAL_OPERATOR=11
    LESS_THAN_OPERATOR=12
    NOT_EQUAL_OPERATOR=13
    PLUS_OPERATOR=14
    MINUS_OPERATOR=15
    MULT_OPERATOR=16
    DIV_OPERATOR=17
    MOD_OPERATOR=18
    LOGICAL_NOT_OPERATOR=19
    BITWISE_NOT_OPERATOR=20
    SHIFT_LEFT_OPERATOR=21
    SHIFT_RIGHT_OPERATOR=22
    LOGICAL_AND_OPERATOR=23
    BITWISE_AND_OPERATOR=24
    BITWISE_XOR_OPERATOR=25
    LOGICAL_OR_OPERATOR=26
    BITWISE_OR_OPERATOR=27
    DOT_SYMBOL=28
    COMMA_SYMBOL=29
    SEMICOLON_SYMBOL=30
    COLON_SYMBOL=31
    OPEN_PAR_SYMBOL=32
    CLOSE_PAR_SYMBOL=33
    OPEN_CURLY_SYMBOL=34
    CLOSE_CURLY_SYMBOL=35
    UNDERLINE_SYMBOL=36
    JSON_SEPARATOR_SYMBOL=37
    JSON_UNQUOTED_SEPARATOR_SYMBOL=38
    AT_SIGN_SYMBOL=39
    AT_TEXT_SUFFIX=40
    AT_AT_SIGN_SYMBOL=41
    NULL2_SYMBOL=42
    PARAM_MARKER=43
    HEX_NUMBER=44
    BIN_NUMBER=45
    DECIMAL_NUMBER=46
    FLOAT_NUMBER=47
    ACCESSIBLE_SYMBOL=48
    ACCOUNT_SYMBOL=49
    ACTION_SYMBOL=50
    ADD_SYMBOL=51
    ADDDATE_SYMBOL=52
    AFTER_SYMBOL=53
    AGAINST_SYMBOL=54
    AGGREGATE_SYMBOL=55
    ALGORITHM_SYMBOL=56
    ALL_SYMBOL=57
    ALTER_SYMBOL=58
    ALWAYS_SYMBOL=59
    ANALYZE_SYMBOL=60
    AND_SYMBOL=61
    ANY_SYMBOL=62
    AS_SYMBOL=63
    ASC_SYMBOL=64
    ASCII_SYMBOL=65
    ASENSITIVE_SYMBOL=66
    AT_SYMBOL=67
    AUTOEXTEND_SIZE_SYMBOL=68
    AUTO_INCREMENT_SYMBOL=69
    AVG_ROW_LENGTH_SYMBOL=70
    AVG_SYMBOL=71
    BACKUP_SYMBOL=72
    BEFORE_SYMBOL=73
    BEGIN_SYMBOL=74
    BETWEEN_SYMBOL=75
    BIGINT_SYMBOL=76
    BINARY_SYMBOL=77
    BINLOG_SYMBOL=78
    BIT_AND_SYMBOL=79
    BIT_OR_SYMBOL=80
    BIT_SYMBOL=81
    BIT_XOR_SYMBOL=82
    BLOB_SYMBOL=83
    BLOCK_SYMBOL=84
    BOOLEAN_SYMBOL=85
    BOOL_SYMBOL=86
    BOTH_SYMBOL=87
    BTREE_SYMBOL=88
    BY_SYMBOL=89
    BYTE_SYMBOL=90
    CACHE_SYMBOL=91
    CALL_SYMBOL=92
    CASCADE_SYMBOL=93
    CASCADED_SYMBOL=94
    CASE_SYMBOL=95
    CAST_SYMBOL=96
    CATALOG_NAME_SYMBOL=97
    CHAIN_SYMBOL=98
    CHANGE_SYMBOL=99
    CHANGED_SYMBOL=100
    CHANNEL_SYMBOL=101
    CHARSET_SYMBOL=102
    CHAR_SYMBOL=103
    CHECKSUM_SYMBOL=104
    CHECK_SYMBOL=105
    CIPHER_SYMBOL=106
    CLASS_ORIGIN_SYMBOL=107
    CLIENT_SYMBOL=108
    CLOSE_SYMBOL=109
    COALESCE_SYMBOL=110
    CODE_SYMBOL=111
    COLLATE_SYMBOL=112
    COLLATION_SYMBOL=113
    COLUMNS_SYMBOL=114
    COLUMN_SYMBOL=115
    COLUMN_NAME_SYMBOL=116
    COLUMN_FORMAT_SYMBOL=117
    COMMENT_SYMBOL=118
    COMMITTED_SYMBOL=119
    COMMIT_SYMBOL=120
    COMPACT_SYMBOL=121
    COMPLETION_SYMBOL=122
    COMPRESSED_SYMBOL=123
    COMPRESSION_SYMBOL=124
    CONCURRENT_SYMBOL=125
    CONDITION_SYMBOL=126
    CONNECTION_SYMBOL=127
    CONSISTENT_SYMBOL=128
    CONSTRAINT_SYMBOL=129
    CONSTRAINT_CATALOG_SYMBOL=130
    CONSTRAINT_NAME_SYMBOL=131
    CONSTRAINT_SCHEMA_SYMBOL=132
    CONTAINS_SYMBOL=133
    CONTEXT_SYMBOL=134
    CONTINUE_SYMBOL=135
    CONVERT_SYMBOL=136
    COUNT_SYMBOL=137
    CPU_SYMBOL=138
    CREATE_SYMBOL=139
    CROSS_SYMBOL=140
    CUBE_SYMBOL=141
    CURDATE_SYMBOL=142
    CURRENT_SYMBOL=143
    CURRENT_DATE_SYMBOL=144
    CURRENT_TIME_SYMBOL=145
    CURRENT_USER_SYMBOL=146
    CURSOR_SYMBOL=147
    CURSOR_NAME_SYMBOL=148
    CURTIME_SYMBOL=149
    DATABASE_SYMBOL=150
    DATABASES_SYMBOL=151
    DATAFILE_SYMBOL=152
    DATA_SYMBOL=153
    DATETIME_SYMBOL=154
    DATE_ADD_SYMBOL=155
    DATE_SUB_SYMBOL=156
    DATE_SYMBOL=157
    DAY_HOUR_SYMBOL=158
    DAY_MICROSECOND_SYMBOL=159
    DAY_MINUTE_SYMBOL=160
    DAY_SECOND_SYMBOL=161
    DAY_SYMBOL=162
    DEALLOCATE_SYMBOL=163
    DECIMAL_SYMBOL=164
    DECLARE_SYMBOL=165
    DEFAULT_SYMBOL=166
    DEFAULT_AUTH_SYMBOL=167
    DEFINER_SYMBOL=168
    DELAYED_SYMBOL=169
    DELAY_KEY_WRITE_SYMBOL=170
    DELETE_SYMBOL=171
    DESC_SYMBOL=172
    DESCRIBE_SYMBOL=173
    DETERMINISTIC_SYMBOL=174
    DIAGNOSTICS_SYMBOL=175
    DIRECTORY_SYMBOL=176
    DISABLE_SYMBOL=177
    DISCARD_SYMBOL=178
    DISK_SYMBOL=179
    DISTINCT_SYMBOL=180
    DIV_SYMBOL=181
    DOUBLE_SYMBOL=182
    DO_SYMBOL=183
    DROP_SYMBOL=184
    DUAL_SYMBOL=185
    DUMPFILE_SYMBOL=186
    DUPLICATE_SYMBOL=187
    DYNAMIC_SYMBOL=188
    EACH_SYMBOL=189
    ELSE_SYMBOL=190
    ELSEIF_SYMBOL=191
    ENABLE_SYMBOL=192
    ENCLOSED_SYMBOL=193
    ENCRYPTION_SYMBOL=194
    END_SYMBOL=195
    ENDS_SYMBOL=196
    ENGINES_SYMBOL=197
    ENGINE_SYMBOL=198
    ENUM_SYMBOL=199
    ERROR_SYMBOL=200
    ERRORS_SYMBOL=201
    ESCAPED_SYMBOL=202
    ESCAPE_SYMBOL=203
    EVENTS_SYMBOL=204
    EVENT_SYMBOL=205
    EVERY_SYMBOL=206
    EXCHANGE_SYMBOL=207
    EXECUTE_SYMBOL=208
    EXISTS_SYMBOL=209
    EXIT_SYMBOL=210
    EXPANSION_SYMBOL=211
    EXPIRE_SYMBOL=212
    EXPLAIN_SYMBOL=213
    EXPORT_SYMBOL=214
    EXTENDED_SYMBOL=215
    EXTENT_SIZE_SYMBOL=216
    EXTRACT_SYMBOL=217
    FALSE_SYMBOL=218
    FAST_SYMBOL=219
    FAULTS_SYMBOL=220
    FETCH_SYMBOL=221
    FILE_SYMBOL=222
    FILE_BLOCK_SIZE_SYMBOL=223
    FILTER_SYMBOL=224
    FIRST_SYMBOL=225
    FIXED_SYMBOL=226
    FLOAT_SYMBOL=227
    FLUSH_SYMBOL=228
    FOLLOWS_SYMBOL=229
    FORCE_SYMBOL=230
    FOREIGN_SYMBOL=231
    FOR_SYMBOL=232
    FORMAT_SYMBOL=233
    FOUND_SYMBOL=234
    FROM_SYMBOL=235
    FULL_SYMBOL=236
    FULLTEXT_SYMBOL=237
    FUNCTION_SYMBOL=238
    GET_SYMBOL=239
    GENERAL_SYMBOL=240
    GENERATED_SYMBOL=241
    GROUP_REPLICATION_SYMBOL=242
    GEOMETRYCOLLECTION_SYMBOL=243
    GEOMETRY_SYMBOL=244
    GET_FORMAT_SYMBOL=245
    GLOBAL_SYMBOL=246
    GRANT_SYMBOL=247
    GRANTS_SYMBOL=248
    GROUP_SYMBOL=249
    GROUP_CONCAT_SYMBOL=250
    HANDLER_SYMBOL=251
    HASH_SYMBOL=252
    HAVING_SYMBOL=253
    HELP_SYMBOL=254
    HIGH_PRIORITY_SYMBOL=255
    HOST_SYMBOL=256
    HOSTS_SYMBOL=257
    HOUR_MICROSECOND_SYMBOL=258
    HOUR_MINUTE_SYMBOL=259
    HOUR_SECOND_SYMBOL=260
    HOUR_SYMBOL=261
    IDENTIFIED_SYMBOL=262
    IF_SYMBOL=263
    IGNORE_SYMBOL=264
    IGNORE_SERVER_IDS_SYMBOL=265
    IMPORT_SYMBOL=266
    INDEXES_SYMBOL=267
    INDEX_SYMBOL=268
    INFILE_SYMBOL=269
    INITIAL_SIZE_SYMBOL=270
    INNER_SYMBOL=271
    INOUT_SYMBOL=272
    INSENSITIVE_SYMBOL=273
    INSERT_SYMBOL=274
    INSERT_METHOD_SYMBOL=275
    INSTANCE_SYMBOL=276
    INSTALL_SYMBOL=277
    INTERVAL_SYMBOL=278
    INTO_SYMBOL=279
    INT_SYMBOL=280
    INVOKER_SYMBOL=281
    IN_SYMBOL=282
    IO_AFTER_GTIDS_SYMBOL=283
    IO_BEFORE_GTIDS_SYMBOL=284
    IO_SYMBOL=285
    IPC_SYMBOL=286
    IS_SYMBOL=287
    ISOLATION_SYMBOL=288
    ISSUER_SYMBOL=289
    ITERATE_SYMBOL=290
    JOIN_SYMBOL=291
    JSON_SYMBOL=292
    KEYS_SYMBOL=293
    KEY_BLOCK_SIZE_SYMBOL=294
    KEY_SYMBOL=295
    KILL_SYMBOL=296
    LANGUAGE_SYMBOL=297
    LAST_SYMBOL=298
    LEADING_SYMBOL=299
    LEAVES_SYMBOL=300
    LEAVE_SYMBOL=301
    LEFT_SYMBOL=302
    LESS_SYMBOL=303
    LEVEL_SYMBOL=304
    LIKE_SYMBOL=305
    LIMIT_SYMBOL=306
    LINEAR_SYMBOL=307
    LINES_SYMBOL=308
    LINESTRING_SYMBOL=309
    LIST_SYMBOL=310
    LOAD_SYMBOL=311
    LOCAL_SYMBOL=312
    LOCKS_SYMBOL=313
    LOCK_SYMBOL=314
    LOGFILE_SYMBOL=315
    LOGS_SYMBOL=316
    LONGBLOB_SYMBOL=317
    LONGTEXT_SYMBOL=318
    LONG_SYMBOL=319
    LOOP_SYMBOL=320
    LOW_PRIORITY_SYMBOL=321
    MASTER_AUTO_POSITION_SYMBOL=322
    MASTER_BIND_SYMBOL=323
    MASTER_CONNECT_RETRY_SYMBOL=324
    MASTER_DELAY_SYMBOL=325
    MASTER_HOST_SYMBOL=326
    MASTER_LOG_FILE_SYMBOL=327
    MASTER_LOG_POS_SYMBOL=328
    MASTER_PASSWORD_SYMBOL=329
    MASTER_PORT_SYMBOL=330
    MASTER_RETRY_COUNT_SYMBOL=331
    MASTER_SSL_CAPATH_SYMBOL=332
    MASTER_SSL_CA_SYMBOL=333
    MASTER_SSL_CERT_SYMBOL=334
    MASTER_SSL_CIPHER_SYMBOL=335
    MASTER_SSL_CRL_SYMBOL=336
    MASTER_SSL_CRLPATH_SYMBOL=337
    MASTER_SSL_KEY_SYMBOL=338
    MASTER_SSL_SYMBOL=339
    MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL=340
    MASTER_SYMBOL=341
    MASTER_TLS_VERSION_SYMBOL=342
    MASTER_USER_SYMBOL=343
    MASTER_HEARTBEAT_PERIOD_SYMBOL=344
    MATCH_SYMBOL=345
    MAX_CONNECTIONS_PER_HOUR_SYMBOL=346
    MAX_QUERIES_PER_HOUR_SYMBOL=347
    MAX_ROWS_SYMBOL=348
    MAX_SIZE_SYMBOL=349
    MAX_SYMBOL=350
    MAX_UPDATES_PER_HOUR_SYMBOL=351
    MAX_USER_CONNECTIONS_SYMBOL=352
    MAXVALUE_SYMBOL=353
    MEDIUMBLOB_SYMBOL=354
    MEDIUMINT_SYMBOL=355
    MEDIUMTEXT_SYMBOL=356
    MEDIUM_SYMBOL=357
    MEMORY_SYMBOL=358
    MERGE_SYMBOL=359
    MESSAGE_TEXT_SYMBOL=360
    MICROSECOND_SYMBOL=361
    MID_SYMBOL=362
    MIGRATE_SYMBOL=363
    MINUTE_MICROSECOND_SYMBOL=364
    MINUTE_SECOND_SYMBOL=365
    MINUTE_SYMBOL=366
    MIN_ROWS_SYMBOL=367
    MIN_SYMBOL=368
    MODE_SYMBOL=369
    MODIFIES_SYMBOL=370
    MODIFY_SYMBOL=371
    MOD_SYMBOL=372
    MONTH_SYMBOL=373
    MULTILINESTRING_SYMBOL=374
    MULTIPOINT_SYMBOL=375
    MULTIPOLYGON_SYMBOL=376
    MUTEX_SYMBOL=377
    MYSQL_ERRNO_SYMBOL=378
    NAMES_SYMBOL=379
    NAME_SYMBOL=380
    NATIONAL_SYMBOL=381
    NATURAL_SYMBOL=382
    NCHAR_SYMBOL=383
    NDBCLUSTER_SYMBOL=384
    NEVER_SYMBOL=385
    NEW_SYMBOL=386
    NEXT_SYMBOL=387
    NODEGROUP_SYMBOL=388
    NONE_SYMBOL=389
    NOT_SYMBOL=390
    NOW_SYMBOL=391
    NO_SYMBOL=392
    NO_WAIT_SYMBOL=393
    NO_WRITE_TO_BINLOG_SYMBOL=394
    NULL_SYMBOL=395
    NUMBER_SYMBOL=396
    NUMERIC_SYMBOL=397
    NVARCHAR_SYMBOL=398
    OFFLINE_SYMBOL=399
    OFFSET_SYMBOL=400
    ON_SYMBOL=401
    ONE_SYMBOL=402
    ONLINE_SYMBOL=403
    ONLY_SYMBOL=404
    OPEN_SYMBOL=405
    OPTIMIZE_SYMBOL=406
    OPTIMIZER_COSTS_SYMBOL=407
    OPTIONS_SYMBOL=408
    OPTION_SYMBOL=409
    OPTIONALLY_SYMBOL=410
    ORDER_SYMBOL=411
    OR_SYMBOL=412
    OUTER_SYMBOL=413
    OUTFILE_SYMBOL=414
    OUT_SYMBOL=415
    OWNER_SYMBOL=416
    PACK_KEYS_SYMBOL=417
    PAGE_SYMBOL=418
    PARSER_SYMBOL=419
    PARTIAL_SYMBOL=420
    PARTITIONING_SYMBOL=421
    PARTITIONS_SYMBOL=422
    PARTITION_SYMBOL=423
    PASSWORD_SYMBOL=424
    PHASE_SYMBOL=425
    PLUGINS_SYMBOL=426
    PLUGIN_DIR_SYMBOL=427
    PLUGIN_SYMBOL=428
    POINT_SYMBOL=429
    POLYGON_SYMBOL=430
    PORT_SYMBOL=431
    POSITION_SYMBOL=432
    PRECEDES_SYMBOL=433
    PRECISION_SYMBOL=434
    PREPARE_SYMBOL=435
    PRESERVE_SYMBOL=436
    PREV_SYMBOL=437
    PRIMARY_SYMBOL=438
    PRIVILEGES_SYMBOL=439
    PROCEDURE_SYMBOL=440
    PROCESS_SYMBOL=441
    PROCESSLIST_SYMBOL=442
    PROFILE_SYMBOL=443
    PROFILES_SYMBOL=444
    PROXY_SYMBOL=445
    PURGE_SYMBOL=446
    QUARTER_SYMBOL=447
    QUERY_SYMBOL=448
    QUICK_SYMBOL=449
    RANGE_SYMBOL=450
    READS_SYMBOL=451
    READ_ONLY_SYMBOL=452
    READ_SYMBOL=453
    READ_WRITE_SYMBOL=454
    REAL_SYMBOL=455
    REBUILD_SYMBOL=456
    RECOVER_SYMBOL=457
    REDO_BUFFER_SIZE_SYMBOL=458
    REDUNDANT_SYMBOL=459
    REFERENCES_SYMBOL=460
    REGEXP_SYMBOL=461
    RELAY_SYMBOL=462
    RELAYLOG_SYMBOL=463
    RELAY_LOG_FILE_SYMBOL=464
    RELAY_LOG_POS_SYMBOL=465
    RELAY_THREAD_SYMBOL=466
    RELEASE_SYMBOL=467
    RELOAD_SYMBOL=468
    REMOVE_SYMBOL=469
    RENAME_SYMBOL=470
    REORGANIZE_SYMBOL=471
    REPAIR_SYMBOL=472
    REPEATABLE_SYMBOL=473
    REPEAT_SYMBOL=474
    REPLACE_SYMBOL=475
    REPLICATION_SYMBOL=476
    REPLICATE_DO_DB_SYMBOL=477
    REPLICATE_IGNORE_DB_SYMBOL=478
    REPLICATE_DO_TABLE_SYMBOL=479
    REPLICATE_IGNORE_TABLE_SYMBOL=480
    REPLICATE_WILD_DO_TABLE_SYMBOL=481
    REPLICATE_WILD_IGNORE_TABLE_SYMBOL=482
    REPLICATE_REWRITE_DB_SYMBOL=483
    REQUIRE_SYMBOL=484
    RESET_SYMBOL=485
    RESIGNAL_SYMBOL=486
    RESTORE_SYMBOL=487
    RESTRICT_SYMBOL=488
    RESUME_SYMBOL=489
    RETURNED_SQLSTATE_SYMBOL=490
    RETURNS_SYMBOL=491
    RETURN_SYMBOL=492
    REVERSE_SYMBOL=493
    REVOKE_SYMBOL=494
    RIGHT_SYMBOL=495
    ROLLBACK_SYMBOL=496
    ROLLUP_SYMBOL=497
    ROTATE_SYMBOL=498
    ROUTINE_SYMBOL=499
    ROWS_SYMBOL=500
    ROW_COUNT_SYMBOL=501
    ROW_FORMAT_SYMBOL=502
    ROW_SYMBOL=503
    RTREE_SYMBOL=504
    SAVEPOINT_SYMBOL=505
    SCHEDULE_SYMBOL=506
    SCHEMA_NAME_SYMBOL=507
    SECOND_MICROSECOND_SYMBOL=508
    SECOND_SYMBOL=509
    SECURITY_SYMBOL=510
    SELECT_SYMBOL=511
    SENSITIVE_SYMBOL=512
    SEPARATOR_SYMBOL=513
    SERIALIZABLE_SYMBOL=514
    SERIAL_SYMBOL=515
    SESSION_SYMBOL=516
    SERVER_SYMBOL=517
    SESSION_USER_SYMBOL=518
    SET_SYMBOL=519
    SHARE_SYMBOL=520
    SHOW_SYMBOL=521
    SHUTDOWN_SYMBOL=522
    SIGNAL_SYMBOL=523
    SIGNED_SYMBOL=524
    SIMPLE_SYMBOL=525
    SLAVE_SYMBOL=526
    SLOW_SYMBOL=527
    SMALLINT_SYMBOL=528
    SNAPSHOT_SYMBOL=529
    SOCKET_SYMBOL=530
    SONAME_SYMBOL=531
    SOUNDS_SYMBOL=532
    SOURCE_SYMBOL=533
    SPATIAL_SYMBOL=534
    SPECIFIC_SYMBOL=535
    SQLEXCEPTION_SYMBOL=536
    SQLSTATE_SYMBOL=537
    SQLWARNING_SYMBOL=538
    SQL_AFTER_GTIDS_SYMBOL=539
    SQL_AFTER_MTS_GAPS_SYMBOL=540
    SQL_BEFORE_GTIDS_SYMBOL=541
    SQL_BIG_RESULT_SYMBOL=542
    SQL_BUFFER_RESULT_SYMBOL=543
    SQL_CALC_FOUND_ROWS_SYMBOL=544
    SQL_NO_CACHE_SYMBOL=545
    SQL_SMALL_RESULT_SYMBOL=546
    SQL_SYMBOL=547
    SQL_THREAD_SYMBOL=548
    SSL_SYMBOL=549
    STACKED_SYMBOL=550
    STARTING_SYMBOL=551
    STARTS_SYMBOL=552
    START_SYMBOL=553
    STATS_AUTO_RECALC_SYMBOL=554
    STATS_PERSISTENT_SYMBOL=555
    STATS_SAMPLE_PAGES_SYMBOL=556
    STATUS_SYMBOL=557
    STDDEV_SAMP_SYMBOL=558
    STDDEV_SYMBOL=559
    STDDEV_POP_SYMBOL=560
    STD_SYMBOL=561
    STOP_SYMBOL=562
    STORAGE_SYMBOL=563
    STORED_SYMBOL=564
    STRAIGHT_JOIN_SYMBOL=565
    STRING_SYMBOL=566
    SUBCLASS_ORIGIN_SYMBOL=567
    SUBDATE_SYMBOL=568
    SUBJECT_SYMBOL=569
    SUBPARTITIONS_SYMBOL=570
    SUBPARTITION_SYMBOL=571
    SUBSTR_SYMBOL=572
    SUBSTRING_SYMBOL=573
    SUM_SYMBOL=574
    SUPER_SYMBOL=575
    SUSPEND_SYMBOL=576
    SWAPS_SYMBOL=577
    SWITCHES_SYMBOL=578
    SYSDATE_SYMBOL=579
    SYSTEM_USER_SYMBOL=580
    TABLES_SYMBOL=581
    TABLESPACE_SYMBOL=582
    TABLE_SYMBOL=583
    TABLE_CHECKSUM_SYMBOL=584
    TABLE_NAME_SYMBOL=585
    TEMPORARY_SYMBOL=586
    TEMPTABLE_SYMBOL=587
    TERMINATED_SYMBOL=588
    TEXT_SYMBOL=589
    THAN_SYMBOL=590
    THEN_SYMBOL=591
    TIMESTAMP_SYMBOL=592
    TIMESTAMPADD_SYMBOL=593
    TIMESTAMPDIFF_SYMBOL=594
    TIME_SYMBOL=595
    TINYBLOB_SYMBOL=596
    TINYINT_SYMBOL=597
    TINYTEXT_SYMBOL=598
    TO_SYMBOL=599
    TRAILING_SYMBOL=600
    TRANSACTION_SYMBOL=601
    TRIGGERS_SYMBOL=602
    TRIGGER_SYMBOL=603
    TRIM_SYMBOL=604
    TRUE_SYMBOL=605
    TRUNCATE_SYMBOL=606
    TYPES_SYMBOL=607
    TYPE_SYMBOL=608
    UDF_RETURNS_SYMBOL=609
    UNCOMMITTED_SYMBOL=610
    UNDEFINED_SYMBOL=611
    UNDOFILE_SYMBOL=612
    UNDO_BUFFER_SIZE_SYMBOL=613
    UNDO_SYMBOL=614
    UNICODE_SYMBOL=615
    UNINSTALL_SYMBOL=616
    UNION_SYMBOL=617
    UNIQUE_SYMBOL=618
    UNKNOWN_SYMBOL=619
    UNLOCK_SYMBOL=620
    UNSIGNED_SYMBOL=621
    UNTIL_SYMBOL=622
    UPDATE_SYMBOL=623
    UPGRADE_SYMBOL=624
    USAGE_SYMBOL=625
    USER_RESOURCES_SYMBOL=626
    USER_SYMBOL=627
    USE_FRM_SYMBOL=628
    USE_SYMBOL=629
    USING_SYMBOL=630
    UTC_DATE_SYMBOL=631
    UTC_TIMESTAMP_SYMBOL=632
    UTC_TIME_SYMBOL=633
    VALIDATION_SYMBOL=634
    VALUES_SYMBOL=635
    VALUE_SYMBOL=636
    VARBINARY_SYMBOL=637
    VARCHAR_SYMBOL=638
    VARIABLES_SYMBOL=639
    VARIANCE_SYMBOL=640
    VARYING_SYMBOL=641
    VAR_POP_SYMBOL=642
    VAR_SAMP_SYMBOL=643
    VIEW_SYMBOL=644
    VIRTUAL_SYMBOL=645
    WAIT_SYMBOL=646
    WARNINGS_SYMBOL=647
    WEEK_SYMBOL=648
    WEIGHT_STRING_SYMBOL=649
    WHEN_SYMBOL=650
    WHERE_SYMBOL=651
    WHILE_SYMBOL=652
    WITH_SYMBOL=653
    WITHOUT_SYMBOL=654
    WORK_SYMBOL=655
    WRAPPER_SYMBOL=656
    WRITE_SYMBOL=657
    X509_SYMBOL=658
    XA_SYMBOL=659
    XID_SYMBOL=660
    XML_SYMBOL=661
    XOR_SYMBOL=662
    YEAR_MONTH_SYMBOL=663
    YEAR_SYMBOL=664
    ZEROFILL_SYMBOL=665
    PERSIST_SYMBOL=666
    ROLE_SYMBOL=667
    ADMIN_SYMBOL=668
    INVISIBLE_SYMBOL=669
    VISIBLE_SYMBOL=670
    EXCEPT_SYMBOL=671
    COMPONENT_SYMBOL=672
    RECURSIVE_SYMBOL=673
    JSON_OBJECTAGG_SYMBOL=674
    JSON_ARRAYAGG_SYMBOL=675
    OF_SYMBOL=676
    SKIP_SYMBOL=677
    LOCKED_SYMBOL=678
    NOWAIT_SYMBOL=679
    GROUPING_SYMBOL=680
    PERSIST_ONLY_SYMBOL=681
    HISTOGRAM_SYMBOL=682
    BUCKETS_SYMBOL=683
    REMOTE_SYMBOL=684
    CLONE_SYMBOL=685
    CUME_DIST_SYMBOL=686
    DENSE_RANK_SYMBOL=687
    EXCLUDE_SYMBOL=688
    FIRST_VALUE_SYMBOL=689
    FOLLOWING_SYMBOL=690
    GROUPS_SYMBOL=691
    LAG_SYMBOL=692
    LAST_VALUE_SYMBOL=693
    LEAD_SYMBOL=694
    NTH_VALUE_SYMBOL=695
    NTILE_SYMBOL=696
    NULLS_SYMBOL=697
    OTHERS_SYMBOL=698
    OVER_SYMBOL=699
    PERCENT_RANK_SYMBOL=700
    PRECEDING_SYMBOL=701
    RANK_SYMBOL=702
    RESPECT_SYMBOL=703
    ROW_NUMBER_SYMBOL=704
    TIES_SYMBOL=705
    UNBOUNDED_SYMBOL=706
    WINDOW_SYMBOL=707
    EMPTY_SYMBOL=708
    JSON_TABLE_SYMBOL=709
    NESTED_SYMBOL=710
    ORDINALITY_SYMBOL=711
    PATH_SYMBOL=712
    HISTORY_SYMBOL=713
    REUSE_SYMBOL=714
    SRID_SYMBOL=715
    THREAD_PRIORITY_SYMBOL=716
    RESOURCE_SYMBOL=717
    SYSTEM_SYMBOL=718
    VCPU_SYMBOL=719
    MASTER_PUBLIC_KEY_PATH_SYMBOL=720
    GET_MASTER_PUBLIC_KEY_SYMBOL=721
    RESTART_SYMBOL=722
    DEFINITION_SYMBOL=723
    DESCRIPTION_SYMBOL=724
    ORGANIZATION_SYMBOL=725
    REFERENCE_SYMBOL=726
    OPTIONAL_SYMBOL=727
    SECONDARY_SYMBOL=728
    SECONDARY_ENGINE_SYMBOL=729
    SECONDARY_LOAD_SYMBOL=730
    SECONDARY_UNLOAD_SYMBOL=731
    ACTIVE_SYMBOL=732
    INACTIVE_SYMBOL=733
    LATERAL_SYMBOL=734
    RETAIN_SYMBOL=735
    OLD_SYMBOL=736
    NETWORK_NAMESPACE_SYMBOL=737
    ENFORCED_SYMBOL=738
    ARRAY_SYMBOL=739
    OJ_SYMBOL=740
    MEMBER_SYMBOL=741
    RANDOM_SYMBOL=742
    MASTER_COMPRESSION_ALGORITHM_SYMBOL=743
    MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL=744
    PRIVILEGE_CHECKS_USER_SYMBOL=745
    MASTER_TLS_CIPHERSUITES_SYMBOL=746
    REQUIRE_ROW_FORMAT_SYMBOL=747
    PASSWORD_LOCK_TIME_SYMBOL=748
    FAILED_LOGIN_ATTEMPTS_SYMBOL=749
    REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL=750
    STREAM_SYMBOL=751
    OFF_SYMBOL=752
    RETURNING_SYMBOL=753
    JSON_VALUE_SYMBOL=754
    TLS_SYMBOL=755
    ATTRIBUTE_SYMBOL=756
    ENGINE_ATTRIBUTE_SYMBOL=757
    SECONDARY_ENGINE_ATTRIBUTE_SYMBOL=758
    SOURCE_CONNECTION_AUTO_FAILOVER_SYMBOL=759
    ZONE_SYMBOL=760
    GRAMMAR_SELECTOR_DERIVED_EXPR=761
    REPLICA_SYMBOL=762
    REPLICAS_SYMBOL=763
    ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_SYMBOL=764
    GET_SOURCE_PUBLIC_KEY_SYMBOL=765
    SOURCE_AUTO_POSITION_SYMBOL=766
    SOURCE_BIND_SYMBOL=767
    SOURCE_COMPRESSION_ALGORITHM_SYMBOL=768
    SOURCE_CONNECT_RETRY_SYMBOL=769
    SOURCE_DELAY_SYMBOL=770
    SOURCE_HEARTBEAT_PERIOD_SYMBOL=771
    SOURCE_HOST_SYMBOL=772
    SOURCE_LOG_FILE_SYMBOL=773
    SOURCE_LOG_POS_SYMBOL=774
    SOURCE_PASSWORD_SYMBOL=775
    SOURCE_PORT_SYMBOL=776
    SOURCE_PUBLIC_KEY_PATH_SYMBOL=777
    SOURCE_RETRY_COUNT_SYMBOL=778
    SOURCE_SSL_SYMBOL=779
    SOURCE_SSL_CA_SYMBOL=780
    SOURCE_SSL_CAPATH_SYMBOL=781
    SOURCE_SSL_CERT_SYMBOL=782
    SOURCE_SSL_CIPHER_SYMBOL=783
    SOURCE_SSL_CRL_SYMBOL=784
    SOURCE_SSL_CRLPATH_SYMBOL=785
    SOURCE_SSL_KEY_SYMBOL=786
    SOURCE_SSL_VERIFY_SERVER_CERT_SYMBOL=787
    SOURCE_TLS_CIPHERSUITES_SYMBOL=788
    SOURCE_TLS_VERSION_SYMBOL=789
    SOURCE_USER_SYMBOL=790
    SOURCE_ZSTD_COMPRESSION_LEVEL_SYMBOL=791
    ST_COLLECT_SYMBOL=792
    KEYRING_SYMBOL=793
    AUTHENTICATION_SYMBOL=794
    FACTOR_SYMBOL=795
    FINISH_SYMBOL=796
    INITIATE_SYMBOL=797
    REGISTRATION_SYMBOL=798
    UNREGISTER_SYMBOL=799
    INITIAL_SYMBOL=800
    CHALLENGE_RESPONSE_SYMBOL=801
    GTID_ONLY_SYMBOL=802
    INTERSECT_SYMBOL=803
    BULK_SYMBOL=804
    URL_SYMBOL=805
    GENERATE_SYMBOL=806
    PARSE_TREE_SYMBOL=807
    LOG_SYMBOL=808
    GTIDS_SYMBOL=809
    PARALLEL_SYMBOL=810
    S3_SYMBOL=811
    QUALIFY_SYMBOL=812
    AUTO_SYMBOL=813
    MANUAL_SYMBOL=814
    BERNOULLI_SYMBOL=815
    TABLESAMPLE_SYMBOL=816
    WHITESPACE=817
    INVALID_INPUT=818
    UNDERSCORE_CHARSET=819
    DOLLAR_QUOTED_STRING_TEXT=820
    IDENTIFIER=821
    NCHAR_TEXT=822
    BACK_TICK_QUOTED_ID=823
    DOUBLE_QUOTED_TEXT=824
    SINGLE_QUOTED_TEXT=825
    VERSION_COMMENT_START=826
    MYSQL_COMMENT_START=827
    VERSION_COMMENT_END=828
    BLOCK_COMMENT=829
    INVALID_BLOCK_COMMENT=830
    POUND_COMMENT=831
    DASHDASH_COMMENT=832
    NOT_EQUAL2_OPERATOR=833

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class QueriesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(MySQLParser.EOF, 0)

        def query(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.QueryContext)
            else:
                return self.getTypedRuleContext(MySQLParser.QueryContext,i)


        def getRuleIndex(self):
            return MySQLParser.RULE_queries

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueries" ):
                listener.enterQueries(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueries" ):
                listener.exitQueries(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQueries" ):
                return visitor.visitQueries(self)
            else:
                return visitor.visitChildren(self)




    def queries(self):

        localctx = MySQLParser.QueriesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_queries)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1513
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1510
                    self.query() 
                self.state = 1515
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

            self.state = 1516
            self.match(MySQLParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMICOLON_SYMBOL(self):
            return self.getToken(MySQLParser.SEMICOLON_SYMBOL, 0)

        def simpleStatement(self):
            return self.getTypedRuleContext(MySQLParser.SimpleStatementContext,0)


        def beginWork(self):
            return self.getTypedRuleContext(MySQLParser.BeginWorkContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuery" ):
                listener.enterQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuery" ):
                listener.exitQuery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuery" ):
                return visitor.visitQuery(self)
            else:
                return visitor.visitChildren(self)




    def query(self):

        localctx = MySQLParser.QueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_query)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1520
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.state = 1518
                self.simpleStatement()
                pass

            elif la_ == 2:
                self.state = 1519
                self.beginWork()
                pass


            self.state = 1522
            self.match(MySQLParser.SEMICOLON_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alterStatement(self):
            return self.getTypedRuleContext(MySQLParser.AlterStatementContext,0)


        def createStatement(self):
            return self.getTypedRuleContext(MySQLParser.CreateStatementContext,0)


        def dropStatement(self):
            return self.getTypedRuleContext(MySQLParser.DropStatementContext,0)


        def renameTableStatement(self):
            return self.getTypedRuleContext(MySQLParser.RenameTableStatementContext,0)


        def truncateTableStatement(self):
            return self.getTypedRuleContext(MySQLParser.TruncateTableStatementContext,0)


        def importStatement(self):
            return self.getTypedRuleContext(MySQLParser.ImportStatementContext,0)


        def callStatement(self):
            return self.getTypedRuleContext(MySQLParser.CallStatementContext,0)


        def deleteStatement(self):
            return self.getTypedRuleContext(MySQLParser.DeleteStatementContext,0)


        def doStatement(self):
            return self.getTypedRuleContext(MySQLParser.DoStatementContext,0)


        def handlerStatement(self):
            return self.getTypedRuleContext(MySQLParser.HandlerStatementContext,0)


        def insertStatement(self):
            return self.getTypedRuleContext(MySQLParser.InsertStatementContext,0)


        def loadStatement(self):
            return self.getTypedRuleContext(MySQLParser.LoadStatementContext,0)


        def replaceStatement(self):
            return self.getTypedRuleContext(MySQLParser.ReplaceStatementContext,0)


        def selectStatement(self):
            return self.getTypedRuleContext(MySQLParser.SelectStatementContext,0)


        def updateStatement(self):
            return self.getTypedRuleContext(MySQLParser.UpdateStatementContext,0)


        def transactionOrLockingStatement(self):
            return self.getTypedRuleContext(MySQLParser.TransactionOrLockingStatementContext,0)


        def replicationStatement(self):
            return self.getTypedRuleContext(MySQLParser.ReplicationStatementContext,0)


        def preparedStatement(self):
            return self.getTypedRuleContext(MySQLParser.PreparedStatementContext,0)


        def cloneStatement(self):
            return self.getTypedRuleContext(MySQLParser.CloneStatementContext,0)


        def accountManagementStatement(self):
            return self.getTypedRuleContext(MySQLParser.AccountManagementStatementContext,0)


        def tableAdministrationStatement(self):
            return self.getTypedRuleContext(MySQLParser.TableAdministrationStatementContext,0)


        def uninstallStatement(self):
            return self.getTypedRuleContext(MySQLParser.UninstallStatementContext,0)


        def installStatement(self):
            return self.getTypedRuleContext(MySQLParser.InstallStatementContext,0)


        def setStatement(self):
            return self.getTypedRuleContext(MySQLParser.SetStatementContext,0)


        def showDatabasesStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowDatabasesStatementContext,0)


        def showTablesStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowTablesStatementContext,0)


        def showTriggersStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowTriggersStatementContext,0)


        def showEventsStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowEventsStatementContext,0)


        def showTableStatusStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowTableStatusStatementContext,0)


        def showOpenTablesStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowOpenTablesStatementContext,0)


        def showParseTreeStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowParseTreeStatementContext,0)


        def showPluginsStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowPluginsStatementContext,0)


        def showEngineLogsStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowEngineLogsStatementContext,0)


        def showEngineMutexStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowEngineMutexStatementContext,0)


        def showEngineStatusStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowEngineStatusStatementContext,0)


        def showColumnsStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowColumnsStatementContext,0)


        def showBinaryLogsStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowBinaryLogsStatementContext,0)


        def showBinaryLogStatusStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowBinaryLogStatusStatementContext,0)


        def showReplicasStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowReplicasStatementContext,0)


        def showBinlogEventsStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowBinlogEventsStatementContext,0)


        def showRelaylogEventsStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowRelaylogEventsStatementContext,0)


        def showKeysStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowKeysStatementContext,0)


        def showEnginesStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowEnginesStatementContext,0)


        def showCountWarningsStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowCountWarningsStatementContext,0)


        def showCountErrorsStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowCountErrorsStatementContext,0)


        def showWarningsStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowWarningsStatementContext,0)


        def showErrorsStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowErrorsStatementContext,0)


        def showProfilesStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowProfilesStatementContext,0)


        def showProfileStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowProfileStatementContext,0)


        def showStatusStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowStatusStatementContext,0)


        def showProcessListStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowProcessListStatementContext,0)


        def showVariablesStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowVariablesStatementContext,0)


        def showCharacterSetStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowCharacterSetStatementContext,0)


        def showCollationStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowCollationStatementContext,0)


        def showPrivilegesStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowPrivilegesStatementContext,0)


        def showGrantsStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowGrantsStatementContext,0)


        def showCreateDatabaseStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowCreateDatabaseStatementContext,0)


        def showCreateTableStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowCreateTableStatementContext,0)


        def showCreateViewStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowCreateViewStatementContext,0)


        def showMasterStatusStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowMasterStatusStatementContext,0)


        def showReplicaStatusStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowReplicaStatusStatementContext,0)


        def showCreateProcedureStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowCreateProcedureStatementContext,0)


        def showCreateFunctionStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowCreateFunctionStatementContext,0)


        def showCreateTriggerStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowCreateTriggerStatementContext,0)


        def showCreateProcedureStatusStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowCreateProcedureStatusStatementContext,0)


        def showCreateFunctionStatusStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowCreateFunctionStatusStatementContext,0)


        def showCreateProcedureCodeStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowCreateProcedureCodeStatementContext,0)


        def showCreateFunctionCodeStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowCreateFunctionCodeStatementContext,0)


        def showCreateEventStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowCreateEventStatementContext,0)


        def showCreateUserStatement(self):
            return self.getTypedRuleContext(MySQLParser.ShowCreateUserStatementContext,0)


        def resourceGroupManagement(self):
            return self.getTypedRuleContext(MySQLParser.ResourceGroupManagementContext,0)


        def otherAdministrativeStatement(self):
            return self.getTypedRuleContext(MySQLParser.OtherAdministrativeStatementContext,0)


        def utilityStatement(self):
            return self.getTypedRuleContext(MySQLParser.UtilityStatementContext,0)


        def getDiagnosticsStatement(self):
            return self.getTypedRuleContext(MySQLParser.GetDiagnosticsStatementContext,0)


        def signalStatement(self):
            return self.getTypedRuleContext(MySQLParser.SignalStatementContext,0)


        def resignalStatement(self):
            return self.getTypedRuleContext(MySQLParser.ResignalStatementContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_simpleStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleStatement" ):
                listener.enterSimpleStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleStatement" ):
                listener.exitSimpleStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleStatement" ):
                return visitor.visitSimpleStatement(self)
            else:
                return visitor.visitChildren(self)




    def simpleStatement(self):

        localctx = MySQLParser.SimpleStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_simpleStatement)
        try:
            self.state = 1600
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1524
                self.alterStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1525
                self.createStatement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1526
                self.dropStatement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1527
                self.renameTableStatement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1528
                self.truncateTableStatement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1529
                self.importStatement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1530
                self.callStatement()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1531
                self.deleteStatement()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1532
                self.doStatement()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1533
                self.handlerStatement()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1534
                self.insertStatement()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 1535
                self.loadStatement()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 1536
                self.replaceStatement()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 1537
                self.selectStatement()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 1538
                self.updateStatement()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 1539
                self.transactionOrLockingStatement()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 1540
                self.replicationStatement()
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 1541
                self.preparedStatement()
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 1542
                self.cloneStatement()
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 1543
                self.accountManagementStatement()
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 1544
                self.tableAdministrationStatement()
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 1545
                self.uninstallStatement()
                pass

            elif la_ == 23:
                self.enterOuterAlt(localctx, 23)
                self.state = 1546
                self.installStatement()
                pass

            elif la_ == 24:
                self.enterOuterAlt(localctx, 24)
                self.state = 1547
                self.setStatement()
                pass

            elif la_ == 25:
                self.enterOuterAlt(localctx, 25)
                self.state = 1548
                self.showDatabasesStatement()
                pass

            elif la_ == 26:
                self.enterOuterAlt(localctx, 26)
                self.state = 1549
                self.showTablesStatement()
                pass

            elif la_ == 27:
                self.enterOuterAlt(localctx, 27)
                self.state = 1550
                self.showTriggersStatement()
                pass

            elif la_ == 28:
                self.enterOuterAlt(localctx, 28)
                self.state = 1551
                self.showEventsStatement()
                pass

            elif la_ == 29:
                self.enterOuterAlt(localctx, 29)
                self.state = 1552
                self.showTableStatusStatement()
                pass

            elif la_ == 30:
                self.enterOuterAlt(localctx, 30)
                self.state = 1553
                self.showOpenTablesStatement()
                pass

            elif la_ == 31:
                self.enterOuterAlt(localctx, 31)
                self.state = 1554
                self.showParseTreeStatement()
                pass

            elif la_ == 32:
                self.enterOuterAlt(localctx, 32)
                self.state = 1555
                self.showPluginsStatement()
                pass

            elif la_ == 33:
                self.enterOuterAlt(localctx, 33)
                self.state = 1556
                self.showEngineLogsStatement()
                pass

            elif la_ == 34:
                self.enterOuterAlt(localctx, 34)
                self.state = 1557
                self.showEngineMutexStatement()
                pass

            elif la_ == 35:
                self.enterOuterAlt(localctx, 35)
                self.state = 1558
                self.showEngineStatusStatement()
                pass

            elif la_ == 36:
                self.enterOuterAlt(localctx, 36)
                self.state = 1559
                self.showColumnsStatement()
                pass

            elif la_ == 37:
                self.enterOuterAlt(localctx, 37)
                self.state = 1560
                self.showBinaryLogsStatement()
                pass

            elif la_ == 38:
                self.enterOuterAlt(localctx, 38)
                self.state = 1561
                self.showBinaryLogStatusStatement()
                pass

            elif la_ == 39:
                self.enterOuterAlt(localctx, 39)
                self.state = 1562
                self.showReplicasStatement()
                pass

            elif la_ == 40:
                self.enterOuterAlt(localctx, 40)
                self.state = 1563
                self.showBinlogEventsStatement()
                pass

            elif la_ == 41:
                self.enterOuterAlt(localctx, 41)
                self.state = 1564
                self.showRelaylogEventsStatement()
                pass

            elif la_ == 42:
                self.enterOuterAlt(localctx, 42)
                self.state = 1565
                self.showKeysStatement()
                pass

            elif la_ == 43:
                self.enterOuterAlt(localctx, 43)
                self.state = 1566
                self.showEnginesStatement()
                pass

            elif la_ == 44:
                self.enterOuterAlt(localctx, 44)
                self.state = 1567
                self.showCountWarningsStatement()
                pass

            elif la_ == 45:
                self.enterOuterAlt(localctx, 45)
                self.state = 1568
                self.showCountErrorsStatement()
                pass

            elif la_ == 46:
                self.enterOuterAlt(localctx, 46)
                self.state = 1569
                self.showWarningsStatement()
                pass

            elif la_ == 47:
                self.enterOuterAlt(localctx, 47)
                self.state = 1570
                self.showErrorsStatement()
                pass

            elif la_ == 48:
                self.enterOuterAlt(localctx, 48)
                self.state = 1571
                self.showProfilesStatement()
                pass

            elif la_ == 49:
                self.enterOuterAlt(localctx, 49)
                self.state = 1572
                self.showProfileStatement()
                pass

            elif la_ == 50:
                self.enterOuterAlt(localctx, 50)
                self.state = 1573
                self.showStatusStatement()
                pass

            elif la_ == 51:
                self.enterOuterAlt(localctx, 51)
                self.state = 1574
                self.showProcessListStatement()
                pass

            elif la_ == 52:
                self.enterOuterAlt(localctx, 52)
                self.state = 1575
                self.showVariablesStatement()
                pass

            elif la_ == 53:
                self.enterOuterAlt(localctx, 53)
                self.state = 1576
                self.showCharacterSetStatement()
                pass

            elif la_ == 54:
                self.enterOuterAlt(localctx, 54)
                self.state = 1577
                self.showCollationStatement()
                pass

            elif la_ == 55:
                self.enterOuterAlt(localctx, 55)
                self.state = 1578
                self.showPrivilegesStatement()
                pass

            elif la_ == 56:
                self.enterOuterAlt(localctx, 56)
                self.state = 1579
                self.showGrantsStatement()
                pass

            elif la_ == 57:
                self.enterOuterAlt(localctx, 57)
                self.state = 1580
                self.showCreateDatabaseStatement()
                pass

            elif la_ == 58:
                self.enterOuterAlt(localctx, 58)
                self.state = 1581
                self.showCreateTableStatement()
                pass

            elif la_ == 59:
                self.enterOuterAlt(localctx, 59)
                self.state = 1582
                self.showCreateViewStatement()
                pass

            elif la_ == 60:
                self.enterOuterAlt(localctx, 60)
                self.state = 1583
                self.showMasterStatusStatement()
                pass

            elif la_ == 61:
                self.enterOuterAlt(localctx, 61)
                self.state = 1584
                self.showReplicaStatusStatement()
                pass

            elif la_ == 62:
                self.enterOuterAlt(localctx, 62)
                self.state = 1585
                self.showCreateProcedureStatement()
                pass

            elif la_ == 63:
                self.enterOuterAlt(localctx, 63)
                self.state = 1586
                self.showCreateFunctionStatement()
                pass

            elif la_ == 64:
                self.enterOuterAlt(localctx, 64)
                self.state = 1587
                self.showCreateTriggerStatement()
                pass

            elif la_ == 65:
                self.enterOuterAlt(localctx, 65)
                self.state = 1588
                self.showCreateProcedureStatusStatement()
                pass

            elif la_ == 66:
                self.enterOuterAlt(localctx, 66)
                self.state = 1589
                self.showCreateFunctionStatusStatement()
                pass

            elif la_ == 67:
                self.enterOuterAlt(localctx, 67)
                self.state = 1590
                self.showCreateProcedureCodeStatement()
                pass

            elif la_ == 68:
                self.enterOuterAlt(localctx, 68)
                self.state = 1591
                self.showCreateFunctionCodeStatement()
                pass

            elif la_ == 69:
                self.enterOuterAlt(localctx, 69)
                self.state = 1592
                self.showCreateEventStatement()
                pass

            elif la_ == 70:
                self.enterOuterAlt(localctx, 70)
                self.state = 1593
                self.showCreateUserStatement()
                pass

            elif la_ == 71:
                self.enterOuterAlt(localctx, 71)
                self.state = 1594
                self.resourceGroupManagement()
                pass

            elif la_ == 72:
                self.enterOuterAlt(localctx, 72)
                self.state = 1595
                self.otherAdministrativeStatement()
                pass

            elif la_ == 73:
                self.enterOuterAlt(localctx, 73)
                self.state = 1596
                self.utilityStatement()
                pass

            elif la_ == 74:
                self.enterOuterAlt(localctx, 74)
                self.state = 1597
                self.getDiagnosticsStatement()
                pass

            elif la_ == 75:
                self.enterOuterAlt(localctx, 75)
                self.state = 1598
                self.signalStatement()
                pass

            elif la_ == 76:
                self.enterOuterAlt(localctx, 76)
                self.state = 1599
                self.resignalStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALTER_SYMBOL(self):
            return self.getToken(MySQLParser.ALTER_SYMBOL, 0)

        def alterTable(self):
            return self.getTypedRuleContext(MySQLParser.AlterTableContext,0)


        def alterDatabase(self):
            return self.getTypedRuleContext(MySQLParser.AlterDatabaseContext,0)


        def PROCEDURE_SYMBOL(self):
            return self.getToken(MySQLParser.PROCEDURE_SYMBOL, 0)

        def procedureRef(self):
            return self.getTypedRuleContext(MySQLParser.ProcedureRefContext,0)


        def FUNCTION_SYMBOL(self):
            return self.getToken(MySQLParser.FUNCTION_SYMBOL, 0)

        def functionRef(self):
            return self.getTypedRuleContext(MySQLParser.FunctionRefContext,0)


        def alterView(self):
            return self.getTypedRuleContext(MySQLParser.AlterViewContext,0)


        def alterEvent(self):
            return self.getTypedRuleContext(MySQLParser.AlterEventContext,0)


        def alterTablespace(self):
            return self.getTypedRuleContext(MySQLParser.AlterTablespaceContext,0)


        def alterUndoTablespace(self):
            return self.getTypedRuleContext(MySQLParser.AlterUndoTablespaceContext,0)


        def alterLogfileGroup(self):
            return self.getTypedRuleContext(MySQLParser.AlterLogfileGroupContext,0)


        def alterServer(self):
            return self.getTypedRuleContext(MySQLParser.AlterServerContext,0)


        def alterInstanceStatement(self):
            return self.getTypedRuleContext(MySQLParser.AlterInstanceStatementContext,0)


        def routineAlterOptions(self):
            return self.getTypedRuleContext(MySQLParser.RoutineAlterOptionsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_alterStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterStatement" ):
                listener.enterAlterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterStatement" ):
                listener.exitAlterStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterStatement" ):
                return visitor.visitAlterStatement(self)
            else:
                return visitor.visitChildren(self)




    def alterStatement(self):

        localctx = MySQLParser.AlterStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_alterStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1602
            self.match(MySQLParser.ALTER_SYMBOL)
            self.state = 1623
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.state = 1603
                self.alterTable()
                pass

            elif la_ == 2:
                self.state = 1604
                self.alterDatabase()
                pass

            elif la_ == 3:
                self.state = 1605
                self.match(MySQLParser.PROCEDURE_SYMBOL)
                self.state = 1606
                self.procedureRef()
                self.state = 1608
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 118)) & ~0x3f) == 0 and ((1 << (_la - 118)) & 72057594037960705) != 0) or _la==297 or ((((_la - 370)) & ~0x3f) == 0 and ((1 << (_la - 370)) & 5242881) != 0) or _la==451 or _la==547:
                    self.state = 1607
                    self.routineAlterOptions()


                pass

            elif la_ == 4:
                self.state = 1610
                self.match(MySQLParser.FUNCTION_SYMBOL)
                self.state = 1611
                self.functionRef()
                self.state = 1613
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 118)) & ~0x3f) == 0 and ((1 << (_la - 118)) & 72057594037960705) != 0) or _la==297 or ((((_la - 370)) & ~0x3f) == 0 and ((1 << (_la - 370)) & 5242881) != 0) or _la==451 or _la==547:
                    self.state = 1612
                    self.routineAlterOptions()


                pass

            elif la_ == 5:
                self.state = 1615
                self.alterView()
                pass

            elif la_ == 6:
                self.state = 1616
                self.alterEvent()
                pass

            elif la_ == 7:
                self.state = 1617
                self.alterTablespace()
                pass

            elif la_ == 8:
                self.state = 1618
                if not self.isServerVersionGe80014():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80014()")
                self.state = 1619
                self.alterUndoTablespace()
                pass

            elif la_ == 9:
                self.state = 1620
                self.alterLogfileGroup()
                pass

            elif la_ == 10:
                self.state = 1621
                self.alterServer()
                pass

            elif la_ == 11:
                self.state = 1622
                self.alterInstanceStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterDatabaseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATABASE_SYMBOL(self):
            return self.getToken(MySQLParser.DATABASE_SYMBOL, 0)

        def schemaRef(self):
            return self.getTypedRuleContext(MySQLParser.SchemaRefContext,0)


        def alterDatabaseOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.AlterDatabaseOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.AlterDatabaseOptionContext,i)


        def getRuleIndex(self):
            return MySQLParser.RULE_alterDatabase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterDatabase" ):
                listener.enterAlterDatabase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterDatabase" ):
                listener.exitAlterDatabase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterDatabase" ):
                return visitor.visitAlterDatabase(self)
            else:
                return visitor.visitChildren(self)




    def alterDatabase(self):

        localctx = MySQLParser.AlterDatabaseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_alterDatabase)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1625
            self.match(MySQLParser.DATABASE_SYMBOL)
            self.state = 1626
            self.schemaRef()
            self.state = 1628 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1627
                    self.alterDatabaseOption()

                else:
                    raise NoViableAltException(self)
                self.state = 1630 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterDatabaseOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def createDatabaseOption(self):
            return self.getTypedRuleContext(MySQLParser.CreateDatabaseOptionContext,0)


        def READ_SYMBOL(self):
            return self.getToken(MySQLParser.READ_SYMBOL, 0)

        def ONLY_SYMBOL(self):
            return self.getToken(MySQLParser.ONLY_SYMBOL, 0)

        def ternaryOption(self):
            return self.getTypedRuleContext(MySQLParser.TernaryOptionContext,0)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_alterDatabaseOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterDatabaseOption" ):
                listener.enterAlterDatabaseOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterDatabaseOption" ):
                listener.exitAlterDatabaseOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterDatabaseOption" ):
                return visitor.visitAlterDatabaseOption(self)
            else:
                return visitor.visitChildren(self)




    def alterDatabaseOption(self):

        localctx = MySQLParser.AlterDatabaseOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_alterDatabaseOption)
        self._la = 0 # Token type
        try:
            self.state = 1639
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1632
                self.createDatabaseOption()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1633
                self.match(MySQLParser.READ_SYMBOL)
                self.state = 1634
                self.match(MySQLParser.ONLY_SYMBOL)
                self.state = 1636
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 1635
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 1638
                self.ternaryOption()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterEventContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EVENT_SYMBOL(self):
            return self.getToken(MySQLParser.EVENT_SYMBOL, 0)

        def eventRef(self):
            return self.getTypedRuleContext(MySQLParser.EventRefContext,0)


        def definerClause(self):
            return self.getTypedRuleContext(MySQLParser.DefinerClauseContext,0)


        def ON_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.ON_SYMBOL)
            else:
                return self.getToken(MySQLParser.ON_SYMBOL, i)

        def SCHEDULE_SYMBOL(self):
            return self.getToken(MySQLParser.SCHEDULE_SYMBOL, 0)

        def schedule(self):
            return self.getTypedRuleContext(MySQLParser.ScheduleContext,0)


        def COMPLETION_SYMBOL(self):
            return self.getToken(MySQLParser.COMPLETION_SYMBOL, 0)

        def PRESERVE_SYMBOL(self):
            return self.getToken(MySQLParser.PRESERVE_SYMBOL, 0)

        def RENAME_SYMBOL(self):
            return self.getToken(MySQLParser.RENAME_SYMBOL, 0)

        def TO_SYMBOL(self):
            return self.getToken(MySQLParser.TO_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def ENABLE_SYMBOL(self):
            return self.getToken(MySQLParser.ENABLE_SYMBOL, 0)

        def DISABLE_SYMBOL(self):
            return self.getToken(MySQLParser.DISABLE_SYMBOL, 0)

        def COMMENT_SYMBOL(self):
            return self.getToken(MySQLParser.COMMENT_SYMBOL, 0)

        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def DO_SYMBOL(self):
            return self.getToken(MySQLParser.DO_SYMBOL, 0)

        def compoundStatement(self):
            return self.getTypedRuleContext(MySQLParser.CompoundStatementContext,0)


        def NOT_SYMBOL(self):
            return self.getToken(MySQLParser.NOT_SYMBOL, 0)

        def replica(self):
            return self.getTypedRuleContext(MySQLParser.ReplicaContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_alterEvent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterEvent" ):
                listener.enterAlterEvent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterEvent" ):
                listener.exitAlterEvent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterEvent" ):
                return visitor.visitAlterEvent(self)
            else:
                return visitor.visitChildren(self)




    def alterEvent(self):

        localctx = MySQLParser.AlterEventContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_alterEvent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1642
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==168:
                self.state = 1641
                self.definerClause()


            self.state = 1644
            self.match(MySQLParser.EVENT_SYMBOL)
            self.state = 1645
            self.eventRef()
            self.state = 1649
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.state = 1646
                self.match(MySQLParser.ON_SYMBOL)
                self.state = 1647
                self.match(MySQLParser.SCHEDULE_SYMBOL)
                self.state = 1648
                self.schedule()


            self.state = 1657
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==401:
                self.state = 1651
                self.match(MySQLParser.ON_SYMBOL)
                self.state = 1652
                self.match(MySQLParser.COMPLETION_SYMBOL)
                self.state = 1654
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==390:
                    self.state = 1653
                    self.match(MySQLParser.NOT_SYMBOL)


                self.state = 1656
                self.match(MySQLParser.PRESERVE_SYMBOL)


            self.state = 1662
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==470:
                self.state = 1659
                self.match(MySQLParser.RENAME_SYMBOL)
                self.state = 1660
                self.match(MySQLParser.TO_SYMBOL)
                self.state = 1661
                self.identifier()


            self.state = 1670
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [192]:
                self.state = 1664
                self.match(MySQLParser.ENABLE_SYMBOL)
                pass
            elif token in [177]:
                self.state = 1665
                self.match(MySQLParser.DISABLE_SYMBOL)
                self.state = 1668
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==401:
                    self.state = 1666
                    self.match(MySQLParser.ON_SYMBOL)
                    self.state = 1667
                    self.replica()


                pass
            elif token in [-1, 30, 118, 183]:
                pass
            else:
                pass
            self.state = 1674
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118:
                self.state = 1672
                self.match(MySQLParser.COMMENT_SYMBOL)
                self.state = 1673
                self.textLiteral()


            self.state = 1678
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==183:
                self.state = 1676
                self.match(MySQLParser.DO_SYMBOL)
                self.state = 1677
                self.compoundStatement()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterLogfileGroupContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOGFILE_SYMBOL(self):
            return self.getToken(MySQLParser.LOGFILE_SYMBOL, 0)

        def GROUP_SYMBOL(self):
            return self.getToken(MySQLParser.GROUP_SYMBOL, 0)

        def logfileGroupRef(self):
            return self.getTypedRuleContext(MySQLParser.LogfileGroupRefContext,0)


        def ADD_SYMBOL(self):
            return self.getToken(MySQLParser.ADD_SYMBOL, 0)

        def UNDOFILE_SYMBOL(self):
            return self.getToken(MySQLParser.UNDOFILE_SYMBOL, 0)

        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def alterLogfileGroupOptions(self):
            return self.getTypedRuleContext(MySQLParser.AlterLogfileGroupOptionsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_alterLogfileGroup

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterLogfileGroup" ):
                listener.enterAlterLogfileGroup(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterLogfileGroup" ):
                listener.exitAlterLogfileGroup(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterLogfileGroup" ):
                return visitor.visitAlterLogfileGroup(self)
            else:
                return visitor.visitChildren(self)




    def alterLogfileGroup(self):

        localctx = MySQLParser.AlterLogfileGroupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_alterLogfileGroup)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1680
            self.match(MySQLParser.LOGFILE_SYMBOL)
            self.state = 1681
            self.match(MySQLParser.GROUP_SYMBOL)
            self.state = 1682
            self.logfileGroupRef()
            self.state = 1683
            self.match(MySQLParser.ADD_SYMBOL)
            self.state = 1684
            self.match(MySQLParser.UNDOFILE_SYMBOL)
            self.state = 1685
            self.textLiteral()
            self.state = 1687
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==198 or _la==270 or _la==393 or _la==563 or _la==646:
                self.state = 1686
                self.alterLogfileGroupOptions()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterLogfileGroupOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alterLogfileGroupOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.AlterLogfileGroupOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.AlterLogfileGroupOptionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_alterLogfileGroupOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterLogfileGroupOptions" ):
                listener.enterAlterLogfileGroupOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterLogfileGroupOptions" ):
                listener.exitAlterLogfileGroupOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterLogfileGroupOptions" ):
                return visitor.visitAlterLogfileGroupOptions(self)
            else:
                return visitor.visitChildren(self)




    def alterLogfileGroupOptions(self):

        localctx = MySQLParser.AlterLogfileGroupOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_alterLogfileGroupOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1689
            self.alterLogfileGroupOption()
            self.state = 1696
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29 or _la==198 or _la==270 or _la==393 or _la==563 or _la==646:
                self.state = 1691
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 1690
                    self.match(MySQLParser.COMMA_SYMBOL)


                self.state = 1693
                self.alterLogfileGroupOption()
                self.state = 1698
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterLogfileGroupOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tsOptionInitialSize(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionInitialSizeContext,0)


        def tsOptionEngine(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionEngineContext,0)


        def tsOptionWait(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionWaitContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_alterLogfileGroupOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterLogfileGroupOption" ):
                listener.enterAlterLogfileGroupOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterLogfileGroupOption" ):
                listener.exitAlterLogfileGroupOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterLogfileGroupOption" ):
                return visitor.visitAlterLogfileGroupOption(self)
            else:
                return visitor.visitChildren(self)




    def alterLogfileGroupOption(self):

        localctx = MySQLParser.AlterLogfileGroupOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_alterLogfileGroupOption)
        try:
            self.state = 1702
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [270]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1699
                self.tsOptionInitialSize()
                pass
            elif token in [198, 563]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1700
                self.tsOptionEngine()
                pass
            elif token in [393, 646]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1701
                self.tsOptionWait()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterServerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SERVER_SYMBOL(self):
            return self.getToken(MySQLParser.SERVER_SYMBOL, 0)

        def serverRef(self):
            return self.getTypedRuleContext(MySQLParser.ServerRefContext,0)


        def serverOptions(self):
            return self.getTypedRuleContext(MySQLParser.ServerOptionsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_alterServer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterServer" ):
                listener.enterAlterServer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterServer" ):
                listener.exitAlterServer(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterServer" ):
                return visitor.visitAlterServer(self)
            else:
                return visitor.visitChildren(self)




    def alterServer(self):

        localctx = MySQLParser.AlterServerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_alterServer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1704
            self.match(MySQLParser.SERVER_SYMBOL)
            self.state = 1705
            self.serverRef()
            self.state = 1706
            self.serverOptions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterTableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_SYMBOL, 0)

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def onlineOption(self):
            return self.getTypedRuleContext(MySQLParser.OnlineOptionContext,0)


        def alterTableActions(self):
            return self.getTypedRuleContext(MySQLParser.AlterTableActionsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_alterTable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterTable" ):
                listener.enterAlterTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterTable" ):
                listener.exitAlterTable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterTable" ):
                return visitor.visitAlterTable(self)
            else:
                return visitor.visitChildren(self)




    def alterTable(self):

        localctx = MySQLParser.AlterTableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_alterTable)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1709
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==399 or _la==403:
                self.state = 1708
                self.onlineOption()


            self.state = 1711
            self.match(MySQLParser.TABLE_SYMBOL)
            self.state = 1712
            self.tableRef()
            self.state = 1714
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                self.state = 1713
                self.alterTableActions()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterTableActionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alterCommandList(self):
            return self.getTypedRuleContext(MySQLParser.AlterCommandListContext,0)


        def partitionClause(self):
            return self.getTypedRuleContext(MySQLParser.PartitionClauseContext,0)


        def removePartitioning(self):
            return self.getTypedRuleContext(MySQLParser.RemovePartitioningContext,0)


        def standaloneAlterCommands(self):
            return self.getTypedRuleContext(MySQLParser.StandaloneAlterCommandsContext,0)


        def alterCommandsModifierList(self):
            return self.getTypedRuleContext(MySQLParser.AlterCommandsModifierListContext,0)


        def COMMA_SYMBOL(self):
            return self.getToken(MySQLParser.COMMA_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_alterTableActions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterTableActions" ):
                listener.enterAlterTableActions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterTableActions" ):
                listener.exitAlterTableActions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterTableActions" ):
                return visitor.visitAlterTableActions(self)
            else:
                return visitor.visitChildren(self)




    def alterTableActions(self):

        localctx = MySQLParser.AlterTableActionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_alterTableActions)
        try:
            self.state = 1729
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1716
                self.alterCommandList()
                self.state = 1719
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [423]:
                    self.state = 1717
                    self.partitionClause()
                    pass
                elif token in [469]:
                    self.state = 1718
                    self.removePartitioning()
                    pass
                elif token in [-1, 30]:
                    pass
                else:
                    pass
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1721
                self.partitionClause()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1722
                self.removePartitioning()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1726
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
                if la_ == 1:
                    self.state = 1723
                    self.alterCommandsModifierList()
                    self.state = 1724
                    self.match(MySQLParser.COMMA_SYMBOL)


                self.state = 1728
                self.standaloneAlterCommands()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterCommandListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alterCommandsModifierList(self):
            return self.getTypedRuleContext(MySQLParser.AlterCommandsModifierListContext,0)


        def alterList(self):
            return self.getTypedRuleContext(MySQLParser.AlterListContext,0)


        def COMMA_SYMBOL(self):
            return self.getToken(MySQLParser.COMMA_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_alterCommandList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterCommandList" ):
                listener.enterAlterCommandList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterCommandList" ):
                listener.exitAlterCommandList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterCommandList" ):
                return visitor.visitAlterCommandList(self)
            else:
                return visitor.visitChildren(self)




    def alterCommandList(self):

        localctx = MySQLParser.AlterCommandListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_alterCommandList)
        try:
            self.state = 1738
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1731
                self.alterCommandsModifierList()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1735
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
                if la_ == 1:
                    self.state = 1732
                    self.alterCommandsModifierList()
                    self.state = 1733
                    self.match(MySQLParser.COMMA_SYMBOL)


                self.state = 1737
                self.alterList()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterCommandsModifierListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alterCommandsModifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.AlterCommandsModifierContext)
            else:
                return self.getTypedRuleContext(MySQLParser.AlterCommandsModifierContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_alterCommandsModifierList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterCommandsModifierList" ):
                listener.enterAlterCommandsModifierList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterCommandsModifierList" ):
                listener.exitAlterCommandsModifierList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterCommandsModifierList" ):
                return visitor.visitAlterCommandsModifierList(self)
            else:
                return visitor.visitChildren(self)




    def alterCommandsModifierList(self):

        localctx = MySQLParser.AlterCommandsModifierListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_alterCommandsModifierList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1740
            self.alterCommandsModifier()
            self.state = 1745
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,29,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1741
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 1742
                    self.alterCommandsModifier() 
                self.state = 1747
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,29,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StandaloneAlterCommandsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISCARD_SYMBOL(self):
            return self.getToken(MySQLParser.DISCARD_SYMBOL, 0)

        def TABLESPACE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLESPACE_SYMBOL, 0)

        def IMPORT_SYMBOL(self):
            return self.getToken(MySQLParser.IMPORT_SYMBOL, 0)

        def alterPartition(self):
            return self.getTypedRuleContext(MySQLParser.AlterPartitionContext,0)


        def SECONDARY_LOAD_SYMBOL(self):
            return self.getToken(MySQLParser.SECONDARY_LOAD_SYMBOL, 0)

        def SECONDARY_UNLOAD_SYMBOL(self):
            return self.getToken(MySQLParser.SECONDARY_UNLOAD_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_standaloneAlterCommands

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStandaloneAlterCommands" ):
                listener.enterStandaloneAlterCommands(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStandaloneAlterCommands" ):
                listener.exitStandaloneAlterCommands(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStandaloneAlterCommands" ):
                return visitor.visitStandaloneAlterCommands(self)
            else:
                return visitor.visitChildren(self)




    def standaloneAlterCommands(self):

        localctx = MySQLParser.StandaloneAlterCommandsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_standaloneAlterCommands)
        self._la = 0 # Token type
        try:
            self.state = 1755
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1748
                self.match(MySQLParser.DISCARD_SYMBOL)
                self.state = 1749
                self.match(MySQLParser.TABLESPACE_SYMBOL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1750
                self.match(MySQLParser.IMPORT_SYMBOL)
                self.state = 1751
                self.match(MySQLParser.TABLESPACE_SYMBOL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1752
                self.alterPartition()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1753
                if not self.isServerVersionGe80014():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80014()")
                self.state = 1754
                _la = self._input.LA(1)
                if not(_la==730 or _la==731):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterPartitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD_SYMBOL(self):
            return self.getToken(MySQLParser.ADD_SYMBOL, 0)

        def PARTITION_SYMBOL(self):
            return self.getToken(MySQLParser.PARTITION_SYMBOL, 0)

        def partitionDefinitions(self):
            return self.getTypedRuleContext(MySQLParser.PartitionDefinitionsContext,0)


        def PARTITIONS_SYMBOL(self):
            return self.getToken(MySQLParser.PARTITIONS_SYMBOL, 0)

        def real_ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Real_ulong_numberContext,0)


        def noWriteToBinLog(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.NoWriteToBinLogContext)
            else:
                return self.getTypedRuleContext(MySQLParser.NoWriteToBinLogContext,i)


        def DROP_SYMBOL(self):
            return self.getToken(MySQLParser.DROP_SYMBOL, 0)

        def identifierList(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierListContext,0)


        def REBUILD_SYMBOL(self):
            return self.getToken(MySQLParser.REBUILD_SYMBOL, 0)

        def allOrPartitionNameList(self):
            return self.getTypedRuleContext(MySQLParser.AllOrPartitionNameListContext,0)


        def OPTIMIZE_SYMBOL(self):
            return self.getToken(MySQLParser.OPTIMIZE_SYMBOL, 0)

        def ANALYZE_SYMBOL(self):
            return self.getToken(MySQLParser.ANALYZE_SYMBOL, 0)

        def CHECK_SYMBOL(self):
            return self.getToken(MySQLParser.CHECK_SYMBOL, 0)

        def checkOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.CheckOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.CheckOptionContext,i)


        def REPAIR_SYMBOL(self):
            return self.getToken(MySQLParser.REPAIR_SYMBOL, 0)

        def repairType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.RepairTypeContext)
            else:
                return self.getTypedRuleContext(MySQLParser.RepairTypeContext,i)


        def COALESCE_SYMBOL(self):
            return self.getToken(MySQLParser.COALESCE_SYMBOL, 0)

        def TRUNCATE_SYMBOL(self):
            return self.getToken(MySQLParser.TRUNCATE_SYMBOL, 0)

        def REORGANIZE_SYMBOL(self):
            return self.getToken(MySQLParser.REORGANIZE_SYMBOL, 0)

        def INTO_SYMBOL(self):
            return self.getToken(MySQLParser.INTO_SYMBOL, 0)

        def EXCHANGE_SYMBOL(self):
            return self.getToken(MySQLParser.EXCHANGE_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_SYMBOL, 0)

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def withValidation(self):
            return self.getTypedRuleContext(MySQLParser.WithValidationContext,0)


        def DISCARD_SYMBOL(self):
            return self.getToken(MySQLParser.DISCARD_SYMBOL, 0)

        def TABLESPACE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLESPACE_SYMBOL, 0)

        def IMPORT_SYMBOL(self):
            return self.getToken(MySQLParser.IMPORT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_alterPartition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterPartition" ):
                listener.enterAlterPartition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterPartition" ):
                listener.exitAlterPartition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterPartition" ):
                return visitor.visitAlterPartition(self)
            else:
                return visitor.visitChildren(self)




    def alterPartition(self):

        localctx = MySQLParser.AlterPartitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_alterPartition)
        self._la = 0 # Token type
        try:
            self.state = 1851
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [51]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1757
                self.match(MySQLParser.ADD_SYMBOL)
                self.state = 1758
                self.match(MySQLParser.PARTITION_SYMBOL)
                self.state = 1760
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==312 or _la==394:
                    self.state = 1759
                    self.noWriteToBinLog()


                self.state = 1765
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [32]:
                    self.state = 1762
                    self.partitionDefinitions()
                    pass
                elif token in [422]:
                    self.state = 1763
                    self.match(MySQLParser.PARTITIONS_SYMBOL)
                    self.state = 1764
                    self.real_ulong_number()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [184]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1767
                self.match(MySQLParser.DROP_SYMBOL)
                self.state = 1768
                self.match(MySQLParser.PARTITION_SYMBOL)
                self.state = 1769
                self.identifierList()
                pass
            elif token in [456]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1770
                self.match(MySQLParser.REBUILD_SYMBOL)
                self.state = 1771
                self.match(MySQLParser.PARTITION_SYMBOL)
                self.state = 1773
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
                if la_ == 1:
                    self.state = 1772
                    self.noWriteToBinLog()


                self.state = 1775
                self.allOrPartitionNameList()
                pass
            elif token in [406]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1776
                self.match(MySQLParser.OPTIMIZE_SYMBOL)
                self.state = 1777
                self.match(MySQLParser.PARTITION_SYMBOL)
                self.state = 1779
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
                if la_ == 1:
                    self.state = 1778
                    self.noWriteToBinLog()


                self.state = 1781
                self.allOrPartitionNameList()
                self.state = 1783
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==312 or _la==394:
                    self.state = 1782
                    self.noWriteToBinLog()


                pass
            elif token in [60]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1785
                self.match(MySQLParser.ANALYZE_SYMBOL)
                self.state = 1786
                self.match(MySQLParser.PARTITION_SYMBOL)
                self.state = 1788
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
                if la_ == 1:
                    self.state = 1787
                    self.noWriteToBinLog()


                self.state = 1790
                self.allOrPartitionNameList()
                pass
            elif token in [105]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1791
                self.match(MySQLParser.CHECK_SYMBOL)
                self.state = 1792
                self.match(MySQLParser.PARTITION_SYMBOL)
                self.state = 1793
                self.allOrPartitionNameList()
                self.state = 1797
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==100 or ((((_la - 215)) & ~0x3f) == 0 and ((1 << (_la - 215)) & 131089) != 0) or _la==357 or _la==449:
                    self.state = 1794
                    self.checkOption()
                    self.state = 1799
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [472]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1800
                self.match(MySQLParser.REPAIR_SYMBOL)
                self.state = 1801
                self.match(MySQLParser.PARTITION_SYMBOL)
                self.state = 1803
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
                if la_ == 1:
                    self.state = 1802
                    self.noWriteToBinLog()


                self.state = 1805
                self.allOrPartitionNameList()
                self.state = 1809
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==215 or _la==449 or _la==628:
                    self.state = 1806
                    self.repairType()
                    self.state = 1811
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [110]:
                self.enterOuterAlt(localctx, 8)
                self.state = 1812
                self.match(MySQLParser.COALESCE_SYMBOL)
                self.state = 1813
                self.match(MySQLParser.PARTITION_SYMBOL)
                self.state = 1815
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==312 or _la==394:
                    self.state = 1814
                    self.noWriteToBinLog()


                self.state = 1817
                self.real_ulong_number()
                pass
            elif token in [606]:
                self.enterOuterAlt(localctx, 9)
                self.state = 1818
                self.match(MySQLParser.TRUNCATE_SYMBOL)
                self.state = 1819
                self.match(MySQLParser.PARTITION_SYMBOL)
                self.state = 1820
                self.allOrPartitionNameList()
                pass
            elif token in [471]:
                self.enterOuterAlt(localctx, 10)
                self.state = 1821
                self.match(MySQLParser.REORGANIZE_SYMBOL)
                self.state = 1822
                self.match(MySQLParser.PARTITION_SYMBOL)
                self.state = 1824
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
                if la_ == 1:
                    self.state = 1823
                    self.noWriteToBinLog()


                self.state = 1830
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
                if la_ == 1:
                    self.state = 1826
                    self.identifierList()
                    self.state = 1827
                    self.match(MySQLParser.INTO_SYMBOL)
                    self.state = 1828
                    self.partitionDefinitions()


                pass
            elif token in [207]:
                self.enterOuterAlt(localctx, 11)
                self.state = 1832
                self.match(MySQLParser.EXCHANGE_SYMBOL)
                self.state = 1833
                self.match(MySQLParser.PARTITION_SYMBOL)
                self.state = 1834
                self.identifier()
                self.state = 1835
                self.match(MySQLParser.WITH_SYMBOL)
                self.state = 1836
                self.match(MySQLParser.TABLE_SYMBOL)
                self.state = 1837
                self.tableRef()
                self.state = 1839
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==653 or _la==654:
                    self.state = 1838
                    self.withValidation()


                pass
            elif token in [178]:
                self.enterOuterAlt(localctx, 12)
                self.state = 1841
                self.match(MySQLParser.DISCARD_SYMBOL)
                self.state = 1842
                self.match(MySQLParser.PARTITION_SYMBOL)
                self.state = 1843
                self.allOrPartitionNameList()
                self.state = 1844
                self.match(MySQLParser.TABLESPACE_SYMBOL)
                pass
            elif token in [266]:
                self.enterOuterAlt(localctx, 13)
                self.state = 1846
                self.match(MySQLParser.IMPORT_SYMBOL)
                self.state = 1847
                self.match(MySQLParser.PARTITION_SYMBOL)
                self.state = 1848
                self.allOrPartitionNameList()
                self.state = 1849
                self.match(MySQLParser.TABLESPACE_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alterListItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.AlterListItemContext)
            else:
                return self.getTypedRuleContext(MySQLParser.AlterListItemContext,i)


        def createTableOptionsSpaceSeparated(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.CreateTableOptionsSpaceSeparatedContext)
            else:
                return self.getTypedRuleContext(MySQLParser.CreateTableOptionsSpaceSeparatedContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def alterCommandsModifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.AlterCommandsModifierContext)
            else:
                return self.getTypedRuleContext(MySQLParser.AlterCommandsModifierContext,i)


        def getRuleIndex(self):
            return MySQLParser.RULE_alterList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterList" ):
                listener.enterAlterList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterList" ):
                listener.exitAlterList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterList" ):
                return visitor.visitAlterList(self)
            else:
                return visitor.visitChildren(self)




    def alterList(self):

        localctx = MySQLParser.AlterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_alterList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1855
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
            if la_ == 1:
                self.state = 1853
                self.alterListItem()
                pass

            elif la_ == 2:
                self.state = 1854
                self.createTableOptionsSpaceSeparated()
                pass


            self.state = 1865
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 1857
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 1861
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
                if la_ == 1:
                    self.state = 1858
                    self.alterListItem()
                    pass

                elif la_ == 2:
                    self.state = 1859
                    self.alterCommandsModifier()
                    pass

                elif la_ == 3:
                    self.state = 1860
                    self.createTableOptionsSpaceSeparated()
                    pass


                self.state = 1867
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterCommandsModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alterAlgorithmOption(self):
            return self.getTypedRuleContext(MySQLParser.AlterAlgorithmOptionContext,0)


        def alterLockOption(self):
            return self.getTypedRuleContext(MySQLParser.AlterLockOptionContext,0)


        def withValidation(self):
            return self.getTypedRuleContext(MySQLParser.WithValidationContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_alterCommandsModifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterCommandsModifier" ):
                listener.enterAlterCommandsModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterCommandsModifier" ):
                listener.exitAlterCommandsModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterCommandsModifier" ):
                return visitor.visitAlterCommandsModifier(self)
            else:
                return visitor.visitChildren(self)




    def alterCommandsModifier(self):

        localctx = MySQLParser.AlterCommandsModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_alterCommandsModifier)
        try:
            self.state = 1871
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [56]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1868
                self.alterAlgorithmOption()
                pass
            elif token in [314]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1869
                self.alterLockOption()
                pass
            elif token in [653, 654]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1870
                self.withValidation()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterListItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD_SYMBOL(self):
            return self.getToken(MySQLParser.ADD_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def fieldDefinition(self):
            return self.getTypedRuleContext(MySQLParser.FieldDefinitionContext,0)


        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def tableElementList(self):
            return self.getTypedRuleContext(MySQLParser.TableElementListContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def COLUMN_SYMBOL(self):
            return self.getToken(MySQLParser.COLUMN_SYMBOL, 0)

        def checkOrReferences(self):
            return self.getTypedRuleContext(MySQLParser.CheckOrReferencesContext,0)


        def place(self):
            return self.getTypedRuleContext(MySQLParser.PlaceContext,0)


        def tableConstraintDef(self):
            return self.getTypedRuleContext(MySQLParser.TableConstraintDefContext,0)


        def CHANGE_SYMBOL(self):
            return self.getToken(MySQLParser.CHANGE_SYMBOL, 0)

        def columnInternalRef(self):
            return self.getTypedRuleContext(MySQLParser.ColumnInternalRefContext,0)


        def MODIFY_SYMBOL(self):
            return self.getToken(MySQLParser.MODIFY_SYMBOL, 0)

        def DROP_SYMBOL(self):
            return self.getToken(MySQLParser.DROP_SYMBOL, 0)

        def FOREIGN_SYMBOL(self):
            return self.getToken(MySQLParser.FOREIGN_SYMBOL, 0)

        def KEY_SYMBOL(self):
            return self.getToken(MySQLParser.KEY_SYMBOL, 0)

        def PRIMARY_SYMBOL(self):
            return self.getToken(MySQLParser.PRIMARY_SYMBOL, 0)

        def keyOrIndex(self):
            return self.getTypedRuleContext(MySQLParser.KeyOrIndexContext,0)


        def indexRef(self):
            return self.getTypedRuleContext(MySQLParser.IndexRefContext,0)


        def CHECK_SYMBOL(self):
            return self.getToken(MySQLParser.CHECK_SYMBOL, 0)

        def CONSTRAINT_SYMBOL(self):
            return self.getToken(MySQLParser.CONSTRAINT_SYMBOL, 0)

        def restrict(self):
            return self.getTypedRuleContext(MySQLParser.RestrictContext,0)


        def DISABLE_SYMBOL(self):
            return self.getToken(MySQLParser.DISABLE_SYMBOL, 0)

        def KEYS_SYMBOL(self):
            return self.getToken(MySQLParser.KEYS_SYMBOL, 0)

        def ENABLE_SYMBOL(self):
            return self.getToken(MySQLParser.ENABLE_SYMBOL, 0)

        def ALTER_SYMBOL(self):
            return self.getToken(MySQLParser.ALTER_SYMBOL, 0)

        def SET_SYMBOL(self):
            return self.getToken(MySQLParser.SET_SYMBOL, 0)

        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def visibility(self):
            return self.getTypedRuleContext(MySQLParser.VisibilityContext,0)


        def exprWithParentheses(self):
            return self.getTypedRuleContext(MySQLParser.ExprWithParenthesesContext,0)


        def signedLiteralOrNull(self):
            return self.getTypedRuleContext(MySQLParser.SignedLiteralOrNullContext,0)


        def INDEX_SYMBOL(self):
            return self.getToken(MySQLParser.INDEX_SYMBOL, 0)

        def constraintEnforcement(self):
            return self.getTypedRuleContext(MySQLParser.ConstraintEnforcementContext,0)


        def RENAME_SYMBOL(self):
            return self.getToken(MySQLParser.RENAME_SYMBOL, 0)

        def TO_SYMBOL(self):
            return self.getToken(MySQLParser.TO_SYMBOL, 0)

        def tableName(self):
            return self.getTypedRuleContext(MySQLParser.TableNameContext,0)


        def AS_SYMBOL(self):
            return self.getToken(MySQLParser.AS_SYMBOL, 0)

        def indexName(self):
            return self.getTypedRuleContext(MySQLParser.IndexNameContext,0)


        def CONVERT_SYMBOL(self):
            return self.getToken(MySQLParser.CONVERT_SYMBOL, 0)

        def charset(self):
            return self.getTypedRuleContext(MySQLParser.CharsetContext,0)


        def charsetName(self):
            return self.getTypedRuleContext(MySQLParser.CharsetNameContext,0)


        def collate(self):
            return self.getTypedRuleContext(MySQLParser.CollateContext,0)


        def FORCE_SYMBOL(self):
            return self.getToken(MySQLParser.FORCE_SYMBOL, 0)

        def ORDER_SYMBOL(self):
            return self.getToken(MySQLParser.ORDER_SYMBOL, 0)

        def BY_SYMBOL(self):
            return self.getToken(MySQLParser.BY_SYMBOL, 0)

        def alterOrderList(self):
            return self.getTypedRuleContext(MySQLParser.AlterOrderListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_alterListItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterListItem" ):
                listener.enterAlterListItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterListItem" ):
                listener.exitAlterListItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterListItem" ):
                return visitor.visitAlterListItem(self)
            else:
                return visitor.visitChildren(self)




    def alterListItem(self):

        localctx = MySQLParser.AlterListItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_alterListItem)
        self._la = 0 # Token type
        try:
            self.state = 2008
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1873
                self.match(MySQLParser.ADD_SYMBOL)
                self.state = 1875
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
                if la_ == 1:
                    self.state = 1874
                    self.match(MySQLParser.COLUMN_SYMBOL)


                self.state = 1889
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,52,self._ctx)
                if la_ == 1:
                    self.state = 1877
                    self.identifier()
                    self.state = 1878
                    self.fieldDefinition()
                    self.state = 1880
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
                    if la_ == 1:
                        self.state = 1879
                        self.checkOrReferences()


                    self.state = 1883
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==53 or _la==225:
                        self.state = 1882
                        self.place()


                    pass

                elif la_ == 2:
                    self.state = 1885
                    self.match(MySQLParser.OPEN_PAR_SYMBOL)
                    self.state = 1886
                    self.tableElementList()
                    self.state = 1887
                    self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                    pass


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1891
                self.match(MySQLParser.ADD_SYMBOL)
                self.state = 1892
                self.tableConstraintDef()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1893
                self.match(MySQLParser.CHANGE_SYMBOL)
                self.state = 1895
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,53,self._ctx)
                if la_ == 1:
                    self.state = 1894
                    self.match(MySQLParser.COLUMN_SYMBOL)


                self.state = 1897
                self.columnInternalRef()
                self.state = 1898
                self.identifier()
                self.state = 1899
                self.fieldDefinition()
                self.state = 1901
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==53 or _la==225:
                    self.state = 1900
                    self.place()


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1903
                self.match(MySQLParser.MODIFY_SYMBOL)
                self.state = 1905
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,55,self._ctx)
                if la_ == 1:
                    self.state = 1904
                    self.match(MySQLParser.COLUMN_SYMBOL)


                self.state = 1907
                self.columnInternalRef()
                self.state = 1908
                self.fieldDefinition()
                self.state = 1910
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==53 or _la==225:
                    self.state = 1909
                    self.place()


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1912
                self.match(MySQLParser.DROP_SYMBOL)
                self.state = 1934
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
                if la_ == 1:
                    self.state = 1914
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
                    if la_ == 1:
                        self.state = 1913
                        self.match(MySQLParser.COLUMN_SYMBOL)


                    self.state = 1916
                    self.columnInternalRef()
                    self.state = 1918
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==93 or _la==488:
                        self.state = 1917
                        self.restrict()


                    pass

                elif la_ == 2:
                    self.state = 1920
                    self.match(MySQLParser.FOREIGN_SYMBOL)
                    self.state = 1921
                    self.match(MySQLParser.KEY_SYMBOL)
                    self.state = 1922
                    self.columnInternalRef()
                    pass

                elif la_ == 3:
                    self.state = 1923
                    self.match(MySQLParser.PRIMARY_SYMBOL)
                    self.state = 1924
                    self.match(MySQLParser.KEY_SYMBOL)
                    pass

                elif la_ == 4:
                    self.state = 1925
                    self.keyOrIndex()
                    self.state = 1926
                    self.indexRef()
                    pass

                elif la_ == 5:
                    self.state = 1928
                    if not self.isServerVersionGe80017():
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.isServerVersionGe80017()")
                    self.state = 1929
                    self.match(MySQLParser.CHECK_SYMBOL)
                    self.state = 1930
                    self.identifier()
                    pass

                elif la_ == 6:
                    self.state = 1931
                    if not self.isServerVersionGe80019():
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.isServerVersionGe80019()")
                    self.state = 1932
                    self.match(MySQLParser.CONSTRAINT_SYMBOL)
                    self.state = 1933
                    self.identifier()
                    pass


                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1936
                self.match(MySQLParser.DISABLE_SYMBOL)
                self.state = 1937
                self.match(MySQLParser.KEYS_SYMBOL)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1938
                self.match(MySQLParser.ENABLE_SYMBOL)
                self.state = 1939
                self.match(MySQLParser.KEYS_SYMBOL)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1940
                self.match(MySQLParser.ALTER_SYMBOL)
                self.state = 1942
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,60,self._ctx)
                if la_ == 1:
                    self.state = 1941
                    self.match(MySQLParser.COLUMN_SYMBOL)


                self.state = 1944
                self.columnInternalRef()
                self.state = 1957
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
                if la_ == 1:
                    self.state = 1945
                    self.match(MySQLParser.SET_SYMBOL)
                    self.state = 1946
                    self.match(MySQLParser.DEFAULT_SYMBOL)
                    self.state = 1950
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,61,self._ctx)
                    if la_ == 1:
                        self.state = 1947
                        if not self.isServerVersionGe80014():
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.isServerVersionGe80014()")
                        self.state = 1948
                        self.exprWithParentheses()
                        pass

                    elif la_ == 2:
                        self.state = 1949
                        self.signedLiteralOrNull()
                        pass


                    pass

                elif la_ == 2:
                    self.state = 1952
                    self.match(MySQLParser.DROP_SYMBOL)
                    self.state = 1953
                    self.match(MySQLParser.DEFAULT_SYMBOL)
                    pass

                elif la_ == 3:
                    self.state = 1954
                    if not self.isServerVersionGe80024():
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                    self.state = 1955
                    self.match(MySQLParser.SET_SYMBOL)
                    self.state = 1956
                    self.visibility()
                    pass


                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1959
                self.match(MySQLParser.ALTER_SYMBOL)
                self.state = 1960
                self.match(MySQLParser.INDEX_SYMBOL)
                self.state = 1961
                self.indexRef()
                self.state = 1962
                self.visibility()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1964
                if not self.isServerVersionGe80017():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80017()")
                self.state = 1965
                self.match(MySQLParser.ALTER_SYMBOL)
                self.state = 1966
                self.match(MySQLParser.CHECK_SYMBOL)
                self.state = 1967
                self.identifier()
                self.state = 1968
                self.constraintEnforcement()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1970
                if not self.isServerVersionGe80019():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80019()")
                self.state = 1971
                self.match(MySQLParser.ALTER_SYMBOL)
                self.state = 1972
                self.match(MySQLParser.CONSTRAINT_SYMBOL)
                self.state = 1973
                self.identifier()
                self.state = 1974
                self.constraintEnforcement()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 1976
                self.match(MySQLParser.RENAME_SYMBOL)
                self.state = 1977
                self.match(MySQLParser.COLUMN_SYMBOL)
                self.state = 1978
                self.columnInternalRef()
                self.state = 1979
                self.match(MySQLParser.TO_SYMBOL)
                self.state = 1980
                self.identifier()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 1982
                self.match(MySQLParser.RENAME_SYMBOL)
                self.state = 1984
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,63,self._ctx)
                if la_ == 1:
                    self.state = 1983
                    _la = self._input.LA(1)
                    if not(_la==63 or _la==599):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 1986
                self.tableName()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 1987
                self.match(MySQLParser.RENAME_SYMBOL)
                self.state = 1988
                self.keyOrIndex()
                self.state = 1989
                self.indexRef()
                self.state = 1990
                self.match(MySQLParser.TO_SYMBOL)
                self.state = 1991
                self.indexName()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 1993
                self.match(MySQLParser.CONVERT_SYMBOL)
                self.state = 1994
                self.match(MySQLParser.TO_SYMBOL)
                self.state = 1995
                self.charset()
                self.state = 1999
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,64,self._ctx)
                if la_ == 1:
                    self.state = 1996
                    if not self.isServerVersionGe80014():
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.isServerVersionGe80014()")
                    self.state = 1997
                    self.match(MySQLParser.DEFAULT_SYMBOL)
                    pass

                elif la_ == 2:
                    self.state = 1998
                    self.charsetName()
                    pass


                self.state = 2002
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==112:
                    self.state = 2001
                    self.collate()


                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 2004
                self.match(MySQLParser.FORCE_SYMBOL)
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 2005
                self.match(MySQLParser.ORDER_SYMBOL)
                self.state = 2006
                self.match(MySQLParser.BY_SYMBOL)
                self.state = 2007
                self.alterOrderList()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AFTER_SYMBOL(self):
            return self.getToken(MySQLParser.AFTER_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def FIRST_SYMBOL(self):
            return self.getToken(MySQLParser.FIRST_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_place

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlace" ):
                listener.enterPlace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlace" ):
                listener.exitPlace(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPlace" ):
                return visitor.visitPlace(self)
            else:
                return visitor.visitChildren(self)




    def place(self):

        localctx = MySQLParser.PlaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_place)
        try:
            self.state = 2013
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [53]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2010
                self.match(MySQLParser.AFTER_SYMBOL)
                self.state = 2011
                self.identifier()
                pass
            elif token in [225]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2012
                self.match(MySQLParser.FIRST_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RestrictContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RESTRICT_SYMBOL(self):
            return self.getToken(MySQLParser.RESTRICT_SYMBOL, 0)

        def CASCADE_SYMBOL(self):
            return self.getToken(MySQLParser.CASCADE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_restrict

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRestrict" ):
                listener.enterRestrict(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRestrict" ):
                listener.exitRestrict(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRestrict" ):
                return visitor.visitRestrict(self)
            else:
                return visitor.visitChildren(self)




    def restrict(self):

        localctx = MySQLParser.RestrictContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_restrict)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2015
            _la = self._input.LA(1)
            if not(_la==93 or _la==488):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterOrderListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(MySQLParser.IdentifierContext,i)


        def direction(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.DirectionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.DirectionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_alterOrderList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterOrderList" ):
                listener.enterAlterOrderList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterOrderList" ):
                listener.exitAlterOrderList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterOrderList" ):
                return visitor.visitAlterOrderList(self)
            else:
                return visitor.visitChildren(self)




    def alterOrderList(self):

        localctx = MySQLParser.AlterOrderListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_alterOrderList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2017
            self.identifier()
            self.state = 2019
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==64 or _la==172:
                self.state = 2018
                self.direction()


            self.state = 2028
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,70,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2021
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 2022
                    self.identifier()
                    self.state = 2024
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==64 or _la==172:
                        self.state = 2023
                        self.direction()

             
                self.state = 2030
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,70,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterAlgorithmOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALGORITHM_SYMBOL(self):
            return self.getToken(MySQLParser.ALGORITHM_SYMBOL, 0)

        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_alterAlgorithmOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterAlgorithmOption" ):
                listener.enterAlterAlgorithmOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterAlgorithmOption" ):
                listener.exitAlterAlgorithmOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterAlgorithmOption" ):
                return visitor.visitAlterAlgorithmOption(self)
            else:
                return visitor.visitChildren(self)




    def alterAlgorithmOption(self):

        localctx = MySQLParser.AlterAlgorithmOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_alterAlgorithmOption)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2031
            self.match(MySQLParser.ALGORITHM_SYMBOL)
            self.state = 2033
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,71,self._ctx)
            if la_ == 1:
                self.state = 2032
                self.match(MySQLParser.EQUAL_OPERATOR)


            self.state = 2037
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,72,self._ctx)
            if la_ == 1:
                self.state = 2035
                self.match(MySQLParser.DEFAULT_SYMBOL)
                pass

            elif la_ == 2:
                self.state = 2036
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterLockOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOCK_SYMBOL(self):
            return self.getToken(MySQLParser.LOCK_SYMBOL, 0)

        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_alterLockOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterLockOption" ):
                listener.enterAlterLockOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterLockOption" ):
                listener.exitAlterLockOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterLockOption" ):
                return visitor.visitAlterLockOption(self)
            else:
                return visitor.visitChildren(self)




    def alterLockOption(self):

        localctx = MySQLParser.AlterLockOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_alterLockOption)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2039
            self.match(MySQLParser.LOCK_SYMBOL)
            self.state = 2041
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,73,self._ctx)
            if la_ == 1:
                self.state = 2040
                self.match(MySQLParser.EQUAL_OPERATOR)


            self.state = 2045
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,74,self._ctx)
            if la_ == 1:
                self.state = 2043
                self.match(MySQLParser.DEFAULT_SYMBOL)
                pass

            elif la_ == 2:
                self.state = 2044
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndexLockAndAlgorithmContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alterAlgorithmOption(self):
            return self.getTypedRuleContext(MySQLParser.AlterAlgorithmOptionContext,0)


        def alterLockOption(self):
            return self.getTypedRuleContext(MySQLParser.AlterLockOptionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_indexLockAndAlgorithm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndexLockAndAlgorithm" ):
                listener.enterIndexLockAndAlgorithm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndexLockAndAlgorithm" ):
                listener.exitIndexLockAndAlgorithm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndexLockAndAlgorithm" ):
                return visitor.visitIndexLockAndAlgorithm(self)
            else:
                return visitor.visitChildren(self)




    def indexLockAndAlgorithm(self):

        localctx = MySQLParser.IndexLockAndAlgorithmContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_indexLockAndAlgorithm)
        self._la = 0 # Token type
        try:
            self.state = 2055
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [56]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2047
                self.alterAlgorithmOption()
                self.state = 2049
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==314:
                    self.state = 2048
                    self.alterLockOption()


                pass
            elif token in [314]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2051
                self.alterLockOption()
                self.state = 2053
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==56:
                    self.state = 2052
                    self.alterAlgorithmOption()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithValidationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VALIDATION_SYMBOL(self):
            return self.getToken(MySQLParser.VALIDATION_SYMBOL, 0)

        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def WITHOUT_SYMBOL(self):
            return self.getToken(MySQLParser.WITHOUT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_withValidation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithValidation" ):
                listener.enterWithValidation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithValidation" ):
                listener.exitWithValidation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWithValidation" ):
                return visitor.visitWithValidation(self)
            else:
                return visitor.visitChildren(self)




    def withValidation(self):

        localctx = MySQLParser.WithValidationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_withValidation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2057
            _la = self._input.LA(1)
            if not(_la==653 or _la==654):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2058
            self.match(MySQLParser.VALIDATION_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RemovePartitioningContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REMOVE_SYMBOL(self):
            return self.getToken(MySQLParser.REMOVE_SYMBOL, 0)

        def PARTITIONING_SYMBOL(self):
            return self.getToken(MySQLParser.PARTITIONING_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_removePartitioning

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRemovePartitioning" ):
                listener.enterRemovePartitioning(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRemovePartitioning" ):
                listener.exitRemovePartitioning(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRemovePartitioning" ):
                return visitor.visitRemovePartitioning(self)
            else:
                return visitor.visitChildren(self)




    def removePartitioning(self):

        localctx = MySQLParser.RemovePartitioningContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_removePartitioning)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2060
            self.match(MySQLParser.REMOVE_SYMBOL)
            self.state = 2061
            self.match(MySQLParser.PARTITIONING_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AllOrPartitionNameListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALL_SYMBOL(self):
            return self.getToken(MySQLParser.ALL_SYMBOL, 0)

        def identifierList(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_allOrPartitionNameList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAllOrPartitionNameList" ):
                listener.enterAllOrPartitionNameList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAllOrPartitionNameList" ):
                listener.exitAllOrPartitionNameList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAllOrPartitionNameList" ):
                return visitor.visitAllOrPartitionNameList(self)
            else:
                return visitor.visitChildren(self)




    def allOrPartitionNameList(self):

        localctx = MySQLParser.AllOrPartitionNameListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_allOrPartitionNameList)
        try:
            self.state = 2065
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,78,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2063
                self.match(MySQLParser.ALL_SYMBOL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2064
                self.identifierList()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterTablespaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TABLESPACE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLESPACE_SYMBOL, 0)

        def tablespaceRef(self):
            return self.getTypedRuleContext(MySQLParser.TablespaceRefContext,0)


        def DATAFILE_SYMBOL(self):
            return self.getToken(MySQLParser.DATAFILE_SYMBOL, 0)

        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def RENAME_SYMBOL(self):
            return self.getToken(MySQLParser.RENAME_SYMBOL, 0)

        def TO_SYMBOL(self):
            return self.getToken(MySQLParser.TO_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def alterTablespaceOptions(self):
            return self.getTypedRuleContext(MySQLParser.AlterTablespaceOptionsContext,0)


        def ADD_SYMBOL(self):
            return self.getToken(MySQLParser.ADD_SYMBOL, 0)

        def DROP_SYMBOL(self):
            return self.getToken(MySQLParser.DROP_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_alterTablespace

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterTablespace" ):
                listener.enterAlterTablespace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterTablespace" ):
                listener.exitAlterTablespace(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterTablespace" ):
                return visitor.visitAlterTablespace(self)
            else:
                return visitor.visitChildren(self)




    def alterTablespace(self):

        localctx = MySQLParser.AlterTablespaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_alterTablespace)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2067
            self.match(MySQLParser.TABLESPACE_SYMBOL)
            self.state = 2068
            self.tablespaceRef()
            self.state = 2080
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,80,self._ctx)
            if la_ == 1:
                self.state = 2069
                _la = self._input.LA(1)
                if not(_la==51 or _la==184):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2070
                self.match(MySQLParser.DATAFILE_SYMBOL)
                self.state = 2071
                self.textLiteral()
                self.state = 2073
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
                if la_ == 1:
                    self.state = 2072
                    self.alterTablespaceOptions()


                pass

            elif la_ == 2:
                self.state = 2075
                self.match(MySQLParser.RENAME_SYMBOL)
                self.state = 2076
                self.match(MySQLParser.TO_SYMBOL)
                self.state = 2077
                self.identifier()
                pass

            elif la_ == 3:
                self.state = 2078
                if not self.isServerVersionGe80014():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80014()")
                self.state = 2079
                self.alterTablespaceOptions()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterUndoTablespaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNDO_SYMBOL(self):
            return self.getToken(MySQLParser.UNDO_SYMBOL, 0)

        def TABLESPACE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLESPACE_SYMBOL, 0)

        def tablespaceRef(self):
            return self.getTypedRuleContext(MySQLParser.TablespaceRefContext,0)


        def SET_SYMBOL(self):
            return self.getToken(MySQLParser.SET_SYMBOL, 0)

        def ACTIVE_SYMBOL(self):
            return self.getToken(MySQLParser.ACTIVE_SYMBOL, 0)

        def INACTIVE_SYMBOL(self):
            return self.getToken(MySQLParser.INACTIVE_SYMBOL, 0)

        def undoTableSpaceOptions(self):
            return self.getTypedRuleContext(MySQLParser.UndoTableSpaceOptionsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_alterUndoTablespace

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterUndoTablespace" ):
                listener.enterAlterUndoTablespace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterUndoTablespace" ):
                listener.exitAlterUndoTablespace(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterUndoTablespace" ):
                return visitor.visitAlterUndoTablespace(self)
            else:
                return visitor.visitChildren(self)




    def alterUndoTablespace(self):

        localctx = MySQLParser.AlterUndoTablespaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_alterUndoTablespace)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2082
            self.match(MySQLParser.UNDO_SYMBOL)
            self.state = 2083
            self.match(MySQLParser.TABLESPACE_SYMBOL)
            self.state = 2084
            self.tablespaceRef()
            self.state = 2085
            self.match(MySQLParser.SET_SYMBOL)
            self.state = 2086
            _la = self._input.LA(1)
            if not(_la==732 or _la==733):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2088
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==198 or _la==563:
                self.state = 2087
                self.undoTableSpaceOptions()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UndoTableSpaceOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def undoTableSpaceOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.UndoTableSpaceOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.UndoTableSpaceOptionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_undoTableSpaceOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUndoTableSpaceOptions" ):
                listener.enterUndoTableSpaceOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUndoTableSpaceOptions" ):
                listener.exitUndoTableSpaceOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUndoTableSpaceOptions" ):
                return visitor.visitUndoTableSpaceOptions(self)
            else:
                return visitor.visitChildren(self)




    def undoTableSpaceOptions(self):

        localctx = MySQLParser.UndoTableSpaceOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_undoTableSpaceOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2090
            self.undoTableSpaceOption()
            self.state = 2097
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29 or _la==198 or _la==563:
                self.state = 2092
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 2091
                    self.match(MySQLParser.COMMA_SYMBOL)


                self.state = 2094
                self.undoTableSpaceOption()
                self.state = 2099
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UndoTableSpaceOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tsOptionEngine(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionEngineContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_undoTableSpaceOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUndoTableSpaceOption" ):
                listener.enterUndoTableSpaceOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUndoTableSpaceOption" ):
                listener.exitUndoTableSpaceOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUndoTableSpaceOption" ):
                return visitor.visitUndoTableSpaceOption(self)
            else:
                return visitor.visitChildren(self)




    def undoTableSpaceOption(self):

        localctx = MySQLParser.UndoTableSpaceOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_undoTableSpaceOption)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2100
            self.tsOptionEngine()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterTablespaceOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alterTablespaceOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.AlterTablespaceOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.AlterTablespaceOptionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_alterTablespaceOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterTablespaceOptions" ):
                listener.enterAlterTablespaceOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterTablespaceOptions" ):
                listener.exitAlterTablespaceOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterTablespaceOptions" ):
                return visitor.visitAlterTablespaceOptions(self)
            else:
                return visitor.visitChildren(self)




    def alterTablespaceOptions(self):

        localctx = MySQLParser.AlterTablespaceOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_alterTablespaceOptions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2102
            self.alterTablespaceOption()
            self.state = 2109
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,85,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2104
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,84,self._ctx)
                    if la_ == 1:
                        self.state = 2103
                        self.match(MySQLParser.COMMA_SYMBOL)


                    self.state = 2106
                    self.alterTablespaceOption() 
                self.state = 2111
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,85,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterTablespaceOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INITIAL_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.INITIAL_SIZE_SYMBOL, 0)

        def sizeNumber(self):
            return self.getTypedRuleContext(MySQLParser.SizeNumberContext,0)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def tsOptionAutoextendSize(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionAutoextendSizeContext,0)


        def tsOptionMaxSize(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionMaxSizeContext,0)


        def tsOptionEngine(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionEngineContext,0)


        def tsOptionWait(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionWaitContext,0)


        def tsOptionEncryption(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionEncryptionContext,0)


        def tsOptionEngineAttribute(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionEngineAttributeContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_alterTablespaceOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterTablespaceOption" ):
                listener.enterAlterTablespaceOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterTablespaceOption" ):
                listener.exitAlterTablespaceOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterTablespaceOption" ):
                return visitor.visitAlterTablespaceOption(self)
            else:
                return visitor.visitChildren(self)




    def alterTablespaceOption(self):

        localctx = MySQLParser.AlterTablespaceOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_alterTablespaceOption)
        try:
            self.state = 2124
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,87,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2112
                self.match(MySQLParser.INITIAL_SIZE_SYMBOL)
                self.state = 2114
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,86,self._ctx)
                if la_ == 1:
                    self.state = 2113
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 2116
                self.sizeNumber()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2117
                self.tsOptionAutoextendSize()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2118
                self.tsOptionMaxSize()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2119
                self.tsOptionEngine()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2120
                self.tsOptionWait()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2121
                self.tsOptionEncryption()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2122
                if not self.isServerVersionGe80024():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                self.state = 2123
                self.tsOptionEngineAttribute()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeTablespaceOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INITIAL_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.INITIAL_SIZE_SYMBOL, 0)

        def sizeNumber(self):
            return self.getTypedRuleContext(MySQLParser.SizeNumberContext,0)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def tsOptionAutoextendSize(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionAutoextendSizeContext,0)


        def tsOptionMaxSize(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionMaxSizeContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_changeTablespaceOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeTablespaceOption" ):
                listener.enterChangeTablespaceOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeTablespaceOption" ):
                listener.exitChangeTablespaceOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeTablespaceOption" ):
                return visitor.visitChangeTablespaceOption(self)
            else:
                return visitor.visitChildren(self)




    def changeTablespaceOption(self):

        localctx = MySQLParser.ChangeTablespaceOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_changeTablespaceOption)
        try:
            self.state = 2133
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [270]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2126
                self.match(MySQLParser.INITIAL_SIZE_SYMBOL)
                self.state = 2128
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,88,self._ctx)
                if la_ == 1:
                    self.state = 2127
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 2130
                self.sizeNumber()
                pass
            elif token in [68]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2131
                self.tsOptionAutoextendSize()
                pass
            elif token in [349]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2132
                self.tsOptionMaxSize()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterViewContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VIEW_SYMBOL(self):
            return self.getToken(MySQLParser.VIEW_SYMBOL, 0)

        def viewRef(self):
            return self.getTypedRuleContext(MySQLParser.ViewRefContext,0)


        def viewTail(self):
            return self.getTypedRuleContext(MySQLParser.ViewTailContext,0)


        def viewAlgorithm(self):
            return self.getTypedRuleContext(MySQLParser.ViewAlgorithmContext,0)


        def definerClause(self):
            return self.getTypedRuleContext(MySQLParser.DefinerClauseContext,0)


        def viewSuid(self):
            return self.getTypedRuleContext(MySQLParser.ViewSuidContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_alterView

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterView" ):
                listener.enterAlterView(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterView" ):
                listener.exitAlterView(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterView" ):
                return visitor.visitAlterView(self)
            else:
                return visitor.visitChildren(self)




    def alterView(self):

        localctx = MySQLParser.AlterViewContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_alterView)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2136
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==56:
                self.state = 2135
                self.viewAlgorithm()


            self.state = 2139
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==168:
                self.state = 2138
                self.definerClause()


            self.state = 2142
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==547:
                self.state = 2141
                self.viewSuid()


            self.state = 2144
            self.match(MySQLParser.VIEW_SYMBOL)
            self.state = 2145
            self.viewRef()
            self.state = 2146
            self.viewTail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ViewTailContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AS_SYMBOL(self):
            return self.getToken(MySQLParser.AS_SYMBOL, 0)

        def viewQueryBlock(self):
            return self.getTypedRuleContext(MySQLParser.ViewQueryBlockContext,0)


        def columnInternalRefList(self):
            return self.getTypedRuleContext(MySQLParser.ColumnInternalRefListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_viewTail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterViewTail" ):
                listener.enterViewTail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitViewTail" ):
                listener.exitViewTail(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitViewTail" ):
                return visitor.visitViewTail(self)
            else:
                return visitor.visitChildren(self)




    def viewTail(self):

        localctx = MySQLParser.ViewTailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_viewTail)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2149
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==32:
                self.state = 2148
                self.columnInternalRefList()


            self.state = 2151
            self.match(MySQLParser.AS_SYMBOL)
            self.state = 2152
            self.viewQueryBlock()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ViewQueryBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def queryExpressionWithOptLockingClauses(self):
            return self.getTypedRuleContext(MySQLParser.QueryExpressionWithOptLockingClausesContext,0)


        def viewCheckOption(self):
            return self.getTypedRuleContext(MySQLParser.ViewCheckOptionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_viewQueryBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterViewQueryBlock" ):
                listener.enterViewQueryBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitViewQueryBlock" ):
                listener.exitViewQueryBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitViewQueryBlock" ):
                return visitor.visitViewQueryBlock(self)
            else:
                return visitor.visitChildren(self)




    def viewQueryBlock(self):

        localctx = MySQLParser.ViewQueryBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_viewQueryBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2154
            self.queryExpressionWithOptLockingClauses()
            self.state = 2156
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==653:
                self.state = 2155
                self.viewCheckOption()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ViewCheckOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def CHECK_SYMBOL(self):
            return self.getToken(MySQLParser.CHECK_SYMBOL, 0)

        def OPTION_SYMBOL(self):
            return self.getToken(MySQLParser.OPTION_SYMBOL, 0)

        def CASCADED_SYMBOL(self):
            return self.getToken(MySQLParser.CASCADED_SYMBOL, 0)

        def LOCAL_SYMBOL(self):
            return self.getToken(MySQLParser.LOCAL_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_viewCheckOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterViewCheckOption" ):
                listener.enterViewCheckOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitViewCheckOption" ):
                listener.exitViewCheckOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitViewCheckOption" ):
                return visitor.visitViewCheckOption(self)
            else:
                return visitor.visitChildren(self)




    def viewCheckOption(self):

        localctx = MySQLParser.ViewCheckOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_viewCheckOption)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2158
            self.match(MySQLParser.WITH_SYMBOL)
            self.state = 2160
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==94 or _la==312:
                self.state = 2159
                _la = self._input.LA(1)
                if not(_la==94 or _la==312):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 2162
            self.match(MySQLParser.CHECK_SYMBOL)
            self.state = 2163
            self.match(MySQLParser.OPTION_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterInstanceStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INSTANCE_SYMBOL(self):
            return self.getToken(MySQLParser.INSTANCE_SYMBOL, 0)

        def ROTATE_SYMBOL(self):
            return self.getToken(MySQLParser.ROTATE_SYMBOL, 0)

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def MASTER_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SYMBOL, 0)

        def KEY_SYMBOL(self):
            return self.getToken(MySQLParser.KEY_SYMBOL, 0)

        def RELOAD_SYMBOL(self):
            return self.getToken(MySQLParser.RELOAD_SYMBOL, 0)

        def TLS_SYMBOL(self):
            return self.getToken(MySQLParser.TLS_SYMBOL, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(MySQLParser.IdentifierContext,i)


        def KEYRING_SYMBOL(self):
            return self.getToken(MySQLParser.KEYRING_SYMBOL, 0)

        def ENABLE_SYMBOL(self):
            return self.getToken(MySQLParser.ENABLE_SYMBOL, 0)

        def DISABLE_SYMBOL(self):
            return self.getToken(MySQLParser.DISABLE_SYMBOL, 0)

        def NO_SYMBOL(self):
            return self.getToken(MySQLParser.NO_SYMBOL, 0)

        def ROLLBACK_SYMBOL(self):
            return self.getToken(MySQLParser.ROLLBACK_SYMBOL, 0)

        def ON_SYMBOL(self):
            return self.getToken(MySQLParser.ON_SYMBOL, 0)

        def ERROR_SYMBOL(self):
            return self.getToken(MySQLParser.ERROR_SYMBOL, 0)

        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def CHANNEL_SYMBOL(self):
            return self.getToken(MySQLParser.CHANNEL_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_alterInstanceStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterInstanceStatement" ):
                listener.enterAlterInstanceStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterInstanceStatement" ):
                listener.exitAlterInstanceStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterInstanceStatement" ):
                return visitor.visitAlterInstanceStatement(self)
            else:
                return visitor.visitChildren(self)




    def alterInstanceStatement(self):

        localctx = MySQLParser.AlterInstanceStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_alterInstanceStatement)
        self._la = 0 # Token type
        try:
            self.state = 2197
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2165
                self.match(MySQLParser.INSTANCE_SYMBOL)
                self.state = 2166
                self.match(MySQLParser.ROTATE_SYMBOL)
                self.state = 2167
                self.textOrIdentifier()
                self.state = 2168
                self.match(MySQLParser.MASTER_SYMBOL)
                self.state = 2169
                self.match(MySQLParser.KEY_SYMBOL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2171
                if not self.isServerVersionGe80024():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                self.state = 2195
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,98,self._ctx)
                if la_ == 1:
                    self.state = 2172
                    self.match(MySQLParser.RELOAD_SYMBOL)
                    self.state = 2173
                    self.match(MySQLParser.TLS_SYMBOL)
                    self.state = 2187
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [392]:
                        self.state = 2174
                        self.match(MySQLParser.NO_SYMBOL)
                        self.state = 2175
                        self.match(MySQLParser.ROLLBACK_SYMBOL)
                        self.state = 2176
                        self.match(MySQLParser.ON_SYMBOL)
                        self.state = 2177
                        self.match(MySQLParser.ERROR_SYMBOL)
                        pass
                    elif token in [232]:
                        self.state = 2178
                        self.match(MySQLParser.FOR_SYMBOL)
                        self.state = 2179
                        self.match(MySQLParser.CHANNEL_SYMBOL)
                        self.state = 2180
                        self.identifier()
                        self.state = 2185
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==392:
                            self.state = 2181
                            self.match(MySQLParser.NO_SYMBOL)
                            self.state = 2182
                            self.match(MySQLParser.ROLLBACK_SYMBOL)
                            self.state = 2183
                            self.match(MySQLParser.ON_SYMBOL)
                            self.state = 2184
                            self.match(MySQLParser.ERROR_SYMBOL)


                        pass
                    else:
                        raise NoViableAltException(self)

                    pass

                elif la_ == 2:
                    self.state = 2189
                    _la = self._input.LA(1)
                    if not(_la==177 or _la==192):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 2190
                    self.identifier()
                    self.state = 2191
                    self.identifier()
                    pass

                elif la_ == 3:
                    self.state = 2193
                    self.match(MySQLParser.RELOAD_SYMBOL)
                    self.state = 2194
                    self.match(MySQLParser.KEYRING_SYMBOL)
                    pass


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE_SYMBOL(self):
            return self.getToken(MySQLParser.CREATE_SYMBOL, 0)

        def createDatabase(self):
            return self.getTypedRuleContext(MySQLParser.CreateDatabaseContext,0)


        def createTable(self):
            return self.getTypedRuleContext(MySQLParser.CreateTableContext,0)


        def createFunction(self):
            return self.getTypedRuleContext(MySQLParser.CreateFunctionContext,0)


        def createProcedure(self):
            return self.getTypedRuleContext(MySQLParser.CreateProcedureContext,0)


        def createUdf(self):
            return self.getTypedRuleContext(MySQLParser.CreateUdfContext,0)


        def createLogfileGroup(self):
            return self.getTypedRuleContext(MySQLParser.CreateLogfileGroupContext,0)


        def createView(self):
            return self.getTypedRuleContext(MySQLParser.CreateViewContext,0)


        def createTrigger(self):
            return self.getTypedRuleContext(MySQLParser.CreateTriggerContext,0)


        def createIndex(self):
            return self.getTypedRuleContext(MySQLParser.CreateIndexContext,0)


        def createServer(self):
            return self.getTypedRuleContext(MySQLParser.CreateServerContext,0)


        def createTablespace(self):
            return self.getTypedRuleContext(MySQLParser.CreateTablespaceContext,0)


        def createEvent(self):
            return self.getTypedRuleContext(MySQLParser.CreateEventContext,0)


        def createRole(self):
            return self.getTypedRuleContext(MySQLParser.CreateRoleContext,0)


        def createSpatialReference(self):
            return self.getTypedRuleContext(MySQLParser.CreateSpatialReferenceContext,0)


        def createUndoTablespace(self):
            return self.getTypedRuleContext(MySQLParser.CreateUndoTablespaceContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateStatement" ):
                listener.enterCreateStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateStatement" ):
                listener.exitCreateStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateStatement" ):
                return visitor.visitCreateStatement(self)
            else:
                return visitor.visitChildren(self)




    def createStatement(self):

        localctx = MySQLParser.CreateStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_createStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2199
            self.match(MySQLParser.CREATE_SYMBOL)
            self.state = 2217
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
            if la_ == 1:
                self.state = 2200
                self.createDatabase()
                pass

            elif la_ == 2:
                self.state = 2201
                self.createTable()
                pass

            elif la_ == 3:
                self.state = 2202
                self.createFunction()
                pass

            elif la_ == 4:
                self.state = 2203
                self.createProcedure()
                pass

            elif la_ == 5:
                self.state = 2204
                self.createUdf()
                pass

            elif la_ == 6:
                self.state = 2205
                self.createLogfileGroup()
                pass

            elif la_ == 7:
                self.state = 2206
                self.createView()
                pass

            elif la_ == 8:
                self.state = 2207
                self.createTrigger()
                pass

            elif la_ == 9:
                self.state = 2208
                self.createIndex()
                pass

            elif la_ == 10:
                self.state = 2209
                self.createServer()
                pass

            elif la_ == 11:
                self.state = 2210
                self.createTablespace()
                pass

            elif la_ == 12:
                self.state = 2211
                self.createEvent()
                pass

            elif la_ == 13:
                self.state = 2212
                self.createRole()
                pass

            elif la_ == 14:
                self.state = 2213
                if not self.isServerVersionGe80011():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80011()")
                self.state = 2214
                self.createSpatialReference()
                pass

            elif la_ == 15:
                self.state = 2215
                if not self.isServerVersionGe80014():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80014()")
                self.state = 2216
                self.createUndoTablespace()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateDatabaseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATABASE_SYMBOL(self):
            return self.getToken(MySQLParser.DATABASE_SYMBOL, 0)

        def schemaName(self):
            return self.getTypedRuleContext(MySQLParser.SchemaNameContext,0)


        def ifNotExists(self):
            return self.getTypedRuleContext(MySQLParser.IfNotExistsContext,0)


        def createDatabaseOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.CreateDatabaseOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.CreateDatabaseOptionContext,i)


        def getRuleIndex(self):
            return MySQLParser.RULE_createDatabase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateDatabase" ):
                listener.enterCreateDatabase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateDatabase" ):
                listener.exitCreateDatabase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateDatabase" ):
                return visitor.visitCreateDatabase(self)
            else:
                return visitor.visitChildren(self)




    def createDatabase(self):

        localctx = MySQLParser.CreateDatabaseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_createDatabase)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2219
            self.match(MySQLParser.DATABASE_SYMBOL)
            self.state = 2221
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
            if la_ == 1:
                self.state = 2220
                self.ifNotExists()


            self.state = 2223
            self.schemaName()
            self.state = 2227
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,102,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2224
                    self.createDatabaseOption() 
                self.state = 2229
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,102,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateDatabaseOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defaultCharset(self):
            return self.getTypedRuleContext(MySQLParser.DefaultCharsetContext,0)


        def defaultCollation(self):
            return self.getTypedRuleContext(MySQLParser.DefaultCollationContext,0)


        def defaultEncryption(self):
            return self.getTypedRuleContext(MySQLParser.DefaultEncryptionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createDatabaseOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateDatabaseOption" ):
                listener.enterCreateDatabaseOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateDatabaseOption" ):
                listener.exitCreateDatabaseOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateDatabaseOption" ):
                return visitor.visitCreateDatabaseOption(self)
            else:
                return visitor.visitChildren(self)




    def createDatabaseOption(self):

        localctx = MySQLParser.CreateDatabaseOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_createDatabaseOption)
        try:
            self.state = 2234
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,103,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2230
                self.defaultCharset()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2231
                self.defaultCollation()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2232
                if not self.isServerVersionGe80016():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80016()")
                self.state = 2233
                self.defaultEncryption()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateTableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_SYMBOL, 0)

        def tableName(self):
            return self.getTypedRuleContext(MySQLParser.TableNameContext,0)


        def LIKE_SYMBOL(self):
            return self.getToken(MySQLParser.LIKE_SYMBOL, 0)

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def TEMPORARY_SYMBOL(self):
            return self.getToken(MySQLParser.TEMPORARY_SYMBOL, 0)

        def ifNotExists(self):
            return self.getTypedRuleContext(MySQLParser.IfNotExistsContext,0)


        def tableElementList(self):
            return self.getTypedRuleContext(MySQLParser.TableElementListContext,0)


        def createTableOptionsEtc(self):
            return self.getTypedRuleContext(MySQLParser.CreateTableOptionsEtcContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createTable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateTable" ):
                listener.enterCreateTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateTable" ):
                listener.exitCreateTable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateTable" ):
                return visitor.visitCreateTable(self)
            else:
                return visitor.visitChildren(self)




    def createTable(self):

        localctx = MySQLParser.CreateTableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_createTable)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2237
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==586:
                self.state = 2236
                self.match(MySQLParser.TEMPORARY_SYMBOL)


            self.state = 2239
            self.match(MySQLParser.TABLE_SYMBOL)
            self.state = 2241
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,105,self._ctx)
            if la_ == 1:
                self.state = 2240
                self.ifNotExists()


            self.state = 2243
            self.tableName()
            self.state = 2260
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
            if la_ == 1:
                self.state = 2248
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,106,self._ctx)
                if la_ == 1:
                    self.state = 2244
                    self.match(MySQLParser.OPEN_PAR_SYMBOL)
                    self.state = 2245
                    self.tableElementList()
                    self.state = 2246
                    self.match(MySQLParser.CLOSE_PAR_SYMBOL)


                self.state = 2251
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,107,self._ctx)
                if la_ == 1:
                    self.state = 2250
                    self.createTableOptionsEtc()


                pass

            elif la_ == 2:
                self.state = 2253
                self.match(MySQLParser.LIKE_SYMBOL)
                self.state = 2254
                self.tableRef()
                pass

            elif la_ == 3:
                self.state = 2255
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 2256
                self.match(MySQLParser.LIKE_SYMBOL)
                self.state = 2257
                self.tableRef()
                self.state = 2258
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableElementListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.TableElementContext)
            else:
                return self.getTypedRuleContext(MySQLParser.TableElementContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_tableElementList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableElementList" ):
                listener.enterTableElementList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableElementList" ):
                listener.exitTableElementList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableElementList" ):
                return visitor.visitTableElementList(self)
            else:
                return visitor.visitChildren(self)




    def tableElementList(self):

        localctx = MySQLParser.TableElementListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_tableElementList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2262
            self.tableElement()
            self.state = 2267
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 2263
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 2264
                self.tableElement()
                self.state = 2269
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def columnDefinition(self):
            return self.getTypedRuleContext(MySQLParser.ColumnDefinitionContext,0)


        def tableConstraintDef(self):
            return self.getTypedRuleContext(MySQLParser.TableConstraintDefContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_tableElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableElement" ):
                listener.enterTableElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableElement" ):
                listener.exitTableElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableElement" ):
                return visitor.visitTableElement(self)
            else:
                return visitor.visitChildren(self)




    def tableElement(self):

        localctx = MySQLParser.TableElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_tableElement)
        try:
            self.state = 2272
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,110,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2270
                self.columnDefinition()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2271
                self.tableConstraintDef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DuplicateAsQeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def asCreateQueryExpression(self):
            return self.getTypedRuleContext(MySQLParser.AsCreateQueryExpressionContext,0)


        def REPLACE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLACE_SYMBOL, 0)

        def IGNORE_SYMBOL(self):
            return self.getToken(MySQLParser.IGNORE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_duplicateAsQe

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDuplicateAsQe" ):
                listener.enterDuplicateAsQe(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDuplicateAsQe" ):
                listener.exitDuplicateAsQe(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDuplicateAsQe" ):
                return visitor.visitDuplicateAsQe(self)
            else:
                return visitor.visitChildren(self)




    def duplicateAsQe(self):

        localctx = MySQLParser.DuplicateAsQeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_duplicateAsQe)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2275
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,111,self._ctx)
            if la_ == 1:
                self.state = 2274
                _la = self._input.LA(1)
                if not(_la==264 or _la==475):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 2277
            self.asCreateQueryExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AsCreateQueryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def queryExpressionWithOptLockingClauses(self):
            return self.getTypedRuleContext(MySQLParser.QueryExpressionWithOptLockingClausesContext,0)


        def AS_SYMBOL(self):
            return self.getToken(MySQLParser.AS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_asCreateQueryExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAsCreateQueryExpression" ):
                listener.enterAsCreateQueryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAsCreateQueryExpression" ):
                listener.exitAsCreateQueryExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAsCreateQueryExpression" ):
                return visitor.visitAsCreateQueryExpression(self)
            else:
                return visitor.visitChildren(self)




    def asCreateQueryExpression(self):

        localctx = MySQLParser.AsCreateQueryExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_asCreateQueryExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2280
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,112,self._ctx)
            if la_ == 1:
                self.state = 2279
                self.match(MySQLParser.AS_SYMBOL)


            self.state = 2282
            self.queryExpressionWithOptLockingClauses()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryExpressionOrParensContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def queryExpression(self):
            return self.getTypedRuleContext(MySQLParser.QueryExpressionContext,0)


        def lockingClauseList(self):
            return self.getTypedRuleContext(MySQLParser.LockingClauseListContext,0)


        def queryExpressionParens(self):
            return self.getTypedRuleContext(MySQLParser.QueryExpressionParensContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_queryExpressionOrParens

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueryExpressionOrParens" ):
                listener.enterQueryExpressionOrParens(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueryExpressionOrParens" ):
                listener.exitQueryExpressionOrParens(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQueryExpressionOrParens" ):
                return visitor.visitQueryExpressionOrParens(self)
            else:
                return visitor.visitChildren(self)




    def queryExpressionOrParens(self):

        localctx = MySQLParser.QueryExpressionOrParensContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_queryExpressionOrParens)
        try:
            self.state = 2289
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,114,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2284
                self.queryExpression()
                self.state = 2286
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,113,self._ctx)
                if la_ == 1:
                    self.state = 2285
                    self.lockingClauseList()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2288
                self.queryExpressionParens()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryExpressionWithOptLockingClausesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def queryExpression(self):
            return self.getTypedRuleContext(MySQLParser.QueryExpressionContext,0)


        def lockingClauseList(self):
            return self.getTypedRuleContext(MySQLParser.LockingClauseListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_queryExpressionWithOptLockingClauses

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueryExpressionWithOptLockingClauses" ):
                listener.enterQueryExpressionWithOptLockingClauses(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueryExpressionWithOptLockingClauses" ):
                listener.exitQueryExpressionWithOptLockingClauses(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQueryExpressionWithOptLockingClauses" ):
                return visitor.visitQueryExpressionWithOptLockingClauses(self)
            else:
                return visitor.visitChildren(self)




    def queryExpressionWithOptLockingClauses(self):

        localctx = MySQLParser.QueryExpressionWithOptLockingClausesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_queryExpressionWithOptLockingClauses)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2291
            self.queryExpression()
            self.state = 2293
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,115,self._ctx)
            if la_ == 1:
                self.state = 2292
                self.lockingClauseList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateRoutineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE_SYMBOL(self):
            return self.getToken(MySQLParser.CREATE_SYMBOL, 0)

        def EOF(self):
            return self.getToken(MySQLParser.EOF, 0)

        def createProcedure(self):
            return self.getTypedRuleContext(MySQLParser.CreateProcedureContext,0)


        def createFunction(self):
            return self.getTypedRuleContext(MySQLParser.CreateFunctionContext,0)


        def createUdf(self):
            return self.getTypedRuleContext(MySQLParser.CreateUdfContext,0)


        def SEMICOLON_SYMBOL(self):
            return self.getToken(MySQLParser.SEMICOLON_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_createRoutine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateRoutine" ):
                listener.enterCreateRoutine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateRoutine" ):
                listener.exitCreateRoutine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateRoutine" ):
                return visitor.visitCreateRoutine(self)
            else:
                return visitor.visitChildren(self)




    def createRoutine(self):

        localctx = MySQLParser.CreateRoutineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_createRoutine)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2295
            self.match(MySQLParser.CREATE_SYMBOL)
            self.state = 2299
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,116,self._ctx)
            if la_ == 1:
                self.state = 2296
                self.createProcedure()
                pass

            elif la_ == 2:
                self.state = 2297
                self.createFunction()
                pass

            elif la_ == 3:
                self.state = 2298
                self.createUdf()
                pass


            self.state = 2302
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==30:
                self.state = 2301
                self.match(MySQLParser.SEMICOLON_SYMBOL)


            self.state = 2304
            self.match(MySQLParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateProcedureContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROCEDURE_SYMBOL(self):
            return self.getToken(MySQLParser.PROCEDURE_SYMBOL, 0)

        def procedureName(self):
            return self.getTypedRuleContext(MySQLParser.ProcedureNameContext,0)


        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def storedRoutineBody(self):
            return self.getTypedRuleContext(MySQLParser.StoredRoutineBodyContext,0)


        def definerClause(self):
            return self.getTypedRuleContext(MySQLParser.DefinerClauseContext,0)


        def ifNotExists(self):
            return self.getTypedRuleContext(MySQLParser.IfNotExistsContext,0)


        def procedureParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ProcedureParameterContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ProcedureParameterContext,i)


        def routineCreateOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.RoutineCreateOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.RoutineCreateOptionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_createProcedure

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateProcedure" ):
                listener.enterCreateProcedure(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateProcedure" ):
                listener.exitCreateProcedure(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateProcedure" ):
                return visitor.visitCreateProcedure(self)
            else:
                return visitor.visitChildren(self)




    def createProcedure(self):

        localctx = MySQLParser.CreateProcedureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_createProcedure)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2307
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==168:
                self.state = 2306
                self.definerClause()


            self.state = 2309
            self.match(MySQLParser.PROCEDURE_SYMBOL)
            self.state = 2311
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,119,self._ctx)
            if la_ == 1:
                self.state = 2310
                self.ifNotExists()


            self.state = 2313
            self.procedureName()
            self.state = 2314
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 2323
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
            if la_ == 1:
                self.state = 2315
                self.procedureParameter()
                self.state = 2320
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==29:
                    self.state = 2316
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 2317
                    self.procedureParameter()
                    self.state = 2322
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 2325
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
            self.state = 2329
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,122,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2326
                    self.routineCreateOption() 
                self.state = 2331
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,122,self._ctx)

            self.state = 2332
            self.storedRoutineBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoutineStringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def DOLLAR_QUOTED_STRING_TEXT(self):
            return self.getToken(MySQLParser.DOLLAR_QUOTED_STRING_TEXT, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_routineString

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoutineString" ):
                listener.enterRoutineString(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoutineString" ):
                listener.exitRoutineString(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRoutineString" ):
                return visitor.visitRoutineString(self)
            else:
                return visitor.visitChildren(self)




    def routineString(self):

        localctx = MySQLParser.RoutineStringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_routineString)
        try:
            self.state = 2336
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,123,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2334
                self.textStringLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2335
                self.match(MySQLParser.DOLLAR_QUOTED_STRING_TEXT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoredRoutineBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compoundStatement(self):
            return self.getTypedRuleContext(MySQLParser.CompoundStatementContext,0)


        def AS_SYMBOL(self):
            return self.getToken(MySQLParser.AS_SYMBOL, 0)

        def routineString(self):
            return self.getTypedRuleContext(MySQLParser.RoutineStringContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_storedRoutineBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStoredRoutineBody" ):
                listener.enterStoredRoutineBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStoredRoutineBody" ):
                listener.exitStoredRoutineBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStoredRoutineBody" ):
                return visitor.visitStoredRoutineBody(self)
            else:
                return visitor.visitChildren(self)




    def storedRoutineBody(self):

        localctx = MySQLParser.StoredRoutineBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_storedRoutineBody)
        try:
            self.state = 2342
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,124,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2338
                self.compoundStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2339
                if not self.isStoredRoutineBody():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isStoredRoutineBody()")
                self.state = 2340
                self.match(MySQLParser.AS_SYMBOL)
                self.state = 2341
                self.routineString()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateFunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNCTION_SYMBOL(self):
            return self.getToken(MySQLParser.FUNCTION_SYMBOL, 0)

        def functionName(self):
            return self.getTypedRuleContext(MySQLParser.FunctionNameContext,0)


        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def RETURNS_SYMBOL(self):
            return self.getToken(MySQLParser.RETURNS_SYMBOL, 0)

        def typeWithOptCollate(self):
            return self.getTypedRuleContext(MySQLParser.TypeWithOptCollateContext,0)


        def storedRoutineBody(self):
            return self.getTypedRuleContext(MySQLParser.StoredRoutineBodyContext,0)


        def definerClause(self):
            return self.getTypedRuleContext(MySQLParser.DefinerClauseContext,0)


        def ifNotExists(self):
            return self.getTypedRuleContext(MySQLParser.IfNotExistsContext,0)


        def functionParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.FunctionParameterContext)
            else:
                return self.getTypedRuleContext(MySQLParser.FunctionParameterContext,i)


        def routineCreateOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.RoutineCreateOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.RoutineCreateOptionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_createFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateFunction" ):
                listener.enterCreateFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateFunction" ):
                listener.exitCreateFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateFunction" ):
                return visitor.visitCreateFunction(self)
            else:
                return visitor.visitChildren(self)




    def createFunction(self):

        localctx = MySQLParser.CreateFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_createFunction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2345
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==168:
                self.state = 2344
                self.definerClause()


            self.state = 2347
            self.match(MySQLParser.FUNCTION_SYMBOL)
            self.state = 2349
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,126,self._ctx)
            if la_ == 1:
                self.state = 2348
                self.ifNotExists()


            self.state = 2351
            self.functionName()
            self.state = 2352
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 2361
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,128,self._ctx)
            if la_ == 1:
                self.state = 2353
                self.functionParameter()
                self.state = 2358
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==29:
                    self.state = 2354
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 2355
                    self.functionParameter()
                    self.state = 2360
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 2363
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
            self.state = 2364
            self.match(MySQLParser.RETURNS_SYMBOL)
            self.state = 2365
            self.typeWithOptCollate()
            self.state = 2369
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,129,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2366
                    self.routineCreateOption() 
                self.state = 2371
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,129,self._ctx)

            self.state = 2372
            self.storedRoutineBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateUdfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # Token

        def FUNCTION_SYMBOL(self):
            return self.getToken(MySQLParser.FUNCTION_SYMBOL, 0)

        def udfName(self):
            return self.getTypedRuleContext(MySQLParser.UdfNameContext,0)


        def RETURNS_SYMBOL(self):
            return self.getToken(MySQLParser.RETURNS_SYMBOL, 0)

        def SONAME_SYMBOL(self):
            return self.getToken(MySQLParser.SONAME_SYMBOL, 0)

        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def STRING_SYMBOL(self):
            return self.getToken(MySQLParser.STRING_SYMBOL, 0)

        def INT_SYMBOL(self):
            return self.getToken(MySQLParser.INT_SYMBOL, 0)

        def REAL_SYMBOL(self):
            return self.getToken(MySQLParser.REAL_SYMBOL, 0)

        def DECIMAL_SYMBOL(self):
            return self.getToken(MySQLParser.DECIMAL_SYMBOL, 0)

        def AGGREGATE_SYMBOL(self):
            return self.getToken(MySQLParser.AGGREGATE_SYMBOL, 0)

        def ifNotExists(self):
            return self.getTypedRuleContext(MySQLParser.IfNotExistsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createUdf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateUdf" ):
                listener.enterCreateUdf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateUdf" ):
                listener.exitCreateUdf(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateUdf" ):
                return visitor.visitCreateUdf(self)
            else:
                return visitor.visitChildren(self)




    def createUdf(self):

        localctx = MySQLParser.CreateUdfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_createUdf)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2375
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==55:
                self.state = 2374
                self.match(MySQLParser.AGGREGATE_SYMBOL)


            self.state = 2377
            self.match(MySQLParser.FUNCTION_SYMBOL)
            self.state = 2379
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,131,self._ctx)
            if la_ == 1:
                self.state = 2378
                self.ifNotExists()


            self.state = 2381
            self.udfName()
            self.state = 2382
            self.match(MySQLParser.RETURNS_SYMBOL)
            self.state = 2383
            localctx.type_ = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==164 or _la==280 or _la==455 or _la==566):
                localctx.type_ = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2384
            self.match(MySQLParser.SONAME_SYMBOL)
            self.state = 2385
            self.textLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoutineCreateOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def routineOption(self):
            return self.getTypedRuleContext(MySQLParser.RoutineOptionContext,0)


        def DETERMINISTIC_SYMBOL(self):
            return self.getToken(MySQLParser.DETERMINISTIC_SYMBOL, 0)

        def NOT_SYMBOL(self):
            return self.getToken(MySQLParser.NOT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_routineCreateOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoutineCreateOption" ):
                listener.enterRoutineCreateOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoutineCreateOption" ):
                listener.exitRoutineCreateOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRoutineCreateOption" ):
                return visitor.visitRoutineCreateOption(self)
            else:
                return visitor.visitChildren(self)




    def routineCreateOption(self):

        localctx = MySQLParser.RoutineCreateOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_routineCreateOption)
        self._la = 0 # Token type
        try:
            self.state = 2392
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [118, 133, 297, 370, 392, 451, 547]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2387
                self.routineOption()
                pass
            elif token in [174, 390]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2389
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==390:
                    self.state = 2388
                    self.match(MySQLParser.NOT_SYMBOL)


                self.state = 2391
                self.match(MySQLParser.DETERMINISTIC_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoutineAlterOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def routineCreateOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.RoutineCreateOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.RoutineCreateOptionContext,i)


        def getRuleIndex(self):
            return MySQLParser.RULE_routineAlterOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoutineAlterOptions" ):
                listener.enterRoutineAlterOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoutineAlterOptions" ):
                listener.exitRoutineAlterOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRoutineAlterOptions" ):
                return visitor.visitRoutineAlterOptions(self)
            else:
                return visitor.visitChildren(self)




    def routineAlterOptions(self):

        localctx = MySQLParser.RoutineAlterOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_routineAlterOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2395 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 2394
                self.routineCreateOption()
                self.state = 2397 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 118)) & ~0x3f) == 0 and ((1 << (_la - 118)) & 72057594037960705) != 0) or _la==297 or ((((_la - 370)) & ~0x3f) == 0 and ((1 << (_la - 370)) & 5242881) != 0) or _la==451 or _la==547):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoutineOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.option = None # Token
            self.security = None # Token

        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def COMMENT_SYMBOL(self):
            return self.getToken(MySQLParser.COMMENT_SYMBOL, 0)

        def LANGUAGE_SYMBOL(self):
            return self.getToken(MySQLParser.LANGUAGE_SYMBOL, 0)

        def SQL_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def NO_SYMBOL(self):
            return self.getToken(MySQLParser.NO_SYMBOL, 0)

        def CONTAINS_SYMBOL(self):
            return self.getToken(MySQLParser.CONTAINS_SYMBOL, 0)

        def DATA_SYMBOL(self):
            return self.getToken(MySQLParser.DATA_SYMBOL, 0)

        def READS_SYMBOL(self):
            return self.getToken(MySQLParser.READS_SYMBOL, 0)

        def MODIFIES_SYMBOL(self):
            return self.getToken(MySQLParser.MODIFIES_SYMBOL, 0)

        def SECURITY_SYMBOL(self):
            return self.getToken(MySQLParser.SECURITY_SYMBOL, 0)

        def DEFINER_SYMBOL(self):
            return self.getToken(MySQLParser.DEFINER_SYMBOL, 0)

        def INVOKER_SYMBOL(self):
            return self.getToken(MySQLParser.INVOKER_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_routineOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoutineOption" ):
                listener.enterRoutineOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoutineOption" ):
                listener.exitRoutineOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRoutineOption" ):
                return visitor.visitRoutineOption(self)
            else:
                return visitor.visitChildren(self)




    def routineOption(self):

        localctx = MySQLParser.RoutineOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_routineOption)
        self._la = 0 # Token type
        try:
            self.state = 2420
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [118]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2399
                localctx.option = self.match(MySQLParser.COMMENT_SYMBOL)
                self.state = 2400
                self.textLiteral()
                pass
            elif token in [297]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2401
                localctx.option = self.match(MySQLParser.LANGUAGE_SYMBOL)
                self.state = 2405
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,135,self._ctx)
                if la_ == 1:
                    self.state = 2402
                    self.match(MySQLParser.SQL_SYMBOL)
                    pass

                elif la_ == 2:
                    self.state = 2403
                    if not self.isServerVersionGe80032():
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.isServerVersionGe80032()")
                    self.state = 2404
                    self.identifier()
                    pass


                pass
            elif token in [392]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2407
                localctx.option = self.match(MySQLParser.NO_SYMBOL)
                self.state = 2408
                self.match(MySQLParser.SQL_SYMBOL)
                pass
            elif token in [133]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2409
                localctx.option = self.match(MySQLParser.CONTAINS_SYMBOL)
                self.state = 2410
                self.match(MySQLParser.SQL_SYMBOL)
                pass
            elif token in [451]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2411
                localctx.option = self.match(MySQLParser.READS_SYMBOL)
                self.state = 2412
                self.match(MySQLParser.SQL_SYMBOL)
                self.state = 2413
                self.match(MySQLParser.DATA_SYMBOL)
                pass
            elif token in [370]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2414
                localctx.option = self.match(MySQLParser.MODIFIES_SYMBOL)
                self.state = 2415
                self.match(MySQLParser.SQL_SYMBOL)
                self.state = 2416
                self.match(MySQLParser.DATA_SYMBOL)
                pass
            elif token in [547]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2417
                localctx.option = self.match(MySQLParser.SQL_SYMBOL)
                self.state = 2418
                self.match(MySQLParser.SECURITY_SYMBOL)
                self.state = 2419
                localctx.security = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==168 or _la==281):
                    localctx.security = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateIndexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # Token

        def indexName(self):
            return self.getTypedRuleContext(MySQLParser.IndexNameContext,0)


        def createIndexTarget(self):
            return self.getTypedRuleContext(MySQLParser.CreateIndexTargetContext,0)


        def INDEX_SYMBOL(self):
            return self.getToken(MySQLParser.INDEX_SYMBOL, 0)

        def onlineOption(self):
            return self.getTypedRuleContext(MySQLParser.OnlineOptionContext,0)


        def FULLTEXT_SYMBOL(self):
            return self.getToken(MySQLParser.FULLTEXT_SYMBOL, 0)

        def SPATIAL_SYMBOL(self):
            return self.getToken(MySQLParser.SPATIAL_SYMBOL, 0)

        def indexLockAndAlgorithm(self):
            return self.getTypedRuleContext(MySQLParser.IndexLockAndAlgorithmContext,0)


        def UNIQUE_SYMBOL(self):
            return self.getToken(MySQLParser.UNIQUE_SYMBOL, 0)

        def indexTypeClause(self):
            return self.getTypedRuleContext(MySQLParser.IndexTypeClauseContext,0)


        def indexOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.IndexOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.IndexOptionContext,i)


        def fulltextIndexOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.FulltextIndexOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.FulltextIndexOptionContext,i)


        def spatialIndexOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.SpatialIndexOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.SpatialIndexOptionContext,i)


        def getRuleIndex(self):
            return MySQLParser.RULE_createIndex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateIndex" ):
                listener.enterCreateIndex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateIndex" ):
                listener.exitCreateIndex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateIndex" ):
                return visitor.visitCreateIndex(self)
            else:
                return visitor.visitChildren(self)




    def createIndex(self):

        localctx = MySQLParser.CreateIndexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_createIndex)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2423
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==399 or _la==403:
                self.state = 2422
                self.onlineOption()


            self.state = 2460
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [268, 618]:
                self.state = 2426
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==618:
                    self.state = 2425
                    self.match(MySQLParser.UNIQUE_SYMBOL)


                self.state = 2428
                localctx.type_ = self.match(MySQLParser.INDEX_SYMBOL)
                self.state = 2429
                self.indexName()
                self.state = 2431
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==608 or _la==630:
                    self.state = 2430
                    self.indexTypeClause()


                self.state = 2433
                self.createIndexTarget()
                self.state = 2437
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,140,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 2434
                        self.indexOption() 
                    self.state = 2439
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,140,self._ctx)

                pass
            elif token in [237]:
                self.state = 2440
                localctx.type_ = self.match(MySQLParser.FULLTEXT_SYMBOL)
                self.state = 2441
                self.match(MySQLParser.INDEX_SYMBOL)
                self.state = 2442
                self.indexName()
                self.state = 2443
                self.createIndexTarget()
                self.state = 2447
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,141,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 2444
                        self.fulltextIndexOption() 
                    self.state = 2449
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,141,self._ctx)

                pass
            elif token in [534]:
                self.state = 2450
                localctx.type_ = self.match(MySQLParser.SPATIAL_SYMBOL)
                self.state = 2451
                self.match(MySQLParser.INDEX_SYMBOL)
                self.state = 2452
                self.indexName()
                self.state = 2453
                self.createIndexTarget()
                self.state = 2457
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,142,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 2454
                        self.spatialIndexOption() 
                    self.state = 2459
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,142,self._ctx)

                pass
            else:
                raise NoViableAltException(self)

            self.state = 2463
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==56 or _la==314:
                self.state = 2462
                self.indexLockAndAlgorithm()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndexNameAndTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def indexName(self):
            return self.getTypedRuleContext(MySQLParser.IndexNameContext,0)


        def USING_SYMBOL(self):
            return self.getToken(MySQLParser.USING_SYMBOL, 0)

        def indexType(self):
            return self.getTypedRuleContext(MySQLParser.IndexTypeContext,0)


        def TYPE_SYMBOL(self):
            return self.getToken(MySQLParser.TYPE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_indexNameAndType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndexNameAndType" ):
                listener.enterIndexNameAndType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndexNameAndType" ):
                listener.exitIndexNameAndType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndexNameAndType" ):
                return visitor.visitIndexNameAndType(self)
            else:
                return visitor.visitChildren(self)




    def indexNameAndType(self):

        localctx = MySQLParser.IndexNameAndTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_indexNameAndType)
        try:
            self.state = 2475
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,146,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2465
                self.indexName()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2467
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,145,self._ctx)
                if la_ == 1:
                    self.state = 2466
                    self.indexName()


                self.state = 2469
                self.match(MySQLParser.USING_SYMBOL)
                self.state = 2470
                self.indexType()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2471
                self.indexName()
                self.state = 2472
                self.match(MySQLParser.TYPE_SYMBOL)
                self.state = 2473
                self.indexType()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateIndexTargetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ON_SYMBOL(self):
            return self.getToken(MySQLParser.ON_SYMBOL, 0)

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def keyListWithExpression(self):
            return self.getTypedRuleContext(MySQLParser.KeyListWithExpressionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createIndexTarget

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateIndexTarget" ):
                listener.enterCreateIndexTarget(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateIndexTarget" ):
                listener.exitCreateIndexTarget(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateIndexTarget" ):
                return visitor.visitCreateIndexTarget(self)
            else:
                return visitor.visitChildren(self)




    def createIndexTarget(self):

        localctx = MySQLParser.CreateIndexTargetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_createIndexTarget)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2477
            self.match(MySQLParser.ON_SYMBOL)
            self.state = 2478
            self.tableRef()
            self.state = 2479
            self.keyListWithExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateLogfileGroupContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOGFILE_SYMBOL(self):
            return self.getToken(MySQLParser.LOGFILE_SYMBOL, 0)

        def GROUP_SYMBOL(self):
            return self.getToken(MySQLParser.GROUP_SYMBOL, 0)

        def logfileGroupName(self):
            return self.getTypedRuleContext(MySQLParser.LogfileGroupNameContext,0)


        def ADD_SYMBOL(self):
            return self.getToken(MySQLParser.ADD_SYMBOL, 0)

        def UNDOFILE_SYMBOL(self):
            return self.getToken(MySQLParser.UNDOFILE_SYMBOL, 0)

        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def logfileGroupOptions(self):
            return self.getTypedRuleContext(MySQLParser.LogfileGroupOptionsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createLogfileGroup

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateLogfileGroup" ):
                listener.enterCreateLogfileGroup(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateLogfileGroup" ):
                listener.exitCreateLogfileGroup(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateLogfileGroup" ):
                return visitor.visitCreateLogfileGroup(self)
            else:
                return visitor.visitChildren(self)




    def createLogfileGroup(self):

        localctx = MySQLParser.CreateLogfileGroupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_createLogfileGroup)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2481
            self.match(MySQLParser.LOGFILE_SYMBOL)
            self.state = 2482
            self.match(MySQLParser.GROUP_SYMBOL)
            self.state = 2483
            self.logfileGroupName()
            self.state = 2484
            self.match(MySQLParser.ADD_SYMBOL)
            self.state = 2485
            self.match(MySQLParser.UNDOFILE_SYMBOL)
            self.state = 2486
            self.textLiteral()
            self.state = 2488
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118 or _la==198 or _la==270 or _la==388 or _la==393 or _la==458 or _la==563 or _la==613 or _la==646:
                self.state = 2487
                self.logfileGroupOptions()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogfileGroupOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logfileGroupOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.LogfileGroupOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.LogfileGroupOptionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_logfileGroupOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogfileGroupOptions" ):
                listener.enterLogfileGroupOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogfileGroupOptions" ):
                listener.exitLogfileGroupOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogfileGroupOptions" ):
                return visitor.visitLogfileGroupOptions(self)
            else:
                return visitor.visitChildren(self)




    def logfileGroupOptions(self):

        localctx = MySQLParser.LogfileGroupOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_logfileGroupOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2490
            self.logfileGroupOption()
            self.state = 2497
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29 or _la==118 or _la==198 or _la==270 or _la==388 or _la==393 or _la==458 or _la==563 or _la==613 or _la==646:
                self.state = 2492
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 2491
                    self.match(MySQLParser.COMMA_SYMBOL)


                self.state = 2494
                self.logfileGroupOption()
                self.state = 2499
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogfileGroupOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tsOptionInitialSize(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionInitialSizeContext,0)


        def tsOptionUndoRedoBufferSize(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionUndoRedoBufferSizeContext,0)


        def tsOptionNodegroup(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionNodegroupContext,0)


        def tsOptionEngine(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionEngineContext,0)


        def tsOptionWait(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionWaitContext,0)


        def tsOptionComment(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionCommentContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_logfileGroupOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogfileGroupOption" ):
                listener.enterLogfileGroupOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogfileGroupOption" ):
                listener.exitLogfileGroupOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogfileGroupOption" ):
                return visitor.visitLogfileGroupOption(self)
            else:
                return visitor.visitChildren(self)




    def logfileGroupOption(self):

        localctx = MySQLParser.LogfileGroupOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_logfileGroupOption)
        try:
            self.state = 2506
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [270]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2500
                self.tsOptionInitialSize()
                pass
            elif token in [458, 613]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2501
                self.tsOptionUndoRedoBufferSize()
                pass
            elif token in [388]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2502
                self.tsOptionNodegroup()
                pass
            elif token in [198, 563]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2503
                self.tsOptionEngine()
                pass
            elif token in [393, 646]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2504
                self.tsOptionWait()
                pass
            elif token in [118]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2505
                self.tsOptionComment()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateServerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SERVER_SYMBOL(self):
            return self.getToken(MySQLParser.SERVER_SYMBOL, 0)

        def serverName(self):
            return self.getTypedRuleContext(MySQLParser.ServerNameContext,0)


        def FOREIGN_SYMBOL(self):
            return self.getToken(MySQLParser.FOREIGN_SYMBOL, 0)

        def DATA_SYMBOL(self):
            return self.getToken(MySQLParser.DATA_SYMBOL, 0)

        def WRAPPER_SYMBOL(self):
            return self.getToken(MySQLParser.WRAPPER_SYMBOL, 0)

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def serverOptions(self):
            return self.getTypedRuleContext(MySQLParser.ServerOptionsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createServer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateServer" ):
                listener.enterCreateServer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateServer" ):
                listener.exitCreateServer(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateServer" ):
                return visitor.visitCreateServer(self)
            else:
                return visitor.visitChildren(self)




    def createServer(self):

        localctx = MySQLParser.CreateServerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_createServer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2508
            self.match(MySQLParser.SERVER_SYMBOL)
            self.state = 2509
            self.serverName()
            self.state = 2510
            self.match(MySQLParser.FOREIGN_SYMBOL)
            self.state = 2511
            self.match(MySQLParser.DATA_SYMBOL)
            self.state = 2512
            self.match(MySQLParser.WRAPPER_SYMBOL)
            self.state = 2513
            self.textOrIdentifier()
            self.state = 2514
            self.serverOptions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ServerOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPTIONS_SYMBOL(self):
            return self.getToken(MySQLParser.OPTIONS_SYMBOL, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def serverOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ServerOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ServerOptionContext,i)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_serverOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterServerOptions" ):
                listener.enterServerOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitServerOptions" ):
                listener.exitServerOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitServerOptions" ):
                return visitor.visitServerOptions(self)
            else:
                return visitor.visitChildren(self)




    def serverOptions(self):

        localctx = MySQLParser.ServerOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_serverOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2516
            self.match(MySQLParser.OPTIONS_SYMBOL)
            self.state = 2517
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 2518
            self.serverOption()
            self.state = 2523
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 2519
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 2520
                self.serverOption()
                self.state = 2525
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2526
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ServerOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.option = None # Token

        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def HOST_SYMBOL(self):
            return self.getToken(MySQLParser.HOST_SYMBOL, 0)

        def DATABASE_SYMBOL(self):
            return self.getToken(MySQLParser.DATABASE_SYMBOL, 0)

        def USER_SYMBOL(self):
            return self.getToken(MySQLParser.USER_SYMBOL, 0)

        def PASSWORD_SYMBOL(self):
            return self.getToken(MySQLParser.PASSWORD_SYMBOL, 0)

        def SOCKET_SYMBOL(self):
            return self.getToken(MySQLParser.SOCKET_SYMBOL, 0)

        def OWNER_SYMBOL(self):
            return self.getToken(MySQLParser.OWNER_SYMBOL, 0)

        def ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Ulong_numberContext,0)


        def PORT_SYMBOL(self):
            return self.getToken(MySQLParser.PORT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_serverOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterServerOption" ):
                listener.enterServerOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitServerOption" ):
                listener.exitServerOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitServerOption" ):
                return visitor.visitServerOption(self)
            else:
                return visitor.visitChildren(self)




    def serverOption(self):

        localctx = MySQLParser.ServerOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_serverOption)
        try:
            self.state = 2542
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [256]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2528
                localctx.option = self.match(MySQLParser.HOST_SYMBOL)
                self.state = 2529
                self.textLiteral()
                pass
            elif token in [150]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2530
                localctx.option = self.match(MySQLParser.DATABASE_SYMBOL)
                self.state = 2531
                self.textLiteral()
                pass
            elif token in [627]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2532
                localctx.option = self.match(MySQLParser.USER_SYMBOL)
                self.state = 2533
                self.textLiteral()
                pass
            elif token in [424]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2534
                localctx.option = self.match(MySQLParser.PASSWORD_SYMBOL)
                self.state = 2535
                self.textLiteral()
                pass
            elif token in [530]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2536
                localctx.option = self.match(MySQLParser.SOCKET_SYMBOL)
                self.state = 2537
                self.textLiteral()
                pass
            elif token in [416]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2538
                localctx.option = self.match(MySQLParser.OWNER_SYMBOL)
                self.state = 2539
                self.textLiteral()
                pass
            elif token in [431]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2540
                localctx.option = self.match(MySQLParser.PORT_SYMBOL)
                self.state = 2541
                self.ulong_number()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateTablespaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TABLESPACE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLESPACE_SYMBOL, 0)

        def tablespaceName(self):
            return self.getTypedRuleContext(MySQLParser.TablespaceNameContext,0)


        def tsDataFileName(self):
            return self.getTypedRuleContext(MySQLParser.TsDataFileNameContext,0)


        def USE_SYMBOL(self):
            return self.getToken(MySQLParser.USE_SYMBOL, 0)

        def LOGFILE_SYMBOL(self):
            return self.getToken(MySQLParser.LOGFILE_SYMBOL, 0)

        def GROUP_SYMBOL(self):
            return self.getToken(MySQLParser.GROUP_SYMBOL, 0)

        def logfileGroupRef(self):
            return self.getTypedRuleContext(MySQLParser.LogfileGroupRefContext,0)


        def tablespaceOptions(self):
            return self.getTypedRuleContext(MySQLParser.TablespaceOptionsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createTablespace

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateTablespace" ):
                listener.enterCreateTablespace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateTablespace" ):
                listener.exitCreateTablespace(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateTablespace" ):
                return visitor.visitCreateTablespace(self)
            else:
                return visitor.visitChildren(self)




    def createTablespace(self):

        localctx = MySQLParser.CreateTablespaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_createTablespace)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2544
            self.match(MySQLParser.TABLESPACE_SYMBOL)
            self.state = 2545
            self.tablespaceName()
            self.state = 2546
            self.tsDataFileName()
            self.state = 2551
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,153,self._ctx)
            if la_ == 1:
                self.state = 2547
                self.match(MySQLParser.USE_SYMBOL)
                self.state = 2548
                self.match(MySQLParser.LOGFILE_SYMBOL)
                self.state = 2549
                self.match(MySQLParser.GROUP_SYMBOL)
                self.state = 2550
                self.logfileGroupRef()


            self.state = 2554
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,154,self._ctx)
            if la_ == 1:
                self.state = 2553
                self.tablespaceOptions()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateUndoTablespaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNDO_SYMBOL(self):
            return self.getToken(MySQLParser.UNDO_SYMBOL, 0)

        def TABLESPACE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLESPACE_SYMBOL, 0)

        def tablespaceName(self):
            return self.getTypedRuleContext(MySQLParser.TablespaceNameContext,0)


        def ADD_SYMBOL(self):
            return self.getToken(MySQLParser.ADD_SYMBOL, 0)

        def tsDataFile(self):
            return self.getTypedRuleContext(MySQLParser.TsDataFileContext,0)


        def undoTableSpaceOptions(self):
            return self.getTypedRuleContext(MySQLParser.UndoTableSpaceOptionsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createUndoTablespace

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateUndoTablespace" ):
                listener.enterCreateUndoTablespace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateUndoTablespace" ):
                listener.exitCreateUndoTablespace(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateUndoTablespace" ):
                return visitor.visitCreateUndoTablespace(self)
            else:
                return visitor.visitChildren(self)




    def createUndoTablespace(self):

        localctx = MySQLParser.CreateUndoTablespaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_createUndoTablespace)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2556
            self.match(MySQLParser.UNDO_SYMBOL)
            self.state = 2557
            self.match(MySQLParser.TABLESPACE_SYMBOL)
            self.state = 2558
            self.tablespaceName()
            self.state = 2559
            self.match(MySQLParser.ADD_SYMBOL)
            self.state = 2560
            self.tsDataFile()
            self.state = 2562
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==198 or _la==563:
                self.state = 2561
                self.undoTableSpaceOptions()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TsDataFileNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD_SYMBOL(self):
            return self.getToken(MySQLParser.ADD_SYMBOL, 0)

        def tsDataFile(self):
            return self.getTypedRuleContext(MySQLParser.TsDataFileContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_tsDataFileName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTsDataFileName" ):
                listener.enterTsDataFileName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTsDataFileName" ):
                listener.exitTsDataFileName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTsDataFileName" ):
                return visitor.visitTsDataFileName(self)
            else:
                return visitor.visitChildren(self)




    def tsDataFileName(self):

        localctx = MySQLParser.TsDataFileNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_tsDataFileName)
        try:
            self.state = 2571
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,157,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2564
                self.match(MySQLParser.ADD_SYMBOL)
                self.state = 2565
                self.tsDataFile()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2566
                if not self.isServerVersionGe80014():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80014()")
                self.state = 2569
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,156,self._ctx)
                if la_ == 1:
                    self.state = 2567
                    self.match(MySQLParser.ADD_SYMBOL)
                    self.state = 2568
                    self.tsDataFile()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TsDataFileContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATAFILE_SYMBOL(self):
            return self.getToken(MySQLParser.DATAFILE_SYMBOL, 0)

        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_tsDataFile

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTsDataFile" ):
                listener.enterTsDataFile(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTsDataFile" ):
                listener.exitTsDataFile(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTsDataFile" ):
                return visitor.visitTsDataFile(self)
            else:
                return visitor.visitChildren(self)




    def tsDataFile(self):

        localctx = MySQLParser.TsDataFileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_tsDataFile)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2573
            self.match(MySQLParser.DATAFILE_SYMBOL)
            self.state = 2574
            self.textLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TablespaceOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tablespaceOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.TablespaceOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.TablespaceOptionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_tablespaceOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTablespaceOptions" ):
                listener.enterTablespaceOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTablespaceOptions" ):
                listener.exitTablespaceOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTablespaceOptions" ):
                return visitor.visitTablespaceOptions(self)
            else:
                return visitor.visitChildren(self)




    def tablespaceOptions(self):

        localctx = MySQLParser.TablespaceOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_tablespaceOptions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2576
            self.tablespaceOption()
            self.state = 2583
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,159,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2578
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,158,self._ctx)
                    if la_ == 1:
                        self.state = 2577
                        self.match(MySQLParser.COMMA_SYMBOL)


                    self.state = 2580
                    self.tablespaceOption() 
                self.state = 2585
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,159,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TablespaceOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tsOptionInitialSize(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionInitialSizeContext,0)


        def tsOptionAutoextendSize(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionAutoextendSizeContext,0)


        def tsOptionMaxSize(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionMaxSizeContext,0)


        def tsOptionExtentSize(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionExtentSizeContext,0)


        def tsOptionNodegroup(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionNodegroupContext,0)


        def tsOptionEngine(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionEngineContext,0)


        def tsOptionWait(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionWaitContext,0)


        def tsOptionComment(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionCommentContext,0)


        def tsOptionFileblockSize(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionFileblockSizeContext,0)


        def tsOptionEncryption(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionEncryptionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_tablespaceOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTablespaceOption" ):
                listener.enterTablespaceOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTablespaceOption" ):
                listener.exitTablespaceOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTablespaceOption" ):
                return visitor.visitTablespaceOption(self)
            else:
                return visitor.visitChildren(self)




    def tablespaceOption(self):

        localctx = MySQLParser.TablespaceOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_tablespaceOption)
        try:
            self.state = 2597
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,160,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2586
                self.tsOptionInitialSize()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2587
                self.tsOptionAutoextendSize()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2588
                self.tsOptionMaxSize()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2589
                self.tsOptionExtentSize()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2590
                self.tsOptionNodegroup()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2591
                self.tsOptionEngine()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2592
                self.tsOptionWait()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 2593
                self.tsOptionComment()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 2594
                self.tsOptionFileblockSize()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 2595
                if not self.isServerVersionGe80014():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80014()")
                self.state = 2596
                self.tsOptionEncryption()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TsOptionInitialSizeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INITIAL_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.INITIAL_SIZE_SYMBOL, 0)

        def sizeNumber(self):
            return self.getTypedRuleContext(MySQLParser.SizeNumberContext,0)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_tsOptionInitialSize

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTsOptionInitialSize" ):
                listener.enterTsOptionInitialSize(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTsOptionInitialSize" ):
                listener.exitTsOptionInitialSize(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTsOptionInitialSize" ):
                return visitor.visitTsOptionInitialSize(self)
            else:
                return visitor.visitChildren(self)




    def tsOptionInitialSize(self):

        localctx = MySQLParser.TsOptionInitialSizeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_tsOptionInitialSize)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2599
            self.match(MySQLParser.INITIAL_SIZE_SYMBOL)
            self.state = 2601
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,161,self._ctx)
            if la_ == 1:
                self.state = 2600
                self.match(MySQLParser.EQUAL_OPERATOR)


            self.state = 2603
            self.sizeNumber()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TsOptionUndoRedoBufferSizeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sizeNumber(self):
            return self.getTypedRuleContext(MySQLParser.SizeNumberContext,0)


        def UNDO_BUFFER_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.UNDO_BUFFER_SIZE_SYMBOL, 0)

        def REDO_BUFFER_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.REDO_BUFFER_SIZE_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_tsOptionUndoRedoBufferSize

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTsOptionUndoRedoBufferSize" ):
                listener.enterTsOptionUndoRedoBufferSize(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTsOptionUndoRedoBufferSize" ):
                listener.exitTsOptionUndoRedoBufferSize(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTsOptionUndoRedoBufferSize" ):
                return visitor.visitTsOptionUndoRedoBufferSize(self)
            else:
                return visitor.visitChildren(self)




    def tsOptionUndoRedoBufferSize(self):

        localctx = MySQLParser.TsOptionUndoRedoBufferSizeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_tsOptionUndoRedoBufferSize)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2605
            _la = self._input.LA(1)
            if not(_la==458 or _la==613):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2607
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,162,self._ctx)
            if la_ == 1:
                self.state = 2606
                self.match(MySQLParser.EQUAL_OPERATOR)


            self.state = 2609
            self.sizeNumber()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TsOptionAutoextendSizeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AUTOEXTEND_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.AUTOEXTEND_SIZE_SYMBOL, 0)

        def sizeNumber(self):
            return self.getTypedRuleContext(MySQLParser.SizeNumberContext,0)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_tsOptionAutoextendSize

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTsOptionAutoextendSize" ):
                listener.enterTsOptionAutoextendSize(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTsOptionAutoextendSize" ):
                listener.exitTsOptionAutoextendSize(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTsOptionAutoextendSize" ):
                return visitor.visitTsOptionAutoextendSize(self)
            else:
                return visitor.visitChildren(self)




    def tsOptionAutoextendSize(self):

        localctx = MySQLParser.TsOptionAutoextendSizeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_tsOptionAutoextendSize)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2611
            self.match(MySQLParser.AUTOEXTEND_SIZE_SYMBOL)
            self.state = 2613
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,163,self._ctx)
            if la_ == 1:
                self.state = 2612
                self.match(MySQLParser.EQUAL_OPERATOR)


            self.state = 2615
            self.sizeNumber()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TsOptionMaxSizeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAX_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_SIZE_SYMBOL, 0)

        def sizeNumber(self):
            return self.getTypedRuleContext(MySQLParser.SizeNumberContext,0)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_tsOptionMaxSize

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTsOptionMaxSize" ):
                listener.enterTsOptionMaxSize(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTsOptionMaxSize" ):
                listener.exitTsOptionMaxSize(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTsOptionMaxSize" ):
                return visitor.visitTsOptionMaxSize(self)
            else:
                return visitor.visitChildren(self)




    def tsOptionMaxSize(self):

        localctx = MySQLParser.TsOptionMaxSizeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_tsOptionMaxSize)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2617
            self.match(MySQLParser.MAX_SIZE_SYMBOL)
            self.state = 2619
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,164,self._ctx)
            if la_ == 1:
                self.state = 2618
                self.match(MySQLParser.EQUAL_OPERATOR)


            self.state = 2621
            self.sizeNumber()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TsOptionExtentSizeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXTENT_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.EXTENT_SIZE_SYMBOL, 0)

        def sizeNumber(self):
            return self.getTypedRuleContext(MySQLParser.SizeNumberContext,0)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_tsOptionExtentSize

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTsOptionExtentSize" ):
                listener.enterTsOptionExtentSize(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTsOptionExtentSize" ):
                listener.exitTsOptionExtentSize(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTsOptionExtentSize" ):
                return visitor.visitTsOptionExtentSize(self)
            else:
                return visitor.visitChildren(self)




    def tsOptionExtentSize(self):

        localctx = MySQLParser.TsOptionExtentSizeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_tsOptionExtentSize)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2623
            self.match(MySQLParser.EXTENT_SIZE_SYMBOL)
            self.state = 2625
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,165,self._ctx)
            if la_ == 1:
                self.state = 2624
                self.match(MySQLParser.EQUAL_OPERATOR)


            self.state = 2627
            self.sizeNumber()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TsOptionNodegroupContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NODEGROUP_SYMBOL(self):
            return self.getToken(MySQLParser.NODEGROUP_SYMBOL, 0)

        def real_ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Real_ulong_numberContext,0)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_tsOptionNodegroup

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTsOptionNodegroup" ):
                listener.enterTsOptionNodegroup(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTsOptionNodegroup" ):
                listener.exitTsOptionNodegroup(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTsOptionNodegroup" ):
                return visitor.visitTsOptionNodegroup(self)
            else:
                return visitor.visitChildren(self)




    def tsOptionNodegroup(self):

        localctx = MySQLParser.TsOptionNodegroupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_tsOptionNodegroup)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2629
            self.match(MySQLParser.NODEGROUP_SYMBOL)
            self.state = 2631
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==6:
                self.state = 2630
                self.match(MySQLParser.EQUAL_OPERATOR)


            self.state = 2633
            self.real_ulong_number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TsOptionEngineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENGINE_SYMBOL(self):
            return self.getToken(MySQLParser.ENGINE_SYMBOL, 0)

        def engineRef(self):
            return self.getTypedRuleContext(MySQLParser.EngineRefContext,0)


        def STORAGE_SYMBOL(self):
            return self.getToken(MySQLParser.STORAGE_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_tsOptionEngine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTsOptionEngine" ):
                listener.enterTsOptionEngine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTsOptionEngine" ):
                listener.exitTsOptionEngine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTsOptionEngine" ):
                return visitor.visitTsOptionEngine(self)
            else:
                return visitor.visitChildren(self)




    def tsOptionEngine(self):

        localctx = MySQLParser.TsOptionEngineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_tsOptionEngine)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2636
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==563:
                self.state = 2635
                self.match(MySQLParser.STORAGE_SYMBOL)


            self.state = 2638
            self.match(MySQLParser.ENGINE_SYMBOL)
            self.state = 2640
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,168,self._ctx)
            if la_ == 1:
                self.state = 2639
                self.match(MySQLParser.EQUAL_OPERATOR)


            self.state = 2642
            self.engineRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TsOptionWaitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WAIT_SYMBOL(self):
            return self.getToken(MySQLParser.WAIT_SYMBOL, 0)

        def NO_WAIT_SYMBOL(self):
            return self.getToken(MySQLParser.NO_WAIT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_tsOptionWait

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTsOptionWait" ):
                listener.enterTsOptionWait(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTsOptionWait" ):
                listener.exitTsOptionWait(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTsOptionWait" ):
                return visitor.visitTsOptionWait(self)
            else:
                return visitor.visitChildren(self)




    def tsOptionWait(self):

        localctx = MySQLParser.TsOptionWaitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_tsOptionWait)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2644
            _la = self._input.LA(1)
            if not(_la==393 or _la==646):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TsOptionCommentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMENT_SYMBOL(self):
            return self.getToken(MySQLParser.COMMENT_SYMBOL, 0)

        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_tsOptionComment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTsOptionComment" ):
                listener.enterTsOptionComment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTsOptionComment" ):
                listener.exitTsOptionComment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTsOptionComment" ):
                return visitor.visitTsOptionComment(self)
            else:
                return visitor.visitChildren(self)




    def tsOptionComment(self):

        localctx = MySQLParser.TsOptionCommentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_tsOptionComment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2646
            self.match(MySQLParser.COMMENT_SYMBOL)
            self.state = 2648
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,169,self._ctx)
            if la_ == 1:
                self.state = 2647
                self.match(MySQLParser.EQUAL_OPERATOR)


            self.state = 2650
            self.textLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TsOptionFileblockSizeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FILE_BLOCK_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.FILE_BLOCK_SIZE_SYMBOL, 0)

        def sizeNumber(self):
            return self.getTypedRuleContext(MySQLParser.SizeNumberContext,0)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_tsOptionFileblockSize

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTsOptionFileblockSize" ):
                listener.enterTsOptionFileblockSize(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTsOptionFileblockSize" ):
                listener.exitTsOptionFileblockSize(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTsOptionFileblockSize" ):
                return visitor.visitTsOptionFileblockSize(self)
            else:
                return visitor.visitChildren(self)




    def tsOptionFileblockSize(self):

        localctx = MySQLParser.TsOptionFileblockSizeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_tsOptionFileblockSize)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2652
            self.match(MySQLParser.FILE_BLOCK_SIZE_SYMBOL)
            self.state = 2654
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,170,self._ctx)
            if la_ == 1:
                self.state = 2653
                self.match(MySQLParser.EQUAL_OPERATOR)


            self.state = 2656
            self.sizeNumber()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TsOptionEncryptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENCRYPTION_SYMBOL(self):
            return self.getToken(MySQLParser.ENCRYPTION_SYMBOL, 0)

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_tsOptionEncryption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTsOptionEncryption" ):
                listener.enterTsOptionEncryption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTsOptionEncryption" ):
                listener.exitTsOptionEncryption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTsOptionEncryption" ):
                return visitor.visitTsOptionEncryption(self)
            else:
                return visitor.visitChildren(self)




    def tsOptionEncryption(self):

        localctx = MySQLParser.TsOptionEncryptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_tsOptionEncryption)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2658
            self.match(MySQLParser.ENCRYPTION_SYMBOL)
            self.state = 2660
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,171,self._ctx)
            if la_ == 1:
                self.state = 2659
                self.match(MySQLParser.EQUAL_OPERATOR)


            self.state = 2662
            self.textStringLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TsOptionEngineAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENGINE_SYMBOL(self):
            return self.getToken(MySQLParser.ENGINE_SYMBOL, 0)

        def jsonAttribute(self):
            return self.getTypedRuleContext(MySQLParser.JsonAttributeContext,0)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_tsOptionEngineAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTsOptionEngineAttribute" ):
                listener.enterTsOptionEngineAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTsOptionEngineAttribute" ):
                listener.exitTsOptionEngineAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTsOptionEngineAttribute" ):
                return visitor.visitTsOptionEngineAttribute(self)
            else:
                return visitor.visitChildren(self)




    def tsOptionEngineAttribute(self):

        localctx = MySQLParser.TsOptionEngineAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_tsOptionEngineAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2664
            self.match(MySQLParser.ENGINE_SYMBOL)
            self.state = 2666
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,172,self._ctx)
            if la_ == 1:
                self.state = 2665
                self.match(MySQLParser.EQUAL_OPERATOR)


            self.state = 2668
            self.jsonAttribute()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateViewContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VIEW_SYMBOL(self):
            return self.getToken(MySQLParser.VIEW_SYMBOL, 0)

        def viewName(self):
            return self.getTypedRuleContext(MySQLParser.ViewNameContext,0)


        def viewTail(self):
            return self.getTypedRuleContext(MySQLParser.ViewTailContext,0)


        def viewReplaceOrAlgorithm(self):
            return self.getTypedRuleContext(MySQLParser.ViewReplaceOrAlgorithmContext,0)


        def definerClause(self):
            return self.getTypedRuleContext(MySQLParser.DefinerClauseContext,0)


        def viewSuid(self):
            return self.getTypedRuleContext(MySQLParser.ViewSuidContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createView

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateView" ):
                listener.enterCreateView(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateView" ):
                listener.exitCreateView(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateView" ):
                return visitor.visitCreateView(self)
            else:
                return visitor.visitChildren(self)




    def createView(self):

        localctx = MySQLParser.CreateViewContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_createView)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2671
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==56 or _la==412:
                self.state = 2670
                self.viewReplaceOrAlgorithm()


            self.state = 2674
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==168:
                self.state = 2673
                self.definerClause()


            self.state = 2677
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==547:
                self.state = 2676
                self.viewSuid()


            self.state = 2679
            self.match(MySQLParser.VIEW_SYMBOL)
            self.state = 2680
            self.viewName()
            self.state = 2681
            self.viewTail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ViewReplaceOrAlgorithmContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OR_SYMBOL(self):
            return self.getToken(MySQLParser.OR_SYMBOL, 0)

        def REPLACE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLACE_SYMBOL, 0)

        def viewAlgorithm(self):
            return self.getTypedRuleContext(MySQLParser.ViewAlgorithmContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_viewReplaceOrAlgorithm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterViewReplaceOrAlgorithm" ):
                listener.enterViewReplaceOrAlgorithm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitViewReplaceOrAlgorithm" ):
                listener.exitViewReplaceOrAlgorithm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitViewReplaceOrAlgorithm" ):
                return visitor.visitViewReplaceOrAlgorithm(self)
            else:
                return visitor.visitChildren(self)




    def viewReplaceOrAlgorithm(self):

        localctx = MySQLParser.ViewReplaceOrAlgorithmContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_viewReplaceOrAlgorithm)
        self._la = 0 # Token type
        try:
            self.state = 2689
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [412]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2683
                self.match(MySQLParser.OR_SYMBOL)
                self.state = 2684
                self.match(MySQLParser.REPLACE_SYMBOL)
                self.state = 2686
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==56:
                    self.state = 2685
                    self.viewAlgorithm()


                pass
            elif token in [56]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2688
                self.viewAlgorithm()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ViewAlgorithmContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.algorithm = None # Token

        def ALGORITHM_SYMBOL(self):
            return self.getToken(MySQLParser.ALGORITHM_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def UNDEFINED_SYMBOL(self):
            return self.getToken(MySQLParser.UNDEFINED_SYMBOL, 0)

        def MERGE_SYMBOL(self):
            return self.getToken(MySQLParser.MERGE_SYMBOL, 0)

        def TEMPTABLE_SYMBOL(self):
            return self.getToken(MySQLParser.TEMPTABLE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_viewAlgorithm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterViewAlgorithm" ):
                listener.enterViewAlgorithm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitViewAlgorithm" ):
                listener.exitViewAlgorithm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitViewAlgorithm" ):
                return visitor.visitViewAlgorithm(self)
            else:
                return visitor.visitChildren(self)




    def viewAlgorithm(self):

        localctx = MySQLParser.ViewAlgorithmContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_viewAlgorithm)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2691
            self.match(MySQLParser.ALGORITHM_SYMBOL)
            self.state = 2692
            self.match(MySQLParser.EQUAL_OPERATOR)
            self.state = 2693
            localctx.algorithm = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==359 or _la==587 or _la==611):
                localctx.algorithm = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ViewSuidContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SQL_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_SYMBOL, 0)

        def SECURITY_SYMBOL(self):
            return self.getToken(MySQLParser.SECURITY_SYMBOL, 0)

        def DEFINER_SYMBOL(self):
            return self.getToken(MySQLParser.DEFINER_SYMBOL, 0)

        def INVOKER_SYMBOL(self):
            return self.getToken(MySQLParser.INVOKER_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_viewSuid

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterViewSuid" ):
                listener.enterViewSuid(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitViewSuid" ):
                listener.exitViewSuid(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitViewSuid" ):
                return visitor.visitViewSuid(self)
            else:
                return visitor.visitChildren(self)




    def viewSuid(self):

        localctx = MySQLParser.ViewSuidContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_viewSuid)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2695
            self.match(MySQLParser.SQL_SYMBOL)
            self.state = 2696
            self.match(MySQLParser.SECURITY_SYMBOL)
            self.state = 2697
            _la = self._input.LA(1)
            if not(_la==168 or _la==281):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateTriggerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.timing = None # Token
            self.event = None # Token

        def TRIGGER_SYMBOL(self):
            return self.getToken(MySQLParser.TRIGGER_SYMBOL, 0)

        def triggerName(self):
            return self.getTypedRuleContext(MySQLParser.TriggerNameContext,0)


        def ON_SYMBOL(self):
            return self.getToken(MySQLParser.ON_SYMBOL, 0)

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def EACH_SYMBOL(self):
            return self.getToken(MySQLParser.EACH_SYMBOL, 0)

        def ROW_SYMBOL(self):
            return self.getToken(MySQLParser.ROW_SYMBOL, 0)

        def compoundStatement(self):
            return self.getTypedRuleContext(MySQLParser.CompoundStatementContext,0)


        def BEFORE_SYMBOL(self):
            return self.getToken(MySQLParser.BEFORE_SYMBOL, 0)

        def AFTER_SYMBOL(self):
            return self.getToken(MySQLParser.AFTER_SYMBOL, 0)

        def INSERT_SYMBOL(self):
            return self.getToken(MySQLParser.INSERT_SYMBOL, 0)

        def UPDATE_SYMBOL(self):
            return self.getToken(MySQLParser.UPDATE_SYMBOL, 0)

        def DELETE_SYMBOL(self):
            return self.getToken(MySQLParser.DELETE_SYMBOL, 0)

        def definerClause(self):
            return self.getTypedRuleContext(MySQLParser.DefinerClauseContext,0)


        def ifNotExists(self):
            return self.getTypedRuleContext(MySQLParser.IfNotExistsContext,0)


        def triggerFollowsPrecedesClause(self):
            return self.getTypedRuleContext(MySQLParser.TriggerFollowsPrecedesClauseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createTrigger

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateTrigger" ):
                listener.enterCreateTrigger(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateTrigger" ):
                listener.exitCreateTrigger(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateTrigger" ):
                return visitor.visitCreateTrigger(self)
            else:
                return visitor.visitChildren(self)




    def createTrigger(self):

        localctx = MySQLParser.CreateTriggerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_createTrigger)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2700
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==168:
                self.state = 2699
                self.definerClause()


            self.state = 2702
            self.match(MySQLParser.TRIGGER_SYMBOL)
            self.state = 2704
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,179,self._ctx)
            if la_ == 1:
                self.state = 2703
                self.ifNotExists()


            self.state = 2706
            self.triggerName()
            self.state = 2707
            localctx.timing = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==53 or _la==73):
                localctx.timing = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2708
            localctx.event = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==171 or _la==274 or _la==623):
                localctx.event = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2709
            self.match(MySQLParser.ON_SYMBOL)
            self.state = 2710
            self.tableRef()
            self.state = 2711
            self.match(MySQLParser.FOR_SYMBOL)
            self.state = 2712
            self.match(MySQLParser.EACH_SYMBOL)
            self.state = 2713
            self.match(MySQLParser.ROW_SYMBOL)
            self.state = 2715
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,180,self._ctx)
            if la_ == 1:
                self.state = 2714
                self.triggerFollowsPrecedesClause()


            self.state = 2717
            self.compoundStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TriggerFollowsPrecedesClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ordering = None # Token

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def FOLLOWS_SYMBOL(self):
            return self.getToken(MySQLParser.FOLLOWS_SYMBOL, 0)

        def PRECEDES_SYMBOL(self):
            return self.getToken(MySQLParser.PRECEDES_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_triggerFollowsPrecedesClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTriggerFollowsPrecedesClause" ):
                listener.enterTriggerFollowsPrecedesClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTriggerFollowsPrecedesClause" ):
                listener.exitTriggerFollowsPrecedesClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTriggerFollowsPrecedesClause" ):
                return visitor.visitTriggerFollowsPrecedesClause(self)
            else:
                return visitor.visitChildren(self)




    def triggerFollowsPrecedesClause(self):

        localctx = MySQLParser.TriggerFollowsPrecedesClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_triggerFollowsPrecedesClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2719
            localctx.ordering = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==229 or _la==433):
                localctx.ordering = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2720
            self.textOrIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateEventContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EVENT_SYMBOL(self):
            return self.getToken(MySQLParser.EVENT_SYMBOL, 0)

        def eventName(self):
            return self.getTypedRuleContext(MySQLParser.EventNameContext,0)


        def ON_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.ON_SYMBOL)
            else:
                return self.getToken(MySQLParser.ON_SYMBOL, i)

        def SCHEDULE_SYMBOL(self):
            return self.getToken(MySQLParser.SCHEDULE_SYMBOL, 0)

        def schedule(self):
            return self.getTypedRuleContext(MySQLParser.ScheduleContext,0)


        def DO_SYMBOL(self):
            return self.getToken(MySQLParser.DO_SYMBOL, 0)

        def compoundStatement(self):
            return self.getTypedRuleContext(MySQLParser.CompoundStatementContext,0)


        def definerClause(self):
            return self.getTypedRuleContext(MySQLParser.DefinerClauseContext,0)


        def ifNotExists(self):
            return self.getTypedRuleContext(MySQLParser.IfNotExistsContext,0)


        def COMPLETION_SYMBOL(self):
            return self.getToken(MySQLParser.COMPLETION_SYMBOL, 0)

        def PRESERVE_SYMBOL(self):
            return self.getToken(MySQLParser.PRESERVE_SYMBOL, 0)

        def ENABLE_SYMBOL(self):
            return self.getToken(MySQLParser.ENABLE_SYMBOL, 0)

        def DISABLE_SYMBOL(self):
            return self.getToken(MySQLParser.DISABLE_SYMBOL, 0)

        def COMMENT_SYMBOL(self):
            return self.getToken(MySQLParser.COMMENT_SYMBOL, 0)

        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def NOT_SYMBOL(self):
            return self.getToken(MySQLParser.NOT_SYMBOL, 0)

        def replica(self):
            return self.getTypedRuleContext(MySQLParser.ReplicaContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createEvent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateEvent" ):
                listener.enterCreateEvent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateEvent" ):
                listener.exitCreateEvent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateEvent" ):
                return visitor.visitCreateEvent(self)
            else:
                return visitor.visitChildren(self)




    def createEvent(self):

        localctx = MySQLParser.CreateEventContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_createEvent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2723
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==168:
                self.state = 2722
                self.definerClause()


            self.state = 2725
            self.match(MySQLParser.EVENT_SYMBOL)
            self.state = 2727
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,182,self._ctx)
            if la_ == 1:
                self.state = 2726
                self.ifNotExists()


            self.state = 2729
            self.eventName()
            self.state = 2730
            self.match(MySQLParser.ON_SYMBOL)
            self.state = 2731
            self.match(MySQLParser.SCHEDULE_SYMBOL)
            self.state = 2732
            self.schedule()
            self.state = 2739
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==401:
                self.state = 2733
                self.match(MySQLParser.ON_SYMBOL)
                self.state = 2734
                self.match(MySQLParser.COMPLETION_SYMBOL)
                self.state = 2736
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==390:
                    self.state = 2735
                    self.match(MySQLParser.NOT_SYMBOL)


                self.state = 2738
                self.match(MySQLParser.PRESERVE_SYMBOL)


            self.state = 2747
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [192]:
                self.state = 2741
                self.match(MySQLParser.ENABLE_SYMBOL)
                pass
            elif token in [177]:
                self.state = 2742
                self.match(MySQLParser.DISABLE_SYMBOL)
                self.state = 2745
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==401:
                    self.state = 2743
                    self.match(MySQLParser.ON_SYMBOL)
                    self.state = 2744
                    self.replica()


                pass
            elif token in [118, 183]:
                pass
            else:
                pass
            self.state = 2751
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==118:
                self.state = 2749
                self.match(MySQLParser.COMMENT_SYMBOL)
                self.state = 2750
                self.textLiteral()


            self.state = 2753
            self.match(MySQLParser.DO_SYMBOL)
            self.state = 2754
            self.compoundStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateRoleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROLE_SYMBOL(self):
            return self.getToken(MySQLParser.ROLE_SYMBOL, 0)

        def roleList(self):
            return self.getTypedRuleContext(MySQLParser.RoleListContext,0)


        def ifNotExists(self):
            return self.getTypedRuleContext(MySQLParser.IfNotExistsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createRole

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateRole" ):
                listener.enterCreateRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateRole" ):
                listener.exitCreateRole(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateRole" ):
                return visitor.visitCreateRole(self)
            else:
                return visitor.visitChildren(self)




    def createRole(self):

        localctx = MySQLParser.CreateRoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_createRole)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2756
            self.match(MySQLParser.ROLE_SYMBOL)
            self.state = 2758
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,188,self._ctx)
            if la_ == 1:
                self.state = 2757
                self.ifNotExists()


            self.state = 2760
            self.roleList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateSpatialReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OR_SYMBOL(self):
            return self.getToken(MySQLParser.OR_SYMBOL, 0)

        def REPLACE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLACE_SYMBOL, 0)

        def SPATIAL_SYMBOL(self):
            return self.getToken(MySQLParser.SPATIAL_SYMBOL, 0)

        def REFERENCE_SYMBOL(self):
            return self.getToken(MySQLParser.REFERENCE_SYMBOL, 0)

        def SYSTEM_SYMBOL(self):
            return self.getToken(MySQLParser.SYSTEM_SYMBOL, 0)

        def real_ulonglong_number(self):
            return self.getTypedRuleContext(MySQLParser.Real_ulonglong_numberContext,0)


        def srsAttribute(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.SrsAttributeContext)
            else:
                return self.getTypedRuleContext(MySQLParser.SrsAttributeContext,i)


        def ifNotExists(self):
            return self.getTypedRuleContext(MySQLParser.IfNotExistsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createSpatialReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateSpatialReference" ):
                listener.enterCreateSpatialReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateSpatialReference" ):
                listener.exitCreateSpatialReference(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateSpatialReference" ):
                return visitor.visitCreateSpatialReference(self)
            else:
                return visitor.visitChildren(self)




    def createSpatialReference(self):

        localctx = MySQLParser.CreateSpatialReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_createSpatialReference)
        self._la = 0 # Token type
        try:
            self.state = 2787
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [412]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2762
                self.match(MySQLParser.OR_SYMBOL)
                self.state = 2763
                self.match(MySQLParser.REPLACE_SYMBOL)
                self.state = 2764
                self.match(MySQLParser.SPATIAL_SYMBOL)
                self.state = 2765
                self.match(MySQLParser.REFERENCE_SYMBOL)
                self.state = 2766
                self.match(MySQLParser.SYSTEM_SYMBOL)
                self.state = 2767
                self.real_ulonglong_number()
                self.state = 2771
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==380 or ((((_la - 723)) & ~0x3f) == 0 and ((1 << (_la - 723)) & 7) != 0):
                    self.state = 2768
                    self.srsAttribute()
                    self.state = 2773
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [534]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2774
                self.match(MySQLParser.SPATIAL_SYMBOL)
                self.state = 2775
                self.match(MySQLParser.REFERENCE_SYMBOL)
                self.state = 2776
                self.match(MySQLParser.SYSTEM_SYMBOL)
                self.state = 2778
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,190,self._ctx)
                if la_ == 1:
                    self.state = 2777
                    self.ifNotExists()


                self.state = 2780
                self.real_ulonglong_number()
                self.state = 2784
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==380 or ((((_la - 723)) & ~0x3f) == 0 and ((1 << (_la - 723)) & 7) != 0):
                    self.state = 2781
                    self.srsAttribute()
                    self.state = 2786
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SrsAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME_SYMBOL(self):
            return self.getToken(MySQLParser.NAME_SYMBOL, 0)

        def TEXT_SYMBOL(self):
            return self.getToken(MySQLParser.TEXT_SYMBOL, 0)

        def textStringNoLinebreak(self):
            return self.getTypedRuleContext(MySQLParser.TextStringNoLinebreakContext,0)


        def DEFINITION_SYMBOL(self):
            return self.getToken(MySQLParser.DEFINITION_SYMBOL, 0)

        def ORGANIZATION_SYMBOL(self):
            return self.getToken(MySQLParser.ORGANIZATION_SYMBOL, 0)

        def IDENTIFIED_SYMBOL(self):
            return self.getToken(MySQLParser.IDENTIFIED_SYMBOL, 0)

        def BY_SYMBOL(self):
            return self.getToken(MySQLParser.BY_SYMBOL, 0)

        def real_ulonglong_number(self):
            return self.getTypedRuleContext(MySQLParser.Real_ulonglong_numberContext,0)


        def DESCRIPTION_SYMBOL(self):
            return self.getToken(MySQLParser.DESCRIPTION_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_srsAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSrsAttribute" ):
                listener.enterSrsAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSrsAttribute" ):
                listener.exitSrsAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSrsAttribute" ):
                return visitor.visitSrsAttribute(self)
            else:
                return visitor.visitChildren(self)




    def srsAttribute(self):

        localctx = MySQLParser.SrsAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_srsAttribute)
        try:
            self.state = 2804
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [380]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2789
                self.match(MySQLParser.NAME_SYMBOL)
                self.state = 2790
                self.match(MySQLParser.TEXT_SYMBOL)
                self.state = 2791
                self.textStringNoLinebreak()
                pass
            elif token in [723]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2792
                self.match(MySQLParser.DEFINITION_SYMBOL)
                self.state = 2793
                self.match(MySQLParser.TEXT_SYMBOL)
                self.state = 2794
                self.textStringNoLinebreak()
                pass
            elif token in [725]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2795
                self.match(MySQLParser.ORGANIZATION_SYMBOL)
                self.state = 2796
                self.textStringNoLinebreak()
                self.state = 2797
                self.match(MySQLParser.IDENTIFIED_SYMBOL)
                self.state = 2798
                self.match(MySQLParser.BY_SYMBOL)
                self.state = 2799
                self.real_ulonglong_number()
                pass
            elif token in [724]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2801
                self.match(MySQLParser.DESCRIPTION_SYMBOL)
                self.state = 2802
                self.match(MySQLParser.TEXT_SYMBOL)
                self.state = 2803
                self.textStringNoLinebreak()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DROP_SYMBOL(self):
            return self.getToken(MySQLParser.DROP_SYMBOL, 0)

        def dropDatabase(self):
            return self.getTypedRuleContext(MySQLParser.DropDatabaseContext,0)


        def dropEvent(self):
            return self.getTypedRuleContext(MySQLParser.DropEventContext,0)


        def dropFunction(self):
            return self.getTypedRuleContext(MySQLParser.DropFunctionContext,0)


        def dropProcedure(self):
            return self.getTypedRuleContext(MySQLParser.DropProcedureContext,0)


        def dropIndex(self):
            return self.getTypedRuleContext(MySQLParser.DropIndexContext,0)


        def dropLogfileGroup(self):
            return self.getTypedRuleContext(MySQLParser.DropLogfileGroupContext,0)


        def dropServer(self):
            return self.getTypedRuleContext(MySQLParser.DropServerContext,0)


        def dropTable(self):
            return self.getTypedRuleContext(MySQLParser.DropTableContext,0)


        def dropTableSpace(self):
            return self.getTypedRuleContext(MySQLParser.DropTableSpaceContext,0)


        def dropTrigger(self):
            return self.getTypedRuleContext(MySQLParser.DropTriggerContext,0)


        def dropView(self):
            return self.getTypedRuleContext(MySQLParser.DropViewContext,0)


        def dropRole(self):
            return self.getTypedRuleContext(MySQLParser.DropRoleContext,0)


        def dropSpatialReference(self):
            return self.getTypedRuleContext(MySQLParser.DropSpatialReferenceContext,0)


        def dropUndoTablespace(self):
            return self.getTypedRuleContext(MySQLParser.DropUndoTablespaceContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_dropStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropStatement" ):
                listener.enterDropStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropStatement" ):
                listener.exitDropStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropStatement" ):
                return visitor.visitDropStatement(self)
            else:
                return visitor.visitChildren(self)




    def dropStatement(self):

        localctx = MySQLParser.DropStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_dropStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2806
            self.match(MySQLParser.DROP_SYMBOL)
            self.state = 2823
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,194,self._ctx)
            if la_ == 1:
                self.state = 2807
                self.dropDatabase()
                pass

            elif la_ == 2:
                self.state = 2808
                self.dropEvent()
                pass

            elif la_ == 3:
                self.state = 2809
                self.dropFunction()
                pass

            elif la_ == 4:
                self.state = 2810
                self.dropProcedure()
                pass

            elif la_ == 5:
                self.state = 2811
                self.dropIndex()
                pass

            elif la_ == 6:
                self.state = 2812
                self.dropLogfileGroup()
                pass

            elif la_ == 7:
                self.state = 2813
                self.dropServer()
                pass

            elif la_ == 8:
                self.state = 2814
                self.dropTable()
                pass

            elif la_ == 9:
                self.state = 2815
                self.dropTableSpace()
                pass

            elif la_ == 10:
                self.state = 2816
                self.dropTrigger()
                pass

            elif la_ == 11:
                self.state = 2817
                self.dropView()
                pass

            elif la_ == 12:
                self.state = 2818
                self.dropRole()
                pass

            elif la_ == 13:
                self.state = 2819
                if not self.isServerVersionGe80011():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80011()")
                self.state = 2820
                self.dropSpatialReference()
                pass

            elif la_ == 14:
                self.state = 2821
                if not self.isServerVersionGe80014():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80014()")
                self.state = 2822
                self.dropUndoTablespace()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropDatabaseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATABASE_SYMBOL(self):
            return self.getToken(MySQLParser.DATABASE_SYMBOL, 0)

        def schemaRef(self):
            return self.getTypedRuleContext(MySQLParser.SchemaRefContext,0)


        def ifExists(self):
            return self.getTypedRuleContext(MySQLParser.IfExistsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_dropDatabase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropDatabase" ):
                listener.enterDropDatabase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropDatabase" ):
                listener.exitDropDatabase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropDatabase" ):
                return visitor.visitDropDatabase(self)
            else:
                return visitor.visitChildren(self)




    def dropDatabase(self):

        localctx = MySQLParser.DropDatabaseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_dropDatabase)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2825
            self.match(MySQLParser.DATABASE_SYMBOL)
            self.state = 2827
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,195,self._ctx)
            if la_ == 1:
                self.state = 2826
                self.ifExists()


            self.state = 2829
            self.schemaRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropEventContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EVENT_SYMBOL(self):
            return self.getToken(MySQLParser.EVENT_SYMBOL, 0)

        def eventRef(self):
            return self.getTypedRuleContext(MySQLParser.EventRefContext,0)


        def ifExists(self):
            return self.getTypedRuleContext(MySQLParser.IfExistsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_dropEvent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropEvent" ):
                listener.enterDropEvent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropEvent" ):
                listener.exitDropEvent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropEvent" ):
                return visitor.visitDropEvent(self)
            else:
                return visitor.visitChildren(self)




    def dropEvent(self):

        localctx = MySQLParser.DropEventContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_dropEvent)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2831
            self.match(MySQLParser.EVENT_SYMBOL)
            self.state = 2833
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,196,self._ctx)
            if la_ == 1:
                self.state = 2832
                self.ifExists()


            self.state = 2835
            self.eventRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropFunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNCTION_SYMBOL(self):
            return self.getToken(MySQLParser.FUNCTION_SYMBOL, 0)

        def functionRef(self):
            return self.getTypedRuleContext(MySQLParser.FunctionRefContext,0)


        def ifExists(self):
            return self.getTypedRuleContext(MySQLParser.IfExistsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_dropFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropFunction" ):
                listener.enterDropFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropFunction" ):
                listener.exitDropFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropFunction" ):
                return visitor.visitDropFunction(self)
            else:
                return visitor.visitChildren(self)




    def dropFunction(self):

        localctx = MySQLParser.DropFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_dropFunction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2837
            self.match(MySQLParser.FUNCTION_SYMBOL)
            self.state = 2839
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,197,self._ctx)
            if la_ == 1:
                self.state = 2838
                self.ifExists()


            self.state = 2841
            self.functionRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropProcedureContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROCEDURE_SYMBOL(self):
            return self.getToken(MySQLParser.PROCEDURE_SYMBOL, 0)

        def procedureRef(self):
            return self.getTypedRuleContext(MySQLParser.ProcedureRefContext,0)


        def ifExists(self):
            return self.getTypedRuleContext(MySQLParser.IfExistsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_dropProcedure

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropProcedure" ):
                listener.enterDropProcedure(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropProcedure" ):
                listener.exitDropProcedure(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropProcedure" ):
                return visitor.visitDropProcedure(self)
            else:
                return visitor.visitChildren(self)




    def dropProcedure(self):

        localctx = MySQLParser.DropProcedureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_dropProcedure)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2843
            self.match(MySQLParser.PROCEDURE_SYMBOL)
            self.state = 2845
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,198,self._ctx)
            if la_ == 1:
                self.state = 2844
                self.ifExists()


            self.state = 2847
            self.procedureRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropIndexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # Token

        def indexRef(self):
            return self.getTypedRuleContext(MySQLParser.IndexRefContext,0)


        def ON_SYMBOL(self):
            return self.getToken(MySQLParser.ON_SYMBOL, 0)

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def INDEX_SYMBOL(self):
            return self.getToken(MySQLParser.INDEX_SYMBOL, 0)

        def onlineOption(self):
            return self.getTypedRuleContext(MySQLParser.OnlineOptionContext,0)


        def indexLockAndAlgorithm(self):
            return self.getTypedRuleContext(MySQLParser.IndexLockAndAlgorithmContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_dropIndex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropIndex" ):
                listener.enterDropIndex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropIndex" ):
                listener.exitDropIndex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropIndex" ):
                return visitor.visitDropIndex(self)
            else:
                return visitor.visitChildren(self)




    def dropIndex(self):

        localctx = MySQLParser.DropIndexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_dropIndex)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2850
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==399 or _la==403:
                self.state = 2849
                self.onlineOption()


            self.state = 2852
            localctx.type_ = self.match(MySQLParser.INDEX_SYMBOL)
            self.state = 2853
            self.indexRef()
            self.state = 2854
            self.match(MySQLParser.ON_SYMBOL)
            self.state = 2855
            self.tableRef()
            self.state = 2857
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==56 or _la==314:
                self.state = 2856
                self.indexLockAndAlgorithm()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropLogfileGroupContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOGFILE_SYMBOL(self):
            return self.getToken(MySQLParser.LOGFILE_SYMBOL, 0)

        def GROUP_SYMBOL(self):
            return self.getToken(MySQLParser.GROUP_SYMBOL, 0)

        def logfileGroupRef(self):
            return self.getTypedRuleContext(MySQLParser.LogfileGroupRefContext,0)


        def dropLogfileGroupOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.DropLogfileGroupOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.DropLogfileGroupOptionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_dropLogfileGroup

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropLogfileGroup" ):
                listener.enterDropLogfileGroup(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropLogfileGroup" ):
                listener.exitDropLogfileGroup(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropLogfileGroup" ):
                return visitor.visitDropLogfileGroup(self)
            else:
                return visitor.visitChildren(self)




    def dropLogfileGroup(self):

        localctx = MySQLParser.DropLogfileGroupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_dropLogfileGroup)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2859
            self.match(MySQLParser.LOGFILE_SYMBOL)
            self.state = 2860
            self.match(MySQLParser.GROUP_SYMBOL)
            self.state = 2861
            self.logfileGroupRef()
            self.state = 2872
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==198 or _la==393 or _la==563 or _la==646:
                self.state = 2862
                self.dropLogfileGroupOption()
                self.state = 2869
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==29 or _la==198 or _la==393 or _la==563 or _la==646:
                    self.state = 2864
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==29:
                        self.state = 2863
                        self.match(MySQLParser.COMMA_SYMBOL)


                    self.state = 2866
                    self.dropLogfileGroupOption()
                    self.state = 2871
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropLogfileGroupOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tsOptionWait(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionWaitContext,0)


        def tsOptionEngine(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionEngineContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_dropLogfileGroupOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropLogfileGroupOption" ):
                listener.enterDropLogfileGroupOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropLogfileGroupOption" ):
                listener.exitDropLogfileGroupOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropLogfileGroupOption" ):
                return visitor.visitDropLogfileGroupOption(self)
            else:
                return visitor.visitChildren(self)




    def dropLogfileGroupOption(self):

        localctx = MySQLParser.DropLogfileGroupOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_dropLogfileGroupOption)
        try:
            self.state = 2876
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [393, 646]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2874
                self.tsOptionWait()
                pass
            elif token in [198, 563]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2875
                self.tsOptionEngine()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropServerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SERVER_SYMBOL(self):
            return self.getToken(MySQLParser.SERVER_SYMBOL, 0)

        def serverRef(self):
            return self.getTypedRuleContext(MySQLParser.ServerRefContext,0)


        def ifExists(self):
            return self.getTypedRuleContext(MySQLParser.IfExistsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_dropServer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropServer" ):
                listener.enterDropServer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropServer" ):
                listener.exitDropServer(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropServer" ):
                return visitor.visitDropServer(self)
            else:
                return visitor.visitChildren(self)




    def dropServer(self):

        localctx = MySQLParser.DropServerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_dropServer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2878
            self.match(MySQLParser.SERVER_SYMBOL)
            self.state = 2880
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,205,self._ctx)
            if la_ == 1:
                self.state = 2879
                self.ifExists()


            self.state = 2882
            self.serverRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropTableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # Token

        def tableRefList(self):
            return self.getTypedRuleContext(MySQLParser.TableRefListContext,0)


        def TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_SYMBOL, 0)

        def TABLES_SYMBOL(self):
            return self.getToken(MySQLParser.TABLES_SYMBOL, 0)

        def TEMPORARY_SYMBOL(self):
            return self.getToken(MySQLParser.TEMPORARY_SYMBOL, 0)

        def ifExists(self):
            return self.getTypedRuleContext(MySQLParser.IfExistsContext,0)


        def RESTRICT_SYMBOL(self):
            return self.getToken(MySQLParser.RESTRICT_SYMBOL, 0)

        def CASCADE_SYMBOL(self):
            return self.getToken(MySQLParser.CASCADE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_dropTable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropTable" ):
                listener.enterDropTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropTable" ):
                listener.exitDropTable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropTable" ):
                return visitor.visitDropTable(self)
            else:
                return visitor.visitChildren(self)




    def dropTable(self):

        localctx = MySQLParser.DropTableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_dropTable)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2885
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==586:
                self.state = 2884
                self.match(MySQLParser.TEMPORARY_SYMBOL)


            self.state = 2887
            localctx.type_ = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==581 or _la==583):
                localctx.type_ = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2889
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,207,self._ctx)
            if la_ == 1:
                self.state = 2888
                self.ifExists()


            self.state = 2891
            self.tableRefList()
            self.state = 2893
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==93 or _la==488:
                self.state = 2892
                _la = self._input.LA(1)
                if not(_la==93 or _la==488):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropTableSpaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TABLESPACE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLESPACE_SYMBOL, 0)

        def tablespaceRef(self):
            return self.getTypedRuleContext(MySQLParser.TablespaceRefContext,0)


        def dropLogfileGroupOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.DropLogfileGroupOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.DropLogfileGroupOptionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_dropTableSpace

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropTableSpace" ):
                listener.enterDropTableSpace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropTableSpace" ):
                listener.exitDropTableSpace(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropTableSpace" ):
                return visitor.visitDropTableSpace(self)
            else:
                return visitor.visitChildren(self)




    def dropTableSpace(self):

        localctx = MySQLParser.DropTableSpaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_dropTableSpace)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2895
            self.match(MySQLParser.TABLESPACE_SYMBOL)
            self.state = 2896
            self.tablespaceRef()
            self.state = 2907
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==198 or _la==393 or _la==563 or _la==646:
                self.state = 2897
                self.dropLogfileGroupOption()
                self.state = 2904
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==29 or _la==198 or _la==393 or _la==563 or _la==646:
                    self.state = 2899
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==29:
                        self.state = 2898
                        self.match(MySQLParser.COMMA_SYMBOL)


                    self.state = 2901
                    self.dropLogfileGroupOption()
                    self.state = 2906
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropTriggerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRIGGER_SYMBOL(self):
            return self.getToken(MySQLParser.TRIGGER_SYMBOL, 0)

        def triggerRef(self):
            return self.getTypedRuleContext(MySQLParser.TriggerRefContext,0)


        def ifExists(self):
            return self.getTypedRuleContext(MySQLParser.IfExistsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_dropTrigger

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropTrigger" ):
                listener.enterDropTrigger(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropTrigger" ):
                listener.exitDropTrigger(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropTrigger" ):
                return visitor.visitDropTrigger(self)
            else:
                return visitor.visitChildren(self)




    def dropTrigger(self):

        localctx = MySQLParser.DropTriggerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_dropTrigger)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2909
            self.match(MySQLParser.TRIGGER_SYMBOL)
            self.state = 2911
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,212,self._ctx)
            if la_ == 1:
                self.state = 2910
                self.ifExists()


            self.state = 2913
            self.triggerRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropViewContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VIEW_SYMBOL(self):
            return self.getToken(MySQLParser.VIEW_SYMBOL, 0)

        def viewRefList(self):
            return self.getTypedRuleContext(MySQLParser.ViewRefListContext,0)


        def ifExists(self):
            return self.getTypedRuleContext(MySQLParser.IfExistsContext,0)


        def RESTRICT_SYMBOL(self):
            return self.getToken(MySQLParser.RESTRICT_SYMBOL, 0)

        def CASCADE_SYMBOL(self):
            return self.getToken(MySQLParser.CASCADE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_dropView

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropView" ):
                listener.enterDropView(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropView" ):
                listener.exitDropView(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropView" ):
                return visitor.visitDropView(self)
            else:
                return visitor.visitChildren(self)




    def dropView(self):

        localctx = MySQLParser.DropViewContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_dropView)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2915
            self.match(MySQLParser.VIEW_SYMBOL)
            self.state = 2917
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,213,self._ctx)
            if la_ == 1:
                self.state = 2916
                self.ifExists()


            self.state = 2919
            self.viewRefList()
            self.state = 2921
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==93 or _la==488:
                self.state = 2920
                _la = self._input.LA(1)
                if not(_la==93 or _la==488):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropRoleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROLE_SYMBOL(self):
            return self.getToken(MySQLParser.ROLE_SYMBOL, 0)

        def roleList(self):
            return self.getTypedRuleContext(MySQLParser.RoleListContext,0)


        def ifExists(self):
            return self.getTypedRuleContext(MySQLParser.IfExistsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_dropRole

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropRole" ):
                listener.enterDropRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropRole" ):
                listener.exitDropRole(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropRole" ):
                return visitor.visitDropRole(self)
            else:
                return visitor.visitChildren(self)




    def dropRole(self):

        localctx = MySQLParser.DropRoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_dropRole)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2923
            self.match(MySQLParser.ROLE_SYMBOL)
            self.state = 2925
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,215,self._ctx)
            if la_ == 1:
                self.state = 2924
                self.ifExists()


            self.state = 2927
            self.roleList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropSpatialReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SPATIAL_SYMBOL(self):
            return self.getToken(MySQLParser.SPATIAL_SYMBOL, 0)

        def REFERENCE_SYMBOL(self):
            return self.getToken(MySQLParser.REFERENCE_SYMBOL, 0)

        def SYSTEM_SYMBOL(self):
            return self.getToken(MySQLParser.SYSTEM_SYMBOL, 0)

        def real_ulonglong_number(self):
            return self.getTypedRuleContext(MySQLParser.Real_ulonglong_numberContext,0)


        def ifExists(self):
            return self.getTypedRuleContext(MySQLParser.IfExistsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_dropSpatialReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropSpatialReference" ):
                listener.enterDropSpatialReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropSpatialReference" ):
                listener.exitDropSpatialReference(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropSpatialReference" ):
                return visitor.visitDropSpatialReference(self)
            else:
                return visitor.visitChildren(self)




    def dropSpatialReference(self):

        localctx = MySQLParser.DropSpatialReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_dropSpatialReference)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2929
            self.match(MySQLParser.SPATIAL_SYMBOL)
            self.state = 2930
            self.match(MySQLParser.REFERENCE_SYMBOL)
            self.state = 2931
            self.match(MySQLParser.SYSTEM_SYMBOL)
            self.state = 2933
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,216,self._ctx)
            if la_ == 1:
                self.state = 2932
                self.ifExists()


            self.state = 2935
            self.real_ulonglong_number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropUndoTablespaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNDO_SYMBOL(self):
            return self.getToken(MySQLParser.UNDO_SYMBOL, 0)

        def TABLESPACE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLESPACE_SYMBOL, 0)

        def tablespaceRef(self):
            return self.getTypedRuleContext(MySQLParser.TablespaceRefContext,0)


        def undoTableSpaceOptions(self):
            return self.getTypedRuleContext(MySQLParser.UndoTableSpaceOptionsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_dropUndoTablespace

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropUndoTablespace" ):
                listener.enterDropUndoTablespace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropUndoTablespace" ):
                listener.exitDropUndoTablespace(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropUndoTablespace" ):
                return visitor.visitDropUndoTablespace(self)
            else:
                return visitor.visitChildren(self)




    def dropUndoTablespace(self):

        localctx = MySQLParser.DropUndoTablespaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_dropUndoTablespace)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2937
            self.match(MySQLParser.UNDO_SYMBOL)
            self.state = 2938
            self.match(MySQLParser.TABLESPACE_SYMBOL)
            self.state = 2939
            self.tablespaceRef()
            self.state = 2941
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==198 or _la==563:
                self.state = 2940
                self.undoTableSpaceOptions()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RenameTableStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RENAME_SYMBOL(self):
            return self.getToken(MySQLParser.RENAME_SYMBOL, 0)

        def renamePair(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.RenamePairContext)
            else:
                return self.getTypedRuleContext(MySQLParser.RenamePairContext,i)


        def TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_SYMBOL, 0)

        def TABLES_SYMBOL(self):
            return self.getToken(MySQLParser.TABLES_SYMBOL, 0)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_renameTableStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRenameTableStatement" ):
                listener.enterRenameTableStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRenameTableStatement" ):
                listener.exitRenameTableStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRenameTableStatement" ):
                return visitor.visitRenameTableStatement(self)
            else:
                return visitor.visitChildren(self)




    def renameTableStatement(self):

        localctx = MySQLParser.RenameTableStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_renameTableStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2943
            self.match(MySQLParser.RENAME_SYMBOL)
            self.state = 2944
            _la = self._input.LA(1)
            if not(_la==581 or _la==583):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2945
            self.renamePair()
            self.state = 2950
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 2946
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 2947
                self.renamePair()
                self.state = 2952
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RenamePairContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def TO_SYMBOL(self):
            return self.getToken(MySQLParser.TO_SYMBOL, 0)

        def tableName(self):
            return self.getTypedRuleContext(MySQLParser.TableNameContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_renamePair

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRenamePair" ):
                listener.enterRenamePair(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRenamePair" ):
                listener.exitRenamePair(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRenamePair" ):
                return visitor.visitRenamePair(self)
            else:
                return visitor.visitChildren(self)




    def renamePair(self):

        localctx = MySQLParser.RenamePairContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_renamePair)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2953
            self.tableRef()
            self.state = 2954
            self.match(MySQLParser.TO_SYMBOL)
            self.state = 2955
            self.tableName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TruncateTableStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUNCATE_SYMBOL(self):
            return self.getToken(MySQLParser.TRUNCATE_SYMBOL, 0)

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_truncateTableStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTruncateTableStatement" ):
                listener.enterTruncateTableStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTruncateTableStatement" ):
                listener.exitTruncateTableStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTruncateTableStatement" ):
                return visitor.visitTruncateTableStatement(self)
            else:
                return visitor.visitChildren(self)




    def truncateTableStatement(self):

        localctx = MySQLParser.TruncateTableStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_truncateTableStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2957
            self.match(MySQLParser.TRUNCATE_SYMBOL)
            self.state = 2959
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,219,self._ctx)
            if la_ == 1:
                self.state = 2958
                self.match(MySQLParser.TABLE_SYMBOL)


            self.state = 2961
            self.tableRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPORT_SYMBOL(self):
            return self.getToken(MySQLParser.IMPORT_SYMBOL, 0)

        def TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_SYMBOL, 0)

        def FROM_SYMBOL(self):
            return self.getToken(MySQLParser.FROM_SYMBOL, 0)

        def textStringLiteralList(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_importStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportStatement" ):
                listener.enterImportStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportStatement" ):
                listener.exitImportStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImportStatement" ):
                return visitor.visitImportStatement(self)
            else:
                return visitor.visitChildren(self)




    def importStatement(self):

        localctx = MySQLParser.ImportStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_importStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2963
            self.match(MySQLParser.IMPORT_SYMBOL)
            self.state = 2964
            self.match(MySQLParser.TABLE_SYMBOL)
            self.state = 2965
            self.match(MySQLParser.FROM_SYMBOL)
            self.state = 2966
            self.textStringLiteralList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CallStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CALL_SYMBOL(self):
            return self.getToken(MySQLParser.CALL_SYMBOL, 0)

        def procedureRef(self):
            return self.getTypedRuleContext(MySQLParser.ProcedureRefContext,0)


        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def exprList(self):
            return self.getTypedRuleContext(MySQLParser.ExprListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_callStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCallStatement" ):
                listener.enterCallStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCallStatement" ):
                listener.exitCallStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCallStatement" ):
                return visitor.visitCallStatement(self)
            else:
                return visitor.visitChildren(self)




    def callStatement(self):

        localctx = MySQLParser.CallStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_callStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2968
            self.match(MySQLParser.CALL_SYMBOL)
            self.state = 2969
            self.procedureRef()
            self.state = 2975
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==32:
                self.state = 2970
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 2972
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,220,self._ctx)
                if la_ == 1:
                    self.state = 2971
                    self.exprList()


                self.state = 2974
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeleteStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DELETE_SYMBOL(self):
            return self.getToken(MySQLParser.DELETE_SYMBOL, 0)

        def FROM_SYMBOL(self):
            return self.getToken(MySQLParser.FROM_SYMBOL, 0)

        def tableAliasRefList(self):
            return self.getTypedRuleContext(MySQLParser.TableAliasRefListContext,0)


        def tableReferenceList(self):
            return self.getTypedRuleContext(MySQLParser.TableReferenceListContext,0)


        def withClause(self):
            return self.getTypedRuleContext(MySQLParser.WithClauseContext,0)


        def deleteStatementOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.DeleteStatementOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.DeleteStatementOptionContext,i)


        def USING_SYMBOL(self):
            return self.getToken(MySQLParser.USING_SYMBOL, 0)

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def whereClause(self):
            return self.getTypedRuleContext(MySQLParser.WhereClauseContext,0)


        def tableAlias(self):
            return self.getTypedRuleContext(MySQLParser.TableAliasContext,0)


        def partitionDelete(self):
            return self.getTypedRuleContext(MySQLParser.PartitionDeleteContext,0)


        def orderClause(self):
            return self.getTypedRuleContext(MySQLParser.OrderClauseContext,0)


        def simpleLimitClause(self):
            return self.getTypedRuleContext(MySQLParser.SimpleLimitClauseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_deleteStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeleteStatement" ):
                listener.enterDeleteStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeleteStatement" ):
                listener.exitDeleteStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeleteStatement" ):
                return visitor.visitDeleteStatement(self)
            else:
                return visitor.visitChildren(self)




    def deleteStatement(self):

        localctx = MySQLParser.DeleteStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_deleteStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2978
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==653:
                self.state = 2977
                self.withClause()


            self.state = 2980
            self.match(MySQLParser.DELETE_SYMBOL)
            self.state = 2984
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,223,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2981
                    self.deleteStatementOption() 
                self.state = 2986
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,223,self._ctx)

            self.state = 3019
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,232,self._ctx)
            if la_ == 1:
                self.state = 2987
                self.match(MySQLParser.FROM_SYMBOL)
                self.state = 3011
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,230,self._ctx)
                if la_ == 1:
                    self.state = 2988
                    self.tableAliasRefList()
                    self.state = 2989
                    self.match(MySQLParser.USING_SYMBOL)
                    self.state = 2990
                    self.tableReferenceList()
                    self.state = 2992
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==651:
                        self.state = 2991
                        self.whereClause()


                    pass

                elif la_ == 2:
                    self.state = 2994
                    self.tableRef()
                    self.state = 2997
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,225,self._ctx)
                    if la_ == 1:
                        self.state = 2995
                        if not self.isServerVersionGe80017():
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.isServerVersionGe80017()")
                        self.state = 2996
                        self.tableAlias()


                    self.state = 3000
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==423:
                        self.state = 2999
                        self.partitionDelete()


                    self.state = 3003
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==651:
                        self.state = 3002
                        self.whereClause()


                    self.state = 3006
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==411:
                        self.state = 3005
                        self.orderClause()


                    self.state = 3009
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==306:
                        self.state = 3008
                        self.simpleLimitClause()


                    pass


                pass

            elif la_ == 2:
                self.state = 3013
                self.tableAliasRefList()
                self.state = 3014
                self.match(MySQLParser.FROM_SYMBOL)
                self.state = 3015
                self.tableReferenceList()
                self.state = 3017
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==651:
                    self.state = 3016
                    self.whereClause()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartitionDeleteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARTITION_SYMBOL(self):
            return self.getToken(MySQLParser.PARTITION_SYMBOL, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def identifierList(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierListContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_partitionDelete

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartitionDelete" ):
                listener.enterPartitionDelete(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartitionDelete" ):
                listener.exitPartitionDelete(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPartitionDelete" ):
                return visitor.visitPartitionDelete(self)
            else:
                return visitor.visitChildren(self)




    def partitionDelete(self):

        localctx = MySQLParser.PartitionDeleteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_partitionDelete)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3021
            self.match(MySQLParser.PARTITION_SYMBOL)
            self.state = 3022
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 3023
            self.identifierList()
            self.state = 3024
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeleteStatementOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUICK_SYMBOL(self):
            return self.getToken(MySQLParser.QUICK_SYMBOL, 0)

        def LOW_PRIORITY_SYMBOL(self):
            return self.getToken(MySQLParser.LOW_PRIORITY_SYMBOL, 0)

        def IGNORE_SYMBOL(self):
            return self.getToken(MySQLParser.IGNORE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_deleteStatementOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeleteStatementOption" ):
                listener.enterDeleteStatementOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeleteStatementOption" ):
                listener.exitDeleteStatementOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeleteStatementOption" ):
                return visitor.visitDeleteStatementOption(self)
            else:
                return visitor.visitChildren(self)




    def deleteStatementOption(self):

        localctx = MySQLParser.DeleteStatementOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_deleteStatementOption)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3026
            _la = self._input.LA(1)
            if not(_la==264 or _la==321 or _la==449):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DoStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DO_SYMBOL(self):
            return self.getToken(MySQLParser.DO_SYMBOL, 0)

        def selectItemList(self):
            return self.getTypedRuleContext(MySQLParser.SelectItemListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_doStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDoStatement" ):
                listener.enterDoStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDoStatement" ):
                listener.exitDoStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDoStatement" ):
                return visitor.visitDoStatement(self)
            else:
                return visitor.visitChildren(self)




    def doStatement(self):

        localctx = MySQLParser.DoStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_doStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3028
            self.match(MySQLParser.DO_SYMBOL)
            self.state = 3029
            self.selectItemList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HandlerStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HANDLER_SYMBOL(self):
            return self.getToken(MySQLParser.HANDLER_SYMBOL, 0)

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def OPEN_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def CLOSE_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_SYMBOL, 0)

        def READ_SYMBOL(self):
            return self.getToken(MySQLParser.READ_SYMBOL, 0)

        def handlerReadOrScan(self):
            return self.getTypedRuleContext(MySQLParser.HandlerReadOrScanContext,0)


        def tableAlias(self):
            return self.getTypedRuleContext(MySQLParser.TableAliasContext,0)


        def whereClause(self):
            return self.getTypedRuleContext(MySQLParser.WhereClauseContext,0)


        def limitClause(self):
            return self.getTypedRuleContext(MySQLParser.LimitClauseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_handlerStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHandlerStatement" ):
                listener.enterHandlerStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHandlerStatement" ):
                listener.exitHandlerStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHandlerStatement" ):
                return visitor.visitHandlerStatement(self)
            else:
                return visitor.visitChildren(self)




    def handlerStatement(self):

        localctx = MySQLParser.HandlerStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_handlerStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3031
            self.match(MySQLParser.HANDLER_SYMBOL)
            self.state = 3049
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,237,self._ctx)
            if la_ == 1:
                self.state = 3032
                self.tableRef()
                self.state = 3033
                self.match(MySQLParser.OPEN_SYMBOL)
                self.state = 3035
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,233,self._ctx)
                if la_ == 1:
                    self.state = 3034
                    self.tableAlias()


                pass

            elif la_ == 2:
                self.state = 3037
                self.identifier()
                self.state = 3047
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [109]:
                    self.state = 3038
                    self.match(MySQLParser.CLOSE_SYMBOL)
                    pass
                elif token in [453]:
                    self.state = 3039
                    self.match(MySQLParser.READ_SYMBOL)
                    self.state = 3040
                    self.handlerReadOrScan()
                    self.state = 3042
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==651:
                        self.state = 3041
                        self.whereClause()


                    self.state = 3045
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==306:
                        self.state = 3044
                        self.limitClause()


                    pass
                else:
                    raise NoViableAltException(self)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HandlerReadOrScanContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FIRST_SYMBOL(self):
            return self.getToken(MySQLParser.FIRST_SYMBOL, 0)

        def NEXT_SYMBOL(self):
            return self.getToken(MySQLParser.NEXT_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def values(self):
            return self.getTypedRuleContext(MySQLParser.ValuesContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def PREV_SYMBOL(self):
            return self.getToken(MySQLParser.PREV_SYMBOL, 0)

        def LAST_SYMBOL(self):
            return self.getToken(MySQLParser.LAST_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def LESS_THAN_OPERATOR(self):
            return self.getToken(MySQLParser.LESS_THAN_OPERATOR, 0)

        def GREATER_THAN_OPERATOR(self):
            return self.getToken(MySQLParser.GREATER_THAN_OPERATOR, 0)

        def LESS_OR_EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.LESS_OR_EQUAL_OPERATOR, 0)

        def GREATER_OR_EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.GREATER_OR_EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_handlerReadOrScan

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHandlerReadOrScan" ):
                listener.enterHandlerReadOrScan(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHandlerReadOrScan" ):
                listener.exitHandlerReadOrScan(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHandlerReadOrScan" ):
                return visitor.visitHandlerReadOrScan(self)
            else:
                return visitor.visitChildren(self)




    def handlerReadOrScan(self):

        localctx = MySQLParser.HandlerReadOrScanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_handlerReadOrScan)
        self._la = 0 # Token type
        try:
            self.state = 3061
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,239,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3051
                _la = self._input.LA(1)
                if not(_la==225 or _la==387):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3052
                self.identifier()
                self.state = 3059
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [225, 298, 387, 437]:
                    self.state = 3053
                    _la = self._input.LA(1)
                    if not(_la==225 or _la==298 or _la==387 or _la==437):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    pass
                elif token in [6, 9, 10, 11, 12]:
                    self.state = 3054
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 7744) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 3055
                    self.match(MySQLParser.OPEN_PAR_SYMBOL)
                    self.state = 3056
                    self.values()
                    self.state = 3057
                    self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                    pass
                else:
                    raise NoViableAltException(self)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InsertStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INSERT_SYMBOL(self):
            return self.getToken(MySQLParser.INSERT_SYMBOL, 0)

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def insertFromConstructor(self):
            return self.getTypedRuleContext(MySQLParser.InsertFromConstructorContext,0)


        def SET_SYMBOL(self):
            return self.getToken(MySQLParser.SET_SYMBOL, 0)

        def updateList(self):
            return self.getTypedRuleContext(MySQLParser.UpdateListContext,0)


        def insertQueryExpression(self):
            return self.getTypedRuleContext(MySQLParser.InsertQueryExpressionContext,0)


        def insertLockOption(self):
            return self.getTypedRuleContext(MySQLParser.InsertLockOptionContext,0)


        def IGNORE_SYMBOL(self):
            return self.getToken(MySQLParser.IGNORE_SYMBOL, 0)

        def INTO_SYMBOL(self):
            return self.getToken(MySQLParser.INTO_SYMBOL, 0)

        def usePartition(self):
            return self.getTypedRuleContext(MySQLParser.UsePartitionContext,0)


        def insertUpdateList(self):
            return self.getTypedRuleContext(MySQLParser.InsertUpdateListContext,0)


        def valuesReference(self):
            return self.getTypedRuleContext(MySQLParser.ValuesReferenceContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_insertStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsertStatement" ):
                listener.enterInsertStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsertStatement" ):
                listener.exitInsertStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInsertStatement" ):
                return visitor.visitInsertStatement(self)
            else:
                return visitor.visitChildren(self)




    def insertStatement(self):

        localctx = MySQLParser.InsertStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_insertStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3063
            self.match(MySQLParser.INSERT_SYMBOL)
            self.state = 3065
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,240,self._ctx)
            if la_ == 1:
                self.state = 3064
                self.insertLockOption()


            self.state = 3068
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,241,self._ctx)
            if la_ == 1:
                self.state = 3067
                self.match(MySQLParser.IGNORE_SYMBOL)


            self.state = 3071
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,242,self._ctx)
            if la_ == 1:
                self.state = 3070
                self.match(MySQLParser.INTO_SYMBOL)


            self.state = 3073
            self.tableRef()
            self.state = 3075
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,243,self._ctx)
            if la_ == 1:
                self.state = 3074
                self.usePartition()


            self.state = 3087
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,246,self._ctx)
            if la_ == 1:
                self.state = 3077
                self.insertFromConstructor()
                self.state = 3079
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,244,self._ctx)
                if la_ == 1:
                    self.state = 3078
                    self.valuesReference()


                pass

            elif la_ == 2:
                self.state = 3081
                self.match(MySQLParser.SET_SYMBOL)
                self.state = 3082
                self.updateList()
                self.state = 3084
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,245,self._ctx)
                if la_ == 1:
                    self.state = 3083
                    self.valuesReference()


                pass

            elif la_ == 3:
                self.state = 3086
                self.insertQueryExpression()
                pass


            self.state = 3090
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==401:
                self.state = 3089
                self.insertUpdateList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InsertLockOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOW_PRIORITY_SYMBOL(self):
            return self.getToken(MySQLParser.LOW_PRIORITY_SYMBOL, 0)

        def DELAYED_SYMBOL(self):
            return self.getToken(MySQLParser.DELAYED_SYMBOL, 0)

        def HIGH_PRIORITY_SYMBOL(self):
            return self.getToken(MySQLParser.HIGH_PRIORITY_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_insertLockOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsertLockOption" ):
                listener.enterInsertLockOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsertLockOption" ):
                listener.exitInsertLockOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInsertLockOption" ):
                return visitor.visitInsertLockOption(self)
            else:
                return visitor.visitChildren(self)




    def insertLockOption(self):

        localctx = MySQLParser.InsertLockOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_insertLockOption)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3092
            _la = self._input.LA(1)
            if not(_la==169 or _la==255 or _la==321):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InsertFromConstructorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def insertValues(self):
            return self.getTypedRuleContext(MySQLParser.InsertValuesContext,0)


        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def fields(self):
            return self.getTypedRuleContext(MySQLParser.FieldsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_insertFromConstructor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsertFromConstructor" ):
                listener.enterInsertFromConstructor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsertFromConstructor" ):
                listener.exitInsertFromConstructor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInsertFromConstructor" ):
                return visitor.visitInsertFromConstructor(self)
            else:
                return visitor.visitChildren(self)




    def insertFromConstructor(self):

        localctx = MySQLParser.InsertFromConstructorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_insertFromConstructor)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3099
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==32:
                self.state = 3094
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 3096
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,248,self._ctx)
                if la_ == 1:
                    self.state = 3095
                    self.fields()


                self.state = 3098
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)


            self.state = 3101
            self.insertValues()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FieldsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def insertIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.InsertIdentifierContext)
            else:
                return self.getTypedRuleContext(MySQLParser.InsertIdentifierContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_fields

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFields" ):
                listener.enterFields(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFields" ):
                listener.exitFields(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFields" ):
                return visitor.visitFields(self)
            else:
                return visitor.visitChildren(self)




    def fields(self):

        localctx = MySQLParser.FieldsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_fields)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3103
            self.insertIdentifier()
            self.state = 3108
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 3104
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 3105
                self.insertIdentifier()
                self.state = 3110
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InsertValuesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valueList(self):
            return self.getTypedRuleContext(MySQLParser.ValueListContext,0)


        def VALUES_SYMBOL(self):
            return self.getToken(MySQLParser.VALUES_SYMBOL, 0)

        def VALUE_SYMBOL(self):
            return self.getToken(MySQLParser.VALUE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_insertValues

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsertValues" ):
                listener.enterInsertValues(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsertValues" ):
                listener.exitInsertValues(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInsertValues" ):
                return visitor.visitInsertValues(self)
            else:
                return visitor.visitChildren(self)




    def insertValues(self):

        localctx = MySQLParser.InsertValuesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_insertValues)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3111
            _la = self._input.LA(1)
            if not(_la==635 or _la==636):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 3112
            self.valueList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InsertQueryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def queryExpression(self):
            return self.getTypedRuleContext(MySQLParser.QueryExpressionContext,0)


        def queryExpressionParens(self):
            return self.getTypedRuleContext(MySQLParser.QueryExpressionParensContext,0)


        def queryExpressionWithOptLockingClauses(self):
            return self.getTypedRuleContext(MySQLParser.QueryExpressionWithOptLockingClausesContext,0)


        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def fields(self):
            return self.getTypedRuleContext(MySQLParser.FieldsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_insertQueryExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsertQueryExpression" ):
                listener.enterInsertQueryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsertQueryExpression" ):
                listener.exitInsertQueryExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInsertQueryExpression" ):
                return visitor.visitInsertQueryExpression(self)
            else:
                return visitor.visitChildren(self)




    def insertQueryExpression(self):

        localctx = MySQLParser.InsertQueryExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_insertQueryExpression)
        try:
            self.state = 3124
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,253,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3114
                self.queryExpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3115
                self.queryExpressionParens()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3121
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,252,self._ctx)
                if la_ == 1:
                    self.state = 3116
                    self.match(MySQLParser.OPEN_PAR_SYMBOL)
                    self.state = 3118
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,251,self._ctx)
                    if la_ == 1:
                        self.state = 3117
                        self.fields()


                    self.state = 3120
                    self.match(MySQLParser.CLOSE_PAR_SYMBOL)


                self.state = 3123
                self.queryExpressionWithOptLockingClauses()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.OPEN_PAR_SYMBOL)
            else:
                return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, i)

        def CLOSE_PAR_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.CLOSE_PAR_SYMBOL)
            else:
                return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, i)

        def values(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ValuesContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ValuesContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_valueList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValueList" ):
                listener.enterValueList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValueList" ):
                listener.exitValueList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValueList" ):
                return visitor.visitValueList(self)
            else:
                return visitor.visitChildren(self)




    def valueList(self):

        localctx = MySQLParser.ValueListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_valueList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3126
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 3128
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,254,self._ctx)
            if la_ == 1:
                self.state = 3127
                self.values()


            self.state = 3130
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
            self.state = 3139
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,256,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 3131
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 3132
                    self.match(MySQLParser.OPEN_PAR_SYMBOL)
                    self.state = 3134
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,255,self._ctx)
                    if la_ == 1:
                        self.state = 3133
                        self.values()


                    self.state = 3136
                    self.match(MySQLParser.CLOSE_PAR_SYMBOL) 
                self.state = 3141
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,256,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValuesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ExprContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ExprContext,i)


        def DEFAULT_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.DEFAULT_SYMBOL)
            else:
                return self.getToken(MySQLParser.DEFAULT_SYMBOL, i)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_values

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValues" ):
                listener.enterValues(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValues" ):
                listener.exitValues(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValues" ):
                return visitor.visitValues(self)
            else:
                return visitor.visitChildren(self)




    def values(self):

        localctx = MySQLParser.ValuesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_values)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3144
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,257,self._ctx)
            if la_ == 1:
                self.state = 3142
                self.expr(0)
                pass

            elif la_ == 2:
                self.state = 3143
                self.match(MySQLParser.DEFAULT_SYMBOL)
                pass


            self.state = 3153
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 3146
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 3149
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,258,self._ctx)
                if la_ == 1:
                    self.state = 3147
                    self.expr(0)
                    pass

                elif la_ == 2:
                    self.state = 3148
                    self.match(MySQLParser.DEFAULT_SYMBOL)
                    pass


                self.state = 3155
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValuesReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AS_SYMBOL(self):
            return self.getToken(MySQLParser.AS_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def columnInternalRefList(self):
            return self.getTypedRuleContext(MySQLParser.ColumnInternalRefListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_valuesReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValuesReference" ):
                listener.enterValuesReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValuesReference" ):
                listener.exitValuesReference(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValuesReference" ):
                return visitor.visitValuesReference(self)
            else:
                return visitor.visitChildren(self)




    def valuesReference(self):

        localctx = MySQLParser.ValuesReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_valuesReference)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3156
            if not self.isServerVersionGe80018():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.isServerVersionGe80018()")
            self.state = 3157
            self.match(MySQLParser.AS_SYMBOL)
            self.state = 3158
            self.identifier()
            self.state = 3160
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==32:
                self.state = 3159
                self.columnInternalRefList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InsertUpdateListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ON_SYMBOL(self):
            return self.getToken(MySQLParser.ON_SYMBOL, 0)

        def DUPLICATE_SYMBOL(self):
            return self.getToken(MySQLParser.DUPLICATE_SYMBOL, 0)

        def KEY_SYMBOL(self):
            return self.getToken(MySQLParser.KEY_SYMBOL, 0)

        def UPDATE_SYMBOL(self):
            return self.getToken(MySQLParser.UPDATE_SYMBOL, 0)

        def updateList(self):
            return self.getTypedRuleContext(MySQLParser.UpdateListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_insertUpdateList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsertUpdateList" ):
                listener.enterInsertUpdateList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsertUpdateList" ):
                listener.exitInsertUpdateList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInsertUpdateList" ):
                return visitor.visitInsertUpdateList(self)
            else:
                return visitor.visitChildren(self)




    def insertUpdateList(self):

        localctx = MySQLParser.InsertUpdateListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 266, self.RULE_insertUpdateList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3162
            self.match(MySQLParser.ON_SYMBOL)
            self.state = 3163
            self.match(MySQLParser.DUPLICATE_SYMBOL)
            self.state = 3164
            self.match(MySQLParser.KEY_SYMBOL)
            self.state = 3165
            self.match(MySQLParser.UPDATE_SYMBOL)
            self.state = 3166
            self.updateList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoadStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOAD_SYMBOL(self):
            return self.getToken(MySQLParser.LOAD_SYMBOL, 0)

        def dataOrXml(self):
            return self.getTypedRuleContext(MySQLParser.DataOrXmlContext,0)


        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def INTO_SYMBOL(self):
            return self.getToken(MySQLParser.INTO_SYMBOL, 0)

        def TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_SYMBOL, 0)

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def loadDataFileTail(self):
            return self.getTypedRuleContext(MySQLParser.LoadDataFileTailContext,0)


        def loadDataLock(self):
            return self.getTypedRuleContext(MySQLParser.LoadDataLockContext,0)


        def loadFrom(self):
            return self.getTypedRuleContext(MySQLParser.LoadFromContext,0)


        def LOCAL_SYMBOL(self):
            return self.getToken(MySQLParser.LOCAL_SYMBOL, 0)

        def loadSourceType(self):
            return self.getTypedRuleContext(MySQLParser.LoadSourceTypeContext,0)


        def sourceCount(self):
            return self.getTypedRuleContext(MySQLParser.SourceCountContext,0)


        def sourceOrder(self):
            return self.getTypedRuleContext(MySQLParser.SourceOrderContext,0)


        def usePartition(self):
            return self.getTypedRuleContext(MySQLParser.UsePartitionContext,0)


        def charsetClause(self):
            return self.getTypedRuleContext(MySQLParser.CharsetClauseContext,0)


        def xmlRowsIdentifiedBy(self):
            return self.getTypedRuleContext(MySQLParser.XmlRowsIdentifiedByContext,0)


        def fieldsClause(self):
            return self.getTypedRuleContext(MySQLParser.FieldsClauseContext,0)


        def linesClause(self):
            return self.getTypedRuleContext(MySQLParser.LinesClauseContext,0)


        def loadParallel(self):
            return self.getTypedRuleContext(MySQLParser.LoadParallelContext,0)


        def loadMemory(self):
            return self.getTypedRuleContext(MySQLParser.LoadMemoryContext,0)


        def loadAlgorithm(self):
            return self.getTypedRuleContext(MySQLParser.LoadAlgorithmContext,0)


        def REPLACE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLACE_SYMBOL, 0)

        def IGNORE_SYMBOL(self):
            return self.getToken(MySQLParser.IGNORE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_loadStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoadStatement" ):
                listener.enterLoadStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoadStatement" ):
                listener.exitLoadStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoadStatement" ):
                return visitor.visitLoadStatement(self)
            else:
                return visitor.visitChildren(self)




    def loadStatement(self):

        localctx = MySQLParser.LoadStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_loadStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3168
            self.match(MySQLParser.LOAD_SYMBOL)
            self.state = 3169
            self.dataOrXml()
            self.state = 3171
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,261,self._ctx)
            if la_ == 1:
                self.state = 3170
                self.loadDataLock()


            self.state = 3174
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,262,self._ctx)
            if la_ == 1:
                self.state = 3173
                self.loadFrom()


            self.state = 3177
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,263,self._ctx)
            if la_ == 1:
                self.state = 3176
                self.match(MySQLParser.LOCAL_SYMBOL)


            self.state = 3180
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,264,self._ctx)
            if la_ == 1:
                self.state = 3179
                self.loadSourceType()


            self.state = 3182
            self.textStringLiteral()
            self.state = 3184
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,265,self._ctx)
            if la_ == 1:
                self.state = 3183
                self.sourceCount()


            self.state = 3187
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,266,self._ctx)
            if la_ == 1:
                self.state = 3186
                self.sourceOrder()


            self.state = 3190
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==264 or _la==475:
                self.state = 3189
                _la = self._input.LA(1)
                if not(_la==264 or _la==475):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 3192
            self.match(MySQLParser.INTO_SYMBOL)
            self.state = 3193
            self.match(MySQLParser.TABLE_SYMBOL)
            self.state = 3194
            self.tableRef()
            self.state = 3196
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,268,self._ctx)
            if la_ == 1:
                self.state = 3195
                self.usePartition()


            self.state = 3199
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,269,self._ctx)
            if la_ == 1:
                self.state = 3198
                self.charsetClause()


            self.state = 3202
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,270,self._ctx)
            if la_ == 1:
                self.state = 3201
                self.xmlRowsIdentifiedBy()


            self.state = 3205
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,271,self._ctx)
            if la_ == 1:
                self.state = 3204
                self.fieldsClause()


            self.state = 3208
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,272,self._ctx)
            if la_ == 1:
                self.state = 3207
                self.linesClause()


            self.state = 3210
            self.loadDataFileTail()
            self.state = 3212
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,273,self._ctx)
            if la_ == 1:
                self.state = 3211
                self.loadParallel()


            self.state = 3215
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,274,self._ctx)
            if la_ == 1:
                self.state = 3214
                self.loadMemory()


            self.state = 3218
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,275,self._ctx)
            if la_ == 1:
                self.state = 3217
                self.loadAlgorithm()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataOrXmlContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATA_SYMBOL(self):
            return self.getToken(MySQLParser.DATA_SYMBOL, 0)

        def XML_SYMBOL(self):
            return self.getToken(MySQLParser.XML_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_dataOrXml

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataOrXml" ):
                listener.enterDataOrXml(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataOrXml" ):
                listener.exitDataOrXml(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataOrXml" ):
                return visitor.visitDataOrXml(self)
            else:
                return visitor.visitChildren(self)




    def dataOrXml(self):

        localctx = MySQLParser.DataOrXmlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 270, self.RULE_dataOrXml)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3220
            _la = self._input.LA(1)
            if not(_la==153 or _la==661):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoadDataLockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOW_PRIORITY_SYMBOL(self):
            return self.getToken(MySQLParser.LOW_PRIORITY_SYMBOL, 0)

        def CONCURRENT_SYMBOL(self):
            return self.getToken(MySQLParser.CONCURRENT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_loadDataLock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoadDataLock" ):
                listener.enterLoadDataLock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoadDataLock" ):
                listener.exitLoadDataLock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoadDataLock" ):
                return visitor.visitLoadDataLock(self)
            else:
                return visitor.visitChildren(self)




    def loadDataLock(self):

        localctx = MySQLParser.LoadDataLockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 272, self.RULE_loadDataLock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3222
            _la = self._input.LA(1)
            if not(_la==125 or _la==321):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoadFromContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FROM_SYMBOL(self):
            return self.getToken(MySQLParser.FROM_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_loadFrom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoadFrom" ):
                listener.enterLoadFrom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoadFrom" ):
                listener.exitLoadFrom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoadFrom" ):
                return visitor.visitLoadFrom(self)
            else:
                return visitor.visitChildren(self)




    def loadFrom(self):

        localctx = MySQLParser.LoadFromContext(self, self._ctx, self.state)
        self.enterRule(localctx, 274, self.RULE_loadFrom)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3224
            if not self.isServerVersionGe80200():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.isServerVersionGe80200()")
            self.state = 3225
            self.match(MySQLParser.FROM_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoadSourceTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INFILE_SYMBOL(self):
            return self.getToken(MySQLParser.INFILE_SYMBOL, 0)

        def URL_SYMBOL(self):
            return self.getToken(MySQLParser.URL_SYMBOL, 0)

        def S3_SYMBOL(self):
            return self.getToken(MySQLParser.S3_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_loadSourceType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoadSourceType" ):
                listener.enterLoadSourceType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoadSourceType" ):
                listener.exitLoadSourceType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoadSourceType" ):
                return visitor.visitLoadSourceType(self)
            else:
                return visitor.visitChildren(self)




    def loadSourceType(self):

        localctx = MySQLParser.LoadSourceTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 276, self.RULE_loadSourceType)
        self._la = 0 # Token type
        try:
            self.state = 3230
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,276,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3227
                self.match(MySQLParser.INFILE_SYMBOL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3228
                if not self.isServerVersionGe80200():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80200()")
                self.state = 3229
                _la = self._input.LA(1)
                if not(_la==805 or _la==811):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceCountContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COUNT_SYMBOL(self):
            return self.getToken(MySQLParser.COUNT_SYMBOL, 0)

        def INT_NUMBER(self):
            return self.getToken(MySQLParser.INT_NUMBER, 0)

        def pureIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.PureIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_sourceCount

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSourceCount" ):
                listener.enterSourceCount(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSourceCount" ):
                listener.exitSourceCount(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSourceCount" ):
                return visitor.visitSourceCount(self)
            else:
                return visitor.visitChildren(self)




    def sourceCount(self):

        localctx = MySQLParser.SourceCountContext(self, self._ctx, self.state)
        self.enterRule(localctx, 278, self.RULE_sourceCount)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3232
            if not self.isServerVersionGe80200():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.isServerVersionGe80200()")
            self.state = 3238
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,277,self._ctx)
            if la_ == 1:
                self.state = 3233
                self.match(MySQLParser.COUNT_SYMBOL)
                self.state = 3234
                self.match(MySQLParser.INT_NUMBER)
                pass

            elif la_ == 2:
                self.state = 3235
                self.pureIdentifier()
                self.state = 3236
                self.match(MySQLParser.INT_NUMBER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceOrderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IN_SYMBOL(self):
            return self.getToken(MySQLParser.IN_SYMBOL, 0)

        def PRIMARY_SYMBOL(self):
            return self.getToken(MySQLParser.PRIMARY_SYMBOL, 0)

        def KEY_SYMBOL(self):
            return self.getToken(MySQLParser.KEY_SYMBOL, 0)

        def ORDER_SYMBOL(self):
            return self.getToken(MySQLParser.ORDER_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_sourceOrder

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSourceOrder" ):
                listener.enterSourceOrder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSourceOrder" ):
                listener.exitSourceOrder(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSourceOrder" ):
                return visitor.visitSourceOrder(self)
            else:
                return visitor.visitChildren(self)




    def sourceOrder(self):

        localctx = MySQLParser.SourceOrderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 280, self.RULE_sourceOrder)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3240
            if not self.isServerVersionGe80200():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.isServerVersionGe80200()")
            self.state = 3241
            self.match(MySQLParser.IN_SYMBOL)
            self.state = 3242
            self.match(MySQLParser.PRIMARY_SYMBOL)
            self.state = 3243
            self.match(MySQLParser.KEY_SYMBOL)
            self.state = 3244
            self.match(MySQLParser.ORDER_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlRowsIdentifiedByContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROWS_SYMBOL(self):
            return self.getToken(MySQLParser.ROWS_SYMBOL, 0)

        def IDENTIFIED_SYMBOL(self):
            return self.getToken(MySQLParser.IDENTIFIED_SYMBOL, 0)

        def BY_SYMBOL(self):
            return self.getToken(MySQLParser.BY_SYMBOL, 0)

        def textString(self):
            return self.getTypedRuleContext(MySQLParser.TextStringContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_xmlRowsIdentifiedBy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlRowsIdentifiedBy" ):
                listener.enterXmlRowsIdentifiedBy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlRowsIdentifiedBy" ):
                listener.exitXmlRowsIdentifiedBy(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlRowsIdentifiedBy" ):
                return visitor.visitXmlRowsIdentifiedBy(self)
            else:
                return visitor.visitChildren(self)




    def xmlRowsIdentifiedBy(self):

        localctx = MySQLParser.XmlRowsIdentifiedByContext(self, self._ctx, self.state)
        self.enterRule(localctx, 282, self.RULE_xmlRowsIdentifiedBy)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3246
            self.match(MySQLParser.ROWS_SYMBOL)
            self.state = 3247
            self.match(MySQLParser.IDENTIFIED_SYMBOL)
            self.state = 3248
            self.match(MySQLParser.BY_SYMBOL)
            self.state = 3249
            self.textString()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoadDataFileTailContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IGNORE_SYMBOL(self):
            return self.getToken(MySQLParser.IGNORE_SYMBOL, 0)

        def INT_NUMBER(self):
            return self.getToken(MySQLParser.INT_NUMBER, 0)

        def loadDataFileTargetList(self):
            return self.getTypedRuleContext(MySQLParser.LoadDataFileTargetListContext,0)


        def SET_SYMBOL(self):
            return self.getToken(MySQLParser.SET_SYMBOL, 0)

        def updateList(self):
            return self.getTypedRuleContext(MySQLParser.UpdateListContext,0)


        def LINES_SYMBOL(self):
            return self.getToken(MySQLParser.LINES_SYMBOL, 0)

        def ROWS_SYMBOL(self):
            return self.getToken(MySQLParser.ROWS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_loadDataFileTail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoadDataFileTail" ):
                listener.enterLoadDataFileTail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoadDataFileTail" ):
                listener.exitLoadDataFileTail(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoadDataFileTail" ):
                return visitor.visitLoadDataFileTail(self)
            else:
                return visitor.visitChildren(self)




    def loadDataFileTail(self):

        localctx = MySQLParser.LoadDataFileTailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 284, self.RULE_loadDataFileTail)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3254
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,278,self._ctx)
            if la_ == 1:
                self.state = 3251
                self.match(MySQLParser.IGNORE_SYMBOL)
                self.state = 3252
                self.match(MySQLParser.INT_NUMBER)
                self.state = 3253
                _la = self._input.LA(1)
                if not(_la==308 or _la==500):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 3257
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,279,self._ctx)
            if la_ == 1:
                self.state = 3256
                self.loadDataFileTargetList()


            self.state = 3261
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,280,self._ctx)
            if la_ == 1:
                self.state = 3259
                self.match(MySQLParser.SET_SYMBOL)
                self.state = 3260
                self.updateList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoadDataFileTargetListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def fieldOrVariableList(self):
            return self.getTypedRuleContext(MySQLParser.FieldOrVariableListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_loadDataFileTargetList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoadDataFileTargetList" ):
                listener.enterLoadDataFileTargetList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoadDataFileTargetList" ):
                listener.exitLoadDataFileTargetList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoadDataFileTargetList" ):
                return visitor.visitLoadDataFileTargetList(self)
            else:
                return visitor.visitChildren(self)




    def loadDataFileTargetList(self):

        localctx = MySQLParser.LoadDataFileTargetListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 286, self.RULE_loadDataFileTargetList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3263
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 3265
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,281,self._ctx)
            if la_ == 1:
                self.state = 3264
                self.fieldOrVariableList()


            self.state = 3267
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FieldOrVariableListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def columnRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ColumnRefContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ColumnRefContext,i)


        def AT_SIGN_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.AT_SIGN_SYMBOL)
            else:
                return self.getToken(MySQLParser.AT_SIGN_SYMBOL, i)

        def textOrIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.TextOrIdentifierContext)
            else:
                return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,i)


        def AT_AT_SIGN_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.AT_AT_SIGN_SYMBOL)
            else:
                return self.getToken(MySQLParser.AT_AT_SIGN_SYMBOL, i)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def AT_TEXT_SUFFIX(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.AT_TEXT_SUFFIX)
            else:
                return self.getToken(MySQLParser.AT_TEXT_SUFFIX, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_fieldOrVariableList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFieldOrVariableList" ):
                listener.enterFieldOrVariableList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFieldOrVariableList" ):
                listener.exitFieldOrVariableList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFieldOrVariableList" ):
                return visitor.visitFieldOrVariableList(self)
            else:
                return visitor.visitChildren(self)




    def fieldOrVariableList(self):

        localctx = MySQLParser.FieldOrVariableListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 288, self.RULE_fieldOrVariableList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3273
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,282,self._ctx)
            if la_ == 1:
                self.state = 3269
                self.columnRef()
                pass

            elif la_ == 2:
                self.state = 3270
                self.match(MySQLParser.AT_SIGN_SYMBOL)
                self.state = 3271
                self.textOrIdentifier()
                pass

            elif la_ == 3:
                self.state = 3272
                self.match(MySQLParser.AT_AT_SIGN_SYMBOL)
                pass


            self.state = 3285
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 3275
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 3281
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,283,self._ctx)
                if la_ == 1:
                    self.state = 3276
                    self.columnRef()
                    pass

                elif la_ == 2:
                    self.state = 3277
                    self.match(MySQLParser.AT_SIGN_SYMBOL)
                    self.state = 3278
                    self.textOrIdentifier()
                    pass

                elif la_ == 3:
                    self.state = 3279
                    self.match(MySQLParser.AT_TEXT_SUFFIX)
                    pass

                elif la_ == 4:
                    self.state = 3280
                    self.match(MySQLParser.AT_AT_SIGN_SYMBOL)
                    pass


                self.state = 3287
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoadAlgorithmContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALGORITHM_SYMBOL(self):
            return self.getToken(MySQLParser.ALGORITHM_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def BULK_SYMBOL(self):
            return self.getToken(MySQLParser.BULK_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_loadAlgorithm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoadAlgorithm" ):
                listener.enterLoadAlgorithm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoadAlgorithm" ):
                listener.exitLoadAlgorithm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoadAlgorithm" ):
                return visitor.visitLoadAlgorithm(self)
            else:
                return visitor.visitChildren(self)




    def loadAlgorithm(self):

        localctx = MySQLParser.LoadAlgorithmContext(self, self._ctx, self.state)
        self.enterRule(localctx, 290, self.RULE_loadAlgorithm)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3288
            if not self.isServerVersionGe80200():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.isServerVersionGe80200()")
            self.state = 3289
            self.match(MySQLParser.ALGORITHM_SYMBOL)
            self.state = 3290
            self.match(MySQLParser.EQUAL_OPERATOR)
            self.state = 3291
            self.match(MySQLParser.BULK_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoadParallelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARALLEL_SYMBOL(self):
            return self.getToken(MySQLParser.PARALLEL_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def INT_NUMBER(self):
            return self.getToken(MySQLParser.INT_NUMBER, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_loadParallel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoadParallel" ):
                listener.enterLoadParallel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoadParallel" ):
                listener.exitLoadParallel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoadParallel" ):
                return visitor.visitLoadParallel(self)
            else:
                return visitor.visitChildren(self)




    def loadParallel(self):

        localctx = MySQLParser.LoadParallelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 292, self.RULE_loadParallel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3293
            if not self.isServerVersionGe80200():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.isServerVersionGe80200()")
            self.state = 3294
            self.match(MySQLParser.PARALLEL_SYMBOL)
            self.state = 3295
            self.match(MySQLParser.EQUAL_OPERATOR)
            self.state = 3296
            self.match(MySQLParser.INT_NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoadMemoryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MEMORY_SYMBOL(self):
            return self.getToken(MySQLParser.MEMORY_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def sizeNumber(self):
            return self.getTypedRuleContext(MySQLParser.SizeNumberContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_loadMemory

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoadMemory" ):
                listener.enterLoadMemory(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoadMemory" ):
                listener.exitLoadMemory(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoadMemory" ):
                return visitor.visitLoadMemory(self)
            else:
                return visitor.visitChildren(self)




    def loadMemory(self):

        localctx = MySQLParser.LoadMemoryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 294, self.RULE_loadMemory)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3298
            if not self.isServerVersionGe80200():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.isServerVersionGe80200()")
            self.state = 3299
            self.match(MySQLParser.MEMORY_SYMBOL)
            self.state = 3300
            self.match(MySQLParser.EQUAL_OPERATOR)
            self.state = 3301
            self.sizeNumber()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReplaceStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPLACE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLACE_SYMBOL, 0)

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def insertFromConstructor(self):
            return self.getTypedRuleContext(MySQLParser.InsertFromConstructorContext,0)


        def SET_SYMBOL(self):
            return self.getToken(MySQLParser.SET_SYMBOL, 0)

        def updateList(self):
            return self.getTypedRuleContext(MySQLParser.UpdateListContext,0)


        def insertQueryExpression(self):
            return self.getTypedRuleContext(MySQLParser.InsertQueryExpressionContext,0)


        def INTO_SYMBOL(self):
            return self.getToken(MySQLParser.INTO_SYMBOL, 0)

        def usePartition(self):
            return self.getTypedRuleContext(MySQLParser.UsePartitionContext,0)


        def LOW_PRIORITY_SYMBOL(self):
            return self.getToken(MySQLParser.LOW_PRIORITY_SYMBOL, 0)

        def DELAYED_SYMBOL(self):
            return self.getToken(MySQLParser.DELAYED_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_replaceStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplaceStatement" ):
                listener.enterReplaceStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplaceStatement" ):
                listener.exitReplaceStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReplaceStatement" ):
                return visitor.visitReplaceStatement(self)
            else:
                return visitor.visitChildren(self)




    def replaceStatement(self):

        localctx = MySQLParser.ReplaceStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 296, self.RULE_replaceStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3303
            self.match(MySQLParser.REPLACE_SYMBOL)
            self.state = 3305
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,285,self._ctx)
            if la_ == 1:
                self.state = 3304
                _la = self._input.LA(1)
                if not(_la==169 or _la==321):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 3308
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,286,self._ctx)
            if la_ == 1:
                self.state = 3307
                self.match(MySQLParser.INTO_SYMBOL)


            self.state = 3310
            self.tableRef()
            self.state = 3312
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,287,self._ctx)
            if la_ == 1:
                self.state = 3311
                self.usePartition()


            self.state = 3318
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,288,self._ctx)
            if la_ == 1:
                self.state = 3314
                self.insertFromConstructor()
                pass

            elif la_ == 2:
                self.state = 3315
                self.match(MySQLParser.SET_SYMBOL)
                self.state = 3316
                self.updateList()
                pass

            elif la_ == 3:
                self.state = 3317
                self.insertQueryExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def queryExpression(self):
            return self.getTypedRuleContext(MySQLParser.QueryExpressionContext,0)


        def lockingClauseList(self):
            return self.getTypedRuleContext(MySQLParser.LockingClauseListContext,0)


        def selectStatementWithInto(self):
            return self.getTypedRuleContext(MySQLParser.SelectStatementWithIntoContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_selectStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectStatement" ):
                listener.enterSelectStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectStatement" ):
                listener.exitSelectStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectStatement" ):
                return visitor.visitSelectStatement(self)
            else:
                return visitor.visitChildren(self)




    def selectStatement(self):

        localctx = MySQLParser.SelectStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 298, self.RULE_selectStatement)
        try:
            self.state = 3325
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,290,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3320
                self.queryExpression()
                self.state = 3322
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,289,self._ctx)
                if la_ == 1:
                    self.state = 3321
                    self.lockingClauseList()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3324
                self.selectStatementWithInto()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectStatementWithIntoContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def selectStatementWithInto(self):
            return self.getTypedRuleContext(MySQLParser.SelectStatementWithIntoContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def queryExpression(self):
            return self.getTypedRuleContext(MySQLParser.QueryExpressionContext,0)


        def intoClause(self):
            return self.getTypedRuleContext(MySQLParser.IntoClauseContext,0)


        def lockingClauseList(self):
            return self.getTypedRuleContext(MySQLParser.LockingClauseListContext,0)


        def queryExpressionParens(self):
            return self.getTypedRuleContext(MySQLParser.QueryExpressionParensContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_selectStatementWithInto

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectStatementWithInto" ):
                listener.enterSelectStatementWithInto(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectStatementWithInto" ):
                listener.exitSelectStatementWithInto(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectStatementWithInto" ):
                return visitor.visitSelectStatementWithInto(self)
            else:
                return visitor.visitChildren(self)




    def selectStatementWithInto(self):

        localctx = MySQLParser.SelectStatementWithIntoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 300, self.RULE_selectStatementWithInto)
        try:
            self.state = 3344
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,292,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3327
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 3328
                self.selectStatementWithInto()
                self.state = 3329
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3331
                self.queryExpression()
                self.state = 3332
                self.intoClause()
                self.state = 3334
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,291,self._ctx)
                if la_ == 1:
                    self.state = 3333
                    self.lockingClauseList()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3336
                self.queryExpression()
                self.state = 3337
                self.lockingClauseList()
                self.state = 3338
                self.intoClause()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 3340
                if not self.isSelectStatementWithInto():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isSelectStatementWithInto()")
                self.state = 3341
                self.queryExpressionParens()
                self.state = 3342
                self.intoClause()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def queryExpressionBody(self):
            return self.getTypedRuleContext(MySQLParser.QueryExpressionBodyContext,0)


        def withClause(self):
            return self.getTypedRuleContext(MySQLParser.WithClauseContext,0)


        def orderClause(self):
            return self.getTypedRuleContext(MySQLParser.OrderClauseContext,0)


        def limitClause(self):
            return self.getTypedRuleContext(MySQLParser.LimitClauseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_queryExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueryExpression" ):
                listener.enterQueryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueryExpression" ):
                listener.exitQueryExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQueryExpression" ):
                return visitor.visitQueryExpression(self)
            else:
                return visitor.visitChildren(self)




    def queryExpression(self):

        localctx = MySQLParser.QueryExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 302, self.RULE_queryExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3347
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,293,self._ctx)
            if la_ == 1:
                self.state = 3346
                self.withClause()


            self.state = 3349
            self.queryExpressionBody()
            self.state = 3351
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,294,self._ctx)
            if la_ == 1:
                self.state = 3350
                self.orderClause()


            self.state = 3354
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,295,self._ctx)
            if la_ == 1:
                self.state = 3353
                self.limitClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryExpressionBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def queryPrimary(self):
            return self.getTypedRuleContext(MySQLParser.QueryPrimaryContext,0)


        def queryExpressionParens(self):
            return self.getTypedRuleContext(MySQLParser.QueryExpressionParensContext,0)


        def queryExpressionBody(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.QueryExpressionBodyContext)
            else:
                return self.getTypedRuleContext(MySQLParser.QueryExpressionBodyContext,i)


        def UNION_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.UNION_SYMBOL)
            else:
                return self.getToken(MySQLParser.UNION_SYMBOL, i)

        def EXCEPT_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.EXCEPT_SYMBOL)
            else:
                return self.getToken(MySQLParser.EXCEPT_SYMBOL, i)

        def INTERSECT_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.INTERSECT_SYMBOL)
            else:
                return self.getToken(MySQLParser.INTERSECT_SYMBOL, i)

        def unionOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.UnionOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.UnionOptionContext,i)


        def getRuleIndex(self):
            return MySQLParser.RULE_queryExpressionBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueryExpressionBody" ):
                listener.enterQueryExpressionBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueryExpressionBody" ):
                listener.exitQueryExpressionBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQueryExpressionBody" ):
                return visitor.visitQueryExpressionBody(self)
            else:
                return visitor.visitChildren(self)




    def queryExpressionBody(self):

        localctx = MySQLParser.QueryExpressionBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 304, self.RULE_queryExpressionBody)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3358
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,296,self._ctx)
            if la_ == 1:
                self.state = 3356
                self.queryPrimary()
                pass

            elif la_ == 2:
                self.state = 3357
                self.queryExpressionParens()
                pass


            self.state = 3371
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,299,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 3363
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,297,self._ctx)
                    if la_ == 1:
                        self.state = 3360
                        self.match(MySQLParser.UNION_SYMBOL)
                        pass

                    elif la_ == 2:
                        self.state = 3361
                        if not self.isServerVersionGe80031():
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.isServerVersionGe80031()")
                        self.state = 3362
                        _la = self._input.LA(1)
                        if not(_la==671 or _la==803):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        pass


                    self.state = 3366
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,298,self._ctx)
                    if la_ == 1:
                        self.state = 3365
                        self.unionOption()


                    self.state = 3368
                    self.queryExpressionBody() 
                self.state = 3373
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,299,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryExpressionParensContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def queryExpressionParens(self):
            return self.getTypedRuleContext(MySQLParser.QueryExpressionParensContext,0)


        def queryExpressionWithOptLockingClauses(self):
            return self.getTypedRuleContext(MySQLParser.QueryExpressionWithOptLockingClausesContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_queryExpressionParens

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueryExpressionParens" ):
                listener.enterQueryExpressionParens(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueryExpressionParens" ):
                listener.exitQueryExpressionParens(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQueryExpressionParens" ):
                return visitor.visitQueryExpressionParens(self)
            else:
                return visitor.visitChildren(self)




    def queryExpressionParens(self):

        localctx = MySQLParser.QueryExpressionParensContext(self, self._ctx, self.state)
        self.enterRule(localctx, 306, self.RULE_queryExpressionParens)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3374
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 3377
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,300,self._ctx)
            if la_ == 1:
                self.state = 3375
                self.queryExpressionParens()
                pass

            elif la_ == 2:
                self.state = 3376
                self.queryExpressionWithOptLockingClauses()
                pass


            self.state = 3379
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryPrimaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def querySpecification(self):
            return self.getTypedRuleContext(MySQLParser.QuerySpecificationContext,0)


        def tableValueConstructor(self):
            return self.getTypedRuleContext(MySQLParser.TableValueConstructorContext,0)


        def explicitTable(self):
            return self.getTypedRuleContext(MySQLParser.ExplicitTableContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_queryPrimary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueryPrimary" ):
                listener.enterQueryPrimary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueryPrimary" ):
                listener.exitQueryPrimary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQueryPrimary" ):
                return visitor.visitQueryPrimary(self)
            else:
                return visitor.visitChildren(self)




    def queryPrimary(self):

        localctx = MySQLParser.QueryPrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 308, self.RULE_queryPrimary)
        try:
            self.state = 3386
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,301,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3381
                self.querySpecification()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3382
                if not self.isServerVersionGe80019():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80019()")
                self.state = 3383
                self.tableValueConstructor()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3384
                if not self.isServerVersionGe80019():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80019()")
                self.state = 3385
                self.explicitTable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QuerySpecificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SELECT_SYMBOL(self):
            return self.getToken(MySQLParser.SELECT_SYMBOL, 0)

        def selectItemList(self):
            return self.getTypedRuleContext(MySQLParser.SelectItemListContext,0)


        def selectOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.SelectOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.SelectOptionContext,i)


        def intoClause(self):
            return self.getTypedRuleContext(MySQLParser.IntoClauseContext,0)


        def fromClause(self):
            return self.getTypedRuleContext(MySQLParser.FromClauseContext,0)


        def whereClause(self):
            return self.getTypedRuleContext(MySQLParser.WhereClauseContext,0)


        def groupByClause(self):
            return self.getTypedRuleContext(MySQLParser.GroupByClauseContext,0)


        def havingClause(self):
            return self.getTypedRuleContext(MySQLParser.HavingClauseContext,0)


        def windowClause(self):
            return self.getTypedRuleContext(MySQLParser.WindowClauseContext,0)


        def qualifyClause(self):
            return self.getTypedRuleContext(MySQLParser.QualifyClauseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_querySpecification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuerySpecification" ):
                listener.enterQuerySpecification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuerySpecification" ):
                listener.exitQuerySpecification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuerySpecification" ):
                return visitor.visitQuerySpecification(self)
            else:
                return visitor.visitChildren(self)




    def querySpecification(self):

        localctx = MySQLParser.QuerySpecificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 310, self.RULE_querySpecification)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3388
            self.match(MySQLParser.SELECT_SYMBOL)
            self.state = 3392
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,302,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 3389
                    self.selectOption() 
                self.state = 3394
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,302,self._ctx)

            self.state = 3395
            self.selectItemList()
            self.state = 3397
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,303,self._ctx)
            if la_ == 1:
                self.state = 3396
                self.intoClause()


            self.state = 3400
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,304,self._ctx)
            if la_ == 1:
                self.state = 3399
                self.fromClause()


            self.state = 3403
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,305,self._ctx)
            if la_ == 1:
                self.state = 3402
                self.whereClause()


            self.state = 3406
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,306,self._ctx)
            if la_ == 1:
                self.state = 3405
                self.groupByClause()


            self.state = 3409
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,307,self._ctx)
            if la_ == 1:
                self.state = 3408
                self.havingClause()


            self.state = 3412
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,308,self._ctx)
            if la_ == 1:
                self.state = 3411
                self.windowClause()


            self.state = 3415
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,309,self._ctx)
            if la_ == 1:
                self.state = 3414
                self.qualifyClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubqueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def queryExpressionParens(self):
            return self.getTypedRuleContext(MySQLParser.QueryExpressionParensContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_subquery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubquery" ):
                listener.enterSubquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubquery" ):
                listener.exitSubquery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubquery" ):
                return visitor.visitSubquery(self)
            else:
                return visitor.visitChildren(self)




    def subquery(self):

        localctx = MySQLParser.SubqueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 312, self.RULE_subquery)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3417
            self.queryExpressionParens()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QuerySpecOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALL_SYMBOL(self):
            return self.getToken(MySQLParser.ALL_SYMBOL, 0)

        def DISTINCT_SYMBOL(self):
            return self.getToken(MySQLParser.DISTINCT_SYMBOL, 0)

        def STRAIGHT_JOIN_SYMBOL(self):
            return self.getToken(MySQLParser.STRAIGHT_JOIN_SYMBOL, 0)

        def HIGH_PRIORITY_SYMBOL(self):
            return self.getToken(MySQLParser.HIGH_PRIORITY_SYMBOL, 0)

        def SQL_SMALL_RESULT_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_SMALL_RESULT_SYMBOL, 0)

        def SQL_BIG_RESULT_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_BIG_RESULT_SYMBOL, 0)

        def SQL_BUFFER_RESULT_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_BUFFER_RESULT_SYMBOL, 0)

        def SQL_CALC_FOUND_ROWS_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_CALC_FOUND_ROWS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_querySpecOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuerySpecOption" ):
                listener.enterQuerySpecOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuerySpecOption" ):
                listener.exitQuerySpecOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuerySpecOption" ):
                return visitor.visitQuerySpecOption(self)
            else:
                return visitor.visitChildren(self)




    def querySpecOption(self):

        localctx = MySQLParser.QuerySpecOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 314, self.RULE_querySpecOption)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3419
            _la = self._input.LA(1)
            if not(_la==57 or _la==180 or _la==255 or ((((_la - 542)) & ~0x3f) == 0 and ((1 << (_la - 542)) & 8388631) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LimitClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIMIT_SYMBOL(self):
            return self.getToken(MySQLParser.LIMIT_SYMBOL, 0)

        def limitOptions(self):
            return self.getTypedRuleContext(MySQLParser.LimitOptionsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_limitClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLimitClause" ):
                listener.enterLimitClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLimitClause" ):
                listener.exitLimitClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLimitClause" ):
                return visitor.visitLimitClause(self)
            else:
                return visitor.visitChildren(self)




    def limitClause(self):

        localctx = MySQLParser.LimitClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 316, self.RULE_limitClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3421
            self.match(MySQLParser.LIMIT_SYMBOL)
            self.state = 3422
            self.limitOptions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleLimitClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIMIT_SYMBOL(self):
            return self.getToken(MySQLParser.LIMIT_SYMBOL, 0)

        def limitOption(self):
            return self.getTypedRuleContext(MySQLParser.LimitOptionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_simpleLimitClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleLimitClause" ):
                listener.enterSimpleLimitClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleLimitClause" ):
                listener.exitSimpleLimitClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleLimitClause" ):
                return visitor.visitSimpleLimitClause(self)
            else:
                return visitor.visitChildren(self)




    def simpleLimitClause(self):

        localctx = MySQLParser.SimpleLimitClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 318, self.RULE_simpleLimitClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3424
            self.match(MySQLParser.LIMIT_SYMBOL)
            self.state = 3425
            self.limitOption()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LimitOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def limitOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.LimitOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.LimitOptionContext,i)


        def COMMA_SYMBOL(self):
            return self.getToken(MySQLParser.COMMA_SYMBOL, 0)

        def OFFSET_SYMBOL(self):
            return self.getToken(MySQLParser.OFFSET_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_limitOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLimitOptions" ):
                listener.enterLimitOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLimitOptions" ):
                listener.exitLimitOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLimitOptions" ):
                return visitor.visitLimitOptions(self)
            else:
                return visitor.visitChildren(self)




    def limitOptions(self):

        localctx = MySQLParser.LimitOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 320, self.RULE_limitOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3427
            self.limitOption()
            self.state = 3430
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,310,self._ctx)
            if la_ == 1:
                self.state = 3428
                _la = self._input.LA(1)
                if not(_la==29 or _la==400):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3429
                self.limitOption()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LimitOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def PARAM_MARKER(self):
            return self.getToken(MySQLParser.PARAM_MARKER, 0)

        def ULONGLONG_NUMBER(self):
            return self.getToken(MySQLParser.ULONGLONG_NUMBER, 0)

        def LONG_NUMBER(self):
            return self.getToken(MySQLParser.LONG_NUMBER, 0)

        def INT_NUMBER(self):
            return self.getToken(MySQLParser.INT_NUMBER, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_limitOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLimitOption" ):
                listener.enterLimitOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLimitOption" ):
                listener.exitLimitOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLimitOption" ):
                return visitor.visitLimitOption(self)
            else:
                return visitor.visitChildren(self)




    def limitOption(self):

        localctx = MySQLParser.LimitOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 322, self.RULE_limitOption)
        self._la = 0 # Token type
        try:
            self.state = 3434
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,311,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3432
                self.identifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3433
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 8796093022264) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntoClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTO_SYMBOL(self):
            return self.getToken(MySQLParser.INTO_SYMBOL, 0)

        def OUTFILE_SYMBOL(self):
            return self.getToken(MySQLParser.OUTFILE_SYMBOL, 0)

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def DUMPFILE_SYMBOL(self):
            return self.getToken(MySQLParser.DUMPFILE_SYMBOL, 0)

        def textOrIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.TextOrIdentifierContext)
            else:
                return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,i)


        def userVariable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.UserVariableContext)
            else:
                return self.getTypedRuleContext(MySQLParser.UserVariableContext,i)


        def charsetClause(self):
            return self.getTypedRuleContext(MySQLParser.CharsetClauseContext,0)


        def fieldsClause(self):
            return self.getTypedRuleContext(MySQLParser.FieldsClauseContext,0)


        def linesClause(self):
            return self.getTypedRuleContext(MySQLParser.LinesClauseContext,0)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_intoClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntoClause" ):
                listener.enterIntoClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntoClause" ):
                listener.exitIntoClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntoClause" ):
                return visitor.visitIntoClause(self)
            else:
                return visitor.visitChildren(self)




    def intoClause(self):

        localctx = MySQLParser.IntoClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 324, self.RULE_intoClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3436
            self.match(MySQLParser.INTO_SYMBOL)
            self.state = 3464
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,318,self._ctx)
            if la_ == 1:
                self.state = 3437
                self.match(MySQLParser.OUTFILE_SYMBOL)
                self.state = 3438
                self.textStringLiteral()
                self.state = 3440
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,312,self._ctx)
                if la_ == 1:
                    self.state = 3439
                    self.charsetClause()


                self.state = 3443
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,313,self._ctx)
                if la_ == 1:
                    self.state = 3442
                    self.fieldsClause()


                self.state = 3446
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,314,self._ctx)
                if la_ == 1:
                    self.state = 3445
                    self.linesClause()


                pass

            elif la_ == 2:
                self.state = 3448
                self.match(MySQLParser.DUMPFILE_SYMBOL)
                self.state = 3449
                self.textStringLiteral()
                pass

            elif la_ == 3:
                self.state = 3452
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,315,self._ctx)
                if la_ == 1:
                    self.state = 3450
                    self.textOrIdentifier()
                    pass

                elif la_ == 2:
                    self.state = 3451
                    self.userVariable()
                    pass


                self.state = 3461
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,317,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 3454
                        self.match(MySQLParser.COMMA_SYMBOL)
                        self.state = 3457
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,316,self._ctx)
                        if la_ == 1:
                            self.state = 3455
                            self.textOrIdentifier()
                            pass

                        elif la_ == 2:
                            self.state = 3456
                            self.userVariable()
                            pass

                 
                    self.state = 3463
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,317,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcedureAnalyseClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROCEDURE_SYMBOL(self):
            return self.getToken(MySQLParser.PROCEDURE_SYMBOL, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def INT_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.INT_NUMBER)
            else:
                return self.getToken(MySQLParser.INT_NUMBER, i)

        def COMMA_SYMBOL(self):
            return self.getToken(MySQLParser.COMMA_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_procedureAnalyseClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcedureAnalyseClause" ):
                listener.enterProcedureAnalyseClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcedureAnalyseClause" ):
                listener.exitProcedureAnalyseClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcedureAnalyseClause" ):
                return visitor.visitProcedureAnalyseClause(self)
            else:
                return visitor.visitChildren(self)




    def procedureAnalyseClause(self):

        localctx = MySQLParser.ProcedureAnalyseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 326, self.RULE_procedureAnalyseClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3466
            self.match(MySQLParser.PROCEDURE_SYMBOL)
            self.state = 3467
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 3473
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==3:
                self.state = 3468
                self.match(MySQLParser.INT_NUMBER)
                self.state = 3471
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 3469
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 3470
                    self.match(MySQLParser.INT_NUMBER)




            self.state = 3475
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HavingClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HAVING_SYMBOL(self):
            return self.getToken(MySQLParser.HAVING_SYMBOL, 0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_havingClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHavingClause" ):
                listener.enterHavingClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHavingClause" ):
                listener.exitHavingClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHavingClause" ):
                return visitor.visitHavingClause(self)
            else:
                return visitor.visitChildren(self)




    def havingClause(self):

        localctx = MySQLParser.HavingClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 328, self.RULE_havingClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3477
            self.match(MySQLParser.HAVING_SYMBOL)
            self.state = 3478
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QualifyClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUALIFY_SYMBOL(self):
            return self.getToken(MySQLParser.QUALIFY_SYMBOL, 0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_qualifyClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQualifyClause" ):
                listener.enterQualifyClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQualifyClause" ):
                listener.exitQualifyClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQualifyClause" ):
                return visitor.visitQualifyClause(self)
            else:
                return visitor.visitChildren(self)




    def qualifyClause(self):

        localctx = MySQLParser.QualifyClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 330, self.RULE_qualifyClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3480
            if not self.isServerVersionGe80200():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.isServerVersionGe80200()")
            self.state = 3481
            self.match(MySQLParser.QUALIFY_SYMBOL)
            self.state = 3482
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WINDOW_SYMBOL(self):
            return self.getToken(MySQLParser.WINDOW_SYMBOL, 0)

        def windowDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.WindowDefinitionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.WindowDefinitionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_windowClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowClause" ):
                listener.enterWindowClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowClause" ):
                listener.exitWindowClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowClause" ):
                return visitor.visitWindowClause(self)
            else:
                return visitor.visitChildren(self)




    def windowClause(self):

        localctx = MySQLParser.WindowClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 332, self.RULE_windowClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3484
            self.match(MySQLParser.WINDOW_SYMBOL)
            self.state = 3485
            self.windowDefinition()
            self.state = 3490
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,321,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 3486
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 3487
                    self.windowDefinition() 
                self.state = 3492
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,321,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def windowName(self):
            return self.getTypedRuleContext(MySQLParser.WindowNameContext,0)


        def AS_SYMBOL(self):
            return self.getToken(MySQLParser.AS_SYMBOL, 0)

        def windowSpec(self):
            return self.getTypedRuleContext(MySQLParser.WindowSpecContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_windowDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowDefinition" ):
                listener.enterWindowDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowDefinition" ):
                listener.exitWindowDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowDefinition" ):
                return visitor.visitWindowDefinition(self)
            else:
                return visitor.visitChildren(self)




    def windowDefinition(self):

        localctx = MySQLParser.WindowDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 334, self.RULE_windowDefinition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3493
            self.windowName()
            self.state = 3494
            self.match(MySQLParser.AS_SYMBOL)
            self.state = 3495
            self.windowSpec()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowSpecContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def windowSpecDetails(self):
            return self.getTypedRuleContext(MySQLParser.WindowSpecDetailsContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_windowSpec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowSpec" ):
                listener.enterWindowSpec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowSpec" ):
                listener.exitWindowSpec(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowSpec" ):
                return visitor.visitWindowSpec(self)
            else:
                return visitor.visitChildren(self)




    def windowSpec(self):

        localctx = MySQLParser.WindowSpecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 336, self.RULE_windowSpec)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3497
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 3498
            self.windowSpecDetails()
            self.state = 3499
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowSpecDetailsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def windowName(self):
            return self.getTypedRuleContext(MySQLParser.WindowNameContext,0)


        def PARTITION_SYMBOL(self):
            return self.getToken(MySQLParser.PARTITION_SYMBOL, 0)

        def BY_SYMBOL(self):
            return self.getToken(MySQLParser.BY_SYMBOL, 0)

        def orderList(self):
            return self.getTypedRuleContext(MySQLParser.OrderListContext,0)


        def orderClause(self):
            return self.getTypedRuleContext(MySQLParser.OrderClauseContext,0)


        def windowFrameClause(self):
            return self.getTypedRuleContext(MySQLParser.WindowFrameClauseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_windowSpecDetails

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowSpecDetails" ):
                listener.enterWindowSpecDetails(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowSpecDetails" ):
                listener.exitWindowSpecDetails(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowSpecDetails" ):
                return visitor.visitWindowSpecDetails(self)
            else:
                return visitor.visitChildren(self)




    def windowSpecDetails(self):

        localctx = MySQLParser.WindowSpecDetailsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 338, self.RULE_windowSpecDetails)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3502
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,322,self._ctx)
            if la_ == 1:
                self.state = 3501
                self.windowName()


            self.state = 3507
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==423:
                self.state = 3504
                self.match(MySQLParser.PARTITION_SYMBOL)
                self.state = 3505
                self.match(MySQLParser.BY_SYMBOL)
                self.state = 3506
                self.orderList()


            self.state = 3510
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==411:
                self.state = 3509
                self.orderClause()


            self.state = 3513
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==450 or _la==500 or _la==691:
                self.state = 3512
                self.windowFrameClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowFrameClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def windowFrameUnits(self):
            return self.getTypedRuleContext(MySQLParser.WindowFrameUnitsContext,0)


        def windowFrameExtent(self):
            return self.getTypedRuleContext(MySQLParser.WindowFrameExtentContext,0)


        def windowFrameExclusion(self):
            return self.getTypedRuleContext(MySQLParser.WindowFrameExclusionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_windowFrameClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowFrameClause" ):
                listener.enterWindowFrameClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowFrameClause" ):
                listener.exitWindowFrameClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowFrameClause" ):
                return visitor.visitWindowFrameClause(self)
            else:
                return visitor.visitChildren(self)




    def windowFrameClause(self):

        localctx = MySQLParser.WindowFrameClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 340, self.RULE_windowFrameClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3515
            self.windowFrameUnits()
            self.state = 3516
            self.windowFrameExtent()
            self.state = 3518
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==688:
                self.state = 3517
                self.windowFrameExclusion()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowFrameUnitsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROWS_SYMBOL(self):
            return self.getToken(MySQLParser.ROWS_SYMBOL, 0)

        def RANGE_SYMBOL(self):
            return self.getToken(MySQLParser.RANGE_SYMBOL, 0)

        def GROUPS_SYMBOL(self):
            return self.getToken(MySQLParser.GROUPS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_windowFrameUnits

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowFrameUnits" ):
                listener.enterWindowFrameUnits(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowFrameUnits" ):
                listener.exitWindowFrameUnits(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowFrameUnits" ):
                return visitor.visitWindowFrameUnits(self)
            else:
                return visitor.visitChildren(self)




    def windowFrameUnits(self):

        localctx = MySQLParser.WindowFrameUnitsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 342, self.RULE_windowFrameUnits)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3520
            _la = self._input.LA(1)
            if not(_la==450 or _la==500 or _la==691):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowFrameExtentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def windowFrameStart(self):
            return self.getTypedRuleContext(MySQLParser.WindowFrameStartContext,0)


        def windowFrameBetween(self):
            return self.getTypedRuleContext(MySQLParser.WindowFrameBetweenContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_windowFrameExtent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowFrameExtent" ):
                listener.enterWindowFrameExtent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowFrameExtent" ):
                listener.exitWindowFrameExtent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowFrameExtent" ):
                return visitor.visitWindowFrameExtent(self)
            else:
                return visitor.visitChildren(self)




    def windowFrameExtent(self):

        localctx = MySQLParser.WindowFrameExtentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 344, self.RULE_windowFrameExtent)
        try:
            self.state = 3524
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 4, 5, 43, 46, 47, 143, 278, 706]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3522
                self.windowFrameStart()
                pass
            elif token in [75]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3523
                self.windowFrameBetween()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowFrameStartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNBOUNDED_SYMBOL(self):
            return self.getToken(MySQLParser.UNBOUNDED_SYMBOL, 0)

        def PRECEDING_SYMBOL(self):
            return self.getToken(MySQLParser.PRECEDING_SYMBOL, 0)

        def ulonglongNumber(self):
            return self.getTypedRuleContext(MySQLParser.UlonglongNumberContext,0)


        def PARAM_MARKER(self):
            return self.getToken(MySQLParser.PARAM_MARKER, 0)

        def INTERVAL_SYMBOL(self):
            return self.getToken(MySQLParser.INTERVAL_SYMBOL, 0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def interval(self):
            return self.getTypedRuleContext(MySQLParser.IntervalContext,0)


        def CURRENT_SYMBOL(self):
            return self.getToken(MySQLParser.CURRENT_SYMBOL, 0)

        def ROW_SYMBOL(self):
            return self.getToken(MySQLParser.ROW_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_windowFrameStart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowFrameStart" ):
                listener.enterWindowFrameStart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowFrameStart" ):
                listener.exitWindowFrameStart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowFrameStart" ):
                return visitor.visitWindowFrameStart(self)
            else:
                return visitor.visitChildren(self)




    def windowFrameStart(self):

        localctx = MySQLParser.WindowFrameStartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 346, self.RULE_windowFrameStart)
        try:
            self.state = 3540
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [706]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3526
                self.match(MySQLParser.UNBOUNDED_SYMBOL)
                self.state = 3527
                self.match(MySQLParser.PRECEDING_SYMBOL)
                pass
            elif token in [3, 4, 5, 46, 47]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3528
                self.ulonglongNumber()
                self.state = 3529
                self.match(MySQLParser.PRECEDING_SYMBOL)
                pass
            elif token in [43]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3531
                self.match(MySQLParser.PARAM_MARKER)
                self.state = 3532
                self.match(MySQLParser.PRECEDING_SYMBOL)
                pass
            elif token in [278]:
                self.enterOuterAlt(localctx, 4)
                self.state = 3533
                self.match(MySQLParser.INTERVAL_SYMBOL)
                self.state = 3534
                self.expr(0)
                self.state = 3535
                self.interval()
                self.state = 3536
                self.match(MySQLParser.PRECEDING_SYMBOL)
                pass
            elif token in [143]:
                self.enterOuterAlt(localctx, 5)
                self.state = 3538
                self.match(MySQLParser.CURRENT_SYMBOL)
                self.state = 3539
                self.match(MySQLParser.ROW_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowFrameBetweenContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BETWEEN_SYMBOL(self):
            return self.getToken(MySQLParser.BETWEEN_SYMBOL, 0)

        def windowFrameBound(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.WindowFrameBoundContext)
            else:
                return self.getTypedRuleContext(MySQLParser.WindowFrameBoundContext,i)


        def AND_SYMBOL(self):
            return self.getToken(MySQLParser.AND_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_windowFrameBetween

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowFrameBetween" ):
                listener.enterWindowFrameBetween(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowFrameBetween" ):
                listener.exitWindowFrameBetween(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowFrameBetween" ):
                return visitor.visitWindowFrameBetween(self)
            else:
                return visitor.visitChildren(self)




    def windowFrameBetween(self):

        localctx = MySQLParser.WindowFrameBetweenContext(self, self._ctx, self.state)
        self.enterRule(localctx, 348, self.RULE_windowFrameBetween)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3542
            self.match(MySQLParser.BETWEEN_SYMBOL)
            self.state = 3543
            self.windowFrameBound()
            self.state = 3544
            self.match(MySQLParser.AND_SYMBOL)
            self.state = 3545
            self.windowFrameBound()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowFrameBoundContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def windowFrameStart(self):
            return self.getTypedRuleContext(MySQLParser.WindowFrameStartContext,0)


        def UNBOUNDED_SYMBOL(self):
            return self.getToken(MySQLParser.UNBOUNDED_SYMBOL, 0)

        def FOLLOWING_SYMBOL(self):
            return self.getToken(MySQLParser.FOLLOWING_SYMBOL, 0)

        def ulonglongNumber(self):
            return self.getTypedRuleContext(MySQLParser.UlonglongNumberContext,0)


        def PARAM_MARKER(self):
            return self.getToken(MySQLParser.PARAM_MARKER, 0)

        def INTERVAL_SYMBOL(self):
            return self.getToken(MySQLParser.INTERVAL_SYMBOL, 0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def interval(self):
            return self.getTypedRuleContext(MySQLParser.IntervalContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_windowFrameBound

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowFrameBound" ):
                listener.enterWindowFrameBound(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowFrameBound" ):
                listener.exitWindowFrameBound(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowFrameBound" ):
                return visitor.visitWindowFrameBound(self)
            else:
                return visitor.visitChildren(self)




    def windowFrameBound(self):

        localctx = MySQLParser.WindowFrameBoundContext(self, self._ctx, self.state)
        self.enterRule(localctx, 350, self.RULE_windowFrameBound)
        try:
            self.state = 3560
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,329,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3547
                self.windowFrameStart()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3548
                self.match(MySQLParser.UNBOUNDED_SYMBOL)
                self.state = 3549
                self.match(MySQLParser.FOLLOWING_SYMBOL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3550
                self.ulonglongNumber()
                self.state = 3551
                self.match(MySQLParser.FOLLOWING_SYMBOL)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 3553
                self.match(MySQLParser.PARAM_MARKER)
                self.state = 3554
                self.match(MySQLParser.FOLLOWING_SYMBOL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 3555
                self.match(MySQLParser.INTERVAL_SYMBOL)
                self.state = 3556
                self.expr(0)
                self.state = 3557
                self.interval()
                self.state = 3558
                self.match(MySQLParser.FOLLOWING_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowFrameExclusionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXCLUDE_SYMBOL(self):
            return self.getToken(MySQLParser.EXCLUDE_SYMBOL, 0)

        def CURRENT_SYMBOL(self):
            return self.getToken(MySQLParser.CURRENT_SYMBOL, 0)

        def ROW_SYMBOL(self):
            return self.getToken(MySQLParser.ROW_SYMBOL, 0)

        def GROUP_SYMBOL(self):
            return self.getToken(MySQLParser.GROUP_SYMBOL, 0)

        def TIES_SYMBOL(self):
            return self.getToken(MySQLParser.TIES_SYMBOL, 0)

        def NO_SYMBOL(self):
            return self.getToken(MySQLParser.NO_SYMBOL, 0)

        def OTHERS_SYMBOL(self):
            return self.getToken(MySQLParser.OTHERS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_windowFrameExclusion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowFrameExclusion" ):
                listener.enterWindowFrameExclusion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowFrameExclusion" ):
                listener.exitWindowFrameExclusion(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowFrameExclusion" ):
                return visitor.visitWindowFrameExclusion(self)
            else:
                return visitor.visitChildren(self)




    def windowFrameExclusion(self):

        localctx = MySQLParser.WindowFrameExclusionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 352, self.RULE_windowFrameExclusion)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3562
            self.match(MySQLParser.EXCLUDE_SYMBOL)
            self.state = 3569
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [143]:
                self.state = 3563
                self.match(MySQLParser.CURRENT_SYMBOL)
                self.state = 3564
                self.match(MySQLParser.ROW_SYMBOL)
                pass
            elif token in [249]:
                self.state = 3565
                self.match(MySQLParser.GROUP_SYMBOL)
                pass
            elif token in [705]:
                self.state = 3566
                self.match(MySQLParser.TIES_SYMBOL)
                pass
            elif token in [392]:
                self.state = 3567
                self.match(MySQLParser.NO_SYMBOL)
                self.state = 3568
                self.match(MySQLParser.OTHERS_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def commonTableExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.CommonTableExpressionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.CommonTableExpressionContext,i)


        def RECURSIVE_SYMBOL(self):
            return self.getToken(MySQLParser.RECURSIVE_SYMBOL, 0)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_withClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithClause" ):
                listener.enterWithClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithClause" ):
                listener.exitWithClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWithClause" ):
                return visitor.visitWithClause(self)
            else:
                return visitor.visitChildren(self)




    def withClause(self):

        localctx = MySQLParser.WithClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 354, self.RULE_withClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3571
            self.match(MySQLParser.WITH_SYMBOL)
            self.state = 3573
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,331,self._ctx)
            if la_ == 1:
                self.state = 3572
                self.match(MySQLParser.RECURSIVE_SYMBOL)


            self.state = 3575
            self.commonTableExpression()
            self.state = 3580
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,332,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 3576
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 3577
                    self.commonTableExpression() 
                self.state = 3582
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,332,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CommonTableExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def AS_SYMBOL(self):
            return self.getToken(MySQLParser.AS_SYMBOL, 0)

        def subquery(self):
            return self.getTypedRuleContext(MySQLParser.SubqueryContext,0)


        def columnInternalRefList(self):
            return self.getTypedRuleContext(MySQLParser.ColumnInternalRefListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_commonTableExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCommonTableExpression" ):
                listener.enterCommonTableExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCommonTableExpression" ):
                listener.exitCommonTableExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCommonTableExpression" ):
                return visitor.visitCommonTableExpression(self)
            else:
                return visitor.visitChildren(self)




    def commonTableExpression(self):

        localctx = MySQLParser.CommonTableExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 356, self.RULE_commonTableExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3583
            self.identifier()
            self.state = 3585
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==32:
                self.state = 3584
                self.columnInternalRefList()


            self.state = 3587
            self.match(MySQLParser.AS_SYMBOL)
            self.state = 3588
            self.subquery()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupByClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GROUP_SYMBOL(self):
            return self.getToken(MySQLParser.GROUP_SYMBOL, 0)

        def BY_SYMBOL(self):
            return self.getToken(MySQLParser.BY_SYMBOL, 0)

        def orderList(self):
            return self.getTypedRuleContext(MySQLParser.OrderListContext,0)


        def olapOption(self):
            return self.getTypedRuleContext(MySQLParser.OlapOptionContext,0)


        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def groupList(self):
            return self.getTypedRuleContext(MySQLParser.GroupListContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def ROLLUP_SYMBOL(self):
            return self.getToken(MySQLParser.ROLLUP_SYMBOL, 0)

        def CUBE_SYMBOL(self):
            return self.getToken(MySQLParser.CUBE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_groupByClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupByClause" ):
                listener.enterGroupByClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupByClause" ):
                listener.exitGroupByClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupByClause" ):
                return visitor.visitGroupByClause(self)
            else:
                return visitor.visitChildren(self)




    def groupByClause(self):

        localctx = MySQLParser.GroupByClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 358, self.RULE_groupByClause)
        self._la = 0 # Token type
        try:
            self.state = 3604
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,335,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3590
                self.match(MySQLParser.GROUP_SYMBOL)
                self.state = 3591
                self.match(MySQLParser.BY_SYMBOL)
                self.state = 3592
                self.orderList()
                self.state = 3594
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,334,self._ctx)
                if la_ == 1:
                    self.state = 3593
                    self.olapOption()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3596
                if not self.isServerVersionGe80032():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80032()")
                self.state = 3597
                self.match(MySQLParser.GROUP_SYMBOL)
                self.state = 3598
                self.match(MySQLParser.BY_SYMBOL)
                self.state = 3599
                _la = self._input.LA(1)
                if not(_la==141 or _la==497):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3600
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 3601
                self.groupList()
                self.state = 3602
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OlapOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def ROLLUP_SYMBOL(self):
            return self.getToken(MySQLParser.ROLLUP_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_olapOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOlapOption" ):
                listener.enterOlapOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOlapOption" ):
                listener.exitOlapOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOlapOption" ):
                return visitor.visitOlapOption(self)
            else:
                return visitor.visitChildren(self)




    def olapOption(self):

        localctx = MySQLParser.OlapOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 360, self.RULE_olapOption)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3606
            self.match(MySQLParser.WITH_SYMBOL)
            self.state = 3607
            self.match(MySQLParser.ROLLUP_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDER_SYMBOL(self):
            return self.getToken(MySQLParser.ORDER_SYMBOL, 0)

        def BY_SYMBOL(self):
            return self.getToken(MySQLParser.BY_SYMBOL, 0)

        def orderList(self):
            return self.getTypedRuleContext(MySQLParser.OrderListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_orderClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderClause" ):
                listener.enterOrderClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderClause" ):
                listener.exitOrderClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrderClause" ):
                return visitor.visitOrderClause(self)
            else:
                return visitor.visitChildren(self)




    def orderClause(self):

        localctx = MySQLParser.OrderClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 362, self.RULE_orderClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3609
            self.match(MySQLParser.ORDER_SYMBOL)
            self.state = 3610
            self.match(MySQLParser.BY_SYMBOL)
            self.state = 3611
            self.orderList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DirectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASC_SYMBOL(self):
            return self.getToken(MySQLParser.ASC_SYMBOL, 0)

        def DESC_SYMBOL(self):
            return self.getToken(MySQLParser.DESC_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_direction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirection" ):
                listener.enterDirection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirection" ):
                listener.exitDirection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDirection" ):
                return visitor.visitDirection(self)
            else:
                return visitor.visitChildren(self)




    def direction(self):

        localctx = MySQLParser.DirectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 364, self.RULE_direction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3613
            _la = self._input.LA(1)
            if not(_la==64 or _la==172):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FromClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FROM_SYMBOL(self):
            return self.getToken(MySQLParser.FROM_SYMBOL, 0)

        def DUAL_SYMBOL(self):
            return self.getToken(MySQLParser.DUAL_SYMBOL, 0)

        def tableReferenceList(self):
            return self.getTypedRuleContext(MySQLParser.TableReferenceListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_fromClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFromClause" ):
                listener.enterFromClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFromClause" ):
                listener.exitFromClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFromClause" ):
                return visitor.visitFromClause(self)
            else:
                return visitor.visitChildren(self)




    def fromClause(self):

        localctx = MySQLParser.FromClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 366, self.RULE_fromClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3615
            self.match(MySQLParser.FROM_SYMBOL)
            self.state = 3618
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,336,self._ctx)
            if la_ == 1:
                self.state = 3616
                self.match(MySQLParser.DUAL_SYMBOL)
                pass

            elif la_ == 2:
                self.state = 3617
                self.tableReferenceList()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableReferenceListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableReference(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.TableReferenceContext)
            else:
                return self.getTypedRuleContext(MySQLParser.TableReferenceContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_tableReferenceList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableReferenceList" ):
                listener.enterTableReferenceList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableReferenceList" ):
                listener.exitTableReferenceList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableReferenceList" ):
                return visitor.visitTableReferenceList(self)
            else:
                return visitor.visitChildren(self)




    def tableReferenceList(self):

        localctx = MySQLParser.TableReferenceListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 368, self.RULE_tableReferenceList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3620
            self.tableReference()
            self.state = 3625
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,337,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 3621
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 3622
                    self.tableReference() 
                self.state = 3627
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,337,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableValueConstructorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VALUES_SYMBOL(self):
            return self.getToken(MySQLParser.VALUES_SYMBOL, 0)

        def rowValueExplicit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.RowValueExplicitContext)
            else:
                return self.getTypedRuleContext(MySQLParser.RowValueExplicitContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_tableValueConstructor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableValueConstructor" ):
                listener.enterTableValueConstructor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableValueConstructor" ):
                listener.exitTableValueConstructor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableValueConstructor" ):
                return visitor.visitTableValueConstructor(self)
            else:
                return visitor.visitChildren(self)




    def tableValueConstructor(self):

        localctx = MySQLParser.TableValueConstructorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 370, self.RULE_tableValueConstructor)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3628
            self.match(MySQLParser.VALUES_SYMBOL)
            self.state = 3629
            self.rowValueExplicit()
            self.state = 3634
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,338,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 3630
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 3631
                    self.rowValueExplicit() 
                self.state = 3636
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,338,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExplicitTableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_SYMBOL, 0)

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_explicitTable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExplicitTable" ):
                listener.enterExplicitTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExplicitTable" ):
                listener.exitExplicitTable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExplicitTable" ):
                return visitor.visitExplicitTable(self)
            else:
                return visitor.visitChildren(self)




    def explicitTable(self):

        localctx = MySQLParser.ExplicitTableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 372, self.RULE_explicitTable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3637
            self.match(MySQLParser.TABLE_SYMBOL)
            self.state = 3638
            self.tableRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RowValueExplicitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROW_SYMBOL(self):
            return self.getToken(MySQLParser.ROW_SYMBOL, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def values(self):
            return self.getTypedRuleContext(MySQLParser.ValuesContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_rowValueExplicit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRowValueExplicit" ):
                listener.enterRowValueExplicit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRowValueExplicit" ):
                listener.exitRowValueExplicit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRowValueExplicit" ):
                return visitor.visitRowValueExplicit(self)
            else:
                return visitor.visitChildren(self)




    def rowValueExplicit(self):

        localctx = MySQLParser.RowValueExplicitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 374, self.RULE_rowValueExplicit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3640
            self.match(MySQLParser.ROW_SYMBOL)
            self.state = 3641
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 3643
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,339,self._ctx)
            if la_ == 1:
                self.state = 3642
                self.values()


            self.state = 3645
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def querySpecOption(self):
            return self.getTypedRuleContext(MySQLParser.QuerySpecOptionContext,0)


        def SQL_NO_CACHE_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_NO_CACHE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_selectOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectOption" ):
                listener.enterSelectOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectOption" ):
                listener.exitSelectOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectOption" ):
                return visitor.visitSelectOption(self)
            else:
                return visitor.visitChildren(self)




    def selectOption(self):

        localctx = MySQLParser.SelectOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 376, self.RULE_selectOption)
        try:
            self.state = 3649
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [57, 180, 255, 542, 543, 544, 546, 565]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3647
                self.querySpecOption()
                pass
            elif token in [545]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3648
                self.match(MySQLParser.SQL_NO_CACHE_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LockingClauseListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lockingClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.LockingClauseContext)
            else:
                return self.getTypedRuleContext(MySQLParser.LockingClauseContext,i)


        def getRuleIndex(self):
            return MySQLParser.RULE_lockingClauseList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLockingClauseList" ):
                listener.enterLockingClauseList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLockingClauseList" ):
                listener.exitLockingClauseList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLockingClauseList" ):
                return visitor.visitLockingClauseList(self)
            else:
                return visitor.visitChildren(self)




    def lockingClauseList(self):

        localctx = MySQLParser.LockingClauseListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 378, self.RULE_lockingClauseList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3651
            if not self.isServerVersionGe80031():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.isServerVersionGe80031()")
            self.state = 3653 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 3652
                self.lockingClause()
                self.state = 3655 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==232 or _la==314):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LockingClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def lockStrengh(self):
            return self.getTypedRuleContext(MySQLParser.LockStrenghContext,0)


        def OF_SYMBOL(self):
            return self.getToken(MySQLParser.OF_SYMBOL, 0)

        def tableAliasRefList(self):
            return self.getTypedRuleContext(MySQLParser.TableAliasRefListContext,0)


        def lockedRowAction(self):
            return self.getTypedRuleContext(MySQLParser.LockedRowActionContext,0)


        def LOCK_SYMBOL(self):
            return self.getToken(MySQLParser.LOCK_SYMBOL, 0)

        def IN_SYMBOL(self):
            return self.getToken(MySQLParser.IN_SYMBOL, 0)

        def SHARE_SYMBOL(self):
            return self.getToken(MySQLParser.SHARE_SYMBOL, 0)

        def MODE_SYMBOL(self):
            return self.getToken(MySQLParser.MODE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_lockingClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLockingClause" ):
                listener.enterLockingClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLockingClause" ):
                listener.exitLockingClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLockingClause" ):
                return visitor.visitLockingClause(self)
            else:
                return visitor.visitChildren(self)




    def lockingClause(self):

        localctx = MySQLParser.LockingClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 380, self.RULE_lockingClause)
        self._la = 0 # Token type
        try:
            self.state = 3670
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [232]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3657
                self.match(MySQLParser.FOR_SYMBOL)
                self.state = 3658
                self.lockStrengh()
                self.state = 3661
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==676:
                    self.state = 3659
                    self.match(MySQLParser.OF_SYMBOL)
                    self.state = 3660
                    self.tableAliasRefList()


                self.state = 3664
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==677 or _la==679:
                    self.state = 3663
                    self.lockedRowAction()


                pass
            elif token in [314]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3666
                self.match(MySQLParser.LOCK_SYMBOL)
                self.state = 3667
                self.match(MySQLParser.IN_SYMBOL)
                self.state = 3668
                self.match(MySQLParser.SHARE_SYMBOL)
                self.state = 3669
                self.match(MySQLParser.MODE_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LockStrenghContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UPDATE_SYMBOL(self):
            return self.getToken(MySQLParser.UPDATE_SYMBOL, 0)

        def SHARE_SYMBOL(self):
            return self.getToken(MySQLParser.SHARE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_lockStrengh

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLockStrengh" ):
                listener.enterLockStrengh(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLockStrengh" ):
                listener.exitLockStrengh(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLockStrengh" ):
                return visitor.visitLockStrengh(self)
            else:
                return visitor.visitChildren(self)




    def lockStrengh(self):

        localctx = MySQLParser.LockStrenghContext(self, self._ctx, self.state)
        self.enterRule(localctx, 382, self.RULE_lockStrengh)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3672
            _la = self._input.LA(1)
            if not(_la==520 or _la==623):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LockedRowActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SKIP_SYMBOL(self):
            return self.getToken(MySQLParser.SKIP_SYMBOL, 0)

        def LOCKED_SYMBOL(self):
            return self.getToken(MySQLParser.LOCKED_SYMBOL, 0)

        def NOWAIT_SYMBOL(self):
            return self.getToken(MySQLParser.NOWAIT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_lockedRowAction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLockedRowAction" ):
                listener.enterLockedRowAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLockedRowAction" ):
                listener.exitLockedRowAction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLockedRowAction" ):
                return visitor.visitLockedRowAction(self)
            else:
                return visitor.visitChildren(self)




    def lockedRowAction(self):

        localctx = MySQLParser.LockedRowActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 384, self.RULE_lockedRowAction)
        try:
            self.state = 3677
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [677]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3674
                self.match(MySQLParser.SKIP_SYMBOL)
                self.state = 3675
                self.match(MySQLParser.LOCKED_SYMBOL)
                pass
            elif token in [679]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3676
                self.match(MySQLParser.NOWAIT_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectItemListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selectItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.SelectItemContext)
            else:
                return self.getTypedRuleContext(MySQLParser.SelectItemContext,i)


        def MULT_OPERATOR(self):
            return self.getToken(MySQLParser.MULT_OPERATOR, 0)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_selectItemList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectItemList" ):
                listener.enterSelectItemList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectItemList" ):
                listener.exitSelectItemList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectItemList" ):
                return visitor.visitSelectItemList(self)
            else:
                return visitor.visitChildren(self)




    def selectItemList(self):

        localctx = MySQLParser.SelectItemListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 386, self.RULE_selectItemList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3681
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,346,self._ctx)
            if la_ == 1:
                self.state = 3679
                self.selectItem()
                pass

            elif la_ == 2:
                self.state = 3680
                self.match(MySQLParser.MULT_OPERATOR)
                pass


            self.state = 3687
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,347,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 3683
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 3684
                    self.selectItem() 
                self.state = 3689
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,347,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableWild(self):
            return self.getTypedRuleContext(MySQLParser.TableWildContext,0)


        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def selectAlias(self):
            return self.getTypedRuleContext(MySQLParser.SelectAliasContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_selectItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectItem" ):
                listener.enterSelectItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectItem" ):
                listener.exitSelectItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectItem" ):
                return visitor.visitSelectItem(self)
            else:
                return visitor.visitChildren(self)




    def selectItem(self):

        localctx = MySQLParser.SelectItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 388, self.RULE_selectItem)
        try:
            self.state = 3695
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,349,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3690
                self.tableWild()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3691
                self.expr(0)
                self.state = 3693
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,348,self._ctx)
                if la_ == 1:
                    self.state = 3692
                    self.selectAlias()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectAliasContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def AS_SYMBOL(self):
            return self.getToken(MySQLParser.AS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_selectAlias

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectAlias" ):
                listener.enterSelectAlias(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectAlias" ):
                listener.exitSelectAlias(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectAlias" ):
                return visitor.visitSelectAlias(self)
            else:
                return visitor.visitChildren(self)




    def selectAlias(self):

        localctx = MySQLParser.SelectAliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 390, self.RULE_selectAlias)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3698
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,350,self._ctx)
            if la_ == 1:
                self.state = 3697
                self.match(MySQLParser.AS_SYMBOL)


            self.state = 3702
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,351,self._ctx)
            if la_ == 1:
                self.state = 3700
                self.identifier()
                pass

            elif la_ == 2:
                self.state = 3701
                self.textStringLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhereClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHERE_SYMBOL(self):
            return self.getToken(MySQLParser.WHERE_SYMBOL, 0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_whereClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhereClause" ):
                listener.enterWhereClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhereClause" ):
                listener.exitWhereClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhereClause" ):
                return visitor.visitWhereClause(self)
            else:
                return visitor.visitChildren(self)




    def whereClause(self):

        localctx = MySQLParser.WhereClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 392, self.RULE_whereClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3704
            self.match(MySQLParser.WHERE_SYMBOL)
            self.state = 3705
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableFactor(self):
            return self.getTypedRuleContext(MySQLParser.TableFactorContext,0)


        def OPEN_CURLY_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_CURLY_SYMBOL, 0)

        def escapedTableReference(self):
            return self.getTypedRuleContext(MySQLParser.EscapedTableReferenceContext,0)


        def CLOSE_CURLY_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_CURLY_SYMBOL, 0)

        def joinedTable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.JoinedTableContext)
            else:
                return self.getTypedRuleContext(MySQLParser.JoinedTableContext,i)


        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def OJ_SYMBOL(self):
            return self.getToken(MySQLParser.OJ_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_tableReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableReference" ):
                listener.enterTableReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableReference" ):
                listener.exitTableReference(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableReference" ):
                return visitor.visitTableReference(self)
            else:
                return visitor.visitChildren(self)




    def tableReference(self):

        localctx = MySQLParser.TableReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 394, self.RULE_tableReference)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3717
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,353,self._ctx)
            if la_ == 1:
                self.state = 3707
                self.tableFactor()
                pass

            elif la_ == 2:
                self.state = 3708
                self.match(MySQLParser.OPEN_CURLY_SYMBOL)
                self.state = 3712
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,352,self._ctx)
                if la_ == 1:
                    self.state = 3709
                    if not self.isServerVersionGe80017():
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.isServerVersionGe80017()")
                    self.state = 3710
                    self.identifier()
                    pass

                elif la_ == 2:
                    self.state = 3711
                    self.match(MySQLParser.OJ_SYMBOL)
                    pass


                self.state = 3714
                self.escapedTableReference()
                self.state = 3715
                self.match(MySQLParser.CLOSE_CURLY_SYMBOL)
                pass


            self.state = 3722
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,354,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 3719
                    self.joinedTable() 
                self.state = 3724
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,354,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EscapedTableReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableFactor(self):
            return self.getTypedRuleContext(MySQLParser.TableFactorContext,0)


        def joinedTable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.JoinedTableContext)
            else:
                return self.getTypedRuleContext(MySQLParser.JoinedTableContext,i)


        def getRuleIndex(self):
            return MySQLParser.RULE_escapedTableReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEscapedTableReference" ):
                listener.enterEscapedTableReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEscapedTableReference" ):
                listener.exitEscapedTableReference(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEscapedTableReference" ):
                return visitor.visitEscapedTableReference(self)
            else:
                return visitor.visitChildren(self)




    def escapedTableReference(self):

        localctx = MySQLParser.EscapedTableReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 396, self.RULE_escapedTableReference)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3725
            self.tableFactor()
            self.state = 3729
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==140 or ((((_la - 271)) & ~0x3f) == 0 and ((1 << (_la - 271)) & 2148532225) != 0) or _la==382 or _la==495 or _la==565:
                self.state = 3726
                self.joinedTable()
                self.state = 3731
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinedTableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def innerJoinType(self):
            return self.getTypedRuleContext(MySQLParser.InnerJoinTypeContext,0)


        def tableReference(self):
            return self.getTypedRuleContext(MySQLParser.TableReferenceContext,0)


        def ON_SYMBOL(self):
            return self.getToken(MySQLParser.ON_SYMBOL, 0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def USING_SYMBOL(self):
            return self.getToken(MySQLParser.USING_SYMBOL, 0)

        def identifierListWithParentheses(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierListWithParenthesesContext,0)


        def outerJoinType(self):
            return self.getTypedRuleContext(MySQLParser.OuterJoinTypeContext,0)


        def naturalJoinType(self):
            return self.getTypedRuleContext(MySQLParser.NaturalJoinTypeContext,0)


        def tableFactor(self):
            return self.getTypedRuleContext(MySQLParser.TableFactorContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_joinedTable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinedTable" ):
                listener.enterJoinedTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinedTable" ):
                listener.exitJoinedTable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoinedTable" ):
                return visitor.visitJoinedTable(self)
            else:
                return visitor.visitChildren(self)




    def joinedTable(self):

        localctx = MySQLParser.JoinedTableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 398, self.RULE_joinedTable)
        try:
            self.state = 3751
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [140, 271, 291, 565]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3732
                self.innerJoinType()
                self.state = 3733
                self.tableReference()
                self.state = 3738
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,356,self._ctx)
                if la_ == 1:
                    self.state = 3734
                    self.match(MySQLParser.ON_SYMBOL)
                    self.state = 3735
                    self.expr(0)

                elif la_ == 2:
                    self.state = 3736
                    self.match(MySQLParser.USING_SYMBOL)
                    self.state = 3737
                    self.identifierListWithParentheses()


                pass
            elif token in [302, 495]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3740
                self.outerJoinType()
                self.state = 3741
                self.tableReference()
                self.state = 3746
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [401]:
                    self.state = 3742
                    self.match(MySQLParser.ON_SYMBOL)
                    self.state = 3743
                    self.expr(0)
                    pass
                elif token in [630]:
                    self.state = 3744
                    self.match(MySQLParser.USING_SYMBOL)
                    self.state = 3745
                    self.identifierListWithParentheses()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [382]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3748
                self.naturalJoinType()
                self.state = 3749
                self.tableFactor()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaturalJoinTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NATURAL_SYMBOL(self):
            return self.getToken(MySQLParser.NATURAL_SYMBOL, 0)

        def JOIN_SYMBOL(self):
            return self.getToken(MySQLParser.JOIN_SYMBOL, 0)

        def INNER_SYMBOL(self):
            return self.getToken(MySQLParser.INNER_SYMBOL, 0)

        def LEFT_SYMBOL(self):
            return self.getToken(MySQLParser.LEFT_SYMBOL, 0)

        def RIGHT_SYMBOL(self):
            return self.getToken(MySQLParser.RIGHT_SYMBOL, 0)

        def OUTER_SYMBOL(self):
            return self.getToken(MySQLParser.OUTER_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_naturalJoinType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaturalJoinType" ):
                listener.enterNaturalJoinType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaturalJoinType" ):
                listener.exitNaturalJoinType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaturalJoinType" ):
                return visitor.visitNaturalJoinType(self)
            else:
                return visitor.visitChildren(self)




    def naturalJoinType(self):

        localctx = MySQLParser.NaturalJoinTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 400, self.RULE_naturalJoinType)
        self._la = 0 # Token type
        try:
            self.state = 3764
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,361,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3753
                self.match(MySQLParser.NATURAL_SYMBOL)
                self.state = 3755
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==271:
                    self.state = 3754
                    self.match(MySQLParser.INNER_SYMBOL)


                self.state = 3757
                self.match(MySQLParser.JOIN_SYMBOL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3758
                self.match(MySQLParser.NATURAL_SYMBOL)
                self.state = 3759
                _la = self._input.LA(1)
                if not(_la==302 or _la==495):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3761
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==413:
                    self.state = 3760
                    self.match(MySQLParser.OUTER_SYMBOL)


                self.state = 3763
                self.match(MySQLParser.JOIN_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InnerJoinTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # Token

        def JOIN_SYMBOL(self):
            return self.getToken(MySQLParser.JOIN_SYMBOL, 0)

        def INNER_SYMBOL(self):
            return self.getToken(MySQLParser.INNER_SYMBOL, 0)

        def CROSS_SYMBOL(self):
            return self.getToken(MySQLParser.CROSS_SYMBOL, 0)

        def STRAIGHT_JOIN_SYMBOL(self):
            return self.getToken(MySQLParser.STRAIGHT_JOIN_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_innerJoinType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInnerJoinType" ):
                listener.enterInnerJoinType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInnerJoinType" ):
                listener.exitInnerJoinType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInnerJoinType" ):
                return visitor.visitInnerJoinType(self)
            else:
                return visitor.visitChildren(self)




    def innerJoinType(self):

        localctx = MySQLParser.InnerJoinTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 402, self.RULE_innerJoinType)
        self._la = 0 # Token type
        try:
            self.state = 3771
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [140, 271, 291]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3767
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==140 or _la==271:
                    self.state = 3766
                    localctx.type_ = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==140 or _la==271):
                        localctx.type_ = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 3769
                self.match(MySQLParser.JOIN_SYMBOL)
                pass
            elif token in [565]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3770
                localctx.type_ = self.match(MySQLParser.STRAIGHT_JOIN_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OuterJoinTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # Token

        def JOIN_SYMBOL(self):
            return self.getToken(MySQLParser.JOIN_SYMBOL, 0)

        def LEFT_SYMBOL(self):
            return self.getToken(MySQLParser.LEFT_SYMBOL, 0)

        def RIGHT_SYMBOL(self):
            return self.getToken(MySQLParser.RIGHT_SYMBOL, 0)

        def OUTER_SYMBOL(self):
            return self.getToken(MySQLParser.OUTER_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_outerJoinType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOuterJoinType" ):
                listener.enterOuterJoinType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOuterJoinType" ):
                listener.exitOuterJoinType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOuterJoinType" ):
                return visitor.visitOuterJoinType(self)
            else:
                return visitor.visitChildren(self)




    def outerJoinType(self):

        localctx = MySQLParser.OuterJoinTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 404, self.RULE_outerJoinType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3773
            localctx.type_ = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==302 or _la==495):
                localctx.type_ = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 3775
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==413:
                self.state = 3774
                self.match(MySQLParser.OUTER_SYMBOL)


            self.state = 3777
            self.match(MySQLParser.JOIN_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableFactorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singleTable(self):
            return self.getTypedRuleContext(MySQLParser.SingleTableContext,0)


        def singleTableParens(self):
            return self.getTypedRuleContext(MySQLParser.SingleTableParensContext,0)


        def derivedTable(self):
            return self.getTypedRuleContext(MySQLParser.DerivedTableContext,0)


        def tableReferenceListParens(self):
            return self.getTypedRuleContext(MySQLParser.TableReferenceListParensContext,0)


        def tableFunction(self):
            return self.getTypedRuleContext(MySQLParser.TableFunctionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_tableFactor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableFactor" ):
                listener.enterTableFactor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableFactor" ):
                listener.exitTableFactor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableFactor" ):
                return visitor.visitTableFactor(self)
            else:
                return visitor.visitChildren(self)




    def tableFactor(self):

        localctx = MySQLParser.TableFactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 406, self.RULE_tableFactor)
        try:
            self.state = 3785
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,365,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3779
                self.singleTable()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3780
                self.singleTableParens()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3781
                self.derivedTable()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 3782
                self.tableReferenceListParens()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 3783
                if not self.isServerVersionGe80004():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80004()")
                self.state = 3784
                self.tableFunction()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleTableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def usePartition(self):
            return self.getTypedRuleContext(MySQLParser.UsePartitionContext,0)


        def tableAlias(self):
            return self.getTypedRuleContext(MySQLParser.TableAliasContext,0)


        def indexHintList(self):
            return self.getTypedRuleContext(MySQLParser.IndexHintListContext,0)


        def tablesampleClause(self):
            return self.getTypedRuleContext(MySQLParser.TablesampleClauseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_singleTable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingleTable" ):
                listener.enterSingleTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingleTable" ):
                listener.exitSingleTable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSingleTable" ):
                return visitor.visitSingleTable(self)
            else:
                return visitor.visitChildren(self)




    def singleTable(self):

        localctx = MySQLParser.SingleTableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 408, self.RULE_singleTable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3787
            self.tableRef()
            self.state = 3789
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,366,self._ctx)
            if la_ == 1:
                self.state = 3788
                self.usePartition()


            self.state = 3792
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,367,self._ctx)
            if la_ == 1:
                self.state = 3791
                self.tableAlias()


            self.state = 3795
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,368,self._ctx)
            if la_ == 1:
                self.state = 3794
                self.indexHintList()


            self.state = 3798
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,369,self._ctx)
            if la_ == 1:
                self.state = 3797
                self.tablesampleClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleTableParensContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def singleTable(self):
            return self.getTypedRuleContext(MySQLParser.SingleTableContext,0)


        def singleTableParens(self):
            return self.getTypedRuleContext(MySQLParser.SingleTableParensContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_singleTableParens

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingleTableParens" ):
                listener.enterSingleTableParens(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingleTableParens" ):
                listener.exitSingleTableParens(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSingleTableParens" ):
                return visitor.visitSingleTableParens(self)
            else:
                return visitor.visitChildren(self)




    def singleTableParens(self):

        localctx = MySQLParser.SingleTableParensContext(self, self._ctx, self.state)
        self.enterRule(localctx, 410, self.RULE_singleTableParens)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3800
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 3803
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,370,self._ctx)
            if la_ == 1:
                self.state = 3801
                self.singleTable()
                pass

            elif la_ == 2:
                self.state = 3802
                self.singleTableParens()
                pass


            self.state = 3805
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DerivedTableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subquery(self):
            return self.getTypedRuleContext(MySQLParser.SubqueryContext,0)


        def tableAlias(self):
            return self.getTypedRuleContext(MySQLParser.TableAliasContext,0)


        def columnInternalRefList(self):
            return self.getTypedRuleContext(MySQLParser.ColumnInternalRefListContext,0)


        def LATERAL_SYMBOL(self):
            return self.getToken(MySQLParser.LATERAL_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_derivedTable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDerivedTable" ):
                listener.enterDerivedTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDerivedTable" ):
                listener.exitDerivedTable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDerivedTable" ):
                return visitor.visitDerivedTable(self)
            else:
                return visitor.visitChildren(self)




    def derivedTable(self):

        localctx = MySQLParser.DerivedTableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 412, self.RULE_derivedTable)
        try:
            self.state = 3823
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,375,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3807
                self.subquery()
                self.state = 3809
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,371,self._ctx)
                if la_ == 1:
                    self.state = 3808
                    self.tableAlias()


                self.state = 3812
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,372,self._ctx)
                if la_ == 1:
                    self.state = 3811
                    self.columnInternalRefList()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3814
                if not self.isServerVersionGe80014():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80014()")
                self.state = 3815
                self.match(MySQLParser.LATERAL_SYMBOL)
                self.state = 3816
                self.subquery()
                self.state = 3818
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,373,self._ctx)
                if la_ == 1:
                    self.state = 3817
                    self.tableAlias()


                self.state = 3821
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,374,self._ctx)
                if la_ == 1:
                    self.state = 3820
                    self.columnInternalRefList()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableReferenceListParensContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def tableReferenceList(self):
            return self.getTypedRuleContext(MySQLParser.TableReferenceListContext,0)


        def tableReferenceListParens(self):
            return self.getTypedRuleContext(MySQLParser.TableReferenceListParensContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_tableReferenceListParens

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableReferenceListParens" ):
                listener.enterTableReferenceListParens(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableReferenceListParens" ):
                listener.exitTableReferenceListParens(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableReferenceListParens" ):
                return visitor.visitTableReferenceListParens(self)
            else:
                return visitor.visitChildren(self)




    def tableReferenceListParens(self):

        localctx = MySQLParser.TableReferenceListParensContext(self, self._ctx, self.state)
        self.enterRule(localctx, 414, self.RULE_tableReferenceListParens)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3825
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 3828
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,376,self._ctx)
            if la_ == 1:
                self.state = 3826
                self.tableReferenceList()
                pass

            elif la_ == 2:
                self.state = 3827
                self.tableReferenceListParens()
                pass


            self.state = 3830
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableFunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def JSON_TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.JSON_TABLE_SYMBOL, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def COMMA_SYMBOL(self):
            return self.getToken(MySQLParser.COMMA_SYMBOL, 0)

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def columnsClause(self):
            return self.getTypedRuleContext(MySQLParser.ColumnsClauseContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def tableAlias(self):
            return self.getTypedRuleContext(MySQLParser.TableAliasContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_tableFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableFunction" ):
                listener.enterTableFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableFunction" ):
                listener.exitTableFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableFunction" ):
                return visitor.visitTableFunction(self)
            else:
                return visitor.visitChildren(self)




    def tableFunction(self):

        localctx = MySQLParser.TableFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 416, self.RULE_tableFunction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3832
            self.match(MySQLParser.JSON_TABLE_SYMBOL)
            self.state = 3833
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 3834
            self.expr(0)
            self.state = 3835
            self.match(MySQLParser.COMMA_SYMBOL)
            self.state = 3836
            self.textStringLiteral()
            self.state = 3837
            self.columnsClause()
            self.state = 3838
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
            self.state = 3840
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,377,self._ctx)
            if la_ == 1:
                self.state = 3839
                self.tableAlias()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnsClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLUMNS_SYMBOL(self):
            return self.getToken(MySQLParser.COLUMNS_SYMBOL, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def jtColumn(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.JtColumnContext)
            else:
                return self.getTypedRuleContext(MySQLParser.JtColumnContext,i)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_columnsClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnsClause" ):
                listener.enterColumnsClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnsClause" ):
                listener.exitColumnsClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnsClause" ):
                return visitor.visitColumnsClause(self)
            else:
                return visitor.visitChildren(self)




    def columnsClause(self):

        localctx = MySQLParser.ColumnsClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 418, self.RULE_columnsClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3842
            self.match(MySQLParser.COLUMNS_SYMBOL)
            self.state = 3843
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 3844
            self.jtColumn()
            self.state = 3849
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 3845
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 3846
                self.jtColumn()
                self.state = 3851
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 3852
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JtColumnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def ORDINALITY_SYMBOL(self):
            return self.getToken(MySQLParser.ORDINALITY_SYMBOL, 0)

        def dataType(self):
            return self.getTypedRuleContext(MySQLParser.DataTypeContext,0)


        def PATH_SYMBOL(self):
            return self.getToken(MySQLParser.PATH_SYMBOL, 0)

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def collate(self):
            return self.getTypedRuleContext(MySQLParser.CollateContext,0)


        def EXISTS_SYMBOL(self):
            return self.getToken(MySQLParser.EXISTS_SYMBOL, 0)

        def onEmptyOrErrorJsonTable(self):
            return self.getTypedRuleContext(MySQLParser.OnEmptyOrErrorJsonTableContext,0)


        def NESTED_SYMBOL(self):
            return self.getToken(MySQLParser.NESTED_SYMBOL, 0)

        def columnsClause(self):
            return self.getTypedRuleContext(MySQLParser.ColumnsClauseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_jtColumn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJtColumn" ):
                listener.enterJtColumn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJtColumn" ):
                listener.exitJtColumn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJtColumn" ):
                return visitor.visitJtColumn(self)
            else:
                return visitor.visitChildren(self)




    def jtColumn(self):

        localctx = MySQLParser.JtColumnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 420, self.RULE_jtColumn)
        self._la = 0 # Token type
        try:
            self.state = 3877
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,382,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3854
                self.identifier()
                self.state = 3855
                self.match(MySQLParser.FOR_SYMBOL)
                self.state = 3856
                self.match(MySQLParser.ORDINALITY_SYMBOL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3858
                self.identifier()
                self.state = 3859
                self.dataType()
                self.state = 3862
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,379,self._ctx)
                if la_ == 1:
                    self.state = 3860
                    if not self.isServerVersionGe80014():
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.isServerVersionGe80014()")
                    self.state = 3861
                    self.collate()


                self.state = 3865
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==209:
                    self.state = 3864
                    self.match(MySQLParser.EXISTS_SYMBOL)


                self.state = 3867
                self.match(MySQLParser.PATH_SYMBOL)
                self.state = 3868
                self.textStringLiteral()
                self.state = 3870
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==166 or _la==200 or _la==395:
                    self.state = 3869
                    self.onEmptyOrErrorJsonTable()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3872
                self.match(MySQLParser.NESTED_SYMBOL)
                self.state = 3873
                self.match(MySQLParser.PATH_SYMBOL)
                self.state = 3874
                self.textStringLiteral()
                self.state = 3875
                self.columnsClause()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnEmptyOrErrorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def onEmpty(self):
            return self.getTypedRuleContext(MySQLParser.OnEmptyContext,0)


        def onError(self):
            return self.getTypedRuleContext(MySQLParser.OnErrorContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_onEmptyOrError

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnEmptyOrError" ):
                listener.enterOnEmptyOrError(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnEmptyOrError" ):
                listener.exitOnEmptyOrError(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnEmptyOrError" ):
                return visitor.visitOnEmptyOrError(self)
            else:
                return visitor.visitChildren(self)




    def onEmptyOrError(self):

        localctx = MySQLParser.OnEmptyOrErrorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 422, self.RULE_onEmptyOrError)
        self._la = 0 # Token type
        try:
            self.state = 3884
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,384,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3879
                self.onEmpty()
                self.state = 3881
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==166 or _la==200 or _la==395:
                    self.state = 3880
                    self.onError()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3883
                self.onError()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnEmptyOrErrorJsonTableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def onEmptyOrError(self):
            return self.getTypedRuleContext(MySQLParser.OnEmptyOrErrorContext,0)


        def onError(self):
            return self.getTypedRuleContext(MySQLParser.OnErrorContext,0)


        def onEmpty(self):
            return self.getTypedRuleContext(MySQLParser.OnEmptyContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_onEmptyOrErrorJsonTable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnEmptyOrErrorJsonTable" ):
                listener.enterOnEmptyOrErrorJsonTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnEmptyOrErrorJsonTable" ):
                listener.exitOnEmptyOrErrorJsonTable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnEmptyOrErrorJsonTable" ):
                return visitor.visitOnEmptyOrErrorJsonTable(self)
            else:
                return visitor.visitChildren(self)




    def onEmptyOrErrorJsonTable(self):

        localctx = MySQLParser.OnEmptyOrErrorJsonTableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 424, self.RULE_onEmptyOrErrorJsonTable)
        try:
            self.state = 3890
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,385,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3886
                self.onEmptyOrError()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3887
                self.onError()
                self.state = 3888
                self.onEmpty()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnEmptyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def jsonOnResponse(self):
            return self.getTypedRuleContext(MySQLParser.JsonOnResponseContext,0)


        def ON_SYMBOL(self):
            return self.getToken(MySQLParser.ON_SYMBOL, 0)

        def EMPTY_SYMBOL(self):
            return self.getToken(MySQLParser.EMPTY_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_onEmpty

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnEmpty" ):
                listener.enterOnEmpty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnEmpty" ):
                listener.exitOnEmpty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnEmpty" ):
                return visitor.visitOnEmpty(self)
            else:
                return visitor.visitChildren(self)




    def onEmpty(self):

        localctx = MySQLParser.OnEmptyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 426, self.RULE_onEmpty)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3892
            self.jsonOnResponse()
            self.state = 3893
            self.match(MySQLParser.ON_SYMBOL)
            self.state = 3894
            self.match(MySQLParser.EMPTY_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnErrorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def jsonOnResponse(self):
            return self.getTypedRuleContext(MySQLParser.JsonOnResponseContext,0)


        def ON_SYMBOL(self):
            return self.getToken(MySQLParser.ON_SYMBOL, 0)

        def ERROR_SYMBOL(self):
            return self.getToken(MySQLParser.ERROR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_onError

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnError" ):
                listener.enterOnError(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnError" ):
                listener.exitOnError(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnError" ):
                return visitor.visitOnError(self)
            else:
                return visitor.visitChildren(self)




    def onError(self):

        localctx = MySQLParser.OnErrorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 428, self.RULE_onError)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3896
            self.jsonOnResponse()
            self.state = 3897
            self.match(MySQLParser.ON_SYMBOL)
            self.state = 3898
            self.match(MySQLParser.ERROR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JsonOnResponseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ERROR_SYMBOL(self):
            return self.getToken(MySQLParser.ERROR_SYMBOL, 0)

        def NULL_SYMBOL(self):
            return self.getToken(MySQLParser.NULL_SYMBOL, 0)

        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_jsonOnResponse

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJsonOnResponse" ):
                listener.enterJsonOnResponse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJsonOnResponse" ):
                listener.exitJsonOnResponse(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJsonOnResponse" ):
                return visitor.visitJsonOnResponse(self)
            else:
                return visitor.visitChildren(self)




    def jsonOnResponse(self):

        localctx = MySQLParser.JsonOnResponseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 430, self.RULE_jsonOnResponse)
        try:
            self.state = 3904
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [200]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3900
                self.match(MySQLParser.ERROR_SYMBOL)
                pass
            elif token in [395]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3901
                self.match(MySQLParser.NULL_SYMBOL)
                pass
            elif token in [166]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3902
                self.match(MySQLParser.DEFAULT_SYMBOL)
                self.state = 3903
                self.textStringLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnionOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISTINCT_SYMBOL(self):
            return self.getToken(MySQLParser.DISTINCT_SYMBOL, 0)

        def ALL_SYMBOL(self):
            return self.getToken(MySQLParser.ALL_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_unionOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnionOption" ):
                listener.enterUnionOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnionOption" ):
                listener.exitUnionOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnionOption" ):
                return visitor.visitUnionOption(self)
            else:
                return visitor.visitChildren(self)




    def unionOption(self):

        localctx = MySQLParser.UnionOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 432, self.RULE_unionOption)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3906
            _la = self._input.LA(1)
            if not(_la==57 or _la==180):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableAliasContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def AS_SYMBOL(self):
            return self.getToken(MySQLParser.AS_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_tableAlias

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableAlias" ):
                listener.enterTableAlias(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableAlias" ):
                listener.exitTableAlias(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableAlias" ):
                return visitor.visitTableAlias(self)
            else:
                return visitor.visitChildren(self)




    def tableAlias(self):

        localctx = MySQLParser.TableAliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 434, self.RULE_tableAlias)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3911
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,387,self._ctx)
            if la_ == 1:
                self.state = 3908
                self.match(MySQLParser.AS_SYMBOL)

            elif la_ == 2:
                self.state = 3909
                if not self.isServerVersionGe80017():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80017()")
                self.state = 3910
                self.match(MySQLParser.EQUAL_OPERATOR)


            self.state = 3913
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndexHintListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def indexHint(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.IndexHintContext)
            else:
                return self.getTypedRuleContext(MySQLParser.IndexHintContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_indexHintList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndexHintList" ):
                listener.enterIndexHintList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndexHintList" ):
                listener.exitIndexHintList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndexHintList" ):
                return visitor.visitIndexHintList(self)
            else:
                return visitor.visitChildren(self)




    def indexHintList(self):

        localctx = MySQLParser.IndexHintListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 436, self.RULE_indexHintList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3915
            self.indexHint()
            self.state = 3920
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,388,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 3916
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 3917
                    self.indexHint() 
                self.state = 3922
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,388,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndexHintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def indexHintType(self):
            return self.getTypedRuleContext(MySQLParser.IndexHintTypeContext,0)


        def keyOrIndex(self):
            return self.getTypedRuleContext(MySQLParser.KeyOrIndexContext,0)


        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def indexList(self):
            return self.getTypedRuleContext(MySQLParser.IndexListContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def indexHintClause(self):
            return self.getTypedRuleContext(MySQLParser.IndexHintClauseContext,0)


        def USE_SYMBOL(self):
            return self.getToken(MySQLParser.USE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_indexHint

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndexHint" ):
                listener.enterIndexHint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndexHint" ):
                listener.exitIndexHint(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndexHint" ):
                return visitor.visitIndexHint(self)
            else:
                return visitor.visitChildren(self)




    def indexHint(self):

        localctx = MySQLParser.IndexHintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 438, self.RULE_indexHint)
        self._la = 0 # Token type
        try:
            self.state = 3943
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [230, 264]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3923
                self.indexHintType()
                self.state = 3924
                self.keyOrIndex()
                self.state = 3926
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==232:
                    self.state = 3925
                    self.indexHintClause()


                self.state = 3928
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 3929
                self.indexList()
                self.state = 3930
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass
            elif token in [629]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3932
                self.match(MySQLParser.USE_SYMBOL)
                self.state = 3933
                self.keyOrIndex()
                self.state = 3935
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==232:
                    self.state = 3934
                    self.indexHintClause()


                self.state = 3937
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 3939
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,391,self._ctx)
                if la_ == 1:
                    self.state = 3938
                    self.indexList()


                self.state = 3941
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndexHintTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FORCE_SYMBOL(self):
            return self.getToken(MySQLParser.FORCE_SYMBOL, 0)

        def IGNORE_SYMBOL(self):
            return self.getToken(MySQLParser.IGNORE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_indexHintType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndexHintType" ):
                listener.enterIndexHintType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndexHintType" ):
                listener.exitIndexHintType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndexHintType" ):
                return visitor.visitIndexHintType(self)
            else:
                return visitor.visitChildren(self)




    def indexHintType(self):

        localctx = MySQLParser.IndexHintTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 440, self.RULE_indexHintType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3945
            _la = self._input.LA(1)
            if not(_la==230 or _la==264):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeyOrIndexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KEY_SYMBOL(self):
            return self.getToken(MySQLParser.KEY_SYMBOL, 0)

        def INDEX_SYMBOL(self):
            return self.getToken(MySQLParser.INDEX_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_keyOrIndex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyOrIndex" ):
                listener.enterKeyOrIndex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyOrIndex" ):
                listener.exitKeyOrIndex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKeyOrIndex" ):
                return visitor.visitKeyOrIndex(self)
            else:
                return visitor.visitChildren(self)




    def keyOrIndex(self):

        localctx = MySQLParser.KeyOrIndexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 442, self.RULE_keyOrIndex)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3947
            _la = self._input.LA(1)
            if not(_la==268 or _la==295):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstraintKeyTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PRIMARY_SYMBOL(self):
            return self.getToken(MySQLParser.PRIMARY_SYMBOL, 0)

        def KEY_SYMBOL(self):
            return self.getToken(MySQLParser.KEY_SYMBOL, 0)

        def UNIQUE_SYMBOL(self):
            return self.getToken(MySQLParser.UNIQUE_SYMBOL, 0)

        def keyOrIndex(self):
            return self.getTypedRuleContext(MySQLParser.KeyOrIndexContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_constraintKeyType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstraintKeyType" ):
                listener.enterConstraintKeyType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstraintKeyType" ):
                listener.exitConstraintKeyType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstraintKeyType" ):
                return visitor.visitConstraintKeyType(self)
            else:
                return visitor.visitChildren(self)




    def constraintKeyType(self):

        localctx = MySQLParser.ConstraintKeyTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 444, self.RULE_constraintKeyType)
        self._la = 0 # Token type
        try:
            self.state = 3955
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [438]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3949
                self.match(MySQLParser.PRIMARY_SYMBOL)
                self.state = 3950
                self.match(MySQLParser.KEY_SYMBOL)
                pass
            elif token in [618]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3951
                self.match(MySQLParser.UNIQUE_SYMBOL)
                self.state = 3953
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==268 or _la==295:
                    self.state = 3952
                    self.keyOrIndex()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndexHintClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def JOIN_SYMBOL(self):
            return self.getToken(MySQLParser.JOIN_SYMBOL, 0)

        def ORDER_SYMBOL(self):
            return self.getToken(MySQLParser.ORDER_SYMBOL, 0)

        def BY_SYMBOL(self):
            return self.getToken(MySQLParser.BY_SYMBOL, 0)

        def GROUP_SYMBOL(self):
            return self.getToken(MySQLParser.GROUP_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_indexHintClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndexHintClause" ):
                listener.enterIndexHintClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndexHintClause" ):
                listener.exitIndexHintClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndexHintClause" ):
                return visitor.visitIndexHintClause(self)
            else:
                return visitor.visitChildren(self)




    def indexHintClause(self):

        localctx = MySQLParser.IndexHintClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 446, self.RULE_indexHintClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3957
            self.match(MySQLParser.FOR_SYMBOL)
            self.state = 3963
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [291]:
                self.state = 3958
                self.match(MySQLParser.JOIN_SYMBOL)
                pass
            elif token in [411]:
                self.state = 3959
                self.match(MySQLParser.ORDER_SYMBOL)
                self.state = 3960
                self.match(MySQLParser.BY_SYMBOL)
                pass
            elif token in [249]:
                self.state = 3961
                self.match(MySQLParser.GROUP_SYMBOL)
                self.state = 3962
                self.match(MySQLParser.BY_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndexListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def indexListElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.IndexListElementContext)
            else:
                return self.getTypedRuleContext(MySQLParser.IndexListElementContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_indexList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndexList" ):
                listener.enterIndexList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndexList" ):
                listener.exitIndexList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndexList" ):
                return visitor.visitIndexList(self)
            else:
                return visitor.visitChildren(self)




    def indexList(self):

        localctx = MySQLParser.IndexListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 448, self.RULE_indexList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3965
            self.indexListElement()
            self.state = 3970
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 3966
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 3967
                self.indexListElement()
                self.state = 3972
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndexListElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def PRIMARY_SYMBOL(self):
            return self.getToken(MySQLParser.PRIMARY_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_indexListElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndexListElement" ):
                listener.enterIndexListElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndexListElement" ):
                listener.exitIndexListElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndexListElement" ):
                return visitor.visitIndexListElement(self)
            else:
                return visitor.visitChildren(self)




    def indexListElement(self):

        localctx = MySQLParser.IndexListElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 450, self.RULE_indexListElement)
        try:
            self.state = 3975
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,397,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3973
                self.identifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3974
                self.match(MySQLParser.PRIMARY_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UpdateStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UPDATE_SYMBOL(self):
            return self.getToken(MySQLParser.UPDATE_SYMBOL, 0)

        def tableReferenceList(self):
            return self.getTypedRuleContext(MySQLParser.TableReferenceListContext,0)


        def SET_SYMBOL(self):
            return self.getToken(MySQLParser.SET_SYMBOL, 0)

        def updateList(self):
            return self.getTypedRuleContext(MySQLParser.UpdateListContext,0)


        def withClause(self):
            return self.getTypedRuleContext(MySQLParser.WithClauseContext,0)


        def LOW_PRIORITY_SYMBOL(self):
            return self.getToken(MySQLParser.LOW_PRIORITY_SYMBOL, 0)

        def IGNORE_SYMBOL(self):
            return self.getToken(MySQLParser.IGNORE_SYMBOL, 0)

        def whereClause(self):
            return self.getTypedRuleContext(MySQLParser.WhereClauseContext,0)


        def orderClause(self):
            return self.getTypedRuleContext(MySQLParser.OrderClauseContext,0)


        def simpleLimitClause(self):
            return self.getTypedRuleContext(MySQLParser.SimpleLimitClauseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_updateStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpdateStatement" ):
                listener.enterUpdateStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpdateStatement" ):
                listener.exitUpdateStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUpdateStatement" ):
                return visitor.visitUpdateStatement(self)
            else:
                return visitor.visitChildren(self)




    def updateStatement(self):

        localctx = MySQLParser.UpdateStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 452, self.RULE_updateStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3978
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==653:
                self.state = 3977
                self.withClause()


            self.state = 3980
            self.match(MySQLParser.UPDATE_SYMBOL)
            self.state = 3982
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,399,self._ctx)
            if la_ == 1:
                self.state = 3981
                self.match(MySQLParser.LOW_PRIORITY_SYMBOL)


            self.state = 3985
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,400,self._ctx)
            if la_ == 1:
                self.state = 3984
                self.match(MySQLParser.IGNORE_SYMBOL)


            self.state = 3987
            self.tableReferenceList()
            self.state = 3988
            self.match(MySQLParser.SET_SYMBOL)
            self.state = 3989
            self.updateList()
            self.state = 3991
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==651:
                self.state = 3990
                self.whereClause()


            self.state = 3994
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==411:
                self.state = 3993
                self.orderClause()


            self.state = 3997
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==306:
                self.state = 3996
                self.simpleLimitClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TransactionOrLockingStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def transactionStatement(self):
            return self.getTypedRuleContext(MySQLParser.TransactionStatementContext,0)


        def savepointStatement(self):
            return self.getTypedRuleContext(MySQLParser.SavepointStatementContext,0)


        def lockStatement(self):
            return self.getTypedRuleContext(MySQLParser.LockStatementContext,0)


        def xaStatement(self):
            return self.getTypedRuleContext(MySQLParser.XaStatementContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_transactionOrLockingStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTransactionOrLockingStatement" ):
                listener.enterTransactionOrLockingStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTransactionOrLockingStatement" ):
                listener.exitTransactionOrLockingStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTransactionOrLockingStatement" ):
                return visitor.visitTransactionOrLockingStatement(self)
            else:
                return visitor.visitChildren(self)




    def transactionOrLockingStatement(self):

        localctx = MySQLParser.TransactionOrLockingStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 454, self.RULE_transactionOrLockingStatement)
        try:
            self.state = 4003
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [120, 553]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3999
                self.transactionStatement()
                pass
            elif token in [467, 496, 505]:
                self.enterOuterAlt(localctx, 2)
                self.state = 4000
                self.savepointStatement()
                pass
            elif token in [314, 620]:
                self.enterOuterAlt(localctx, 3)
                self.state = 4001
                self.lockStatement()
                pass
            elif token in [659]:
                self.enterOuterAlt(localctx, 4)
                self.state = 4002
                self.xaStatement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TransactionStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def START_SYMBOL(self):
            return self.getToken(MySQLParser.START_SYMBOL, 0)

        def TRANSACTION_SYMBOL(self):
            return self.getToken(MySQLParser.TRANSACTION_SYMBOL, 0)

        def startTransactionOptionList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.StartTransactionOptionListContext)
            else:
                return self.getTypedRuleContext(MySQLParser.StartTransactionOptionListContext,i)


        def COMMIT_SYMBOL(self):
            return self.getToken(MySQLParser.COMMIT_SYMBOL, 0)

        def WORK_SYMBOL(self):
            return self.getToken(MySQLParser.WORK_SYMBOL, 0)

        def AND_SYMBOL(self):
            return self.getToken(MySQLParser.AND_SYMBOL, 0)

        def CHAIN_SYMBOL(self):
            return self.getToken(MySQLParser.CHAIN_SYMBOL, 0)

        def RELEASE_SYMBOL(self):
            return self.getToken(MySQLParser.RELEASE_SYMBOL, 0)

        def NO_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.NO_SYMBOL)
            else:
                return self.getToken(MySQLParser.NO_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_transactionStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTransactionStatement" ):
                listener.enterTransactionStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTransactionStatement" ):
                listener.exitTransactionStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTransactionStatement" ):
                return visitor.visitTransactionStatement(self)
            else:
                return visitor.visitChildren(self)




    def transactionStatement(self):

        localctx = MySQLParser.TransactionStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 456, self.RULE_transactionStatement)
        self._la = 0 # Token type
        try:
            self.state = 4030
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [553]:
                self.enterOuterAlt(localctx, 1)
                self.state = 4005
                self.match(MySQLParser.START_SYMBOL)
                self.state = 4006
                self.match(MySQLParser.TRANSACTION_SYMBOL)
                self.state = 4010
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==453 or _la==653:
                    self.state = 4007
                    self.startTransactionOptionList()
                    self.state = 4012
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [120]:
                self.enterOuterAlt(localctx, 2)
                self.state = 4013
                self.match(MySQLParser.COMMIT_SYMBOL)
                self.state = 4015
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==655:
                    self.state = 4014
                    self.match(MySQLParser.WORK_SYMBOL)


                self.state = 4022
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==61:
                    self.state = 4017
                    self.match(MySQLParser.AND_SYMBOL)
                    self.state = 4019
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==392:
                        self.state = 4018
                        self.match(MySQLParser.NO_SYMBOL)


                    self.state = 4021
                    self.match(MySQLParser.CHAIN_SYMBOL)


                self.state = 4028
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==392 or _la==467:
                    self.state = 4025
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==392:
                        self.state = 4024
                        self.match(MySQLParser.NO_SYMBOL)


                    self.state = 4027
                    self.match(MySQLParser.RELEASE_SYMBOL)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeginWorkContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BEGIN_SYMBOL(self):
            return self.getToken(MySQLParser.BEGIN_SYMBOL, 0)

        def WORK_SYMBOL(self):
            return self.getToken(MySQLParser.WORK_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_beginWork

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeginWork" ):
                listener.enterBeginWork(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeginWork" ):
                listener.exitBeginWork(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeginWork" ):
                return visitor.visitBeginWork(self)
            else:
                return visitor.visitChildren(self)




    def beginWork(self):

        localctx = MySQLParser.BeginWorkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 458, self.RULE_beginWork)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4032
            self.match(MySQLParser.BEGIN_SYMBOL)
            self.state = 4034
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==655:
                self.state = 4033
                self.match(MySQLParser.WORK_SYMBOL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StartTransactionOptionListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def CONSISTENT_SYMBOL(self):
            return self.getToken(MySQLParser.CONSISTENT_SYMBOL, 0)

        def SNAPSHOT_SYMBOL(self):
            return self.getToken(MySQLParser.SNAPSHOT_SYMBOL, 0)

        def READ_SYMBOL(self):
            return self.getToken(MySQLParser.READ_SYMBOL, 0)

        def WRITE_SYMBOL(self):
            return self.getToken(MySQLParser.WRITE_SYMBOL, 0)

        def ONLY_SYMBOL(self):
            return self.getToken(MySQLParser.ONLY_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_startTransactionOptionList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartTransactionOptionList" ):
                listener.enterStartTransactionOptionList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartTransactionOptionList" ):
                listener.exitStartTransactionOptionList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartTransactionOptionList" ):
                return visitor.visitStartTransactionOptionList(self)
            else:
                return visitor.visitChildren(self)




    def startTransactionOptionList(self):

        localctx = MySQLParser.StartTransactionOptionListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 460, self.RULE_startTransactionOptionList)
        self._la = 0 # Token type
        try:
            self.state = 4041
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [653]:
                self.enterOuterAlt(localctx, 1)
                self.state = 4036
                self.match(MySQLParser.WITH_SYMBOL)
                self.state = 4037
                self.match(MySQLParser.CONSISTENT_SYMBOL)
                self.state = 4038
                self.match(MySQLParser.SNAPSHOT_SYMBOL)
                pass
            elif token in [453]:
                self.enterOuterAlt(localctx, 2)
                self.state = 4039
                self.match(MySQLParser.READ_SYMBOL)
                self.state = 4040
                _la = self._input.LA(1)
                if not(_la==404 or _la==657):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SavepointStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SAVEPOINT_SYMBOL(self):
            return self.getToken(MySQLParser.SAVEPOINT_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def ROLLBACK_SYMBOL(self):
            return self.getToken(MySQLParser.ROLLBACK_SYMBOL, 0)

        def TO_SYMBOL(self):
            return self.getToken(MySQLParser.TO_SYMBOL, 0)

        def WORK_SYMBOL(self):
            return self.getToken(MySQLParser.WORK_SYMBOL, 0)

        def AND_SYMBOL(self):
            return self.getToken(MySQLParser.AND_SYMBOL, 0)

        def CHAIN_SYMBOL(self):
            return self.getToken(MySQLParser.CHAIN_SYMBOL, 0)

        def RELEASE_SYMBOL(self):
            return self.getToken(MySQLParser.RELEASE_SYMBOL, 0)

        def NO_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.NO_SYMBOL)
            else:
                return self.getToken(MySQLParser.NO_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_savepointStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSavepointStatement" ):
                listener.enterSavepointStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSavepointStatement" ):
                listener.exitSavepointStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSavepointStatement" ):
                return visitor.visitSavepointStatement(self)
            else:
                return visitor.visitChildren(self)




    def savepointStatement(self):

        localctx = MySQLParser.SavepointStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 462, self.RULE_savepointStatement)
        self._la = 0 # Token type
        try:
            self.state = 4072
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [505]:
                self.enterOuterAlt(localctx, 1)
                self.state = 4043
                self.match(MySQLParser.SAVEPOINT_SYMBOL)
                self.state = 4044
                self.identifier()
                pass
            elif token in [496]:
                self.enterOuterAlt(localctx, 2)
                self.state = 4045
                self.match(MySQLParser.ROLLBACK_SYMBOL)
                self.state = 4047
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==655:
                    self.state = 4046
                    self.match(MySQLParser.WORK_SYMBOL)


                self.state = 4067
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [599]:
                    self.state = 4049
                    self.match(MySQLParser.TO_SYMBOL)
                    self.state = 4051
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,415,self._ctx)
                    if la_ == 1:
                        self.state = 4050
                        self.match(MySQLParser.SAVEPOINT_SYMBOL)


                    self.state = 4053
                    self.identifier()
                    pass
                elif token in [-1, 30, 61, 392, 467]:
                    self.state = 4059
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==61:
                        self.state = 4054
                        self.match(MySQLParser.AND_SYMBOL)
                        self.state = 4056
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==392:
                            self.state = 4055
                            self.match(MySQLParser.NO_SYMBOL)


                        self.state = 4058
                        self.match(MySQLParser.CHAIN_SYMBOL)


                    self.state = 4065
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==392 or _la==467:
                        self.state = 4062
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==392:
                            self.state = 4061
                            self.match(MySQLParser.NO_SYMBOL)


                        self.state = 4064
                        self.match(MySQLParser.RELEASE_SYMBOL)


                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [467]:
                self.enterOuterAlt(localctx, 3)
                self.state = 4069
                self.match(MySQLParser.RELEASE_SYMBOL)
                self.state = 4070
                self.match(MySQLParser.SAVEPOINT_SYMBOL)
                self.state = 4071
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LockStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOCK_SYMBOL(self):
            return self.getToken(MySQLParser.LOCK_SYMBOL, 0)

        def lockItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.LockItemContext)
            else:
                return self.getTypedRuleContext(MySQLParser.LockItemContext,i)


        def TABLES_SYMBOL(self):
            return self.getToken(MySQLParser.TABLES_SYMBOL, 0)

        def TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_SYMBOL, 0)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def INSTANCE_SYMBOL(self):
            return self.getToken(MySQLParser.INSTANCE_SYMBOL, 0)

        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def BACKUP_SYMBOL(self):
            return self.getToken(MySQLParser.BACKUP_SYMBOL, 0)

        def UNLOCK_SYMBOL(self):
            return self.getToken(MySQLParser.UNLOCK_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_lockStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLockStatement" ):
                listener.enterLockStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLockStatement" ):
                listener.exitLockStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLockStatement" ):
                return visitor.visitLockStatement(self)
            else:
                return visitor.visitChildren(self)




    def lockStatement(self):

        localctx = MySQLParser.LockStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 464, self.RULE_lockStatement)
        self._la = 0 # Token type
        try:
            self.state = 4090
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,423,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4074
                self.match(MySQLParser.LOCK_SYMBOL)
                self.state = 4075
                _la = self._input.LA(1)
                if not(_la==581 or _la==583):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 4076
                self.lockItem()
                self.state = 4081
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==29:
                    self.state = 4077
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 4078
                    self.lockItem()
                    self.state = 4083
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4084
                self.match(MySQLParser.LOCK_SYMBOL)
                self.state = 4085
                self.match(MySQLParser.INSTANCE_SYMBOL)
                self.state = 4086
                self.match(MySQLParser.FOR_SYMBOL)
                self.state = 4087
                self.match(MySQLParser.BACKUP_SYMBOL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 4088
                self.match(MySQLParser.UNLOCK_SYMBOL)
                self.state = 4089
                _la = self._input.LA(1)
                if not(_la==276 or _la==581 or _la==583):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LockItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def lockOption(self):
            return self.getTypedRuleContext(MySQLParser.LockOptionContext,0)


        def tableAlias(self):
            return self.getTypedRuleContext(MySQLParser.TableAliasContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_lockItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLockItem" ):
                listener.enterLockItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLockItem" ):
                listener.exitLockItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLockItem" ):
                return visitor.visitLockItem(self)
            else:
                return visitor.visitChildren(self)




    def lockItem(self):

        localctx = MySQLParser.LockItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 466, self.RULE_lockItem)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4092
            self.tableRef()
            self.state = 4094
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,424,self._ctx)
            if la_ == 1:
                self.state = 4093
                self.tableAlias()


            self.state = 4096
            self.lockOption()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LockOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def READ_SYMBOL(self):
            return self.getToken(MySQLParser.READ_SYMBOL, 0)

        def LOCAL_SYMBOL(self):
            return self.getToken(MySQLParser.LOCAL_SYMBOL, 0)

        def WRITE_SYMBOL(self):
            return self.getToken(MySQLParser.WRITE_SYMBOL, 0)

        def LOW_PRIORITY_SYMBOL(self):
            return self.getToken(MySQLParser.LOW_PRIORITY_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_lockOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLockOption" ):
                listener.enterLockOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLockOption" ):
                listener.exitLockOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLockOption" ):
                return visitor.visitLockOption(self)
            else:
                return visitor.visitChildren(self)




    def lockOption(self):

        localctx = MySQLParser.LockOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 468, self.RULE_lockOption)
        self._la = 0 # Token type
        try:
            self.state = 4106
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [453]:
                self.enterOuterAlt(localctx, 1)
                self.state = 4098
                self.match(MySQLParser.READ_SYMBOL)
                self.state = 4100
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==312:
                    self.state = 4099
                    self.match(MySQLParser.LOCAL_SYMBOL)


                pass
            elif token in [321, 657]:
                self.enterOuterAlt(localctx, 2)
                self.state = 4103
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==321:
                    self.state = 4102
                    self.match(MySQLParser.LOW_PRIORITY_SYMBOL)


                self.state = 4105
                self.match(MySQLParser.WRITE_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XaStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def XA_SYMBOL(self):
            return self.getToken(MySQLParser.XA_SYMBOL, 0)

        def xid(self):
            return self.getTypedRuleContext(MySQLParser.XidContext,0)


        def END_SYMBOL(self):
            return self.getToken(MySQLParser.END_SYMBOL, 0)

        def PREPARE_SYMBOL(self):
            return self.getToken(MySQLParser.PREPARE_SYMBOL, 0)

        def COMMIT_SYMBOL(self):
            return self.getToken(MySQLParser.COMMIT_SYMBOL, 0)

        def ROLLBACK_SYMBOL(self):
            return self.getToken(MySQLParser.ROLLBACK_SYMBOL, 0)

        def RECOVER_SYMBOL(self):
            return self.getToken(MySQLParser.RECOVER_SYMBOL, 0)

        def START_SYMBOL(self):
            return self.getToken(MySQLParser.START_SYMBOL, 0)

        def BEGIN_SYMBOL(self):
            return self.getToken(MySQLParser.BEGIN_SYMBOL, 0)

        def SUSPEND_SYMBOL(self):
            return self.getToken(MySQLParser.SUSPEND_SYMBOL, 0)

        def ONE_SYMBOL(self):
            return self.getToken(MySQLParser.ONE_SYMBOL, 0)

        def PHASE_SYMBOL(self):
            return self.getToken(MySQLParser.PHASE_SYMBOL, 0)

        def xaConvert(self):
            return self.getTypedRuleContext(MySQLParser.XaConvertContext,0)


        def JOIN_SYMBOL(self):
            return self.getToken(MySQLParser.JOIN_SYMBOL, 0)

        def RESUME_SYMBOL(self):
            return self.getToken(MySQLParser.RESUME_SYMBOL, 0)

        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def MIGRATE_SYMBOL(self):
            return self.getToken(MySQLParser.MIGRATE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_xaStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXaStatement" ):
                listener.enterXaStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXaStatement" ):
                listener.exitXaStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXaStatement" ):
                return visitor.visitXaStatement(self)
            else:
                return visitor.visitChildren(self)




    def xaStatement(self):

        localctx = MySQLParser.XaStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 470, self.RULE_xaStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4108
            self.match(MySQLParser.XA_SYMBOL)
            self.state = 4137
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [74, 553]:
                self.state = 4109
                _la = self._input.LA(1)
                if not(_la==74 or _la==553):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 4110
                self.xid()
                self.state = 4112
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==291 or _la==489:
                    self.state = 4111
                    _la = self._input.LA(1)
                    if not(_la==291 or _la==489):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass
            elif token in [195]:
                self.state = 4114
                self.match(MySQLParser.END_SYMBOL)
                self.state = 4115
                self.xid()
                self.state = 4121
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==576:
                    self.state = 4116
                    self.match(MySQLParser.SUSPEND_SYMBOL)
                    self.state = 4119
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==232:
                        self.state = 4117
                        self.match(MySQLParser.FOR_SYMBOL)
                        self.state = 4118
                        self.match(MySQLParser.MIGRATE_SYMBOL)




                pass
            elif token in [435]:
                self.state = 4123
                self.match(MySQLParser.PREPARE_SYMBOL)
                self.state = 4124
                self.xid()
                pass
            elif token in [120]:
                self.state = 4125
                self.match(MySQLParser.COMMIT_SYMBOL)
                self.state = 4126
                self.xid()
                self.state = 4129
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==402:
                    self.state = 4127
                    self.match(MySQLParser.ONE_SYMBOL)
                    self.state = 4128
                    self.match(MySQLParser.PHASE_SYMBOL)


                pass
            elif token in [496]:
                self.state = 4131
                self.match(MySQLParser.ROLLBACK_SYMBOL)
                self.state = 4132
                self.xid()
                pass
            elif token in [457]:
                self.state = 4133
                self.match(MySQLParser.RECOVER_SYMBOL)
                self.state = 4135
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==136:
                    self.state = 4134
                    self.xaConvert()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XaConvertContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONVERT_SYMBOL(self):
            return self.getToken(MySQLParser.CONVERT_SYMBOL, 0)

        def XID_SYMBOL(self):
            return self.getToken(MySQLParser.XID_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_xaConvert

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXaConvert" ):
                listener.enterXaConvert(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXaConvert" ):
                listener.exitXaConvert(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXaConvert" ):
                return visitor.visitXaConvert(self)
            else:
                return visitor.visitChildren(self)




    def xaConvert(self):

        localctx = MySQLParser.XaConvertContext(self, self._ctx, self.state)
        self.enterRule(localctx, 472, self.RULE_xaConvert)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4139
            self.match(MySQLParser.CONVERT_SYMBOL)
            self.state = 4140
            self.match(MySQLParser.XID_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XidContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textString(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.TextStringContext)
            else:
                return self.getTypedRuleContext(MySQLParser.TextStringContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Ulong_numberContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_xid

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXid" ):
                listener.enterXid(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXid" ):
                listener.exitXid(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXid" ):
                return visitor.visitXid(self)
            else:
                return visitor.visitChildren(self)




    def xid(self):

        localctx = MySQLParser.XidContext(self, self._ctx, self.state)
        self.enterRule(localctx, 474, self.RULE_xid)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4142
            self.textString()
            self.state = 4149
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==29:
                self.state = 4143
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 4144
                self.textString()
                self.state = 4147
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 4145
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 4146
                    self.ulong_number()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReplicationStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PURGE_SYMBOL(self):
            return self.getToken(MySQLParser.PURGE_SYMBOL, 0)

        def purgeOptions(self):
            return self.getTypedRuleContext(MySQLParser.PurgeOptionsContext,0)


        def changeSource(self):
            return self.getTypedRuleContext(MySQLParser.ChangeSourceContext,0)


        def RESET_SYMBOL(self):
            return self.getToken(MySQLParser.RESET_SYMBOL, 0)

        def resetOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ResetOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ResetOptionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def PERSIST_SYMBOL(self):
            return self.getToken(MySQLParser.PERSIST_SYMBOL, 0)

        def ifExistsIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.IfExistsIdentifierContext,0)


        def startReplicaStatement(self):
            return self.getTypedRuleContext(MySQLParser.StartReplicaStatementContext,0)


        def stopReplicaStatement(self):
            return self.getTypedRuleContext(MySQLParser.StopReplicaStatementContext,0)


        def changeReplication(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationContext,0)


        def replicationLoad(self):
            return self.getTypedRuleContext(MySQLParser.ReplicationLoadContext,0)


        def groupReplication(self):
            return self.getTypedRuleContext(MySQLParser.GroupReplicationContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_replicationStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplicationStatement" ):
                listener.enterReplicationStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplicationStatement" ):
                listener.exitReplicationStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReplicationStatement" ):
                return visitor.visitReplicationStatement(self)
            else:
                return visitor.visitChildren(self)




    def replicationStatement(self):

        localctx = MySQLParser.ReplicationStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 476, self.RULE_replicationStatement)
        self._la = 0 # Token type
        try:
            self.state = 4173
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,438,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4151
                self.match(MySQLParser.PURGE_SYMBOL)
                self.state = 4152
                self.purgeOptions()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4153
                self.changeSource()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 4154
                self.match(MySQLParser.RESET_SYMBOL)
                self.state = 4155
                self.resetOption()
                self.state = 4160
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==29:
                    self.state = 4156
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 4157
                    self.resetOption()
                    self.state = 4162
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 4163
                self.match(MySQLParser.RESET_SYMBOL)
                self.state = 4164
                self.match(MySQLParser.PERSIST_SYMBOL)
                self.state = 4166
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==263:
                    self.state = 4165
                    self.ifExistsIdentifier()


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 4168
                self.startReplicaStatement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 4169
                self.stopReplicaStatement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 4170
                self.changeReplication()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 4171
                self.replicationLoad()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 4172
                self.groupReplication()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PurgeOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOGS_SYMBOL(self):
            return self.getToken(MySQLParser.LOGS_SYMBOL, 0)

        def BINARY_SYMBOL(self):
            return self.getToken(MySQLParser.BINARY_SYMBOL, 0)

        def MASTER_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SYMBOL, 0)

        def TO_SYMBOL(self):
            return self.getToken(MySQLParser.TO_SYMBOL, 0)

        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def BEFORE_SYMBOL(self):
            return self.getToken(MySQLParser.BEFORE_SYMBOL, 0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_purgeOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPurgeOptions" ):
                listener.enterPurgeOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPurgeOptions" ):
                listener.exitPurgeOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPurgeOptions" ):
                return visitor.visitPurgeOptions(self)
            else:
                return visitor.visitChildren(self)




    def purgeOptions(self):

        localctx = MySQLParser.PurgeOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 478, self.RULE_purgeOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4175
            _la = self._input.LA(1)
            if not(_la==77 or _la==341):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 4176
            self.match(MySQLParser.LOGS_SYMBOL)
            self.state = 4181
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [599]:
                self.state = 4177
                self.match(MySQLParser.TO_SYMBOL)
                self.state = 4178
                self.textLiteral()
                pass
            elif token in [73]:
                self.state = 4179
                self.match(MySQLParser.BEFORE_SYMBOL)
                self.state = 4180
                self.expr(0)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResetOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def masterOrBinaryLogsAndGtids(self):
            return self.getTypedRuleContext(MySQLParser.MasterOrBinaryLogsAndGtidsContext,0)


        def sourceResetOptions(self):
            return self.getTypedRuleContext(MySQLParser.SourceResetOptionsContext,0)


        def replica(self):
            return self.getTypedRuleContext(MySQLParser.ReplicaContext,0)


        def ALL_SYMBOL(self):
            return self.getToken(MySQLParser.ALL_SYMBOL, 0)

        def channel(self):
            return self.getTypedRuleContext(MySQLParser.ChannelContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_resetOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResetOption" ):
                listener.enterResetOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResetOption" ):
                listener.exitResetOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResetOption" ):
                return visitor.visitResetOption(self)
            else:
                return visitor.visitChildren(self)




    def resetOption(self):

        localctx = MySQLParser.ResetOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 480, self.RULE_resetOption)
        self._la = 0 # Token type
        try:
            self.state = 4194
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,443,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4183
                self.masterOrBinaryLogsAndGtids()
                self.state = 4185
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==599:
                    self.state = 4184
                    self.sourceResetOptions()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4187
                self.replica()
                self.state = 4189
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==57:
                    self.state = 4188
                    self.match(MySQLParser.ALL_SYMBOL)


                self.state = 4192
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==232:
                    self.state = 4191
                    self.channel()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MasterOrBinaryLogsAndGtidsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SYMBOL, 0)

        def BINARY_SYMBOL(self):
            return self.getToken(MySQLParser.BINARY_SYMBOL, 0)

        def LOGS_SYMBOL(self):
            return self.getToken(MySQLParser.LOGS_SYMBOL, 0)

        def AND_SYMBOL(self):
            return self.getToken(MySQLParser.AND_SYMBOL, 0)

        def GTIDS_SYMBOL(self):
            return self.getToken(MySQLParser.GTIDS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_masterOrBinaryLogsAndGtids

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMasterOrBinaryLogsAndGtids" ):
                listener.enterMasterOrBinaryLogsAndGtids(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMasterOrBinaryLogsAndGtids" ):
                listener.exitMasterOrBinaryLogsAndGtids(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMasterOrBinaryLogsAndGtids" ):
                return visitor.visitMasterOrBinaryLogsAndGtids(self)
            else:
                return visitor.visitChildren(self)




    def masterOrBinaryLogsAndGtids(self):

        localctx = MySQLParser.MasterOrBinaryLogsAndGtidsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 482, self.RULE_masterOrBinaryLogsAndGtids)
        try:
            self.state = 4202
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,444,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4196
                self.match(MySQLParser.MASTER_SYMBOL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4197
                if not self.isServerVersionGe80032():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80032()")
                self.state = 4198
                self.match(MySQLParser.BINARY_SYMBOL)
                self.state = 4199
                self.match(MySQLParser.LOGS_SYMBOL)
                self.state = 4200
                self.match(MySQLParser.AND_SYMBOL)
                self.state = 4201
                self.match(MySQLParser.GTIDS_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceResetOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TO_SYMBOL(self):
            return self.getToken(MySQLParser.TO_SYMBOL, 0)

        def real_ulonglong_number(self):
            return self.getTypedRuleContext(MySQLParser.Real_ulonglong_numberContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_sourceResetOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSourceResetOptions" ):
                listener.enterSourceResetOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSourceResetOptions" ):
                listener.exitSourceResetOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSourceResetOptions" ):
                return visitor.visitSourceResetOptions(self)
            else:
                return visitor.visitChildren(self)




    def sourceResetOptions(self):

        localctx = MySQLParser.SourceResetOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 484, self.RULE_sourceResetOptions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4204
            self.match(MySQLParser.TO_SYMBOL)
            self.state = 4205
            self.real_ulonglong_number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReplicationLoadContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOAD_SYMBOL(self):
            return self.getToken(MySQLParser.LOAD_SYMBOL, 0)

        def FROM_SYMBOL(self):
            return self.getToken(MySQLParser.FROM_SYMBOL, 0)

        def MASTER_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SYMBOL, 0)

        def DATA_SYMBOL(self):
            return self.getToken(MySQLParser.DATA_SYMBOL, 0)

        def TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_SYMBOL, 0)

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_replicationLoad

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplicationLoad" ):
                listener.enterReplicationLoad(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplicationLoad" ):
                listener.exitReplicationLoad(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReplicationLoad" ):
                return visitor.visitReplicationLoad(self)
            else:
                return visitor.visitChildren(self)




    def replicationLoad(self):

        localctx = MySQLParser.ReplicationLoadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 486, self.RULE_replicationLoad)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4207
            self.match(MySQLParser.LOAD_SYMBOL)
            self.state = 4211
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [153]:
                self.state = 4208
                self.match(MySQLParser.DATA_SYMBOL)
                pass
            elif token in [583]:
                self.state = 4209
                self.match(MySQLParser.TABLE_SYMBOL)
                self.state = 4210
                self.tableRef()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 4213
            self.match(MySQLParser.FROM_SYMBOL)
            self.state = 4214
            self.match(MySQLParser.MASTER_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SYMBOL, 0)

        def REPLICATION_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATION_SYMBOL, 0)

        def SOURCE_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSource

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSource" ):
                listener.enterChangeReplicationSource(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSource" ):
                listener.exitChangeReplicationSource(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSource" ):
                return visitor.visitChangeReplicationSource(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSource(self):

        localctx = MySQLParser.ChangeReplicationSourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 488, self.RULE_changeReplicationSource)
        try:
            self.state = 4220
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,446,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4216
                self.match(MySQLParser.MASTER_SYMBOL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4217
                if not self.isServerVersionGe80024():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                self.state = 4218
                self.match(MySQLParser.REPLICATION_SYMBOL)
                self.state = 4219
                self.match(MySQLParser.SOURCE_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeSourceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHANGE_SYMBOL(self):
            return self.getToken(MySQLParser.CHANGE_SYMBOL, 0)

        def changeReplicationSource(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceContext,0)


        def TO_SYMBOL(self):
            return self.getToken(MySQLParser.TO_SYMBOL, 0)

        def sourceDefinitions(self):
            return self.getTypedRuleContext(MySQLParser.SourceDefinitionsContext,0)


        def channel(self):
            return self.getTypedRuleContext(MySQLParser.ChannelContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_changeSource

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeSource" ):
                listener.enterChangeSource(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeSource" ):
                listener.exitChangeSource(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeSource" ):
                return visitor.visitChangeSource(self)
            else:
                return visitor.visitChildren(self)




    def changeSource(self):

        localctx = MySQLParser.ChangeSourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 490, self.RULE_changeSource)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4222
            self.match(MySQLParser.CHANGE_SYMBOL)
            self.state = 4223
            self.changeReplicationSource()
            self.state = 4224
            self.match(MySQLParser.TO_SYMBOL)
            self.state = 4225
            self.sourceDefinitions()
            self.state = 4227
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==232:
                self.state = 4226
                self.channel()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceDefinitionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sourceDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.SourceDefinitionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.SourceDefinitionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_sourceDefinitions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSourceDefinitions" ):
                listener.enterSourceDefinitions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSourceDefinitions" ):
                listener.exitSourceDefinitions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSourceDefinitions" ):
                return visitor.visitSourceDefinitions(self)
            else:
                return visitor.visitChildren(self)




    def sourceDefinitions(self):

        localctx = MySQLParser.SourceDefinitionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 492, self.RULE_sourceDefinitions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4229
            self.sourceDefinition()
            self.state = 4234
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 4230
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 4231
                self.sourceDefinition()
                self.state = 4236
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def changeReplicationSourceHost(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceHostContext,0)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def textStringNoLinebreak(self):
            return self.getTypedRuleContext(MySQLParser.TextStringNoLinebreakContext,0)


        def NETWORK_NAMESPACE_SYMBOL(self):
            return self.getToken(MySQLParser.NETWORK_NAMESPACE_SYMBOL, 0)

        def changeReplicationSourceBind(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceBindContext,0)


        def changeReplicationSourceUser(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceUserContext,0)


        def changeReplicationSourcePassword(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourcePasswordContext,0)


        def changeReplicationSourcePort(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourcePortContext,0)


        def ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Ulong_numberContext,0)


        def changeReplicationSourceConnectRetry(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceConnectRetryContext,0)


        def changeReplicationSourceRetryCount(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceRetryCountContext,0)


        def changeReplicationSourceDelay(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceDelayContext,0)


        def changeReplicationSourceSSL(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceSSLContext,0)


        def changeReplicationSourceSSLCA(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceSSLCAContext,0)


        def changeReplicationSourceSSLCApath(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceSSLCApathContext,0)


        def changeReplicationSourceTLSVersion(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceTLSVersionContext,0)


        def changeReplicationSourceSSLCert(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceSSLCertContext,0)


        def changeReplicationSourceTLSCiphersuites(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceTLSCiphersuitesContext,0)


        def sourceTlsCiphersuitesDef(self):
            return self.getTypedRuleContext(MySQLParser.SourceTlsCiphersuitesDefContext,0)


        def changeReplicationSourceSSLCipher(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceSSLCipherContext,0)


        def changeReplicationSourceSSLKey(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceSSLKeyContext,0)


        def changeReplicationSourceSSLVerifyServerCert(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceSSLVerifyServerCertContext,0)


        def changeReplicationSourceSSLCLR(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceSSLCLRContext,0)


        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def changeReplicationSourceSSLCLRpath(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceSSLCLRpathContext,0)


        def changeReplicationSourcePublicKey(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourcePublicKeyContext,0)


        def changeReplicationSourceGetSourcePublicKey(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceGetSourcePublicKeyContext,0)


        def changeReplicationSourceHeartbeatPeriod(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceHeartbeatPeriodContext,0)


        def IGNORE_SERVER_IDS_SYMBOL(self):
            return self.getToken(MySQLParser.IGNORE_SERVER_IDS_SYMBOL, 0)

        def serverIdList(self):
            return self.getTypedRuleContext(MySQLParser.ServerIdListContext,0)


        def changeReplicationSourceCompressionAlgorithm(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceCompressionAlgorithmContext,0)


        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def changeReplicationSourceZstdCompressionLevel(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceZstdCompressionLevelContext,0)


        def changeReplicationSourceAutoPosition(self):
            return self.getTypedRuleContext(MySQLParser.ChangeReplicationSourceAutoPositionContext,0)


        def PRIVILEGE_CHECKS_USER_SYMBOL(self):
            return self.getToken(MySQLParser.PRIVILEGE_CHECKS_USER_SYMBOL, 0)

        def privilegeCheckDef(self):
            return self.getTypedRuleContext(MySQLParser.PrivilegeCheckDefContext,0)


        def REQUIRE_ROW_FORMAT_SYMBOL(self):
            return self.getToken(MySQLParser.REQUIRE_ROW_FORMAT_SYMBOL, 0)

        def REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL(self):
            return self.getToken(MySQLParser.REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, 0)

        def tablePrimaryKeyCheckDef(self):
            return self.getTypedRuleContext(MySQLParser.TablePrimaryKeyCheckDefContext,0)


        def SOURCE_CONNECTION_AUTO_FAILOVER_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_CONNECTION_AUTO_FAILOVER_SYMBOL, 0)

        def real_ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Real_ulong_numberContext,0)


        def ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_SYMBOL(self):
            return self.getToken(MySQLParser.ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_SYMBOL, 0)

        def assignGtidsToAnonymousTransactionsDefinition(self):
            return self.getTypedRuleContext(MySQLParser.AssignGtidsToAnonymousTransactionsDefinitionContext,0)


        def GTID_ONLY_SYMBOL(self):
            return self.getToken(MySQLParser.GTID_ONLY_SYMBOL, 0)

        def sourceFileDef(self):
            return self.getTypedRuleContext(MySQLParser.SourceFileDefContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_sourceDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSourceDefinition" ):
                listener.enterSourceDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSourceDefinition" ):
                listener.exitSourceDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSourceDefinition" ):
                return visitor.visitSourceDefinition(self)
            else:
                return visitor.visitChildren(self)




    def sourceDefinition(self):

        localctx = MySQLParser.SourceDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 494, self.RULE_sourceDefinition)
        try:
            self.state = 4365
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,449,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4237
                self.changeReplicationSourceHost()
                self.state = 4238
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4239
                self.textStringNoLinebreak()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4241
                self.match(MySQLParser.NETWORK_NAMESPACE_SYMBOL)
                self.state = 4242
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4243
                self.textStringNoLinebreak()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 4244
                self.changeReplicationSourceBind()
                self.state = 4245
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4246
                self.textStringNoLinebreak()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 4248
                self.changeReplicationSourceUser()
                self.state = 4249
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4250
                self.textStringNoLinebreak()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 4252
                self.changeReplicationSourcePassword()
                self.state = 4253
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4254
                self.textStringNoLinebreak()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 4256
                self.changeReplicationSourcePort()
                self.state = 4257
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4258
                self.ulong_number()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 4260
                self.changeReplicationSourceConnectRetry()
                self.state = 4261
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4262
                self.ulong_number()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 4264
                self.changeReplicationSourceRetryCount()
                self.state = 4265
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4266
                self.ulong_number()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 4268
                self.changeReplicationSourceDelay()
                self.state = 4269
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4270
                self.ulong_number()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 4272
                self.changeReplicationSourceSSL()
                self.state = 4273
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4274
                self.ulong_number()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 4276
                self.changeReplicationSourceSSLCA()
                self.state = 4277
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4278
                self.textStringNoLinebreak()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 4280
                self.changeReplicationSourceSSLCApath()
                self.state = 4281
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4282
                self.textStringNoLinebreak()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 4284
                self.changeReplicationSourceTLSVersion()
                self.state = 4285
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4286
                self.textStringNoLinebreak()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 4288
                self.changeReplicationSourceSSLCert()
                self.state = 4289
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4290
                self.textStringNoLinebreak()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 4292
                self.changeReplicationSourceTLSCiphersuites()
                self.state = 4293
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4294
                self.sourceTlsCiphersuitesDef()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 4296
                self.changeReplicationSourceSSLCipher()
                self.state = 4297
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4298
                self.textStringNoLinebreak()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 4300
                self.changeReplicationSourceSSLKey()
                self.state = 4301
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4302
                self.textStringNoLinebreak()
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 4304
                self.changeReplicationSourceSSLVerifyServerCert()
                self.state = 4305
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4306
                self.ulong_number()
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 4308
                self.changeReplicationSourceSSLCLR()
                self.state = 4309
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4310
                self.textLiteral()
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 4312
                self.changeReplicationSourceSSLCLRpath()
                self.state = 4313
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4314
                self.textStringNoLinebreak()
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 4316
                self.changeReplicationSourcePublicKey()
                self.state = 4317
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4318
                self.textStringNoLinebreak()
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 4320
                self.changeReplicationSourceGetSourcePublicKey()
                self.state = 4321
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4322
                self.ulong_number()
                pass

            elif la_ == 23:
                self.enterOuterAlt(localctx, 23)
                self.state = 4324
                self.changeReplicationSourceHeartbeatPeriod()
                self.state = 4325
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4326
                self.ulong_number()
                pass

            elif la_ == 24:
                self.enterOuterAlt(localctx, 24)
                self.state = 4328
                self.match(MySQLParser.IGNORE_SERVER_IDS_SYMBOL)
                self.state = 4329
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4330
                self.serverIdList()
                pass

            elif la_ == 25:
                self.enterOuterAlt(localctx, 25)
                self.state = 4331
                self.changeReplicationSourceCompressionAlgorithm()
                self.state = 4332
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4333
                self.textStringLiteral()
                pass

            elif la_ == 26:
                self.enterOuterAlt(localctx, 26)
                self.state = 4335
                self.changeReplicationSourceZstdCompressionLevel()
                self.state = 4336
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4337
                self.ulong_number()
                pass

            elif la_ == 27:
                self.enterOuterAlt(localctx, 27)
                self.state = 4339
                self.changeReplicationSourceAutoPosition()
                self.state = 4340
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4341
                self.ulong_number()
                pass

            elif la_ == 28:
                self.enterOuterAlt(localctx, 28)
                self.state = 4343
                self.match(MySQLParser.PRIVILEGE_CHECKS_USER_SYMBOL)
                self.state = 4344
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4345
                self.privilegeCheckDef()
                pass

            elif la_ == 29:
                self.enterOuterAlt(localctx, 29)
                self.state = 4346
                self.match(MySQLParser.REQUIRE_ROW_FORMAT_SYMBOL)
                self.state = 4347
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4348
                self.ulong_number()
                pass

            elif la_ == 30:
                self.enterOuterAlt(localctx, 30)
                self.state = 4349
                self.match(MySQLParser.REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL)
                self.state = 4350
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4351
                self.tablePrimaryKeyCheckDef()
                pass

            elif la_ == 31:
                self.enterOuterAlt(localctx, 31)
                self.state = 4352
                if not self.isServerVersionGe80024():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                self.state = 4353
                self.match(MySQLParser.SOURCE_CONNECTION_AUTO_FAILOVER_SYMBOL)
                self.state = 4354
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4355
                self.real_ulong_number()
                pass

            elif la_ == 32:
                self.enterOuterAlt(localctx, 32)
                self.state = 4356
                if not self.isServerVersionGe80024():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                self.state = 4357
                self.match(MySQLParser.ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_SYMBOL)
                self.state = 4358
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4359
                self.assignGtidsToAnonymousTransactionsDefinition()
                pass

            elif la_ == 33:
                self.enterOuterAlt(localctx, 33)
                self.state = 4360
                if not self.isServerVersionGe80027():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80027()")
                self.state = 4361
                self.match(MySQLParser.GTID_ONLY_SYMBOL)
                self.state = 4362
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4363
                self.real_ulong_number()
                pass

            elif la_ == 34:
                self.enterOuterAlt(localctx, 34)
                self.state = 4364
                self.sourceFileDef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceAutoPositionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_AUTO_POSITION_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_AUTO_POSITION_SYMBOL, 0)

        def SOURCE_AUTO_POSITION_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_AUTO_POSITION_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceAutoPosition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceAutoPosition" ):
                listener.enterChangeReplicationSourceAutoPosition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceAutoPosition" ):
                listener.exitChangeReplicationSourceAutoPosition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceAutoPosition" ):
                return visitor.visitChangeReplicationSourceAutoPosition(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceAutoPosition(self):

        localctx = MySQLParser.ChangeReplicationSourceAutoPositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 496, self.RULE_changeReplicationSourceAutoPosition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4367
            _la = self._input.LA(1)
            if not(_la==322 or _la==766):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceHostContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_HOST_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_HOST_SYMBOL, 0)

        def SOURCE_HOST_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_HOST_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceHost

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceHost" ):
                listener.enterChangeReplicationSourceHost(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceHost" ):
                listener.exitChangeReplicationSourceHost(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceHost" ):
                return visitor.visitChangeReplicationSourceHost(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceHost(self):

        localctx = MySQLParser.ChangeReplicationSourceHostContext(self, self._ctx, self.state)
        self.enterRule(localctx, 498, self.RULE_changeReplicationSourceHost)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4369
            _la = self._input.LA(1)
            if not(_la==326 or _la==772):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceBindContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_BIND_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_BIND_SYMBOL, 0)

        def SOURCE_BIND_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_BIND_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceBind

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceBind" ):
                listener.enterChangeReplicationSourceBind(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceBind" ):
                listener.exitChangeReplicationSourceBind(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceBind" ):
                return visitor.visitChangeReplicationSourceBind(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceBind(self):

        localctx = MySQLParser.ChangeReplicationSourceBindContext(self, self._ctx, self.state)
        self.enterRule(localctx, 500, self.RULE_changeReplicationSourceBind)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4371
            _la = self._input.LA(1)
            if not(_la==323 or _la==767):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceUserContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_USER_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_USER_SYMBOL, 0)

        def SOURCE_USER_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_USER_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceUser

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceUser" ):
                listener.enterChangeReplicationSourceUser(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceUser" ):
                listener.exitChangeReplicationSourceUser(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceUser" ):
                return visitor.visitChangeReplicationSourceUser(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceUser(self):

        localctx = MySQLParser.ChangeReplicationSourceUserContext(self, self._ctx, self.state)
        self.enterRule(localctx, 502, self.RULE_changeReplicationSourceUser)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4373
            _la = self._input.LA(1)
            if not(_la==343 or _la==790):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourcePasswordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_PASSWORD_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_PASSWORD_SYMBOL, 0)

        def SOURCE_PASSWORD_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_PASSWORD_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourcePassword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourcePassword" ):
                listener.enterChangeReplicationSourcePassword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourcePassword" ):
                listener.exitChangeReplicationSourcePassword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourcePassword" ):
                return visitor.visitChangeReplicationSourcePassword(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourcePassword(self):

        localctx = MySQLParser.ChangeReplicationSourcePasswordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 504, self.RULE_changeReplicationSourcePassword)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4375
            _la = self._input.LA(1)
            if not(_la==329 or _la==775):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourcePortContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_PORT_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_PORT_SYMBOL, 0)

        def SOURCE_PORT_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_PORT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourcePort

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourcePort" ):
                listener.enterChangeReplicationSourcePort(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourcePort" ):
                listener.exitChangeReplicationSourcePort(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourcePort" ):
                return visitor.visitChangeReplicationSourcePort(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourcePort(self):

        localctx = MySQLParser.ChangeReplicationSourcePortContext(self, self._ctx, self.state)
        self.enterRule(localctx, 506, self.RULE_changeReplicationSourcePort)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4377
            _la = self._input.LA(1)
            if not(_la==330 or _la==776):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceConnectRetryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_CONNECT_RETRY_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_CONNECT_RETRY_SYMBOL, 0)

        def SOURCE_CONNECT_RETRY_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_CONNECT_RETRY_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceConnectRetry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceConnectRetry" ):
                listener.enterChangeReplicationSourceConnectRetry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceConnectRetry" ):
                listener.exitChangeReplicationSourceConnectRetry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceConnectRetry" ):
                return visitor.visitChangeReplicationSourceConnectRetry(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceConnectRetry(self):

        localctx = MySQLParser.ChangeReplicationSourceConnectRetryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 508, self.RULE_changeReplicationSourceConnectRetry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4379
            _la = self._input.LA(1)
            if not(_la==324 or _la==769):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceRetryCountContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_RETRY_COUNT_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_RETRY_COUNT_SYMBOL, 0)

        def SOURCE_RETRY_COUNT_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_RETRY_COUNT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceRetryCount

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceRetryCount" ):
                listener.enterChangeReplicationSourceRetryCount(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceRetryCount" ):
                listener.exitChangeReplicationSourceRetryCount(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceRetryCount" ):
                return visitor.visitChangeReplicationSourceRetryCount(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceRetryCount(self):

        localctx = MySQLParser.ChangeReplicationSourceRetryCountContext(self, self._ctx, self.state)
        self.enterRule(localctx, 510, self.RULE_changeReplicationSourceRetryCount)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4381
            _la = self._input.LA(1)
            if not(_la==331 or _la==778):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceDelayContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_DELAY_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_DELAY_SYMBOL, 0)

        def SOURCE_DELAY_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_DELAY_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceDelay

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceDelay" ):
                listener.enterChangeReplicationSourceDelay(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceDelay" ):
                listener.exitChangeReplicationSourceDelay(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceDelay" ):
                return visitor.visitChangeReplicationSourceDelay(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceDelay(self):

        localctx = MySQLParser.ChangeReplicationSourceDelayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 512, self.RULE_changeReplicationSourceDelay)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4383
            _la = self._input.LA(1)
            if not(_la==325 or _la==770):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceSSLContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_SSL_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_SYMBOL, 0)

        def SOURCE_SSL_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SSL_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceSSL

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceSSL" ):
                listener.enterChangeReplicationSourceSSL(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceSSL" ):
                listener.exitChangeReplicationSourceSSL(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceSSL" ):
                return visitor.visitChangeReplicationSourceSSL(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceSSL(self):

        localctx = MySQLParser.ChangeReplicationSourceSSLContext(self, self._ctx, self.state)
        self.enterRule(localctx, 514, self.RULE_changeReplicationSourceSSL)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4385
            _la = self._input.LA(1)
            if not(_la==339 or _la==779):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceSSLCAContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_SSL_CA_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_CA_SYMBOL, 0)

        def SOURCE_SSL_CA_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SSL_CA_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceSSLCA

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceSSLCA" ):
                listener.enterChangeReplicationSourceSSLCA(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceSSLCA" ):
                listener.exitChangeReplicationSourceSSLCA(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceSSLCA" ):
                return visitor.visitChangeReplicationSourceSSLCA(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceSSLCA(self):

        localctx = MySQLParser.ChangeReplicationSourceSSLCAContext(self, self._ctx, self.state)
        self.enterRule(localctx, 516, self.RULE_changeReplicationSourceSSLCA)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4387
            _la = self._input.LA(1)
            if not(_la==333 or _la==780):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceSSLCApathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_SSL_CAPATH_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_CAPATH_SYMBOL, 0)

        def SOURCE_SSL_CAPATH_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SSL_CAPATH_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceSSLCApath

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceSSLCApath" ):
                listener.enterChangeReplicationSourceSSLCApath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceSSLCApath" ):
                listener.exitChangeReplicationSourceSSLCApath(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceSSLCApath" ):
                return visitor.visitChangeReplicationSourceSSLCApath(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceSSLCApath(self):

        localctx = MySQLParser.ChangeReplicationSourceSSLCApathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 518, self.RULE_changeReplicationSourceSSLCApath)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4389
            _la = self._input.LA(1)
            if not(_la==332 or _la==781):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceSSLCipherContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_SSL_CIPHER_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_CIPHER_SYMBOL, 0)

        def SOURCE_SSL_CIPHER_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SSL_CIPHER_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceSSLCipher

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceSSLCipher" ):
                listener.enterChangeReplicationSourceSSLCipher(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceSSLCipher" ):
                listener.exitChangeReplicationSourceSSLCipher(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceSSLCipher" ):
                return visitor.visitChangeReplicationSourceSSLCipher(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceSSLCipher(self):

        localctx = MySQLParser.ChangeReplicationSourceSSLCipherContext(self, self._ctx, self.state)
        self.enterRule(localctx, 520, self.RULE_changeReplicationSourceSSLCipher)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4391
            _la = self._input.LA(1)
            if not(_la==335 or _la==783):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceSSLCLRContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_SSL_CRL_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_CRL_SYMBOL, 0)

        def SOURCE_SSL_CRL_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SSL_CRL_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceSSLCLR

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceSSLCLR" ):
                listener.enterChangeReplicationSourceSSLCLR(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceSSLCLR" ):
                listener.exitChangeReplicationSourceSSLCLR(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceSSLCLR" ):
                return visitor.visitChangeReplicationSourceSSLCLR(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceSSLCLR(self):

        localctx = MySQLParser.ChangeReplicationSourceSSLCLRContext(self, self._ctx, self.state)
        self.enterRule(localctx, 522, self.RULE_changeReplicationSourceSSLCLR)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4393
            _la = self._input.LA(1)
            if not(_la==336 or _la==784):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceSSLCLRpathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_SSL_CRLPATH_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_CRLPATH_SYMBOL, 0)

        def SOURCE_SSL_CRLPATH_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SSL_CRLPATH_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceSSLCLRpath

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceSSLCLRpath" ):
                listener.enterChangeReplicationSourceSSLCLRpath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceSSLCLRpath" ):
                listener.exitChangeReplicationSourceSSLCLRpath(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceSSLCLRpath" ):
                return visitor.visitChangeReplicationSourceSSLCLRpath(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceSSLCLRpath(self):

        localctx = MySQLParser.ChangeReplicationSourceSSLCLRpathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 524, self.RULE_changeReplicationSourceSSLCLRpath)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4395
            _la = self._input.LA(1)
            if not(_la==337 or _la==785):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceSSLKeyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_SSL_KEY_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_KEY_SYMBOL, 0)

        def SOURCE_SSL_KEY_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SSL_KEY_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceSSLKey

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceSSLKey" ):
                listener.enterChangeReplicationSourceSSLKey(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceSSLKey" ):
                listener.exitChangeReplicationSourceSSLKey(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceSSLKey" ):
                return visitor.visitChangeReplicationSourceSSLKey(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceSSLKey(self):

        localctx = MySQLParser.ChangeReplicationSourceSSLKeyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 526, self.RULE_changeReplicationSourceSSLKey)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4397
            _la = self._input.LA(1)
            if not(_la==338 or _la==786):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceSSLVerifyServerCertContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL, 0)

        def SOURCE_SSL_VERIFY_SERVER_CERT_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SSL_VERIFY_SERVER_CERT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceSSLVerifyServerCert

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceSSLVerifyServerCert" ):
                listener.enterChangeReplicationSourceSSLVerifyServerCert(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceSSLVerifyServerCert" ):
                listener.exitChangeReplicationSourceSSLVerifyServerCert(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceSSLVerifyServerCert" ):
                return visitor.visitChangeReplicationSourceSSLVerifyServerCert(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceSSLVerifyServerCert(self):

        localctx = MySQLParser.ChangeReplicationSourceSSLVerifyServerCertContext(self, self._ctx, self.state)
        self.enterRule(localctx, 528, self.RULE_changeReplicationSourceSSLVerifyServerCert)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4399
            _la = self._input.LA(1)
            if not(_la==340 or _la==787):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceTLSVersionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_TLS_VERSION_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_TLS_VERSION_SYMBOL, 0)

        def SOURCE_TLS_VERSION_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_TLS_VERSION_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceTLSVersion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceTLSVersion" ):
                listener.enterChangeReplicationSourceTLSVersion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceTLSVersion" ):
                listener.exitChangeReplicationSourceTLSVersion(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceTLSVersion" ):
                return visitor.visitChangeReplicationSourceTLSVersion(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceTLSVersion(self):

        localctx = MySQLParser.ChangeReplicationSourceTLSVersionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 530, self.RULE_changeReplicationSourceTLSVersion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4401
            _la = self._input.LA(1)
            if not(_la==342 or _la==789):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceTLSCiphersuitesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_TLS_CIPHERSUITES_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_TLS_CIPHERSUITES_SYMBOL, 0)

        def SOURCE_TLS_CIPHERSUITES_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_TLS_CIPHERSUITES_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceTLSCiphersuites

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceTLSCiphersuites" ):
                listener.enterChangeReplicationSourceTLSCiphersuites(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceTLSCiphersuites" ):
                listener.exitChangeReplicationSourceTLSCiphersuites(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceTLSCiphersuites" ):
                return visitor.visitChangeReplicationSourceTLSCiphersuites(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceTLSCiphersuites(self):

        localctx = MySQLParser.ChangeReplicationSourceTLSCiphersuitesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 532, self.RULE_changeReplicationSourceTLSCiphersuites)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4403
            _la = self._input.LA(1)
            if not(_la==746 or _la==788):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceSSLCertContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_SSL_CERT_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_CERT_SYMBOL, 0)

        def SOURCE_SSL_CERT_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SSL_CERT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceSSLCert

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceSSLCert" ):
                listener.enterChangeReplicationSourceSSLCert(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceSSLCert" ):
                listener.exitChangeReplicationSourceSSLCert(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceSSLCert" ):
                return visitor.visitChangeReplicationSourceSSLCert(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceSSLCert(self):

        localctx = MySQLParser.ChangeReplicationSourceSSLCertContext(self, self._ctx, self.state)
        self.enterRule(localctx, 534, self.RULE_changeReplicationSourceSSLCert)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4405
            _la = self._input.LA(1)
            if not(_la==334 or _la==782):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourcePublicKeyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_PUBLIC_KEY_PATH_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_PUBLIC_KEY_PATH_SYMBOL, 0)

        def SOURCE_PUBLIC_KEY_PATH_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_PUBLIC_KEY_PATH_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourcePublicKey

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourcePublicKey" ):
                listener.enterChangeReplicationSourcePublicKey(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourcePublicKey" ):
                listener.exitChangeReplicationSourcePublicKey(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourcePublicKey" ):
                return visitor.visitChangeReplicationSourcePublicKey(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourcePublicKey(self):

        localctx = MySQLParser.ChangeReplicationSourcePublicKeyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 536, self.RULE_changeReplicationSourcePublicKey)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4407
            _la = self._input.LA(1)
            if not(_la==720 or _la==777):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceGetSourcePublicKeyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GET_MASTER_PUBLIC_KEY_SYMBOL(self):
            return self.getToken(MySQLParser.GET_MASTER_PUBLIC_KEY_SYMBOL, 0)

        def GET_SOURCE_PUBLIC_KEY_SYMBOL(self):
            return self.getToken(MySQLParser.GET_SOURCE_PUBLIC_KEY_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceGetSourcePublicKey

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceGetSourcePublicKey" ):
                listener.enterChangeReplicationSourceGetSourcePublicKey(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceGetSourcePublicKey" ):
                listener.exitChangeReplicationSourceGetSourcePublicKey(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceGetSourcePublicKey" ):
                return visitor.visitChangeReplicationSourceGetSourcePublicKey(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceGetSourcePublicKey(self):

        localctx = MySQLParser.ChangeReplicationSourceGetSourcePublicKeyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 538, self.RULE_changeReplicationSourceGetSourcePublicKey)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4409
            _la = self._input.LA(1)
            if not(_la==721 or _la==765):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceHeartbeatPeriodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_HEARTBEAT_PERIOD_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_HEARTBEAT_PERIOD_SYMBOL, 0)

        def SOURCE_HEARTBEAT_PERIOD_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_HEARTBEAT_PERIOD_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceHeartbeatPeriod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceHeartbeatPeriod" ):
                listener.enterChangeReplicationSourceHeartbeatPeriod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceHeartbeatPeriod" ):
                listener.exitChangeReplicationSourceHeartbeatPeriod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceHeartbeatPeriod" ):
                return visitor.visitChangeReplicationSourceHeartbeatPeriod(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceHeartbeatPeriod(self):

        localctx = MySQLParser.ChangeReplicationSourceHeartbeatPeriodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 540, self.RULE_changeReplicationSourceHeartbeatPeriod)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4411
            _la = self._input.LA(1)
            if not(_la==344 or _la==771):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceCompressionAlgorithmContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_COMPRESSION_ALGORITHM_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_COMPRESSION_ALGORITHM_SYMBOL, 0)

        def SOURCE_COMPRESSION_ALGORITHM_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_COMPRESSION_ALGORITHM_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceCompressionAlgorithm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceCompressionAlgorithm" ):
                listener.enterChangeReplicationSourceCompressionAlgorithm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceCompressionAlgorithm" ):
                listener.exitChangeReplicationSourceCompressionAlgorithm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceCompressionAlgorithm" ):
                return visitor.visitChangeReplicationSourceCompressionAlgorithm(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceCompressionAlgorithm(self):

        localctx = MySQLParser.ChangeReplicationSourceCompressionAlgorithmContext(self, self._ctx, self.state)
        self.enterRule(localctx, 542, self.RULE_changeReplicationSourceCompressionAlgorithm)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4413
            _la = self._input.LA(1)
            if not(_la==743 or _la==768):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationSourceZstdCompressionLevelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, 0)

        def SOURCE_ZSTD_COMPRESSION_LEVEL_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_ZSTD_COMPRESSION_LEVEL_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplicationSourceZstdCompressionLevel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplicationSourceZstdCompressionLevel" ):
                listener.enterChangeReplicationSourceZstdCompressionLevel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplicationSourceZstdCompressionLevel" ):
                listener.exitChangeReplicationSourceZstdCompressionLevel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplicationSourceZstdCompressionLevel" ):
                return visitor.visitChangeReplicationSourceZstdCompressionLevel(self)
            else:
                return visitor.visitChildren(self)




    def changeReplicationSourceZstdCompressionLevel(self):

        localctx = MySQLParser.ChangeReplicationSourceZstdCompressionLevelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 544, self.RULE_changeReplicationSourceZstdCompressionLevel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4415
            _la = self._input.LA(1)
            if not(_la==744 or _la==791):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrivilegeCheckDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def userIdentifierOrText(self):
            return self.getTypedRuleContext(MySQLParser.UserIdentifierOrTextContext,0)


        def NULL_SYMBOL(self):
            return self.getToken(MySQLParser.NULL_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_privilegeCheckDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrivilegeCheckDef" ):
                listener.enterPrivilegeCheckDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrivilegeCheckDef" ):
                listener.exitPrivilegeCheckDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrivilegeCheckDef" ):
                return visitor.visitPrivilegeCheckDef(self)
            else:
                return visitor.visitChildren(self)




    def privilegeCheckDef(self):

        localctx = MySQLParser.PrivilegeCheckDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 546, self.RULE_privilegeCheckDef)
        try:
            self.state = 4419
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,450,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4417
                self.userIdentifierOrText()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4418
                self.match(MySQLParser.NULL_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TablePrimaryKeyCheckDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STREAM_SYMBOL(self):
            return self.getToken(MySQLParser.STREAM_SYMBOL, 0)

        def ON_SYMBOL(self):
            return self.getToken(MySQLParser.ON_SYMBOL, 0)

        def OFF_SYMBOL(self):
            return self.getToken(MySQLParser.OFF_SYMBOL, 0)

        def GENERATE_SYMBOL(self):
            return self.getToken(MySQLParser.GENERATE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_tablePrimaryKeyCheckDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTablePrimaryKeyCheckDef" ):
                listener.enterTablePrimaryKeyCheckDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTablePrimaryKeyCheckDef" ):
                listener.exitTablePrimaryKeyCheckDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTablePrimaryKeyCheckDef" ):
                return visitor.visitTablePrimaryKeyCheckDef(self)
            else:
                return visitor.visitChildren(self)




    def tablePrimaryKeyCheckDef(self):

        localctx = MySQLParser.TablePrimaryKeyCheckDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 548, self.RULE_tablePrimaryKeyCheckDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4421
            _la = self._input.LA(1)
            if not(_la==401 or ((((_la - 751)) & ~0x3f) == 0 and ((1 << (_la - 751)) & 36028797018963971) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignGtidsToAnonymousTransactionsDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OFF_SYMBOL(self):
            return self.getToken(MySQLParser.OFF_SYMBOL, 0)

        def LOCAL_SYMBOL(self):
            return self.getToken(MySQLParser.LOCAL_SYMBOL, 0)

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_assignGtidsToAnonymousTransactionsDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignGtidsToAnonymousTransactionsDefinition" ):
                listener.enterAssignGtidsToAnonymousTransactionsDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignGtidsToAnonymousTransactionsDefinition" ):
                listener.exitAssignGtidsToAnonymousTransactionsDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignGtidsToAnonymousTransactionsDefinition" ):
                return visitor.visitAssignGtidsToAnonymousTransactionsDefinition(self)
            else:
                return visitor.visitChildren(self)




    def assignGtidsToAnonymousTransactionsDefinition(self):

        localctx = MySQLParser.AssignGtidsToAnonymousTransactionsDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 550, self.RULE_assignGtidsToAnonymousTransactionsDefinition)
        try:
            self.state = 4426
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,451,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4423
                self.match(MySQLParser.OFF_SYMBOL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4424
                self.match(MySQLParser.LOCAL_SYMBOL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 4425
                self.textStringLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceTlsCiphersuitesDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textStringNoLinebreak(self):
            return self.getTypedRuleContext(MySQLParser.TextStringNoLinebreakContext,0)


        def NULL_SYMBOL(self):
            return self.getToken(MySQLParser.NULL_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_sourceTlsCiphersuitesDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSourceTlsCiphersuitesDef" ):
                listener.enterSourceTlsCiphersuitesDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSourceTlsCiphersuitesDef" ):
                listener.exitSourceTlsCiphersuitesDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSourceTlsCiphersuitesDef" ):
                return visitor.visitSourceTlsCiphersuitesDef(self)
            else:
                return visitor.visitChildren(self)




    def sourceTlsCiphersuitesDef(self):

        localctx = MySQLParser.SourceTlsCiphersuitesDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 552, self.RULE_sourceTlsCiphersuitesDef)
        try:
            self.state = 4430
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,452,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4428
                self.textStringNoLinebreak()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4429
                self.match(MySQLParser.NULL_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceFileDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sourceLogFile(self):
            return self.getTypedRuleContext(MySQLParser.SourceLogFileContext,0)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def textStringNoLinebreak(self):
            return self.getTypedRuleContext(MySQLParser.TextStringNoLinebreakContext,0)


        def sourceLogPos(self):
            return self.getTypedRuleContext(MySQLParser.SourceLogPosContext,0)


        def ulonglongNumber(self):
            return self.getTypedRuleContext(MySQLParser.UlonglongNumberContext,0)


        def RELAY_LOG_FILE_SYMBOL(self):
            return self.getToken(MySQLParser.RELAY_LOG_FILE_SYMBOL, 0)

        def RELAY_LOG_POS_SYMBOL(self):
            return self.getToken(MySQLParser.RELAY_LOG_POS_SYMBOL, 0)

        def ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Ulong_numberContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_sourceFileDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSourceFileDef" ):
                listener.enterSourceFileDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSourceFileDef" ):
                listener.exitSourceFileDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSourceFileDef" ):
                return visitor.visitSourceFileDef(self)
            else:
                return visitor.visitChildren(self)




    def sourceFileDef(self):

        localctx = MySQLParser.SourceFileDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 554, self.RULE_sourceFileDef)
        try:
            self.state = 4446
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [327, 773]:
                self.enterOuterAlt(localctx, 1)
                self.state = 4432
                self.sourceLogFile()
                self.state = 4433
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4434
                self.textStringNoLinebreak()
                pass
            elif token in [328, 774]:
                self.enterOuterAlt(localctx, 2)
                self.state = 4436
                self.sourceLogPos()
                self.state = 4437
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4438
                self.ulonglongNumber()
                pass
            elif token in [464]:
                self.enterOuterAlt(localctx, 3)
                self.state = 4440
                self.match(MySQLParser.RELAY_LOG_FILE_SYMBOL)
                self.state = 4441
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4442
                self.textStringNoLinebreak()
                pass
            elif token in [465]:
                self.enterOuterAlt(localctx, 4)
                self.state = 4443
                self.match(MySQLParser.RELAY_LOG_POS_SYMBOL)
                self.state = 4444
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4445
                self.ulong_number()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceLogFileContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_LOG_FILE_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_LOG_FILE_SYMBOL, 0)

        def SOURCE_LOG_FILE_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_LOG_FILE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_sourceLogFile

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSourceLogFile" ):
                listener.enterSourceLogFile(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSourceLogFile" ):
                listener.exitSourceLogFile(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSourceLogFile" ):
                return visitor.visitSourceLogFile(self)
            else:
                return visitor.visitChildren(self)




    def sourceLogFile(self):

        localctx = MySQLParser.SourceLogFileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 556, self.RULE_sourceLogFile)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4448
            _la = self._input.LA(1)
            if not(_la==327 or _la==773):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceLogPosContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASTER_LOG_POS_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_LOG_POS_SYMBOL, 0)

        def SOURCE_LOG_POS_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_LOG_POS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_sourceLogPos

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSourceLogPos" ):
                listener.enterSourceLogPos(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSourceLogPos" ):
                listener.exitSourceLogPos(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSourceLogPos" ):
                return visitor.visitSourceLogPos(self)
            else:
                return visitor.visitChildren(self)




    def sourceLogPos(self):

        localctx = MySQLParser.SourceLogPosContext(self, self._ctx, self.state)
        self.enterRule(localctx, 558, self.RULE_sourceLogPos)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4450
            _la = self._input.LA(1)
            if not(_la==328 or _la==774):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ServerIdListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def ulong_number(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.Ulong_numberContext)
            else:
                return self.getTypedRuleContext(MySQLParser.Ulong_numberContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_serverIdList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterServerIdList" ):
                listener.enterServerIdList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitServerIdList" ):
                listener.exitServerIdList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitServerIdList" ):
                return visitor.visitServerIdList(self)
            else:
                return visitor.visitChildren(self)




    def serverIdList(self):

        localctx = MySQLParser.ServerIdListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 560, self.RULE_serverIdList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4452
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 4461
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 228698418577464) != 0):
                self.state = 4453
                self.ulong_number()
                self.state = 4458
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==29:
                    self.state = 4454
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 4455
                    self.ulong_number()
                    self.state = 4460
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 4463
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeReplicationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHANGE_SYMBOL(self):
            return self.getToken(MySQLParser.CHANGE_SYMBOL, 0)

        def REPLICATION_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATION_SYMBOL, 0)

        def FILTER_SYMBOL(self):
            return self.getToken(MySQLParser.FILTER_SYMBOL, 0)

        def filterDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.FilterDefinitionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.FilterDefinitionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def channel(self):
            return self.getTypedRuleContext(MySQLParser.ChannelContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_changeReplication

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeReplication" ):
                listener.enterChangeReplication(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeReplication" ):
                listener.exitChangeReplication(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeReplication" ):
                return visitor.visitChangeReplication(self)
            else:
                return visitor.visitChildren(self)




    def changeReplication(self):

        localctx = MySQLParser.ChangeReplicationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 562, self.RULE_changeReplication)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4465
            self.match(MySQLParser.CHANGE_SYMBOL)
            self.state = 4466
            self.match(MySQLParser.REPLICATION_SYMBOL)
            self.state = 4467
            self.match(MySQLParser.FILTER_SYMBOL)
            self.state = 4468
            self.filterDefinition()
            self.state = 4473
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 4469
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 4470
                self.filterDefinition()
                self.state = 4475
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 4477
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==232:
                self.state = 4476
                self.channel()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FilterDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPLICATE_DO_DB_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_DO_DB_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def filterDbList(self):
            return self.getTypedRuleContext(MySQLParser.FilterDbListContext,0)


        def REPLICATE_IGNORE_DB_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_IGNORE_DB_SYMBOL, 0)

        def REPLICATE_DO_TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_DO_TABLE_SYMBOL, 0)

        def filterTableList(self):
            return self.getTypedRuleContext(MySQLParser.FilterTableListContext,0)


        def REPLICATE_IGNORE_TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_IGNORE_TABLE_SYMBOL, 0)

        def REPLICATE_WILD_DO_TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_WILD_DO_TABLE_SYMBOL, 0)

        def filterStringList(self):
            return self.getTypedRuleContext(MySQLParser.FilterStringListContext,0)


        def REPLICATE_WILD_IGNORE_TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_WILD_IGNORE_TABLE_SYMBOL, 0)

        def REPLICATE_REWRITE_DB_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_REWRITE_DB_SYMBOL, 0)

        def filterDbPairList(self):
            return self.getTypedRuleContext(MySQLParser.FilterDbPairListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_filterDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilterDefinition" ):
                listener.enterFilterDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilterDefinition" ):
                listener.exitFilterDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilterDefinition" ):
                return visitor.visitFilterDefinition(self)
            else:
                return visitor.visitChildren(self)




    def filterDefinition(self):

        localctx = MySQLParser.FilterDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 564, self.RULE_filterDefinition)
        self._la = 0 # Token type
        try:
            self.state = 4528
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [477]:
                self.enterOuterAlt(localctx, 1)
                self.state = 4479
                self.match(MySQLParser.REPLICATE_DO_DB_SYMBOL)
                self.state = 4480
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4481
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 4483
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,458,self._ctx)
                if la_ == 1:
                    self.state = 4482
                    self.filterDbList()


                self.state = 4485
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass
            elif token in [478]:
                self.enterOuterAlt(localctx, 2)
                self.state = 4486
                self.match(MySQLParser.REPLICATE_IGNORE_DB_SYMBOL)
                self.state = 4487
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4488
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 4490
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,459,self._ctx)
                if la_ == 1:
                    self.state = 4489
                    self.filterDbList()


                self.state = 4492
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass
            elif token in [479]:
                self.enterOuterAlt(localctx, 3)
                self.state = 4493
                self.match(MySQLParser.REPLICATE_DO_TABLE_SYMBOL)
                self.state = 4494
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4495
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 4497
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,460,self._ctx)
                if la_ == 1:
                    self.state = 4496
                    self.filterTableList()


                self.state = 4499
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass
            elif token in [480]:
                self.enterOuterAlt(localctx, 4)
                self.state = 4500
                self.match(MySQLParser.REPLICATE_IGNORE_TABLE_SYMBOL)
                self.state = 4501
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4502
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 4504
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,461,self._ctx)
                if la_ == 1:
                    self.state = 4503
                    self.filterTableList()


                self.state = 4506
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass
            elif token in [481]:
                self.enterOuterAlt(localctx, 5)
                self.state = 4507
                self.match(MySQLParser.REPLICATE_WILD_DO_TABLE_SYMBOL)
                self.state = 4508
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4509
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 4511
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,462,self._ctx)
                if la_ == 1:
                    self.state = 4510
                    self.filterStringList()


                self.state = 4513
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass
            elif token in [482]:
                self.enterOuterAlt(localctx, 6)
                self.state = 4514
                self.match(MySQLParser.REPLICATE_WILD_IGNORE_TABLE_SYMBOL)
                self.state = 4515
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4516
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 4518
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,463,self._ctx)
                if la_ == 1:
                    self.state = 4517
                    self.filterStringList()


                self.state = 4520
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass
            elif token in [483]:
                self.enterOuterAlt(localctx, 7)
                self.state = 4521
                self.match(MySQLParser.REPLICATE_REWRITE_DB_SYMBOL)
                self.state = 4522
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4523
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 4525
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==32:
                    self.state = 4524
                    self.filterDbPairList()


                self.state = 4527
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FilterDbListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def schemaRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.SchemaRefContext)
            else:
                return self.getTypedRuleContext(MySQLParser.SchemaRefContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_filterDbList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilterDbList" ):
                listener.enterFilterDbList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilterDbList" ):
                listener.exitFilterDbList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilterDbList" ):
                return visitor.visitFilterDbList(self)
            else:
                return visitor.visitChildren(self)




    def filterDbList(self):

        localctx = MySQLParser.FilterDbListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 566, self.RULE_filterDbList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4530
            self.schemaRef()
            self.state = 4535
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 4531
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 4532
                self.schemaRef()
                self.state = 4537
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FilterTableListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filterTableRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.FilterTableRefContext)
            else:
                return self.getTypedRuleContext(MySQLParser.FilterTableRefContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_filterTableList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilterTableList" ):
                listener.enterFilterTableList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilterTableList" ):
                listener.exitFilterTableList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilterTableList" ):
                return visitor.visitFilterTableList(self)
            else:
                return visitor.visitChildren(self)




    def filterTableList(self):

        localctx = MySQLParser.FilterTableListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 568, self.RULE_filterTableList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4538
            self.filterTableRef()
            self.state = 4543
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 4539
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 4540
                self.filterTableRef()
                self.state = 4545
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FilterStringListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filterWildDbTableString(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.FilterWildDbTableStringContext)
            else:
                return self.getTypedRuleContext(MySQLParser.FilterWildDbTableStringContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_filterStringList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilterStringList" ):
                listener.enterFilterStringList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilterStringList" ):
                listener.exitFilterStringList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilterStringList" ):
                return visitor.visitFilterStringList(self)
            else:
                return visitor.visitChildren(self)




    def filterStringList(self):

        localctx = MySQLParser.FilterStringListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 570, self.RULE_filterStringList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4546
            self.filterWildDbTableString()
            self.state = 4551
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 4547
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 4548
                self.filterWildDbTableString()
                self.state = 4553
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FilterWildDbTableStringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textStringNoLinebreak(self):
            return self.getTypedRuleContext(MySQLParser.TextStringNoLinebreakContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_filterWildDbTableString

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilterWildDbTableString" ):
                listener.enterFilterWildDbTableString(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilterWildDbTableString" ):
                listener.exitFilterWildDbTableString(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilterWildDbTableString" ):
                return visitor.visitFilterWildDbTableString(self)
            else:
                return visitor.visitChildren(self)




    def filterWildDbTableString(self):

        localctx = MySQLParser.FilterWildDbTableStringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 572, self.RULE_filterWildDbTableString)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4554
            self.textStringNoLinebreak()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FilterDbPairListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def schemaIdentifierPair(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.SchemaIdentifierPairContext)
            else:
                return self.getTypedRuleContext(MySQLParser.SchemaIdentifierPairContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_filterDbPairList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilterDbPairList" ):
                listener.enterFilterDbPairList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilterDbPairList" ):
                listener.exitFilterDbPairList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilterDbPairList" ):
                return visitor.visitFilterDbPairList(self)
            else:
                return visitor.visitChildren(self)




    def filterDbPairList(self):

        localctx = MySQLParser.FilterDbPairListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 574, self.RULE_filterDbPairList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4556
            self.schemaIdentifierPair()
            self.state = 4561
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 4557
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 4558
                self.schemaIdentifierPair()
                self.state = 4563
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StartReplicaStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def START_SYMBOL(self):
            return self.getToken(MySQLParser.START_SYMBOL, 0)

        def replica(self):
            return self.getTypedRuleContext(MySQLParser.ReplicaContext,0)


        def replicaThreadOptions(self):
            return self.getTypedRuleContext(MySQLParser.ReplicaThreadOptionsContext,0)


        def UNTIL_SYMBOL(self):
            return self.getToken(MySQLParser.UNTIL_SYMBOL, 0)

        def replicaUntil(self):
            return self.getTypedRuleContext(MySQLParser.ReplicaUntilContext,0)


        def userOption(self):
            return self.getTypedRuleContext(MySQLParser.UserOptionContext,0)


        def passwordOption(self):
            return self.getTypedRuleContext(MySQLParser.PasswordOptionContext,0)


        def defaultAuthOption(self):
            return self.getTypedRuleContext(MySQLParser.DefaultAuthOptionContext,0)


        def pluginDirOption(self):
            return self.getTypedRuleContext(MySQLParser.PluginDirOptionContext,0)


        def channel(self):
            return self.getTypedRuleContext(MySQLParser.ChannelContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_startReplicaStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartReplicaStatement" ):
                listener.enterStartReplicaStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartReplicaStatement" ):
                listener.exitStartReplicaStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartReplicaStatement" ):
                return visitor.visitStartReplicaStatement(self)
            else:
                return visitor.visitChildren(self)




    def startReplicaStatement(self):

        localctx = MySQLParser.StartReplicaStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 576, self.RULE_startReplicaStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4564
            self.match(MySQLParser.START_SYMBOL)
            self.state = 4565
            self.replica()
            self.state = 4567
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==466 or _la==548:
                self.state = 4566
                self.replicaThreadOptions()


            self.state = 4571
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==622:
                self.state = 4569
                self.match(MySQLParser.UNTIL_SYMBOL)
                self.state = 4570
                self.replicaUntil()


            self.state = 4574
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==627:
                self.state = 4573
                self.userOption()


            self.state = 4577
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==424:
                self.state = 4576
                self.passwordOption()


            self.state = 4580
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==167:
                self.state = 4579
                self.defaultAuthOption()


            self.state = 4583
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==427:
                self.state = 4582
                self.pluginDirOption()


            self.state = 4586
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==232:
                self.state = 4585
                self.channel()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StopReplicaStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STOP_SYMBOL(self):
            return self.getToken(MySQLParser.STOP_SYMBOL, 0)

        def replica(self):
            return self.getTypedRuleContext(MySQLParser.ReplicaContext,0)


        def replicaThreadOptions(self):
            return self.getTypedRuleContext(MySQLParser.ReplicaThreadOptionsContext,0)


        def channel(self):
            return self.getTypedRuleContext(MySQLParser.ChannelContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_stopReplicaStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStopReplicaStatement" ):
                listener.enterStopReplicaStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStopReplicaStatement" ):
                listener.exitStopReplicaStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStopReplicaStatement" ):
                return visitor.visitStopReplicaStatement(self)
            else:
                return visitor.visitChildren(self)




    def stopReplicaStatement(self):

        localctx = MySQLParser.StopReplicaStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 578, self.RULE_stopReplicaStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4588
            self.match(MySQLParser.STOP_SYMBOL)
            self.state = 4589
            self.replica()
            self.state = 4591
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==466 or _la==548:
                self.state = 4590
                self.replicaThreadOptions()


            self.state = 4594
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==232:
                self.state = 4593
                self.channel()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReplicaUntilContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sourceFileDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.SourceFileDefContext)
            else:
                return self.getTypedRuleContext(MySQLParser.SourceFileDefContext,i)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def textString(self):
            return self.getTypedRuleContext(MySQLParser.TextStringContext,0)


        def SQL_AFTER_MTS_GAPS_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_AFTER_MTS_GAPS_SYMBOL, 0)

        def SQL_BEFORE_GTIDS_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_BEFORE_GTIDS_SYMBOL, 0)

        def SQL_AFTER_GTIDS_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_AFTER_GTIDS_SYMBOL, 0)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_replicaUntil

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplicaUntil" ):
                listener.enterReplicaUntil(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplicaUntil" ):
                listener.exitReplicaUntil(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReplicaUntil" ):
                return visitor.visitReplicaUntil(self)
            else:
                return visitor.visitChildren(self)




    def replicaUntil(self):

        localctx = MySQLParser.ReplicaUntilContext(self, self._ctx, self.state)
        self.enterRule(localctx, 580, self.RULE_replicaUntil)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4601
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [327, 328, 464, 465, 773, 774]:
                self.state = 4596
                self.sourceFileDef()
                pass
            elif token in [539, 541]:
                self.state = 4597
                _la = self._input.LA(1)
                if not(_la==539 or _la==541):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 4598
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 4599
                self.textString()
                pass
            elif token in [540]:
                self.state = 4600
                self.match(MySQLParser.SQL_AFTER_MTS_GAPS_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 4607
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 4603
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 4604
                self.sourceFileDef()
                self.state = 4609
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UserOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USER_SYMBOL(self):
            return self.getToken(MySQLParser.USER_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def textString(self):
            return self.getTypedRuleContext(MySQLParser.TextStringContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_userOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUserOption" ):
                listener.enterUserOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUserOption" ):
                listener.exitUserOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUserOption" ):
                return visitor.visitUserOption(self)
            else:
                return visitor.visitChildren(self)




    def userOption(self):

        localctx = MySQLParser.UserOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 582, self.RULE_userOption)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4610
            self.match(MySQLParser.USER_SYMBOL)
            self.state = 4611
            self.match(MySQLParser.EQUAL_OPERATOR)
            self.state = 4612
            self.textString()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PasswordOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PASSWORD_SYMBOL(self):
            return self.getToken(MySQLParser.PASSWORD_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def textString(self):
            return self.getTypedRuleContext(MySQLParser.TextStringContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_passwordOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPasswordOption" ):
                listener.enterPasswordOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPasswordOption" ):
                listener.exitPasswordOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPasswordOption" ):
                return visitor.visitPasswordOption(self)
            else:
                return visitor.visitChildren(self)




    def passwordOption(self):

        localctx = MySQLParser.PasswordOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 584, self.RULE_passwordOption)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4614
            self.match(MySQLParser.PASSWORD_SYMBOL)
            self.state = 4615
            self.match(MySQLParser.EQUAL_OPERATOR)
            self.state = 4616
            self.textString()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultAuthOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFAULT_AUTH_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_AUTH_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def textString(self):
            return self.getTypedRuleContext(MySQLParser.TextStringContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_defaultAuthOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefaultAuthOption" ):
                listener.enterDefaultAuthOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefaultAuthOption" ):
                listener.exitDefaultAuthOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefaultAuthOption" ):
                return visitor.visitDefaultAuthOption(self)
            else:
                return visitor.visitChildren(self)




    def defaultAuthOption(self):

        localctx = MySQLParser.DefaultAuthOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 586, self.RULE_defaultAuthOption)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4618
            self.match(MySQLParser.DEFAULT_AUTH_SYMBOL)
            self.state = 4619
            self.match(MySQLParser.EQUAL_OPERATOR)
            self.state = 4620
            self.textString()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PluginDirOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUGIN_DIR_SYMBOL(self):
            return self.getToken(MySQLParser.PLUGIN_DIR_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def textString(self):
            return self.getTypedRuleContext(MySQLParser.TextStringContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_pluginDirOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPluginDirOption" ):
                listener.enterPluginDirOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPluginDirOption" ):
                listener.exitPluginDirOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPluginDirOption" ):
                return visitor.visitPluginDirOption(self)
            else:
                return visitor.visitChildren(self)




    def pluginDirOption(self):

        localctx = MySQLParser.PluginDirOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 588, self.RULE_pluginDirOption)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4622
            self.match(MySQLParser.PLUGIN_DIR_SYMBOL)
            self.state = 4623
            self.match(MySQLParser.EQUAL_OPERATOR)
            self.state = 4624
            self.textString()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReplicaThreadOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def replicaThreadOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ReplicaThreadOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ReplicaThreadOptionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_replicaThreadOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplicaThreadOptions" ):
                listener.enterReplicaThreadOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplicaThreadOptions" ):
                listener.exitReplicaThreadOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReplicaThreadOptions" ):
                return visitor.visitReplicaThreadOptions(self)
            else:
                return visitor.visitChildren(self)




    def replicaThreadOptions(self):

        localctx = MySQLParser.ReplicaThreadOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 590, self.RULE_replicaThreadOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4626
            self.replicaThreadOption()
            self.state = 4631
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 4627
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 4628
                self.replicaThreadOption()
                self.state = 4633
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReplicaThreadOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SQL_THREAD_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_THREAD_SYMBOL, 0)

        def RELAY_THREAD_SYMBOL(self):
            return self.getToken(MySQLParser.RELAY_THREAD_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_replicaThreadOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplicaThreadOption" ):
                listener.enterReplicaThreadOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplicaThreadOption" ):
                listener.exitReplicaThreadOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReplicaThreadOption" ):
                return visitor.visitReplicaThreadOption(self)
            else:
                return visitor.visitChildren(self)




    def replicaThreadOption(self):

        localctx = MySQLParser.ReplicaThreadOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 592, self.RULE_replicaThreadOption)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4634
            _la = self._input.LA(1)
            if not(_la==466 or _la==548):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupReplicationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GROUP_REPLICATION_SYMBOL(self):
            return self.getToken(MySQLParser.GROUP_REPLICATION_SYMBOL, 0)

        def START_SYMBOL(self):
            return self.getToken(MySQLParser.START_SYMBOL, 0)

        def STOP_SYMBOL(self):
            return self.getToken(MySQLParser.STOP_SYMBOL, 0)

        def groupReplicationStartOptions(self):
            return self.getTypedRuleContext(MySQLParser.GroupReplicationStartOptionsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_groupReplication

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupReplication" ):
                listener.enterGroupReplication(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupReplication" ):
                listener.exitGroupReplication(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupReplication" ):
                return visitor.visitGroupReplication(self)
            else:
                return visitor.visitChildren(self)




    def groupReplication(self):

        localctx = MySQLParser.GroupReplicationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 594, self.RULE_groupReplication)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4641
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [553]:
                self.state = 4636
                self.match(MySQLParser.START_SYMBOL)
                self.state = 4638
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==167 or _la==424 or _la==627:
                    self.state = 4637
                    self.groupReplicationStartOptions()


                pass
            elif token in [562]:
                self.state = 4640
                self.match(MySQLParser.STOP_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 4643
            self.match(MySQLParser.GROUP_REPLICATION_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupReplicationStartOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def groupReplicationStartOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.GroupReplicationStartOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.GroupReplicationStartOptionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_groupReplicationStartOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupReplicationStartOptions" ):
                listener.enterGroupReplicationStartOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupReplicationStartOptions" ):
                listener.exitGroupReplicationStartOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupReplicationStartOptions" ):
                return visitor.visitGroupReplicationStartOptions(self)
            else:
                return visitor.visitChildren(self)




    def groupReplicationStartOptions(self):

        localctx = MySQLParser.GroupReplicationStartOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 596, self.RULE_groupReplicationStartOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4645
            self.groupReplicationStartOption()
            self.state = 4650
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 4646
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 4647
                self.groupReplicationStartOption()
                self.state = 4652
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupReplicationStartOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def groupReplicationUser(self):
            return self.getTypedRuleContext(MySQLParser.GroupReplicationUserContext,0)


        def groupReplicationPassword(self):
            return self.getTypedRuleContext(MySQLParser.GroupReplicationPasswordContext,0)


        def groupReplicationPluginAuth(self):
            return self.getTypedRuleContext(MySQLParser.GroupReplicationPluginAuthContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_groupReplicationStartOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupReplicationStartOption" ):
                listener.enterGroupReplicationStartOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupReplicationStartOption" ):
                listener.exitGroupReplicationStartOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupReplicationStartOption" ):
                return visitor.visitGroupReplicationStartOption(self)
            else:
                return visitor.visitChildren(self)




    def groupReplicationStartOption(self):

        localctx = MySQLParser.GroupReplicationStartOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 598, self.RULE_groupReplicationStartOption)
        try:
            self.state = 4656
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [627]:
                self.enterOuterAlt(localctx, 1)
                self.state = 4653
                self.groupReplicationUser()
                pass
            elif token in [424]:
                self.enterOuterAlt(localctx, 2)
                self.state = 4654
                self.groupReplicationPassword()
                pass
            elif token in [167]:
                self.enterOuterAlt(localctx, 3)
                self.state = 4655
                self.groupReplicationPluginAuth()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupReplicationUserContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USER_SYMBOL(self):
            return self.getToken(MySQLParser.USER_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def textStringNoLinebreak(self):
            return self.getTypedRuleContext(MySQLParser.TextStringNoLinebreakContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_groupReplicationUser

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupReplicationUser" ):
                listener.enterGroupReplicationUser(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupReplicationUser" ):
                listener.exitGroupReplicationUser(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupReplicationUser" ):
                return visitor.visitGroupReplicationUser(self)
            else:
                return visitor.visitChildren(self)




    def groupReplicationUser(self):

        localctx = MySQLParser.GroupReplicationUserContext(self, self._ctx, self.state)
        self.enterRule(localctx, 600, self.RULE_groupReplicationUser)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4658
            self.match(MySQLParser.USER_SYMBOL)
            self.state = 4659
            self.match(MySQLParser.EQUAL_OPERATOR)
            self.state = 4660
            self.textStringNoLinebreak()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupReplicationPasswordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PASSWORD_SYMBOL(self):
            return self.getToken(MySQLParser.PASSWORD_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def textStringNoLinebreak(self):
            return self.getTypedRuleContext(MySQLParser.TextStringNoLinebreakContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_groupReplicationPassword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupReplicationPassword" ):
                listener.enterGroupReplicationPassword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupReplicationPassword" ):
                listener.exitGroupReplicationPassword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupReplicationPassword" ):
                return visitor.visitGroupReplicationPassword(self)
            else:
                return visitor.visitChildren(self)




    def groupReplicationPassword(self):

        localctx = MySQLParser.GroupReplicationPasswordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 602, self.RULE_groupReplicationPassword)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4662
            self.match(MySQLParser.PASSWORD_SYMBOL)
            self.state = 4663
            self.match(MySQLParser.EQUAL_OPERATOR)
            self.state = 4664
            self.textStringNoLinebreak()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupReplicationPluginAuthContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFAULT_AUTH_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_AUTH_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def textStringNoLinebreak(self):
            return self.getTypedRuleContext(MySQLParser.TextStringNoLinebreakContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_groupReplicationPluginAuth

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupReplicationPluginAuth" ):
                listener.enterGroupReplicationPluginAuth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupReplicationPluginAuth" ):
                listener.exitGroupReplicationPluginAuth(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupReplicationPluginAuth" ):
                return visitor.visitGroupReplicationPluginAuth(self)
            else:
                return visitor.visitChildren(self)




    def groupReplicationPluginAuth(self):

        localctx = MySQLParser.GroupReplicationPluginAuthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 604, self.RULE_groupReplicationPluginAuth)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4666
            self.match(MySQLParser.DEFAULT_AUTH_SYMBOL)
            self.state = 4667
            self.match(MySQLParser.EQUAL_OPERATOR)
            self.state = 4668
            self.textStringNoLinebreak()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReplicaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SLAVE_SYMBOL(self):
            return self.getToken(MySQLParser.SLAVE_SYMBOL, 0)

        def REPLICA_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICA_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_replica

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplica" ):
                listener.enterReplica(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplica" ):
                listener.exitReplica(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReplica" ):
                return visitor.visitReplica(self)
            else:
                return visitor.visitChildren(self)




    def replica(self):

        localctx = MySQLParser.ReplicaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 606, self.RULE_replica)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4670
            _la = self._input.LA(1)
            if not(_la==526 or _la==762):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PreparedStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # Token

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def FROM_SYMBOL(self):
            return self.getToken(MySQLParser.FROM_SYMBOL, 0)

        def PREPARE_SYMBOL(self):
            return self.getToken(MySQLParser.PREPARE_SYMBOL, 0)

        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def userVariable(self):
            return self.getTypedRuleContext(MySQLParser.UserVariableContext,0)


        def executeStatement(self):
            return self.getTypedRuleContext(MySQLParser.ExecuteStatementContext,0)


        def DEALLOCATE_SYMBOL(self):
            return self.getToken(MySQLParser.DEALLOCATE_SYMBOL, 0)

        def DROP_SYMBOL(self):
            return self.getToken(MySQLParser.DROP_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_preparedStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreparedStatement" ):
                listener.enterPreparedStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreparedStatement" ):
                listener.exitPreparedStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreparedStatement" ):
                return visitor.visitPreparedStatement(self)
            else:
                return visitor.visitChildren(self)




    def preparedStatement(self):

        localctx = MySQLParser.PreparedStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 608, self.RULE_preparedStatement)
        self._la = 0 # Token type
        try:
            self.state = 4683
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [435]:
                self.enterOuterAlt(localctx, 1)
                self.state = 4672
                localctx.type_ = self.match(MySQLParser.PREPARE_SYMBOL)
                self.state = 4673
                self.identifier()
                self.state = 4674
                self.match(MySQLParser.FROM_SYMBOL)
                self.state = 4677
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,486,self._ctx)
                if la_ == 1:
                    self.state = 4675
                    self.textLiteral()
                    pass

                elif la_ == 2:
                    self.state = 4676
                    self.userVariable()
                    pass


                pass
            elif token in [208]:
                self.enterOuterAlt(localctx, 2)
                self.state = 4679
                self.executeStatement()
                pass
            elif token in [163, 184]:
                self.enterOuterAlt(localctx, 3)
                self.state = 4680
                localctx.type_ = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==163 or _la==184):
                    localctx.type_ = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 4681
                self.match(MySQLParser.PREPARE_SYMBOL)
                self.state = 4682
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExecuteStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXECUTE_SYMBOL(self):
            return self.getToken(MySQLParser.EXECUTE_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def USING_SYMBOL(self):
            return self.getToken(MySQLParser.USING_SYMBOL, 0)

        def executeVarList(self):
            return self.getTypedRuleContext(MySQLParser.ExecuteVarListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_executeStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExecuteStatement" ):
                listener.enterExecuteStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExecuteStatement" ):
                listener.exitExecuteStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExecuteStatement" ):
                return visitor.visitExecuteStatement(self)
            else:
                return visitor.visitChildren(self)




    def executeStatement(self):

        localctx = MySQLParser.ExecuteStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 610, self.RULE_executeStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4685
            self.match(MySQLParser.EXECUTE_SYMBOL)
            self.state = 4686
            self.identifier()
            self.state = 4689
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==630:
                self.state = 4687
                self.match(MySQLParser.USING_SYMBOL)
                self.state = 4688
                self.executeVarList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExecuteVarListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def userVariable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.UserVariableContext)
            else:
                return self.getTypedRuleContext(MySQLParser.UserVariableContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_executeVarList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExecuteVarList" ):
                listener.enterExecuteVarList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExecuteVarList" ):
                listener.exitExecuteVarList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExecuteVarList" ):
                return visitor.visitExecuteVarList(self)
            else:
                return visitor.visitChildren(self)




    def executeVarList(self):

        localctx = MySQLParser.ExecuteVarListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 612, self.RULE_executeVarList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4691
            self.userVariable()
            self.state = 4696
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 4692
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 4693
                self.userVariable()
                self.state = 4698
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CloneStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CLONE_SYMBOL(self):
            return self.getToken(MySQLParser.CLONE_SYMBOL, 0)

        def LOCAL_SYMBOL(self):
            return self.getToken(MySQLParser.LOCAL_SYMBOL, 0)

        def DATA_SYMBOL(self):
            return self.getToken(MySQLParser.DATA_SYMBOL, 0)

        def DIRECTORY_SYMBOL(self):
            return self.getToken(MySQLParser.DIRECTORY_SYMBOL, 0)

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def REMOTE_SYMBOL(self):
            return self.getToken(MySQLParser.REMOTE_SYMBOL, 0)

        def INSTANCE_SYMBOL(self):
            return self.getToken(MySQLParser.INSTANCE_SYMBOL, 0)

        def FROM_SYMBOL(self):
            return self.getToken(MySQLParser.FROM_SYMBOL, 0)

        def user(self):
            return self.getTypedRuleContext(MySQLParser.UserContext,0)


        def COLON_SYMBOL(self):
            return self.getToken(MySQLParser.COLON_SYMBOL, 0)

        def ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Ulong_numberContext,0)


        def IDENTIFIED_SYMBOL(self):
            return self.getToken(MySQLParser.IDENTIFIED_SYMBOL, 0)

        def BY_SYMBOL(self):
            return self.getToken(MySQLParser.BY_SYMBOL, 0)

        def equal(self):
            return self.getTypedRuleContext(MySQLParser.EqualContext,0)


        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def REPLICATION_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATION_SYMBOL, 0)

        def dataDirSSL(self):
            return self.getTypedRuleContext(MySQLParser.DataDirSSLContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_cloneStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCloneStatement" ):
                listener.enterCloneStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCloneStatement" ):
                listener.exitCloneStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCloneStatement" ):
                return visitor.visitCloneStatement(self)
            else:
                return visitor.visitChildren(self)




    def cloneStatement(self):

        localctx = MySQLParser.CloneStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 614, self.RULE_cloneStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4699
            self.match(MySQLParser.CLONE_SYMBOL)
            self.state = 4724
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,493,self._ctx)
            if la_ == 1:
                self.state = 4700
                self.match(MySQLParser.LOCAL_SYMBOL)
                self.state = 4701
                self.match(MySQLParser.DATA_SYMBOL)
                self.state = 4702
                self.match(MySQLParser.DIRECTORY_SYMBOL)
                self.state = 4704
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,490,self._ctx)
                if la_ == 1:
                    self.state = 4703
                    self.equal()


                self.state = 4706
                self.textStringLiteral()
                pass

            elif la_ == 2:
                self.state = 4707
                self.match(MySQLParser.REMOTE_SYMBOL)
                self.state = 4710
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==232:
                    self.state = 4708
                    self.match(MySQLParser.FOR_SYMBOL)
                    self.state = 4709
                    self.match(MySQLParser.REPLICATION_SYMBOL)


                pass

            elif la_ == 3:
                self.state = 4712
                if not self.isServerVersionGe80014():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80014()")
                self.state = 4713
                self.match(MySQLParser.INSTANCE_SYMBOL)
                self.state = 4714
                self.match(MySQLParser.FROM_SYMBOL)
                self.state = 4715
                self.user()
                self.state = 4716
                self.match(MySQLParser.COLON_SYMBOL)
                self.state = 4717
                self.ulong_number()
                self.state = 4718
                self.match(MySQLParser.IDENTIFIED_SYMBOL)
                self.state = 4719
                self.match(MySQLParser.BY_SYMBOL)
                self.state = 4720
                self.textStringLiteral()
                self.state = 4722
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==153 or _la==484:
                    self.state = 4721
                    self.dataDirSSL()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataDirSSLContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ssl(self):
            return self.getTypedRuleContext(MySQLParser.SslContext,0)


        def DATA_SYMBOL(self):
            return self.getToken(MySQLParser.DATA_SYMBOL, 0)

        def DIRECTORY_SYMBOL(self):
            return self.getToken(MySQLParser.DIRECTORY_SYMBOL, 0)

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def equal(self):
            return self.getTypedRuleContext(MySQLParser.EqualContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_dataDirSSL

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataDirSSL" ):
                listener.enterDataDirSSL(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataDirSSL" ):
                listener.exitDataDirSSL(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataDirSSL" ):
                return visitor.visitDataDirSSL(self)
            else:
                return visitor.visitChildren(self)




    def dataDirSSL(self):

        localctx = MySQLParser.DataDirSSLContext(self, self._ctx, self.state)
        self.enterRule(localctx, 616, self.RULE_dataDirSSL)
        self._la = 0 # Token type
        try:
            self.state = 4736
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [484]:
                self.enterOuterAlt(localctx, 1)
                self.state = 4726
                self.ssl()
                pass
            elif token in [153]:
                self.enterOuterAlt(localctx, 2)
                self.state = 4727
                self.match(MySQLParser.DATA_SYMBOL)
                self.state = 4728
                self.match(MySQLParser.DIRECTORY_SYMBOL)
                self.state = 4730
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,494,self._ctx)
                if la_ == 1:
                    self.state = 4729
                    self.equal()


                self.state = 4732
                self.textStringLiteral()
                self.state = 4734
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==484:
                    self.state = 4733
                    self.ssl()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SslContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REQUIRE_SYMBOL(self):
            return self.getToken(MySQLParser.REQUIRE_SYMBOL, 0)

        def SSL_SYMBOL(self):
            return self.getToken(MySQLParser.SSL_SYMBOL, 0)

        def NO_SYMBOL(self):
            return self.getToken(MySQLParser.NO_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_ssl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSsl" ):
                listener.enterSsl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSsl" ):
                listener.exitSsl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSsl" ):
                return visitor.visitSsl(self)
            else:
                return visitor.visitChildren(self)




    def ssl(self):

        localctx = MySQLParser.SslContext(self, self._ctx, self.state)
        self.enterRule(localctx, 618, self.RULE_ssl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4738
            self.match(MySQLParser.REQUIRE_SYMBOL)
            self.state = 4740
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==392:
                self.state = 4739
                self.match(MySQLParser.NO_SYMBOL)


            self.state = 4742
            self.match(MySQLParser.SSL_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AccountManagementStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alterUserStatement(self):
            return self.getTypedRuleContext(MySQLParser.AlterUserStatementContext,0)


        def createUserStatement(self):
            return self.getTypedRuleContext(MySQLParser.CreateUserStatementContext,0)


        def dropUserStatement(self):
            return self.getTypedRuleContext(MySQLParser.DropUserStatementContext,0)


        def grantStatement(self):
            return self.getTypedRuleContext(MySQLParser.GrantStatementContext,0)


        def renameUserStatement(self):
            return self.getTypedRuleContext(MySQLParser.RenameUserStatementContext,0)


        def revokeStatement(self):
            return self.getTypedRuleContext(MySQLParser.RevokeStatementContext,0)


        def setRoleStatement(self):
            return self.getTypedRuleContext(MySQLParser.SetRoleStatementContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_accountManagementStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAccountManagementStatement" ):
                listener.enterAccountManagementStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAccountManagementStatement" ):
                listener.exitAccountManagementStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAccountManagementStatement" ):
                return visitor.visitAccountManagementStatement(self)
            else:
                return visitor.visitChildren(self)




    def accountManagementStatement(self):

        localctx = MySQLParser.AccountManagementStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 620, self.RULE_accountManagementStatement)
        try:
            self.state = 4751
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [58]:
                self.enterOuterAlt(localctx, 1)
                self.state = 4744
                self.alterUserStatement()
                pass
            elif token in [139]:
                self.enterOuterAlt(localctx, 2)
                self.state = 4745
                self.createUserStatement()
                pass
            elif token in [184]:
                self.enterOuterAlt(localctx, 3)
                self.state = 4746
                self.dropUserStatement()
                pass
            elif token in [247]:
                self.enterOuterAlt(localctx, 4)
                self.state = 4747
                self.grantStatement()
                pass
            elif token in [470]:
                self.enterOuterAlt(localctx, 5)
                self.state = 4748
                self.renameUserStatement()
                pass
            elif token in [494]:
                self.enterOuterAlt(localctx, 6)
                self.state = 4749
                self.revokeStatement()
                pass
            elif token in [519]:
                self.enterOuterAlt(localctx, 7)
                self.state = 4750
                self.setRoleStatement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterUserStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALTER_SYMBOL(self):
            return self.getToken(MySQLParser.ALTER_SYMBOL, 0)

        def USER_SYMBOL(self):
            return self.getToken(MySQLParser.USER_SYMBOL, 0)

        def createUserTail(self):
            return self.getTypedRuleContext(MySQLParser.CreateUserTailContext,0)


        def userFunction(self):
            return self.getTypedRuleContext(MySQLParser.UserFunctionContext,0)


        def user(self):
            return self.getTypedRuleContext(MySQLParser.UserContext,0)


        def ifExists(self):
            return self.getTypedRuleContext(MySQLParser.IfExistsContext,0)


        def createUserList(self):
            return self.getTypedRuleContext(MySQLParser.CreateUserListContext,0)


        def alterUserList(self):
            return self.getTypedRuleContext(MySQLParser.AlterUserListContext,0)


        def DISCARD_SYMBOL(self):
            return self.getToken(MySQLParser.DISCARD_SYMBOL, 0)

        def OLD_SYMBOL(self):
            return self.getToken(MySQLParser.OLD_SYMBOL, 0)

        def PASSWORD_SYMBOL(self):
            return self.getToken(MySQLParser.PASSWORD_SYMBOL, 0)

        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def ROLE_SYMBOL(self):
            return self.getToken(MySQLParser.ROLE_SYMBOL, 0)

        def identifiedByRandomPassword(self):
            return self.getTypedRuleContext(MySQLParser.IdentifiedByRandomPasswordContext,0)


        def identifiedByPassword(self):
            return self.getTypedRuleContext(MySQLParser.IdentifiedByPasswordContext,0)


        def ALL_SYMBOL(self):
            return self.getToken(MySQLParser.ALL_SYMBOL, 0)

        def NONE_SYMBOL(self):
            return self.getToken(MySQLParser.NONE_SYMBOL, 0)

        def roleList(self):
            return self.getTypedRuleContext(MySQLParser.RoleListContext,0)


        def replacePassword(self):
            return self.getTypedRuleContext(MySQLParser.ReplacePasswordContext,0)


        def retainCurrentPassword(self):
            return self.getTypedRuleContext(MySQLParser.RetainCurrentPasswordContext,0)


        def userRegistration(self):
            return self.getTypedRuleContext(MySQLParser.UserRegistrationContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_alterUserStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterUserStatement" ):
                listener.enterAlterUserStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterUserStatement" ):
                listener.exitAlterUserStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterUserStatement" ):
                return visitor.visitAlterUserStatement(self)
            else:
                return visitor.visitChildren(self)




    def alterUserStatement(self):

        localctx = MySQLParser.AlterUserStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 622, self.RULE_alterUserStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4753
            self.match(MySQLParser.ALTER_SYMBOL)
            self.state = 4754
            self.match(MySQLParser.USER_SYMBOL)
            self.state = 4756
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,499,self._ctx)
            if la_ == 1:
                self.state = 4755
                self.ifExists()


            self.state = 4798
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,509,self._ctx)
            if la_ == 1:
                self.state = 4762
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,500,self._ctx)
                if la_ == 1:
                    self.state = 4758
                    if not self.isServerVersionGe80014():
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.isServerVersionGe80014()")
                    self.state = 4759
                    self.createUserList()
                    pass

                elif la_ == 2:
                    self.state = 4760
                    if not self.isServerVersionGe80014():
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.isServerVersionGe80014()")
                    self.state = 4761
                    self.alterUserList()
                    pass


                self.state = 4764
                self.createUserTail()
                pass

            elif la_ == 2:
                self.state = 4766
                self.userFunction()
                self.state = 4783
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [262]:
                    self.state = 4769
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,501,self._ctx)
                    if la_ == 1:
                        self.state = 4767
                        self.identifiedByRandomPassword()
                        pass

                    elif la_ == 2:
                        self.state = 4768
                        self.identifiedByPassword()
                        pass


                    self.state = 4772
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==475:
                        self.state = 4771
                        self.replacePassword()


                    self.state = 4775
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==735:
                        self.state = 4774
                        self.retainCurrentPassword()


                    pass
                elif token in [178]:
                    self.state = 4777
                    self.match(MySQLParser.DISCARD_SYMBOL)
                    self.state = 4778
                    self.match(MySQLParser.OLD_SYMBOL)
                    self.state = 4779
                    self.match(MySQLParser.PASSWORD_SYMBOL)
                    pass
                elif token in [-1, 3, 4, 5, 30, 46, 47]:
                    self.state = 4781
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if (((_la) & ~0x3f) == 0 and ((1 << _la) & 211106232533048) != 0):
                        self.state = 4780
                        self.userRegistration()


                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 3:
                self.state = 4785
                self.user()
                self.state = 4796
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [166]:
                    self.state = 4786
                    self.match(MySQLParser.DEFAULT_SYMBOL)
                    self.state = 4787
                    self.match(MySQLParser.ROLE_SYMBOL)
                    self.state = 4791
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,506,self._ctx)
                    if la_ == 1:
                        self.state = 4788
                        self.match(MySQLParser.ALL_SYMBOL)
                        pass

                    elif la_ == 2:
                        self.state = 4789
                        self.match(MySQLParser.NONE_SYMBOL)
                        pass

                    elif la_ == 3:
                        self.state = 4790
                        self.roleList()
                        pass


                    pass
                elif token in [-1, 3, 4, 5, 30, 46, 47]:
                    self.state = 4794
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if (((_la) & ~0x3f) == 0 and ((1 << _la) & 211106232533048) != 0):
                        self.state = 4793
                        self.userRegistration()


                    pass
                else:
                    raise NoViableAltException(self)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterUserListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alterUser(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.AlterUserContext)
            else:
                return self.getTypedRuleContext(MySQLParser.AlterUserContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_alterUserList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterUserList" ):
                listener.enterAlterUserList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterUserList" ):
                listener.exitAlterUserList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterUserList" ):
                return visitor.visitAlterUserList(self)
            else:
                return visitor.visitChildren(self)




    def alterUserList(self):

        localctx = MySQLParser.AlterUserListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 624, self.RULE_alterUserList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4800
            self.alterUser()
            self.state = 4805
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,510,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 4801
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 4802
                    self.alterUser() 
                self.state = 4807
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,510,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterUserContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def oldAlterUser(self):
            return self.getTypedRuleContext(MySQLParser.OldAlterUserContext,0)


        def user(self):
            return self.getTypedRuleContext(MySQLParser.UserContext,0)


        def identifiedByPassword(self):
            return self.getTypedRuleContext(MySQLParser.IdentifiedByPasswordContext,0)


        def identifiedByRandomPassword(self):
            return self.getTypedRuleContext(MySQLParser.IdentifiedByRandomPasswordContext,0)


        def identifiedWithPlugin(self):
            return self.getTypedRuleContext(MySQLParser.IdentifiedWithPluginContext,0)


        def identifiedWithPluginAsAuth(self):
            return self.getTypedRuleContext(MySQLParser.IdentifiedWithPluginAsAuthContext,0)


        def identifiedWithPluginByPassword(self):
            return self.getTypedRuleContext(MySQLParser.IdentifiedWithPluginByPasswordContext,0)


        def identifiedWithPluginByRandomPassword(self):
            return self.getTypedRuleContext(MySQLParser.IdentifiedWithPluginByRandomPasswordContext,0)


        def ADD_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.ADD_SYMBOL)
            else:
                return self.getToken(MySQLParser.ADD_SYMBOL, i)

        def factor(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.FactorContext)
            else:
                return self.getTypedRuleContext(MySQLParser.FactorContext,i)


        def identification(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.IdentificationContext)
            else:
                return self.getTypedRuleContext(MySQLParser.IdentificationContext,i)


        def MODIFY_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.MODIFY_SYMBOL)
            else:
                return self.getToken(MySQLParser.MODIFY_SYMBOL, i)

        def DROP_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.DROP_SYMBOL)
            else:
                return self.getToken(MySQLParser.DROP_SYMBOL, i)

        def REPLACE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLACE_SYMBOL, 0)

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def retainCurrentPassword(self):
            return self.getTypedRuleContext(MySQLParser.RetainCurrentPasswordContext,0)


        def discardOldPassword(self):
            return self.getTypedRuleContext(MySQLParser.DiscardOldPasswordContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_alterUser

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterUser" ):
                listener.enterAlterUser(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterUser" ):
                listener.exitAlterUser(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterUser" ):
                return visitor.visitAlterUser(self)
            else:
                return visitor.visitChildren(self)




    def alterUser(self):

        localctx = MySQLParser.AlterUserContext(self, self._ctx, self.state)
        self.enterRule(localctx, 626, self.RULE_alterUser)
        try:
            self.state = 4883
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,527,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4808
                if not self.isServerVersionLt80025():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionLt80025()")
                self.state = 4809
                self.oldAlterUser()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4810
                if not self.isServerVersionGe80025():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80025()")

                self.state = 4811
                self.user()
                self.state = 4881
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,526,self._ctx)
                if la_ == 1:
                    self.state = 4812
                    self.identifiedByPassword()
                    self.state = 4821
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,513,self._ctx)
                    if la_ == 1:
                        self.state = 4813
                        self.match(MySQLParser.REPLACE_SYMBOL)
                        self.state = 4814
                        self.textStringLiteral()
                        self.state = 4816
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,511,self._ctx)
                        if la_ == 1:
                            self.state = 4815
                            self.retainCurrentPassword()


                        pass

                    elif la_ == 2:
                        self.state = 4819
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,512,self._ctx)
                        if la_ == 1:
                            self.state = 4818
                            self.retainCurrentPassword()


                        pass


                    pass

                elif la_ == 2:
                    self.state = 4823
                    self.identifiedByRandomPassword()
                    self.state = 4832
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,516,self._ctx)
                    if la_ == 1:
                        self.state = 4825
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,514,self._ctx)
                        if la_ == 1:
                            self.state = 4824
                            self.retainCurrentPassword()


                        pass

                    elif la_ == 2:
                        self.state = 4827
                        self.match(MySQLParser.REPLACE_SYMBOL)
                        self.state = 4828
                        self.textStringLiteral()
                        self.state = 4830
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,515,self._ctx)
                        if la_ == 1:
                            self.state = 4829
                            self.retainCurrentPassword()


                        pass


                    pass

                elif la_ == 3:
                    self.state = 4834
                    self.identifiedWithPlugin()
                    pass

                elif la_ == 4:
                    self.state = 4835
                    self.identifiedWithPluginAsAuth()
                    self.state = 4837
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,517,self._ctx)
                    if la_ == 1:
                        self.state = 4836
                        self.retainCurrentPassword()


                    pass

                elif la_ == 5:
                    self.state = 4839
                    self.identifiedWithPluginByPassword()
                    self.state = 4848
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,520,self._ctx)
                    if la_ == 1:
                        self.state = 4840
                        self.match(MySQLParser.REPLACE_SYMBOL)
                        self.state = 4841
                        self.textStringLiteral()
                        self.state = 4843
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,518,self._ctx)
                        if la_ == 1:
                            self.state = 4842
                            self.retainCurrentPassword()


                        pass

                    elif la_ == 2:
                        self.state = 4846
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,519,self._ctx)
                        if la_ == 1:
                            self.state = 4845
                            self.retainCurrentPassword()


                        pass


                    pass

                elif la_ == 6:
                    self.state = 4850
                    self.identifiedWithPluginByRandomPassword()
                    self.state = 4852
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,521,self._ctx)
                    if la_ == 1:
                        self.state = 4851
                        self.retainCurrentPassword()


                    pass

                elif la_ == 7:
                    self.state = 4855
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,522,self._ctx)
                    if la_ == 1:
                        self.state = 4854
                        self.discardOldPassword()


                    pass

                elif la_ == 8:
                    self.state = 4857
                    self.match(MySQLParser.ADD_SYMBOL)
                    self.state = 4858
                    self.factor()
                    self.state = 4859
                    self.identification()
                    self.state = 4864
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,523,self._ctx)
                    if la_ == 1:
                        self.state = 4860
                        self.match(MySQLParser.ADD_SYMBOL)
                        self.state = 4861
                        self.factor()
                        self.state = 4862
                        self.identification()


                    pass

                elif la_ == 9:
                    self.state = 4866
                    self.match(MySQLParser.MODIFY_SYMBOL)
                    self.state = 4867
                    self.factor()
                    self.state = 4868
                    self.identification()
                    self.state = 4873
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,524,self._ctx)
                    if la_ == 1:
                        self.state = 4869
                        self.match(MySQLParser.MODIFY_SYMBOL)
                        self.state = 4870
                        self.factor()
                        self.state = 4871
                        self.identification()


                    pass

                elif la_ == 10:
                    self.state = 4875
                    self.match(MySQLParser.DROP_SYMBOL)
                    self.state = 4876
                    self.factor()
                    self.state = 4879
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,525,self._ctx)
                    if la_ == 1:
                        self.state = 4877
                        self.match(MySQLParser.DROP_SYMBOL)
                        self.state = 4878
                        self.factor()


                    pass


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OldAlterUserContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def user(self):
            return self.getTypedRuleContext(MySQLParser.UserContext,0)


        def IDENTIFIED_SYMBOL(self):
            return self.getToken(MySQLParser.IDENTIFIED_SYMBOL, 0)

        def BY_SYMBOL(self):
            return self.getToken(MySQLParser.BY_SYMBOL, 0)

        def textString(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.TextStringContext)
            else:
                return self.getTypedRuleContext(MySQLParser.TextStringContext,i)


        def REPLACE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLACE_SYMBOL, 0)

        def RANDOM_SYMBOL(self):
            return self.getToken(MySQLParser.RANDOM_SYMBOL, 0)

        def PASSWORD_SYMBOL(self):
            return self.getToken(MySQLParser.PASSWORD_SYMBOL, 0)

        def retainCurrentPassword(self):
            return self.getTypedRuleContext(MySQLParser.RetainCurrentPasswordContext,0)


        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def AS_SYMBOL(self):
            return self.getToken(MySQLParser.AS_SYMBOL, 0)

        def textStringHash(self):
            return self.getTypedRuleContext(MySQLParser.TextStringHashContext,0)


        def discardOldPassword(self):
            return self.getTypedRuleContext(MySQLParser.DiscardOldPasswordContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_oldAlterUser

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOldAlterUser" ):
                listener.enterOldAlterUser(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOldAlterUser" ):
                listener.exitOldAlterUser(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOldAlterUser" ):
                return visitor.visitOldAlterUser(self)
            else:
                return visitor.visitChildren(self)




    def oldAlterUser(self):

        localctx = MySQLParser.OldAlterUserContext(self, self._ctx, self.state)
        self.enterRule(localctx, 628, self.RULE_oldAlterUser)
        try:
            self.state = 4942
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,539,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4885
                self.user()
                self.state = 4886
                self.match(MySQLParser.IDENTIFIED_SYMBOL)
                self.state = 4887
                self.match(MySQLParser.BY_SYMBOL)
                self.state = 4907
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,532,self._ctx)
                if la_ == 1:
                    self.state = 4888
                    self.textString()
                    self.state = 4889
                    self.match(MySQLParser.REPLACE_SYMBOL)
                    self.state = 4890
                    self.textString()
                    self.state = 4892
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,528,self._ctx)
                    if la_ == 1:
                        self.state = 4891
                        self.retainCurrentPassword()


                    pass

                elif la_ == 2:
                    self.state = 4894
                    self.textString()
                    self.state = 4896
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,529,self._ctx)
                    if la_ == 1:
                        self.state = 4895
                        self.retainCurrentPassword()


                    pass

                elif la_ == 3:
                    self.state = 4898
                    self.match(MySQLParser.RANDOM_SYMBOL)
                    self.state = 4899
                    self.match(MySQLParser.PASSWORD_SYMBOL)
                    self.state = 4902
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,530,self._ctx)
                    if la_ == 1:
                        self.state = 4900
                        self.match(MySQLParser.REPLACE_SYMBOL)
                        self.state = 4901
                        self.textString()


                    self.state = 4905
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,531,self._ctx)
                    if la_ == 1:
                        self.state = 4904
                        self.retainCurrentPassword()


                    pass


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4909
                self.user()
                self.state = 4910
                self.match(MySQLParser.IDENTIFIED_SYMBOL)
                self.state = 4911
                self.match(MySQLParser.WITH_SYMBOL)

                self.state = 4912
                self.textOrIdentifier()
                self.state = 4936
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,537,self._ctx)
                if la_ == 1:
                    self.state = 4913
                    self.match(MySQLParser.BY_SYMBOL)
                    self.state = 4914
                    self.textString()
                    self.state = 4915
                    self.match(MySQLParser.REPLACE_SYMBOL)
                    self.state = 4916
                    self.textString()
                    self.state = 4918
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,533,self._ctx)
                    if la_ == 1:
                        self.state = 4917
                        self.retainCurrentPassword()



                elif la_ == 2:
                    self.state = 4920
                    self.match(MySQLParser.AS_SYMBOL)
                    self.state = 4921
                    self.textStringHash()
                    self.state = 4923
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,534,self._ctx)
                    if la_ == 1:
                        self.state = 4922
                        self.retainCurrentPassword()



                elif la_ == 3:
                    self.state = 4925
                    self.match(MySQLParser.BY_SYMBOL)
                    self.state = 4926
                    self.textString()
                    self.state = 4928
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,535,self._ctx)
                    if la_ == 1:
                        self.state = 4927
                        self.retainCurrentPassword()



                elif la_ == 4:
                    self.state = 4930
                    self.match(MySQLParser.BY_SYMBOL)
                    self.state = 4931
                    self.match(MySQLParser.RANDOM_SYMBOL)
                    self.state = 4932
                    self.match(MySQLParser.PASSWORD_SYMBOL)
                    self.state = 4934
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,536,self._ctx)
                    if la_ == 1:
                        self.state = 4933
                        self.retainCurrentPassword()




                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 4938
                self.user()
                self.state = 4940
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,538,self._ctx)
                if la_ == 1:
                    self.state = 4939
                    self.discardOldPassword()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UserFunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USER_SYMBOL(self):
            return self.getToken(MySQLParser.USER_SYMBOL, 0)

        def parentheses(self):
            return self.getTypedRuleContext(MySQLParser.ParenthesesContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_userFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUserFunction" ):
                listener.enterUserFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUserFunction" ):
                listener.exitUserFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUserFunction" ):
                return visitor.visitUserFunction(self)
            else:
                return visitor.visitChildren(self)




    def userFunction(self):

        localctx = MySQLParser.UserFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 630, self.RULE_userFunction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4944
            self.match(MySQLParser.USER_SYMBOL)
            self.state = 4945
            self.parentheses()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateUserStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE_SYMBOL(self):
            return self.getToken(MySQLParser.CREATE_SYMBOL, 0)

        def USER_SYMBOL(self):
            return self.getToken(MySQLParser.USER_SYMBOL, 0)

        def createUserList(self):
            return self.getTypedRuleContext(MySQLParser.CreateUserListContext,0)


        def createUserTail(self):
            return self.getTypedRuleContext(MySQLParser.CreateUserTailContext,0)


        def ifNotExists(self):
            return self.getTypedRuleContext(MySQLParser.IfNotExistsContext,0)


        def defaultRoleClause(self):
            return self.getTypedRuleContext(MySQLParser.DefaultRoleClauseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createUserStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateUserStatement" ):
                listener.enterCreateUserStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateUserStatement" ):
                listener.exitCreateUserStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateUserStatement" ):
                return visitor.visitCreateUserStatement(self)
            else:
                return visitor.visitChildren(self)




    def createUserStatement(self):

        localctx = MySQLParser.CreateUserStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 632, self.RULE_createUserStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4947
            self.match(MySQLParser.CREATE_SYMBOL)
            self.state = 4948
            self.match(MySQLParser.USER_SYMBOL)
            self.state = 4950
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,540,self._ctx)
            if la_ == 1:
                self.state = 4949
                self.ifNotExists()


            self.state = 4952
            self.createUserList()
            self.state = 4954
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,541,self._ctx)
            if la_ == 1:
                self.state = 4953
                self.defaultRoleClause()


            self.state = 4956
            self.createUserTail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateUserTailContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def requireClause(self):
            return self.getTypedRuleContext(MySQLParser.RequireClauseContext,0)


        def connectOptions(self):
            return self.getTypedRuleContext(MySQLParser.ConnectOptionsContext,0)


        def accountLockPasswordExpireOptions(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.AccountLockPasswordExpireOptionsContext)
            else:
                return self.getTypedRuleContext(MySQLParser.AccountLockPasswordExpireOptionsContext,i)


        def userAttributes(self):
            return self.getTypedRuleContext(MySQLParser.UserAttributesContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createUserTail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateUserTail" ):
                listener.enterCreateUserTail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateUserTail" ):
                listener.exitCreateUserTail(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateUserTail" ):
                return visitor.visitCreateUserTail(self)
            else:
                return visitor.visitChildren(self)




    def createUserTail(self):

        localctx = MySQLParser.CreateUserTailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 634, self.RULE_createUserTail)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4959
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,542,self._ctx)
            if la_ == 1:
                self.state = 4958
                self.requireClause()


            self.state = 4962
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,543,self._ctx)
            if la_ == 1:
                self.state = 4961
                self.connectOptions()


            self.state = 4967
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,544,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 4964
                    self.accountLockPasswordExpireOptions() 
                self.state = 4969
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,544,self._ctx)

            self.state = 4972
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,545,self._ctx)
            if la_ == 1:
                self.state = 4970
                if not self.isServerVersionGe80024():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                self.state = 4971
                self.userAttributes()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UserAttributesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATTRIBUTE_SYMBOL(self):
            return self.getToken(MySQLParser.ATTRIBUTE_SYMBOL, 0)

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def COMMENT_SYMBOL(self):
            return self.getToken(MySQLParser.COMMENT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_userAttributes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUserAttributes" ):
                listener.enterUserAttributes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUserAttributes" ):
                listener.exitUserAttributes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUserAttributes" ):
                return visitor.visitUserAttributes(self)
            else:
                return visitor.visitChildren(self)




    def userAttributes(self):

        localctx = MySQLParser.UserAttributesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 636, self.RULE_userAttributes)
        try:
            self.state = 4978
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [756]:
                self.enterOuterAlt(localctx, 1)
                self.state = 4974
                self.match(MySQLParser.ATTRIBUTE_SYMBOL)
                self.state = 4975
                self.textStringLiteral()
                pass
            elif token in [118]:
                self.enterOuterAlt(localctx, 2)
                self.state = 4976
                self.match(MySQLParser.COMMENT_SYMBOL)
                self.state = 4977
                self.textStringLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultRoleClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def ROLE_SYMBOL(self):
            return self.getToken(MySQLParser.ROLE_SYMBOL, 0)

        def roleList(self):
            return self.getTypedRuleContext(MySQLParser.RoleListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_defaultRoleClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefaultRoleClause" ):
                listener.enterDefaultRoleClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefaultRoleClause" ):
                listener.exitDefaultRoleClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefaultRoleClause" ):
                return visitor.visitDefaultRoleClause(self)
            else:
                return visitor.visitChildren(self)




    def defaultRoleClause(self):

        localctx = MySQLParser.DefaultRoleClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 638, self.RULE_defaultRoleClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4980
            self.match(MySQLParser.DEFAULT_SYMBOL)
            self.state = 4981
            self.match(MySQLParser.ROLE_SYMBOL)
            self.state = 4982
            self.roleList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.option = None # Token

        def REQUIRE_SYMBOL(self):
            return self.getToken(MySQLParser.REQUIRE_SYMBOL, 0)

        def requireList(self):
            return self.getTypedRuleContext(MySQLParser.RequireListContext,0)


        def SSL_SYMBOL(self):
            return self.getToken(MySQLParser.SSL_SYMBOL, 0)

        def X509_SYMBOL(self):
            return self.getToken(MySQLParser.X509_SYMBOL, 0)

        def NONE_SYMBOL(self):
            return self.getToken(MySQLParser.NONE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_requireClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireClause" ):
                listener.enterRequireClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireClause" ):
                listener.exitRequireClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequireClause" ):
                return visitor.visitRequireClause(self)
            else:
                return visitor.visitChildren(self)




    def requireClause(self):

        localctx = MySQLParser.RequireClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 640, self.RULE_requireClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4984
            self.match(MySQLParser.REQUIRE_SYMBOL)
            self.state = 4987
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [106, 289, 569]:
                self.state = 4985
                self.requireList()
                pass
            elif token in [389, 549, 658]:
                self.state = 4986
                localctx.option = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==389 or _la==549 or _la==658):
                    localctx.option = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConnectOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def MAX_QUERIES_PER_HOUR_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.MAX_QUERIES_PER_HOUR_SYMBOL)
            else:
                return self.getToken(MySQLParser.MAX_QUERIES_PER_HOUR_SYMBOL, i)

        def ulong_number(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.Ulong_numberContext)
            else:
                return self.getTypedRuleContext(MySQLParser.Ulong_numberContext,i)


        def MAX_UPDATES_PER_HOUR_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.MAX_UPDATES_PER_HOUR_SYMBOL)
            else:
                return self.getToken(MySQLParser.MAX_UPDATES_PER_HOUR_SYMBOL, i)

        def MAX_CONNECTIONS_PER_HOUR_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.MAX_CONNECTIONS_PER_HOUR_SYMBOL)
            else:
                return self.getToken(MySQLParser.MAX_CONNECTIONS_PER_HOUR_SYMBOL, i)

        def MAX_USER_CONNECTIONS_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.MAX_USER_CONNECTIONS_SYMBOL)
            else:
                return self.getToken(MySQLParser.MAX_USER_CONNECTIONS_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_connectOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConnectOptions" ):
                listener.enterConnectOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConnectOptions" ):
                listener.exitConnectOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConnectOptions" ):
                return visitor.visitConnectOptions(self)
            else:
                return visitor.visitChildren(self)




    def connectOptions(self):

        localctx = MySQLParser.ConnectOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 642, self.RULE_connectOptions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4989
            self.match(MySQLParser.WITH_SYMBOL)
            self.state = 4998 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 4998
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [347]:
                        self.state = 4990
                        self.match(MySQLParser.MAX_QUERIES_PER_HOUR_SYMBOL)
                        self.state = 4991
                        self.ulong_number()
                        pass
                    elif token in [351]:
                        self.state = 4992
                        self.match(MySQLParser.MAX_UPDATES_PER_HOUR_SYMBOL)
                        self.state = 4993
                        self.ulong_number()
                        pass
                    elif token in [346]:
                        self.state = 4994
                        self.match(MySQLParser.MAX_CONNECTIONS_PER_HOUR_SYMBOL)
                        self.state = 4995
                        self.ulong_number()
                        pass
                    elif token in [352]:
                        self.state = 4996
                        self.match(MySQLParser.MAX_USER_CONNECTIONS_SYMBOL)
                        self.state = 4997
                        self.ulong_number()
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 5000 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,549,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AccountLockPasswordExpireOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ACCOUNT_SYMBOL(self):
            return self.getToken(MySQLParser.ACCOUNT_SYMBOL, 0)

        def LOCK_SYMBOL(self):
            return self.getToken(MySQLParser.LOCK_SYMBOL, 0)

        def UNLOCK_SYMBOL(self):
            return self.getToken(MySQLParser.UNLOCK_SYMBOL, 0)

        def PASSWORD_SYMBOL(self):
            return self.getToken(MySQLParser.PASSWORD_SYMBOL, 0)

        def EXPIRE_SYMBOL(self):
            return self.getToken(MySQLParser.EXPIRE_SYMBOL, 0)

        def HISTORY_SYMBOL(self):
            return self.getToken(MySQLParser.HISTORY_SYMBOL, 0)

        def REUSE_SYMBOL(self):
            return self.getToken(MySQLParser.REUSE_SYMBOL, 0)

        def INTERVAL_SYMBOL(self):
            return self.getToken(MySQLParser.INTERVAL_SYMBOL, 0)

        def REQUIRE_SYMBOL(self):
            return self.getToken(MySQLParser.REQUIRE_SYMBOL, 0)

        def CURRENT_SYMBOL(self):
            return self.getToken(MySQLParser.CURRENT_SYMBOL, 0)

        def real_ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Real_ulong_numberContext,0)


        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def DAY_SYMBOL(self):
            return self.getToken(MySQLParser.DAY_SYMBOL, 0)

        def NEVER_SYMBOL(self):
            return self.getToken(MySQLParser.NEVER_SYMBOL, 0)

        def OPTIONAL_SYMBOL(self):
            return self.getToken(MySQLParser.OPTIONAL_SYMBOL, 0)

        def FAILED_LOGIN_ATTEMPTS_SYMBOL(self):
            return self.getToken(MySQLParser.FAILED_LOGIN_ATTEMPTS_SYMBOL, 0)

        def PASSWORD_LOCK_TIME_SYMBOL(self):
            return self.getToken(MySQLParser.PASSWORD_LOCK_TIME_SYMBOL, 0)

        def UNBOUNDED_SYMBOL(self):
            return self.getToken(MySQLParser.UNBOUNDED_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_accountLockPasswordExpireOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAccountLockPasswordExpireOptions" ):
                listener.enterAccountLockPasswordExpireOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAccountLockPasswordExpireOptions" ):
                listener.exitAccountLockPasswordExpireOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAccountLockPasswordExpireOptions" ):
                return visitor.visitAccountLockPasswordExpireOptions(self)
            else:
                return visitor.visitChildren(self)




    def accountLockPasswordExpireOptions(self):

        localctx = MySQLParser.AccountLockPasswordExpireOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 644, self.RULE_accountLockPasswordExpireOptions)
        self._la = 0 # Token type
        try:
            self.state = 5042
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [49]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5002
                self.match(MySQLParser.ACCOUNT_SYMBOL)
                self.state = 5003
                _la = self._input.LA(1)
                if not(_la==314 or _la==620):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [424]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5004
                self.match(MySQLParser.PASSWORD_SYMBOL)
                self.state = 5033
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,554,self._ctx)
                if la_ == 1:
                    self.state = 5005
                    self.match(MySQLParser.EXPIRE_SYMBOL)
                    self.state = 5012
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,550,self._ctx)
                    if la_ == 1:
                        self.state = 5006
                        self.match(MySQLParser.INTERVAL_SYMBOL)
                        self.state = 5007
                        self.real_ulong_number()
                        self.state = 5008
                        self.match(MySQLParser.DAY_SYMBOL)

                    elif la_ == 2:
                        self.state = 5010
                        self.match(MySQLParser.NEVER_SYMBOL)

                    elif la_ == 3:
                        self.state = 5011
                        self.match(MySQLParser.DEFAULT_SYMBOL)


                    pass

                elif la_ == 2:
                    self.state = 5014
                    self.match(MySQLParser.HISTORY_SYMBOL)
                    self.state = 5017
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [3, 4, 5, 44]:
                        self.state = 5015
                        self.real_ulong_number()
                        pass
                    elif token in [166]:
                        self.state = 5016
                        self.match(MySQLParser.DEFAULT_SYMBOL)
                        pass
                    else:
                        raise NoViableAltException(self)

                    pass

                elif la_ == 3:
                    self.state = 5019
                    self.match(MySQLParser.REUSE_SYMBOL)
                    self.state = 5020
                    self.match(MySQLParser.INTERVAL_SYMBOL)
                    self.state = 5025
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [3, 4, 5, 44]:
                        self.state = 5021
                        self.real_ulong_number()
                        self.state = 5022
                        self.match(MySQLParser.DAY_SYMBOL)
                        pass
                    elif token in [166]:
                        self.state = 5024
                        self.match(MySQLParser.DEFAULT_SYMBOL)
                        pass
                    else:
                        raise NoViableAltException(self)

                    pass

                elif la_ == 4:
                    self.state = 5027
                    if not self.isServerVersionGe80014():
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.isServerVersionGe80014()")
                    self.state = 5028
                    self.match(MySQLParser.REQUIRE_SYMBOL)
                    self.state = 5029
                    self.match(MySQLParser.CURRENT_SYMBOL)
                    self.state = 5031
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,553,self._ctx)
                    if la_ == 1:
                        self.state = 5030
                        _la = self._input.LA(1)
                        if not(_la==166 or _la==727):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()


                    pass


                pass
            elif token in [749]:
                self.enterOuterAlt(localctx, 3)
                self.state = 5035
                self.match(MySQLParser.FAILED_LOGIN_ATTEMPTS_SYMBOL)
                self.state = 5036
                self.real_ulong_number()
                pass
            elif token in [748]:
                self.enterOuterAlt(localctx, 4)
                self.state = 5037
                self.match(MySQLParser.PASSWORD_LOCK_TIME_SYMBOL)
                self.state = 5040
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [3, 4, 5, 44]:
                    self.state = 5038
                    self.real_ulong_number()
                    pass
                elif token in [706]:
                    self.state = 5039
                    self.match(MySQLParser.UNBOUNDED_SYMBOL)
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UserAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATTRIBUTE_SYMBOL(self):
            return self.getToken(MySQLParser.ATTRIBUTE_SYMBOL, 0)

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def COMMENT_SYMBOL(self):
            return self.getToken(MySQLParser.COMMENT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_userAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUserAttribute" ):
                listener.enterUserAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUserAttribute" ):
                listener.exitUserAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUserAttribute" ):
                return visitor.visitUserAttribute(self)
            else:
                return visitor.visitChildren(self)




    def userAttribute(self):

        localctx = MySQLParser.UserAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 646, self.RULE_userAttribute)
        try:
            self.state = 5049
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [-1]:
                self.enterOuterAlt(localctx, 1)

                pass
            elif token in [756]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5045
                self.match(MySQLParser.ATTRIBUTE_SYMBOL)
                self.state = 5046
                self.textStringLiteral()
                pass
            elif token in [118]:
                self.enterOuterAlt(localctx, 3)
                self.state = 5047
                self.match(MySQLParser.COMMENT_SYMBOL)
                self.state = 5048
                self.textStringLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropUserStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DROP_SYMBOL(self):
            return self.getToken(MySQLParser.DROP_SYMBOL, 0)

        def USER_SYMBOL(self):
            return self.getToken(MySQLParser.USER_SYMBOL, 0)

        def userList(self):
            return self.getTypedRuleContext(MySQLParser.UserListContext,0)


        def ifExists(self):
            return self.getTypedRuleContext(MySQLParser.IfExistsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_dropUserStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropUserStatement" ):
                listener.enterDropUserStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropUserStatement" ):
                listener.exitDropUserStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropUserStatement" ):
                return visitor.visitDropUserStatement(self)
            else:
                return visitor.visitChildren(self)




    def dropUserStatement(self):

        localctx = MySQLParser.DropUserStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 648, self.RULE_dropUserStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5051
            self.match(MySQLParser.DROP_SYMBOL)
            self.state = 5052
            self.match(MySQLParser.USER_SYMBOL)
            self.state = 5054
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,558,self._ctx)
            if la_ == 1:
                self.state = 5053
                self.ifExists()


            self.state = 5056
            self.userList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GrantStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRANT_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.GRANT_SYMBOL)
            else:
                return self.getToken(MySQLParser.GRANT_SYMBOL, i)

        def roleOrPrivilegesList(self):
            return self.getTypedRuleContext(MySQLParser.RoleOrPrivilegesListContext,0)


        def TO_SYMBOL(self):
            return self.getToken(MySQLParser.TO_SYMBOL, 0)

        def userList(self):
            return self.getTypedRuleContext(MySQLParser.UserListContext,0)


        def ON_SYMBOL(self):
            return self.getToken(MySQLParser.ON_SYMBOL, 0)

        def grantIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.GrantIdentifierContext,0)


        def grantTargetList(self):
            return self.getTypedRuleContext(MySQLParser.GrantTargetListContext,0)


        def PROXY_SYMBOL(self):
            return self.getToken(MySQLParser.PROXY_SYMBOL, 0)

        def user(self):
            return self.getTypedRuleContext(MySQLParser.UserContext,0)


        def ALL_SYMBOL(self):
            return self.getToken(MySQLParser.ALL_SYMBOL, 0)

        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def ADMIN_SYMBOL(self):
            return self.getToken(MySQLParser.ADMIN_SYMBOL, 0)

        def OPTION_SYMBOL(self):
            return self.getToken(MySQLParser.OPTION_SYMBOL, 0)

        def aclType(self):
            return self.getTypedRuleContext(MySQLParser.AclTypeContext,0)


        def versionedRequireClause(self):
            return self.getTypedRuleContext(MySQLParser.VersionedRequireClauseContext,0)


        def grantOptions(self):
            return self.getTypedRuleContext(MySQLParser.GrantOptionsContext,0)


        def grantAs(self):
            return self.getTypedRuleContext(MySQLParser.GrantAsContext,0)


        def PRIVILEGES_SYMBOL(self):
            return self.getToken(MySQLParser.PRIVILEGES_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_grantStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGrantStatement" ):
                listener.enterGrantStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGrantStatement" ):
                listener.exitGrantStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGrantStatement" ):
                return visitor.visitGrantStatement(self)
            else:
                return visitor.visitChildren(self)




    def grantStatement(self):

        localctx = MySQLParser.GrantStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 650, self.RULE_grantStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5058
            self.match(MySQLParser.GRANT_SYMBOL)
            self.state = 5100
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,567,self._ctx)
            if la_ == 1:
                self.state = 5059
                self.roleOrPrivilegesList()
                self.state = 5060
                self.match(MySQLParser.TO_SYMBOL)
                self.state = 5061
                self.userList()
                self.state = 5065
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==653:
                    self.state = 5062
                    self.match(MySQLParser.WITH_SYMBOL)
                    self.state = 5063
                    self.match(MySQLParser.ADMIN_SYMBOL)
                    self.state = 5064
                    self.match(MySQLParser.OPTION_SYMBOL)


                pass

            elif la_ == 2:
                self.state = 5072
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,561,self._ctx)
                if la_ == 1:
                    self.state = 5067
                    self.roleOrPrivilegesList()
                    pass

                elif la_ == 2:
                    self.state = 5068
                    self.match(MySQLParser.ALL_SYMBOL)
                    self.state = 5070
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==439:
                        self.state = 5069
                        self.match(MySQLParser.PRIVILEGES_SYMBOL)


                    pass


                self.state = 5074
                self.match(MySQLParser.ON_SYMBOL)
                self.state = 5076
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,562,self._ctx)
                if la_ == 1:
                    self.state = 5075
                    self.aclType()


                self.state = 5078
                self.grantIdentifier()
                self.state = 5079
                self.match(MySQLParser.TO_SYMBOL)
                self.state = 5080
                self.grantTargetList()
                self.state = 5082
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,563,self._ctx)
                if la_ == 1:
                    self.state = 5081
                    self.versionedRequireClause()


                self.state = 5085
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==653:
                    self.state = 5084
                    self.grantOptions()


                self.state = 5088
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==63:
                    self.state = 5087
                    self.grantAs()


                pass

            elif la_ == 3:
                self.state = 5090
                self.match(MySQLParser.PROXY_SYMBOL)
                self.state = 5091
                self.match(MySQLParser.ON_SYMBOL)
                self.state = 5092
                self.user()
                self.state = 5093
                self.match(MySQLParser.TO_SYMBOL)
                self.state = 5094
                self.grantTargetList()
                self.state = 5098
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==653:
                    self.state = 5095
                    self.match(MySQLParser.WITH_SYMBOL)
                    self.state = 5096
                    self.match(MySQLParser.GRANT_SYMBOL)
                    self.state = 5097
                    self.match(MySQLParser.OPTION_SYMBOL)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GrantTargetListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def createUserList(self):
            return self.getTypedRuleContext(MySQLParser.CreateUserListContext,0)


        def userList(self):
            return self.getTypedRuleContext(MySQLParser.UserListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_grantTargetList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGrantTargetList" ):
                listener.enterGrantTargetList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGrantTargetList" ):
                listener.exitGrantTargetList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGrantTargetList" ):
                return visitor.visitGrantTargetList(self)
            else:
                return visitor.visitChildren(self)




    def grantTargetList(self):

        localctx = MySQLParser.GrantTargetListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 652, self.RULE_grantTargetList)
        try:
            self.state = 5106
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,568,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5102
                if not self.isServerVersionLt80011():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionLt80011()")
                self.state = 5103
                self.createUserList()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5104
                if not self.isServerVersionGe80011():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80011()")
                self.state = 5105
                self.userList()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GrantOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def grantOption(self):
            return self.getTypedRuleContext(MySQLParser.GrantOptionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_grantOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGrantOptions" ):
                listener.enterGrantOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGrantOptions" ):
                listener.exitGrantOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGrantOptions" ):
                return visitor.visitGrantOptions(self)
            else:
                return visitor.visitChildren(self)




    def grantOptions(self):

        localctx = MySQLParser.GrantOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 654, self.RULE_grantOptions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5108
            self.match(MySQLParser.WITH_SYMBOL)
            self.state = 5109
            self.grantOption()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExceptRoleListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXCEPT_SYMBOL(self):
            return self.getToken(MySQLParser.EXCEPT_SYMBOL, 0)

        def roleList(self):
            return self.getTypedRuleContext(MySQLParser.RoleListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_exceptRoleList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExceptRoleList" ):
                listener.enterExceptRoleList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExceptRoleList" ):
                listener.exitExceptRoleList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExceptRoleList" ):
                return visitor.visitExceptRoleList(self)
            else:
                return visitor.visitChildren(self)




    def exceptRoleList(self):

        localctx = MySQLParser.ExceptRoleListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 656, self.RULE_exceptRoleList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5111
            self.match(MySQLParser.EXCEPT_SYMBOL)
            self.state = 5112
            self.roleList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithRolesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def ROLE_SYMBOL(self):
            return self.getToken(MySQLParser.ROLE_SYMBOL, 0)

        def roleList(self):
            return self.getTypedRuleContext(MySQLParser.RoleListContext,0)


        def ALL_SYMBOL(self):
            return self.getToken(MySQLParser.ALL_SYMBOL, 0)

        def NONE_SYMBOL(self):
            return self.getToken(MySQLParser.NONE_SYMBOL, 0)

        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def exceptRoleList(self):
            return self.getTypedRuleContext(MySQLParser.ExceptRoleListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_withRoles

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithRoles" ):
                listener.enterWithRoles(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithRoles" ):
                listener.exitWithRoles(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWithRoles" ):
                return visitor.visitWithRoles(self)
            else:
                return visitor.visitChildren(self)




    def withRoles(self):

        localctx = MySQLParser.WithRolesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 658, self.RULE_withRoles)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5114
            self.match(MySQLParser.WITH_SYMBOL)
            self.state = 5115
            self.match(MySQLParser.ROLE_SYMBOL)
            self.state = 5123
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,570,self._ctx)
            if la_ == 1:
                self.state = 5116
                self.roleList()
                pass

            elif la_ == 2:
                self.state = 5117
                self.match(MySQLParser.ALL_SYMBOL)
                self.state = 5119
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==671:
                    self.state = 5118
                    self.exceptRoleList()


                pass

            elif la_ == 3:
                self.state = 5121
                self.match(MySQLParser.NONE_SYMBOL)
                pass

            elif la_ == 4:
                self.state = 5122
                self.match(MySQLParser.DEFAULT_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GrantAsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AS_SYMBOL(self):
            return self.getToken(MySQLParser.AS_SYMBOL, 0)

        def USER_SYMBOL(self):
            return self.getToken(MySQLParser.USER_SYMBOL, 0)

        def withRoles(self):
            return self.getTypedRuleContext(MySQLParser.WithRolesContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_grantAs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGrantAs" ):
                listener.enterGrantAs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGrantAs" ):
                listener.exitGrantAs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGrantAs" ):
                return visitor.visitGrantAs(self)
            else:
                return visitor.visitChildren(self)




    def grantAs(self):

        localctx = MySQLParser.GrantAsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 660, self.RULE_grantAs)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5125
            self.match(MySQLParser.AS_SYMBOL)
            self.state = 5126
            self.match(MySQLParser.USER_SYMBOL)
            self.state = 5128
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==653:
                self.state = 5127
                self.withRoles()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VersionedRequireClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def requireClause(self):
            return self.getTypedRuleContext(MySQLParser.RequireClauseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_versionedRequireClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVersionedRequireClause" ):
                listener.enterVersionedRequireClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVersionedRequireClause" ):
                listener.exitVersionedRequireClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVersionedRequireClause" ):
                return visitor.visitVersionedRequireClause(self)
            else:
                return visitor.visitChildren(self)




    def versionedRequireClause(self):

        localctx = MySQLParser.VersionedRequireClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 662, self.RULE_versionedRequireClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5130
            if not self.isServerVersionLt80011():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.isServerVersionLt80011()")
            self.state = 5131
            self.requireClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RenameUserStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RENAME_SYMBOL(self):
            return self.getToken(MySQLParser.RENAME_SYMBOL, 0)

        def USER_SYMBOL(self):
            return self.getToken(MySQLParser.USER_SYMBOL, 0)

        def user(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.UserContext)
            else:
                return self.getTypedRuleContext(MySQLParser.UserContext,i)


        def TO_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.TO_SYMBOL)
            else:
                return self.getToken(MySQLParser.TO_SYMBOL, i)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_renameUserStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRenameUserStatement" ):
                listener.enterRenameUserStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRenameUserStatement" ):
                listener.exitRenameUserStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRenameUserStatement" ):
                return visitor.visitRenameUserStatement(self)
            else:
                return visitor.visitChildren(self)




    def renameUserStatement(self):

        localctx = MySQLParser.RenameUserStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 664, self.RULE_renameUserStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5133
            self.match(MySQLParser.RENAME_SYMBOL)
            self.state = 5134
            self.match(MySQLParser.USER_SYMBOL)
            self.state = 5135
            self.user()
            self.state = 5136
            self.match(MySQLParser.TO_SYMBOL)
            self.state = 5137
            self.user()
            self.state = 5145
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 5138
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 5139
                self.user()
                self.state = 5140
                self.match(MySQLParser.TO_SYMBOL)
                self.state = 5141
                self.user()
                self.state = 5147
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RevokeStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REVOKE_SYMBOL(self):
            return self.getToken(MySQLParser.REVOKE_SYMBOL, 0)

        def roleOrPrivilegesList(self):
            return self.getTypedRuleContext(MySQLParser.RoleOrPrivilegesListContext,0)


        def FROM_SYMBOL(self):
            return self.getToken(MySQLParser.FROM_SYMBOL, 0)

        def userList(self):
            return self.getTypedRuleContext(MySQLParser.UserListContext,0)


        def ON_SYMBOL(self):
            return self.getToken(MySQLParser.ON_SYMBOL, 0)

        def grantIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.GrantIdentifierContext,0)


        def ALL_SYMBOL(self):
            return self.getToken(MySQLParser.ALL_SYMBOL, 0)

        def PROXY_SYMBOL(self):
            return self.getToken(MySQLParser.PROXY_SYMBOL, 0)

        def user(self):
            return self.getTypedRuleContext(MySQLParser.UserContext,0)


        def ifExists(self):
            return self.getTypedRuleContext(MySQLParser.IfExistsContext,0)


        def ignoreUnknownUser(self):
            return self.getTypedRuleContext(MySQLParser.IgnoreUnknownUserContext,0)


        def COMMA_SYMBOL(self):
            return self.getToken(MySQLParser.COMMA_SYMBOL, 0)

        def GRANT_SYMBOL(self):
            return self.getToken(MySQLParser.GRANT_SYMBOL, 0)

        def OPTION_SYMBOL(self):
            return self.getToken(MySQLParser.OPTION_SYMBOL, 0)

        def aclType(self):
            return self.getTypedRuleContext(MySQLParser.AclTypeContext,0)


        def PRIVILEGES_SYMBOL(self):
            return self.getToken(MySQLParser.PRIVILEGES_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_revokeStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRevokeStatement" ):
                listener.enterRevokeStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRevokeStatement" ):
                listener.exitRevokeStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRevokeStatement" ):
                return visitor.visitRevokeStatement(self)
            else:
                return visitor.visitChildren(self)




    def revokeStatement(self):

        localctx = MySQLParser.RevokeStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 666, self.RULE_revokeStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5148
            self.match(MySQLParser.REVOKE_SYMBOL)
            self.state = 5151
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,573,self._ctx)
            if la_ == 1:
                self.state = 5149
                if not self.isServerVersionGe80031():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80031()")
                self.state = 5150
                self.ifExists()


            self.state = 5188
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,578,self._ctx)
            if la_ == 1:
                self.state = 5153
                self.roleOrPrivilegesList()
                self.state = 5154
                self.match(MySQLParser.FROM_SYMBOL)
                self.state = 5155
                self.userList()
                pass

            elif la_ == 2:
                self.state = 5157
                self.roleOrPrivilegesList()
                self.state = 5158
                self.match(MySQLParser.ON_SYMBOL)
                self.state = 5160
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,574,self._ctx)
                if la_ == 1:
                    self.state = 5159
                    self.aclType()


                self.state = 5162
                self.grantIdentifier()
                self.state = 5163
                self.match(MySQLParser.FROM_SYMBOL)
                self.state = 5164
                self.userList()
                pass

            elif la_ == 3:
                self.state = 5166
                self.match(MySQLParser.ALL_SYMBOL)
                self.state = 5168
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==439:
                    self.state = 5167
                    self.match(MySQLParser.PRIVILEGES_SYMBOL)


                self.state = 5178
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [401]:
                    self.state = 5170
                    self.match(MySQLParser.ON_SYMBOL)
                    self.state = 5172
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,576,self._ctx)
                    if la_ == 1:
                        self.state = 5171
                        self.aclType()


                    self.state = 5174
                    self.grantIdentifier()
                    pass
                elif token in [29]:
                    self.state = 5175
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 5176
                    self.match(MySQLParser.GRANT_SYMBOL)
                    self.state = 5177
                    self.match(MySQLParser.OPTION_SYMBOL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 5180
                self.match(MySQLParser.FROM_SYMBOL)
                self.state = 5181
                self.userList()
                pass

            elif la_ == 4:
                self.state = 5182
                self.match(MySQLParser.PROXY_SYMBOL)
                self.state = 5183
                self.match(MySQLParser.ON_SYMBOL)
                self.state = 5184
                self.user()
                self.state = 5185
                self.match(MySQLParser.FROM_SYMBOL)
                self.state = 5186
                self.userList()
                pass


            self.state = 5192
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,579,self._ctx)
            if la_ == 1:
                self.state = 5190
                if not self.isServerVersionGe80031():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80031()")
                self.state = 5191
                self.ignoreUnknownUser()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AclTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_SYMBOL, 0)

        def FUNCTION_SYMBOL(self):
            return self.getToken(MySQLParser.FUNCTION_SYMBOL, 0)

        def PROCEDURE_SYMBOL(self):
            return self.getToken(MySQLParser.PROCEDURE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_aclType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAclType" ):
                listener.enterAclType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAclType" ):
                listener.exitAclType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAclType" ):
                return visitor.visitAclType(self)
            else:
                return visitor.visitChildren(self)




    def aclType(self):

        localctx = MySQLParser.AclTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 668, self.RULE_aclType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5194
            _la = self._input.LA(1)
            if not(_la==238 or _la==440 or _la==583):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleOrPrivilegesListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def roleOrPrivilege(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.RoleOrPrivilegeContext)
            else:
                return self.getTypedRuleContext(MySQLParser.RoleOrPrivilegeContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_roleOrPrivilegesList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoleOrPrivilegesList" ):
                listener.enterRoleOrPrivilegesList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoleOrPrivilegesList" ):
                listener.exitRoleOrPrivilegesList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRoleOrPrivilegesList" ):
                return visitor.visitRoleOrPrivilegesList(self)
            else:
                return visitor.visitChildren(self)




    def roleOrPrivilegesList(self):

        localctx = MySQLParser.RoleOrPrivilegesListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 670, self.RULE_roleOrPrivilegesList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5196
            self.roleOrPrivilege()
            self.state = 5201
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 5197
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 5198
                self.roleOrPrivilege()
                self.state = 5203
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleOrPrivilegeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.object_ = None # Token

        def roleIdentifierOrText(self):
            return self.getTypedRuleContext(MySQLParser.RoleIdentifierOrTextContext,0)


        def AT_TEXT_SUFFIX(self):
            return self.getToken(MySQLParser.AT_TEXT_SUFFIX, 0)

        def AT_SIGN_SYMBOL(self):
            return self.getToken(MySQLParser.AT_SIGN_SYMBOL, 0)

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def columnInternalRefList(self):
            return self.getTypedRuleContext(MySQLParser.ColumnInternalRefListContext,0)


        def SELECT_SYMBOL(self):
            return self.getToken(MySQLParser.SELECT_SYMBOL, 0)

        def INSERT_SYMBOL(self):
            return self.getToken(MySQLParser.INSERT_SYMBOL, 0)

        def UPDATE_SYMBOL(self):
            return self.getToken(MySQLParser.UPDATE_SYMBOL, 0)

        def REFERENCES_SYMBOL(self):
            return self.getToken(MySQLParser.REFERENCES_SYMBOL, 0)

        def DELETE_SYMBOL(self):
            return self.getToken(MySQLParser.DELETE_SYMBOL, 0)

        def USAGE_SYMBOL(self):
            return self.getToken(MySQLParser.USAGE_SYMBOL, 0)

        def INDEX_SYMBOL(self):
            return self.getToken(MySQLParser.INDEX_SYMBOL, 0)

        def DROP_SYMBOL(self):
            return self.getToken(MySQLParser.DROP_SYMBOL, 0)

        def EXECUTE_SYMBOL(self):
            return self.getToken(MySQLParser.EXECUTE_SYMBOL, 0)

        def RELOAD_SYMBOL(self):
            return self.getToken(MySQLParser.RELOAD_SYMBOL, 0)

        def SHUTDOWN_SYMBOL(self):
            return self.getToken(MySQLParser.SHUTDOWN_SYMBOL, 0)

        def PROCESS_SYMBOL(self):
            return self.getToken(MySQLParser.PROCESS_SYMBOL, 0)

        def FILE_SYMBOL(self):
            return self.getToken(MySQLParser.FILE_SYMBOL, 0)

        def PROXY_SYMBOL(self):
            return self.getToken(MySQLParser.PROXY_SYMBOL, 0)

        def SUPER_SYMBOL(self):
            return self.getToken(MySQLParser.SUPER_SYMBOL, 0)

        def EVENT_SYMBOL(self):
            return self.getToken(MySQLParser.EVENT_SYMBOL, 0)

        def TRIGGER_SYMBOL(self):
            return self.getToken(MySQLParser.TRIGGER_SYMBOL, 0)

        def GRANT_SYMBOL(self):
            return self.getToken(MySQLParser.GRANT_SYMBOL, 0)

        def OPTION_SYMBOL(self):
            return self.getToken(MySQLParser.OPTION_SYMBOL, 0)

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def DATABASES_SYMBOL(self):
            return self.getToken(MySQLParser.DATABASES_SYMBOL, 0)

        def CREATE_SYMBOL(self):
            return self.getToken(MySQLParser.CREATE_SYMBOL, 0)

        def TEMPORARY_SYMBOL(self):
            return self.getToken(MySQLParser.TEMPORARY_SYMBOL, 0)

        def TABLES_SYMBOL(self):
            return self.getToken(MySQLParser.TABLES_SYMBOL, 0)

        def ROUTINE_SYMBOL(self):
            return self.getToken(MySQLParser.ROUTINE_SYMBOL, 0)

        def TABLESPACE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLESPACE_SYMBOL, 0)

        def USER_SYMBOL(self):
            return self.getToken(MySQLParser.USER_SYMBOL, 0)

        def VIEW_SYMBOL(self):
            return self.getToken(MySQLParser.VIEW_SYMBOL, 0)

        def LOCK_SYMBOL(self):
            return self.getToken(MySQLParser.LOCK_SYMBOL, 0)

        def REPLICATION_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATION_SYMBOL, 0)

        def CLIENT_SYMBOL(self):
            return self.getToken(MySQLParser.CLIENT_SYMBOL, 0)

        def replica(self):
            return self.getTypedRuleContext(MySQLParser.ReplicaContext,0)


        def ALTER_SYMBOL(self):
            return self.getToken(MySQLParser.ALTER_SYMBOL, 0)

        def ROLE_SYMBOL(self):
            return self.getToken(MySQLParser.ROLE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_roleOrPrivilege

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoleOrPrivilege" ):
                listener.enterRoleOrPrivilege(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoleOrPrivilege" ):
                listener.exitRoleOrPrivilege(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRoleOrPrivilege" ):
                return visitor.visitRoleOrPrivilege(self)
            else:
                return visitor.visitChildren(self)




    def roleOrPrivilege(self):

        localctx = MySQLParser.RoleOrPrivilegeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 672, self.RULE_roleOrPrivilege)
        self._la = 0 # Token type
        try:
            self.state = 5246
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,588,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5214
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,583,self._ctx)
                if la_ == 1:
                    self.state = 5204
                    self.roleIdentifierOrText()
                    self.state = 5206
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==32:
                        self.state = 5205
                        self.columnInternalRefList()


                    pass

                elif la_ == 2:
                    self.state = 5208
                    self.roleIdentifierOrText()
                    self.state = 5212
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [40]:
                        self.state = 5209
                        self.match(MySQLParser.AT_TEXT_SUFFIX)
                        pass
                    elif token in [39]:
                        self.state = 5210
                        self.match(MySQLParser.AT_SIGN_SYMBOL)
                        self.state = 5211
                        self.textOrIdentifier()
                        pass
                    else:
                        raise NoViableAltException(self)

                    pass


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5216
                _la = self._input.LA(1)
                if not(_la==274 or _la==460 or _la==511 or _la==623):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 5218
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==32:
                    self.state = 5217
                    self.columnInternalRefList()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 5220
                _la = self._input.LA(1)
                if not(((((_la - 171)) & ~0x3f) == 0 and ((1 << (_la - 171)) & 2251954432516097) != 0) or _la==268 or ((((_la - 441)) & ~0x3f) == 0 and ((1 << (_la - 441)) & 134217745) != 0) or _la==522 or _la==575 or _la==603 or _la==625):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 5221
                self.match(MySQLParser.GRANT_SYMBOL)
                self.state = 5222
                self.match(MySQLParser.OPTION_SYMBOL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 5223
                self.match(MySQLParser.SHOW_SYMBOL)
                self.state = 5224
                self.match(MySQLParser.DATABASES_SYMBOL)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 5225
                self.match(MySQLParser.CREATE_SYMBOL)
                self.state = 5229
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [586]:
                    self.state = 5226
                    self.match(MySQLParser.TEMPORARY_SYMBOL)
                    self.state = 5227
                    localctx.object_ = self.match(MySQLParser.TABLES_SYMBOL)
                    pass
                elif token in [499, 582, 627, 644]:
                    self.state = 5228
                    localctx.object_ = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==499 or ((((_la - 582)) & ~0x3f) == 0 and ((1 << (_la - 582)) & 4611721202799476737) != 0)):
                        localctx.object_ = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    pass
                elif token in [29, 235, 401, 599]:
                    pass
                else:
                    pass
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 5231
                self.match(MySQLParser.LOCK_SYMBOL)
                self.state = 5232
                self.match(MySQLParser.TABLES_SYMBOL)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 5233
                self.match(MySQLParser.REPLICATION_SYMBOL)
                self.state = 5236
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [108]:
                    self.state = 5234
                    self.match(MySQLParser.CLIENT_SYMBOL)
                    pass
                elif token in [526, 762]:
                    self.state = 5235
                    self.replica()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 5238
                self.match(MySQLParser.SHOW_SYMBOL)
                self.state = 5239
                self.match(MySQLParser.VIEW_SYMBOL)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 5240
                self.match(MySQLParser.ALTER_SYMBOL)
                self.state = 5242
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==499:
                    self.state = 5241
                    self.match(MySQLParser.ROUTINE_SYMBOL)


                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 5244
                _la = self._input.LA(1)
                if not(_la==139 or _la==184):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 5245
                self.match(MySQLParser.ROLE_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GrantIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MULT_OPERATOR(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.MULT_OPERATOR)
            else:
                return self.getToken(MySQLParser.MULT_OPERATOR, i)

        def DOT_SYMBOL(self):
            return self.getToken(MySQLParser.DOT_SYMBOL, 0)

        def schemaRef(self):
            return self.getTypedRuleContext(MySQLParser.SchemaRefContext,0)


        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_grantIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGrantIdentifier" ):
                listener.enterGrantIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGrantIdentifier" ):
                listener.exitGrantIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGrantIdentifier" ):
                return visitor.visitGrantIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def grantIdentifier(self):

        localctx = MySQLParser.GrantIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 674, self.RULE_grantIdentifier)
        self._la = 0 # Token type
        try:
            self.state = 5264
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,591,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5248
                self.match(MySQLParser.MULT_OPERATOR)
                self.state = 5251
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==28:
                    self.state = 5249
                    self.match(MySQLParser.DOT_SYMBOL)
                    self.state = 5250
                    self.match(MySQLParser.MULT_OPERATOR)


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5253
                self.schemaRef()
                self.state = 5256
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==28:
                    self.state = 5254
                    self.match(MySQLParser.DOT_SYMBOL)
                    self.state = 5255
                    self.match(MySQLParser.MULT_OPERATOR)


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 5258
                self.tableRef()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 5259
                if not self.isServerVersionGe80017():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80017()")
                self.state = 5260
                self.schemaRef()
                self.state = 5261
                self.match(MySQLParser.DOT_SYMBOL)
                self.state = 5262
                self.tableRef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def requireListElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.RequireListElementContext)
            else:
                return self.getTypedRuleContext(MySQLParser.RequireListElementContext,i)


        def AND_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.AND_SYMBOL)
            else:
                return self.getToken(MySQLParser.AND_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_requireList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireList" ):
                listener.enterRequireList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireList" ):
                listener.exitRequireList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequireList" ):
                return visitor.visitRequireList(self)
            else:
                return visitor.visitChildren(self)




    def requireList(self):

        localctx = MySQLParser.RequireListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 676, self.RULE_requireList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5266
            self.requireListElement()
            self.state = 5273
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,593,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 5268
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==61:
                        self.state = 5267
                        self.match(MySQLParser.AND_SYMBOL)


                    self.state = 5270
                    self.requireListElement() 
                self.state = 5275
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,593,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireListElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.element = None # Token

        def textString(self):
            return self.getTypedRuleContext(MySQLParser.TextStringContext,0)


        def CIPHER_SYMBOL(self):
            return self.getToken(MySQLParser.CIPHER_SYMBOL, 0)

        def ISSUER_SYMBOL(self):
            return self.getToken(MySQLParser.ISSUER_SYMBOL, 0)

        def SUBJECT_SYMBOL(self):
            return self.getToken(MySQLParser.SUBJECT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_requireListElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireListElement" ):
                listener.enterRequireListElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireListElement" ):
                listener.exitRequireListElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequireListElement" ):
                return visitor.visitRequireListElement(self)
            else:
                return visitor.visitChildren(self)




    def requireListElement(self):

        localctx = MySQLParser.RequireListElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 678, self.RULE_requireListElement)
        try:
            self.state = 5282
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [106]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5276
                localctx.element = self.match(MySQLParser.CIPHER_SYMBOL)
                self.state = 5277
                self.textString()
                pass
            elif token in [289]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5278
                localctx.element = self.match(MySQLParser.ISSUER_SYMBOL)
                self.state = 5279
                self.textString()
                pass
            elif token in [569]:
                self.enterOuterAlt(localctx, 3)
                self.state = 5280
                localctx.element = self.match(MySQLParser.SUBJECT_SYMBOL)
                self.state = 5281
                self.textString()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GrantOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.option = None # Token

        def OPTION_SYMBOL(self):
            return self.getToken(MySQLParser.OPTION_SYMBOL, 0)

        def GRANT_SYMBOL(self):
            return self.getToken(MySQLParser.GRANT_SYMBOL, 0)

        def ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Ulong_numberContext,0)


        def MAX_QUERIES_PER_HOUR_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_QUERIES_PER_HOUR_SYMBOL, 0)

        def MAX_UPDATES_PER_HOUR_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_UPDATES_PER_HOUR_SYMBOL, 0)

        def MAX_CONNECTIONS_PER_HOUR_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_CONNECTIONS_PER_HOUR_SYMBOL, 0)

        def MAX_USER_CONNECTIONS_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_USER_CONNECTIONS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_grantOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGrantOption" ):
                listener.enterGrantOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGrantOption" ):
                listener.exitGrantOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGrantOption" ):
                return visitor.visitGrantOption(self)
            else:
                return visitor.visitChildren(self)




    def grantOption(self):

        localctx = MySQLParser.GrantOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 680, self.RULE_grantOption)
        try:
            self.state = 5297
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,596,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5284
                localctx.option = self.match(MySQLParser.GRANT_SYMBOL)
                self.state = 5285
                self.match(MySQLParser.OPTION_SYMBOL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5286
                if not self.isServerVersionLt80011():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionLt80011()")
                self.state = 5295
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [347]:
                    self.state = 5287
                    localctx.option = self.match(MySQLParser.MAX_QUERIES_PER_HOUR_SYMBOL)
                    self.state = 5288
                    self.ulong_number()
                    pass
                elif token in [351]:
                    self.state = 5289
                    localctx.option = self.match(MySQLParser.MAX_UPDATES_PER_HOUR_SYMBOL)
                    self.state = 5290
                    self.ulong_number()
                    pass
                elif token in [346]:
                    self.state = 5291
                    localctx.option = self.match(MySQLParser.MAX_CONNECTIONS_PER_HOUR_SYMBOL)
                    self.state = 5292
                    self.ulong_number()
                    pass
                elif token in [352]:
                    self.state = 5293
                    localctx.option = self.match(MySQLParser.MAX_USER_CONNECTIONS_SYMBOL)
                    self.state = 5294
                    self.ulong_number()
                    pass
                else:
                    raise NoViableAltException(self)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetRoleStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET_SYMBOL(self):
            return self.getToken(MySQLParser.SET_SYMBOL, 0)

        def ROLE_SYMBOL(self):
            return self.getToken(MySQLParser.ROLE_SYMBOL, 0)

        def roleList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.RoleListContext)
            else:
                return self.getTypedRuleContext(MySQLParser.RoleListContext,i)


        def NONE_SYMBOL(self):
            return self.getToken(MySQLParser.NONE_SYMBOL, 0)

        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def TO_SYMBOL(self):
            return self.getToken(MySQLParser.TO_SYMBOL, 0)

        def ALL_SYMBOL(self):
            return self.getToken(MySQLParser.ALL_SYMBOL, 0)

        def EXCEPT_SYMBOL(self):
            return self.getToken(MySQLParser.EXCEPT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_setRoleStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetRoleStatement" ):
                listener.enterSetRoleStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetRoleStatement" ):
                listener.exitSetRoleStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetRoleStatement" ):
                return visitor.visitSetRoleStatement(self)
            else:
                return visitor.visitChildren(self)




    def setRoleStatement(self):

        localctx = MySQLParser.SetRoleStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 682, self.RULE_setRoleStatement)
        self._la = 0 # Token type
        try:
            self.state = 5322
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,599,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5299
                self.match(MySQLParser.SET_SYMBOL)
                self.state = 5300
                self.match(MySQLParser.ROLE_SYMBOL)
                self.state = 5301
                self.roleList()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5302
                self.match(MySQLParser.SET_SYMBOL)
                self.state = 5303
                self.match(MySQLParser.ROLE_SYMBOL)
                self.state = 5304
                _la = self._input.LA(1)
                if not(_la==166 or _la==389):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 5305
                self.match(MySQLParser.SET_SYMBOL)
                self.state = 5306
                self.match(MySQLParser.DEFAULT_SYMBOL)
                self.state = 5307
                self.match(MySQLParser.ROLE_SYMBOL)
                self.state = 5311
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,597,self._ctx)
                if la_ == 1:
                    self.state = 5308
                    self.roleList()
                    pass

                elif la_ == 2:
                    self.state = 5309
                    self.match(MySQLParser.NONE_SYMBOL)
                    pass

                elif la_ == 3:
                    self.state = 5310
                    self.match(MySQLParser.ALL_SYMBOL)
                    pass


                self.state = 5313
                self.match(MySQLParser.TO_SYMBOL)
                self.state = 5314
                self.roleList()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 5315
                self.match(MySQLParser.SET_SYMBOL)
                self.state = 5316
                self.match(MySQLParser.ROLE_SYMBOL)
                self.state = 5317
                self.match(MySQLParser.ALL_SYMBOL)
                self.state = 5320
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==671:
                    self.state = 5318
                    self.match(MySQLParser.EXCEPT_SYMBOL)
                    self.state = 5319
                    self.roleList()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def role(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.RoleContext)
            else:
                return self.getTypedRuleContext(MySQLParser.RoleContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_roleList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoleList" ):
                listener.enterRoleList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoleList" ):
                listener.exitRoleList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRoleList" ):
                return visitor.visitRoleList(self)
            else:
                return visitor.visitChildren(self)




    def roleList(self):

        localctx = MySQLParser.RoleListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 684, self.RULE_roleList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5324
            self.role()
            self.state = 5329
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,600,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 5325
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 5326
                    self.role() 
                self.state = 5331
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,600,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def roleIdentifierOrText(self):
            return self.getTypedRuleContext(MySQLParser.RoleIdentifierOrTextContext,0)


        def userVariable(self):
            return self.getTypedRuleContext(MySQLParser.UserVariableContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_role

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRole" ):
                listener.enterRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRole" ):
                listener.exitRole(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRole" ):
                return visitor.visitRole(self)
            else:
                return visitor.visitChildren(self)




    def role(self):

        localctx = MySQLParser.RoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 686, self.RULE_role)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5332
            self.roleIdentifierOrText()
            self.state = 5334
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,601,self._ctx)
            if la_ == 1:
                self.state = 5333
                self.userVariable()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableAdministrationStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # Token

        def TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_SYMBOL, 0)

        def tableRefList(self):
            return self.getTypedRuleContext(MySQLParser.TableRefListContext,0)


        def ANALYZE_SYMBOL(self):
            return self.getToken(MySQLParser.ANALYZE_SYMBOL, 0)

        def noWriteToBinLog(self):
            return self.getTypedRuleContext(MySQLParser.NoWriteToBinLogContext,0)


        def histogram(self):
            return self.getTypedRuleContext(MySQLParser.HistogramContext,0)


        def CHECK_SYMBOL(self):
            return self.getToken(MySQLParser.CHECK_SYMBOL, 0)

        def checkOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.CheckOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.CheckOptionContext,i)


        def CHECKSUM_SYMBOL(self):
            return self.getToken(MySQLParser.CHECKSUM_SYMBOL, 0)

        def QUICK_SYMBOL(self):
            return self.getToken(MySQLParser.QUICK_SYMBOL, 0)

        def EXTENDED_SYMBOL(self):
            return self.getToken(MySQLParser.EXTENDED_SYMBOL, 0)

        def OPTIMIZE_SYMBOL(self):
            return self.getToken(MySQLParser.OPTIMIZE_SYMBOL, 0)

        def REPAIR_SYMBOL(self):
            return self.getToken(MySQLParser.REPAIR_SYMBOL, 0)

        def repairType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.RepairTypeContext)
            else:
                return self.getTypedRuleContext(MySQLParser.RepairTypeContext,i)


        def getRuleIndex(self):
            return MySQLParser.RULE_tableAdministrationStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableAdministrationStatement" ):
                listener.enterTableAdministrationStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableAdministrationStatement" ):
                listener.exitTableAdministrationStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableAdministrationStatement" ):
                return visitor.visitTableAdministrationStatement(self)
            else:
                return visitor.visitChildren(self)




    def tableAdministrationStatement(self):

        localctx = MySQLParser.TableAdministrationStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 688, self.RULE_tableAdministrationStatement)
        self._la = 0 # Token type
        try:
            self.state = 5378
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [60]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5336
                localctx.type_ = self.match(MySQLParser.ANALYZE_SYMBOL)
                self.state = 5338
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==312 or _la==394:
                    self.state = 5337
                    self.noWriteToBinLog()


                self.state = 5340
                self.match(MySQLParser.TABLE_SYMBOL)
                self.state = 5341
                self.tableRefList()
                self.state = 5343
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==184 or _la==623:
                    self.state = 5342
                    self.histogram()


                pass
            elif token in [105]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5345
                localctx.type_ = self.match(MySQLParser.CHECK_SYMBOL)
                self.state = 5346
                self.match(MySQLParser.TABLE_SYMBOL)
                self.state = 5347
                self.tableRefList()
                self.state = 5351
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==100 or ((((_la - 215)) & ~0x3f) == 0 and ((1 << (_la - 215)) & 131089) != 0) or _la==357 or _la==449:
                    self.state = 5348
                    self.checkOption()
                    self.state = 5353
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [104]:
                self.enterOuterAlt(localctx, 3)
                self.state = 5354
                localctx.type_ = self.match(MySQLParser.CHECKSUM_SYMBOL)
                self.state = 5355
                self.match(MySQLParser.TABLE_SYMBOL)
                self.state = 5356
                self.tableRefList()
                self.state = 5358
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==215 or _la==449:
                    self.state = 5357
                    _la = self._input.LA(1)
                    if not(_la==215 or _la==449):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass
            elif token in [406]:
                self.enterOuterAlt(localctx, 4)
                self.state = 5360
                localctx.type_ = self.match(MySQLParser.OPTIMIZE_SYMBOL)
                self.state = 5362
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==312 or _la==394:
                    self.state = 5361
                    self.noWriteToBinLog()


                self.state = 5364
                self.match(MySQLParser.TABLE_SYMBOL)
                self.state = 5365
                self.tableRefList()
                pass
            elif token in [472]:
                self.enterOuterAlt(localctx, 5)
                self.state = 5366
                localctx.type_ = self.match(MySQLParser.REPAIR_SYMBOL)
                self.state = 5368
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==312 or _la==394:
                    self.state = 5367
                    self.noWriteToBinLog()


                self.state = 5370
                self.match(MySQLParser.TABLE_SYMBOL)
                self.state = 5371
                self.tableRefList()
                self.state = 5375
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==215 or _la==449 or _la==628:
                    self.state = 5372
                    self.repairType()
                    self.state = 5377
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HistogramAutoUpdateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UPDATE_SYMBOL(self):
            return self.getToken(MySQLParser.UPDATE_SYMBOL, 0)

        def MANUAL_SYMBOL(self):
            return self.getToken(MySQLParser.MANUAL_SYMBOL, 0)

        def AUTO_SYMBOL(self):
            return self.getToken(MySQLParser.AUTO_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_histogramAutoUpdate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHistogramAutoUpdate" ):
                listener.enterHistogramAutoUpdate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHistogramAutoUpdate" ):
                listener.exitHistogramAutoUpdate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHistogramAutoUpdate" ):
                return visitor.visitHistogramAutoUpdate(self)
            else:
                return visitor.visitChildren(self)




    def histogramAutoUpdate(self):

        localctx = MySQLParser.HistogramAutoUpdateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 690, self.RULE_histogramAutoUpdate)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5380
            if not self.isServerVersionGe80200():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.isServerVersionGe80200()")
            self.state = 5381
            _la = self._input.LA(1)
            if not(_la==813 or _la==814):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 5382
            self.match(MySQLParser.UPDATE_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HistogramUpdateParamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def histogramNumBuckets(self):
            return self.getTypedRuleContext(MySQLParser.HistogramNumBucketsContext,0)


        def histogramAutoUpdate(self):
            return self.getTypedRuleContext(MySQLParser.HistogramAutoUpdateContext,0)


        def USING_SYMBOL(self):
            return self.getToken(MySQLParser.USING_SYMBOL, 0)

        def DATA_SYMBOL(self):
            return self.getToken(MySQLParser.DATA_SYMBOL, 0)

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_histogramUpdateParam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHistogramUpdateParam" ):
                listener.enterHistogramUpdateParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHistogramUpdateParam" ):
                listener.exitHistogramUpdateParam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHistogramUpdateParam" ):
                return visitor.visitHistogramUpdateParam(self)
            else:
                return visitor.visitChildren(self)




    def histogramUpdateParam(self):

        localctx = MySQLParser.HistogramUpdateParamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 692, self.RULE_histogramUpdateParam)
        try:
            self.state = 5394
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,612,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5385
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,610,self._ctx)
                if la_ == 1:
                    self.state = 5384
                    self.histogramNumBuckets()


                self.state = 5388
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,611,self._ctx)
                if la_ == 1:
                    self.state = 5387
                    self.histogramAutoUpdate()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5390
                if not self.isServerVersionGe80031():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80031()")
                self.state = 5391
                self.match(MySQLParser.USING_SYMBOL)
                self.state = 5392
                self.match(MySQLParser.DATA_SYMBOL)
                self.state = 5393
                self.textStringLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HistogramNumBucketsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def INT_NUMBER(self):
            return self.getToken(MySQLParser.INT_NUMBER, 0)

        def BUCKETS_SYMBOL(self):
            return self.getToken(MySQLParser.BUCKETS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_histogramNumBuckets

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHistogramNumBuckets" ):
                listener.enterHistogramNumBuckets(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHistogramNumBuckets" ):
                listener.exitHistogramNumBuckets(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHistogramNumBuckets" ):
                return visitor.visitHistogramNumBuckets(self)
            else:
                return visitor.visitChildren(self)




    def histogramNumBuckets(self):

        localctx = MySQLParser.HistogramNumBucketsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 694, self.RULE_histogramNumBuckets)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5396
            if not self.isServerVersionGe80200():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.isServerVersionGe80200()")
            self.state = 5397
            self.match(MySQLParser.WITH_SYMBOL)
            self.state = 5398
            self.match(MySQLParser.INT_NUMBER)
            self.state = 5399
            self.match(MySQLParser.BUCKETS_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HistogramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UPDATE_SYMBOL(self):
            return self.getToken(MySQLParser.UPDATE_SYMBOL, 0)

        def HISTOGRAM_SYMBOL(self):
            return self.getToken(MySQLParser.HISTOGRAM_SYMBOL, 0)

        def ON_SYMBOL(self):
            return self.getToken(MySQLParser.ON_SYMBOL, 0)

        def identifierList(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierListContext,0)


        def histogramUpdateParam(self):
            return self.getTypedRuleContext(MySQLParser.HistogramUpdateParamContext,0)


        def DROP_SYMBOL(self):
            return self.getToken(MySQLParser.DROP_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_histogram

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHistogram" ):
                listener.enterHistogram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHistogram" ):
                listener.exitHistogram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHistogram" ):
                return visitor.visitHistogram(self)
            else:
                return visitor.visitChildren(self)




    def histogram(self):

        localctx = MySQLParser.HistogramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 696, self.RULE_histogram)
        try:
            self.state = 5411
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [623]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5401
                self.match(MySQLParser.UPDATE_SYMBOL)
                self.state = 5402
                self.match(MySQLParser.HISTOGRAM_SYMBOL)
                self.state = 5403
                self.match(MySQLParser.ON_SYMBOL)
                self.state = 5404
                self.identifierList()
                self.state = 5405
                self.histogramUpdateParam()
                pass
            elif token in [184]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5407
                self.match(MySQLParser.DROP_SYMBOL)
                self.state = 5408
                self.match(MySQLParser.HISTOGRAM_SYMBOL)
                self.state = 5409
                self.match(MySQLParser.ON_SYMBOL)
                self.state = 5410
                self.identifierList()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CheckOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def UPGRADE_SYMBOL(self):
            return self.getToken(MySQLParser.UPGRADE_SYMBOL, 0)

        def QUICK_SYMBOL(self):
            return self.getToken(MySQLParser.QUICK_SYMBOL, 0)

        def FAST_SYMBOL(self):
            return self.getToken(MySQLParser.FAST_SYMBOL, 0)

        def MEDIUM_SYMBOL(self):
            return self.getToken(MySQLParser.MEDIUM_SYMBOL, 0)

        def EXTENDED_SYMBOL(self):
            return self.getToken(MySQLParser.EXTENDED_SYMBOL, 0)

        def CHANGED_SYMBOL(self):
            return self.getToken(MySQLParser.CHANGED_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_checkOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCheckOption" ):
                listener.enterCheckOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCheckOption" ):
                listener.exitCheckOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCheckOption" ):
                return visitor.visitCheckOption(self)
            else:
                return visitor.visitChildren(self)




    def checkOption(self):

        localctx = MySQLParser.CheckOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 698, self.RULE_checkOption)
        self._la = 0 # Token type
        try:
            self.state = 5416
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [232]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5413
                self.match(MySQLParser.FOR_SYMBOL)
                self.state = 5414
                self.match(MySQLParser.UPGRADE_SYMBOL)
                pass
            elif token in [100, 215, 219, 357, 449]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5415
                _la = self._input.LA(1)
                if not(_la==100 or _la==215 or _la==219 or _la==357 or _la==449):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RepairTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUICK_SYMBOL(self):
            return self.getToken(MySQLParser.QUICK_SYMBOL, 0)

        def EXTENDED_SYMBOL(self):
            return self.getToken(MySQLParser.EXTENDED_SYMBOL, 0)

        def USE_FRM_SYMBOL(self):
            return self.getToken(MySQLParser.USE_FRM_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_repairType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRepairType" ):
                listener.enterRepairType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRepairType" ):
                listener.exitRepairType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRepairType" ):
                return visitor.visitRepairType(self)
            else:
                return visitor.visitChildren(self)




    def repairType(self):

        localctx = MySQLParser.RepairTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 700, self.RULE_repairType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5418
            _la = self._input.LA(1)
            if not(_la==215 or _la==449 or _la==628):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UninstallStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNINSTALL_SYMBOL(self):
            return self.getToken(MySQLParser.UNINSTALL_SYMBOL, 0)

        def PLUGIN_SYMBOL(self):
            return self.getToken(MySQLParser.PLUGIN_SYMBOL, 0)

        def pluginRef(self):
            return self.getTypedRuleContext(MySQLParser.PluginRefContext,0)


        def COMPONENT_SYMBOL(self):
            return self.getToken(MySQLParser.COMPONENT_SYMBOL, 0)

        def componentRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ComponentRefContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ComponentRefContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_uninstallStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUninstallStatement" ):
                listener.enterUninstallStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUninstallStatement" ):
                listener.exitUninstallStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUninstallStatement" ):
                return visitor.visitUninstallStatement(self)
            else:
                return visitor.visitChildren(self)




    def uninstallStatement(self):

        localctx = MySQLParser.UninstallStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 702, self.RULE_uninstallStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5420
            self.match(MySQLParser.UNINSTALL_SYMBOL)
            self.state = 5432
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [428]:
                self.state = 5421
                self.match(MySQLParser.PLUGIN_SYMBOL)
                self.state = 5422
                self.pluginRef()
                pass
            elif token in [672]:
                self.state = 5423
                self.match(MySQLParser.COMPONENT_SYMBOL)
                self.state = 5424
                self.componentRef()
                self.state = 5429
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==29:
                    self.state = 5425
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 5426
                    self.componentRef()
                    self.state = 5431
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InstallStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INSTALL_SYMBOL(self):
            return self.getToken(MySQLParser.INSTALL_SYMBOL, 0)

        def PLUGIN_SYMBOL(self):
            return self.getToken(MySQLParser.PLUGIN_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def SONAME_SYMBOL(self):
            return self.getToken(MySQLParser.SONAME_SYMBOL, 0)

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def COMPONENT_SYMBOL(self):
            return self.getToken(MySQLParser.COMPONENT_SYMBOL, 0)

        def textStringLiteralList(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralListContext,0)


        def installSetValueList(self):
            return self.getTypedRuleContext(MySQLParser.InstallSetValueListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_installStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstallStatement" ):
                listener.enterInstallStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstallStatement" ):
                listener.exitInstallStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInstallStatement" ):
                return visitor.visitInstallStatement(self)
            else:
                return visitor.visitChildren(self)




    def installStatement(self):

        localctx = MySQLParser.InstallStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 704, self.RULE_installStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5434
            self.match(MySQLParser.INSTALL_SYMBOL)
            self.state = 5445
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [428]:
                self.state = 5435
                self.match(MySQLParser.PLUGIN_SYMBOL)
                self.state = 5436
                self.identifier()
                self.state = 5437
                self.match(MySQLParser.SONAME_SYMBOL)
                self.state = 5438
                self.textStringLiteral()
                pass
            elif token in [672]:
                self.state = 5440
                self.match(MySQLParser.COMPONENT_SYMBOL)
                self.state = 5441
                self.textStringLiteralList()
                self.state = 5443
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,617,self._ctx)
                if la_ == 1:
                    self.state = 5442
                    self.installSetValueList()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InstallOptionTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GLOBAL_SYMBOL(self):
            return self.getToken(MySQLParser.GLOBAL_SYMBOL, 0)

        def PERSIST_SYMBOL(self):
            return self.getToken(MySQLParser.PERSIST_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_installOptionType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstallOptionType" ):
                listener.enterInstallOptionType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstallOptionType" ):
                listener.exitInstallOptionType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInstallOptionType" ):
                return visitor.visitInstallOptionType(self)
            else:
                return visitor.visitChildren(self)




    def installOptionType(self):

        localctx = MySQLParser.InstallOptionTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 706, self.RULE_installOptionType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5447
            _la = self._input.LA(1)
            if not(_la==246 or _la==666):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InstallSetRvalueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def ON_SYMBOL(self):
            return self.getToken(MySQLParser.ON_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_installSetRvalue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstallSetRvalue" ):
                listener.enterInstallSetRvalue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstallSetRvalue" ):
                listener.exitInstallSetRvalue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInstallSetRvalue" ):
                return visitor.visitInstallSetRvalue(self)
            else:
                return visitor.visitChildren(self)




    def installSetRvalue(self):

        localctx = MySQLParser.InstallSetRvalueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 708, self.RULE_installSetRvalue)
        try:
            self.state = 5451
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,619,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5449
                self.expr(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5450
                self.match(MySQLParser.ON_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InstallSetValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def installOptionType(self):
            return self.getTypedRuleContext(MySQLParser.InstallOptionTypeContext,0)


        def lvalueVariable(self):
            return self.getTypedRuleContext(MySQLParser.LvalueVariableContext,0)


        def equal(self):
            return self.getTypedRuleContext(MySQLParser.EqualContext,0)


        def installSetRvalue(self):
            return self.getTypedRuleContext(MySQLParser.InstallSetRvalueContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_installSetValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstallSetValue" ):
                listener.enterInstallSetValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstallSetValue" ):
                listener.exitInstallSetValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInstallSetValue" ):
                return visitor.visitInstallSetValue(self)
            else:
                return visitor.visitChildren(self)




    def installSetValue(self):

        localctx = MySQLParser.InstallSetValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 710, self.RULE_installSetValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5453
            self.installOptionType()
            self.state = 5454
            self.lvalueVariable()
            self.state = 5455
            self.equal()
            self.state = 5456
            self.installSetRvalue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InstallSetValueListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET_SYMBOL(self):
            return self.getToken(MySQLParser.SET_SYMBOL, 0)

        def installSetValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.InstallSetValueContext)
            else:
                return self.getTypedRuleContext(MySQLParser.InstallSetValueContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_installSetValueList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstallSetValueList" ):
                listener.enterInstallSetValueList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstallSetValueList" ):
                listener.exitInstallSetValueList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInstallSetValueList" ):
                return visitor.visitInstallSetValueList(self)
            else:
                return visitor.visitChildren(self)




    def installSetValueList(self):

        localctx = MySQLParser.InstallSetValueListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 712, self.RULE_installSetValueList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5458
            if not self.isServerVersionGe80032():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.isServerVersionGe80032()")
            self.state = 5459
            self.match(MySQLParser.SET_SYMBOL)
            self.state = 5460
            self.installSetValue()
            self.state = 5465
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 5461
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 5462
                self.installSetValue()
                self.state = 5467
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET_SYMBOL(self):
            return self.getToken(MySQLParser.SET_SYMBOL, 0)

        def startOptionValueList(self):
            return self.getTypedRuleContext(MySQLParser.StartOptionValueListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_setStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetStatement" ):
                listener.enterSetStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetStatement" ):
                listener.exitSetStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetStatement" ):
                return visitor.visitSetStatement(self)
            else:
                return visitor.visitChildren(self)




    def setStatement(self):

        localctx = MySQLParser.SetStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 714, self.RULE_setStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5468
            self.match(MySQLParser.SET_SYMBOL)
            self.state = 5469
            self.startOptionValueList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StartOptionValueListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def optionValueNoOptionType(self):
            return self.getTypedRuleContext(MySQLParser.OptionValueNoOptionTypeContext,0)


        def optionValueListContinued(self):
            return self.getTypedRuleContext(MySQLParser.OptionValueListContinuedContext,0)


        def TRANSACTION_SYMBOL(self):
            return self.getToken(MySQLParser.TRANSACTION_SYMBOL, 0)

        def transactionCharacteristics(self):
            return self.getTypedRuleContext(MySQLParser.TransactionCharacteristicsContext,0)


        def optionType(self):
            return self.getTypedRuleContext(MySQLParser.OptionTypeContext,0)


        def startOptionValueListFollowingOptionType(self):
            return self.getTypedRuleContext(MySQLParser.StartOptionValueListFollowingOptionTypeContext,0)


        def PASSWORD_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.PASSWORD_SYMBOL)
            else:
                return self.getToken(MySQLParser.PASSWORD_SYMBOL, i)

        def equal(self):
            return self.getTypedRuleContext(MySQLParser.EqualContext,0)


        def textString(self):
            return self.getTypedRuleContext(MySQLParser.TextStringContext,0)


        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def user(self):
            return self.getTypedRuleContext(MySQLParser.UserContext,0)


        def replacePassword(self):
            return self.getTypedRuleContext(MySQLParser.ReplacePasswordContext,0)


        def retainCurrentPassword(self):
            return self.getTypedRuleContext(MySQLParser.RetainCurrentPasswordContext,0)


        def TO_SYMBOL(self):
            return self.getToken(MySQLParser.TO_SYMBOL, 0)

        def RANDOM_SYMBOL(self):
            return self.getToken(MySQLParser.RANDOM_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_startOptionValueList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartOptionValueList" ):
                listener.enterStartOptionValueList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartOptionValueList" ):
                listener.exitStartOptionValueList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartOptionValueList" ):
                return visitor.visitStartOptionValueList(self)
            else:
                return visitor.visitChildren(self)




    def startOptionValueList(self):

        localctx = MySQLParser.StartOptionValueListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 716, self.RULE_startOptionValueList)
        self._la = 0 # Token type
        try:
            self.state = 5521
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,630,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5471
                self.optionValueNoOptionType()
                self.state = 5472
                self.optionValueListContinued()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5474
                self.match(MySQLParser.TRANSACTION_SYMBOL)
                self.state = 5475
                self.transactionCharacteristics()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 5476
                self.optionType()
                self.state = 5477
                self.startOptionValueListFollowingOptionType()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 5479
                self.match(MySQLParser.PASSWORD_SYMBOL)
                self.state = 5482
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==232:
                    self.state = 5480
                    self.match(MySQLParser.FOR_SYMBOL)
                    self.state = 5481
                    self.user()


                self.state = 5484
                self.equal()
                self.state = 5505
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,626,self._ctx)
                if la_ == 1:
                    self.state = 5485
                    self.textString()
                    self.state = 5487
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==475:
                        self.state = 5486
                        self.replacePassword()


                    self.state = 5490
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==735:
                        self.state = 5489
                        self.retainCurrentPassword()


                    pass

                elif la_ == 2:
                    self.state = 5492
                    self.textString()
                    self.state = 5494
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==475:
                        self.state = 5493
                        self.replacePassword()


                    self.state = 5497
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==735:
                        self.state = 5496
                        self.retainCurrentPassword()


                    pass

                elif la_ == 3:
                    self.state = 5499
                    if not self.isServerVersionLt80014():
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.isServerVersionLt80014()")
                    self.state = 5500
                    self.match(MySQLParser.PASSWORD_SYMBOL)
                    self.state = 5501
                    self.match(MySQLParser.OPEN_PAR_SYMBOL)
                    self.state = 5502
                    self.textString()
                    self.state = 5503
                    self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                    pass


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 5507
                if not self.isServerVersionGe80018():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80018()")
                self.state = 5508
                self.match(MySQLParser.PASSWORD_SYMBOL)
                self.state = 5511
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==232:
                    self.state = 5509
                    self.match(MySQLParser.FOR_SYMBOL)
                    self.state = 5510
                    self.user()


                self.state = 5513
                self.match(MySQLParser.TO_SYMBOL)
                self.state = 5514
                self.match(MySQLParser.RANDOM_SYMBOL)
                self.state = 5516
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==475:
                    self.state = 5515
                    self.replacePassword()


                self.state = 5519
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==735:
                    self.state = 5518
                    self.retainCurrentPassword()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TransactionCharacteristicsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def transactionAccessMode(self):
            return self.getTypedRuleContext(MySQLParser.TransactionAccessModeContext,0)


        def isolationLevel(self):
            return self.getTypedRuleContext(MySQLParser.IsolationLevelContext,0)


        def COMMA_SYMBOL(self):
            return self.getToken(MySQLParser.COMMA_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_transactionCharacteristics

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTransactionCharacteristics" ):
                listener.enterTransactionCharacteristics(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTransactionCharacteristics" ):
                listener.exitTransactionCharacteristics(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTransactionCharacteristics" ):
                return visitor.visitTransactionCharacteristics(self)
            else:
                return visitor.visitChildren(self)




    def transactionCharacteristics(self):

        localctx = MySQLParser.TransactionCharacteristicsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 718, self.RULE_transactionCharacteristics)
        self._la = 0 # Token type
        try:
            self.state = 5532
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [453]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5523
                self.transactionAccessMode()
                self.state = 5525
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==288:
                    self.state = 5524
                    self.isolationLevel()


                pass
            elif token in [288]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5527
                self.isolationLevel()
                self.state = 5530
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 5528
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 5529
                    self.transactionAccessMode()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TransactionAccessModeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def READ_SYMBOL(self):
            return self.getToken(MySQLParser.READ_SYMBOL, 0)

        def WRITE_SYMBOL(self):
            return self.getToken(MySQLParser.WRITE_SYMBOL, 0)

        def ONLY_SYMBOL(self):
            return self.getToken(MySQLParser.ONLY_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_transactionAccessMode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTransactionAccessMode" ):
                listener.enterTransactionAccessMode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTransactionAccessMode" ):
                listener.exitTransactionAccessMode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTransactionAccessMode" ):
                return visitor.visitTransactionAccessMode(self)
            else:
                return visitor.visitChildren(self)




    def transactionAccessMode(self):

        localctx = MySQLParser.TransactionAccessModeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 720, self.RULE_transactionAccessMode)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5534
            self.match(MySQLParser.READ_SYMBOL)
            self.state = 5535
            _la = self._input.LA(1)
            if not(_la==404 or _la==657):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IsolationLevelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ISOLATION_SYMBOL(self):
            return self.getToken(MySQLParser.ISOLATION_SYMBOL, 0)

        def LEVEL_SYMBOL(self):
            return self.getToken(MySQLParser.LEVEL_SYMBOL, 0)

        def REPEATABLE_SYMBOL(self):
            return self.getToken(MySQLParser.REPEATABLE_SYMBOL, 0)

        def READ_SYMBOL(self):
            return self.getToken(MySQLParser.READ_SYMBOL, 0)

        def SERIALIZABLE_SYMBOL(self):
            return self.getToken(MySQLParser.SERIALIZABLE_SYMBOL, 0)

        def COMMITTED_SYMBOL(self):
            return self.getToken(MySQLParser.COMMITTED_SYMBOL, 0)

        def UNCOMMITTED_SYMBOL(self):
            return self.getToken(MySQLParser.UNCOMMITTED_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_isolationLevel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIsolationLevel" ):
                listener.enterIsolationLevel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIsolationLevel" ):
                listener.exitIsolationLevel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIsolationLevel" ):
                return visitor.visitIsolationLevel(self)
            else:
                return visitor.visitChildren(self)




    def isolationLevel(self):

        localctx = MySQLParser.IsolationLevelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 722, self.RULE_isolationLevel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5537
            self.match(MySQLParser.ISOLATION_SYMBOL)
            self.state = 5538
            self.match(MySQLParser.LEVEL_SYMBOL)
            self.state = 5544
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [473]:
                self.state = 5539
                self.match(MySQLParser.REPEATABLE_SYMBOL)
                self.state = 5540
                self.match(MySQLParser.READ_SYMBOL)
                pass
            elif token in [453]:
                self.state = 5541
                self.match(MySQLParser.READ_SYMBOL)
                self.state = 5542
                _la = self._input.LA(1)
                if not(_la==119 or _la==610):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [514]:
                self.state = 5543
                self.match(MySQLParser.SERIALIZABLE_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionValueListContinuedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def optionValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.OptionValueContext)
            else:
                return self.getTypedRuleContext(MySQLParser.OptionValueContext,i)


        def getRuleIndex(self):
            return MySQLParser.RULE_optionValueListContinued

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptionValueListContinued" ):
                listener.enterOptionValueListContinued(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptionValueListContinued" ):
                listener.exitOptionValueListContinued(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOptionValueListContinued" ):
                return visitor.visitOptionValueListContinued(self)
            else:
                return visitor.visitChildren(self)




    def optionValueListContinued(self):

        localctx = MySQLParser.OptionValueListContinuedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 724, self.RULE_optionValueListContinued)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5550
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 5546
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 5547
                self.optionValue()
                self.state = 5552
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionValueNoOptionTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lvalueVariable(self):
            return self.getTypedRuleContext(MySQLParser.LvalueVariableContext,0)


        def equal(self):
            return self.getTypedRuleContext(MySQLParser.EqualContext,0)


        def setExprOrDefault(self):
            return self.getTypedRuleContext(MySQLParser.SetExprOrDefaultContext,0)


        def charsetClause(self):
            return self.getTypedRuleContext(MySQLParser.CharsetClauseContext,0)


        def userVariable(self):
            return self.getTypedRuleContext(MySQLParser.UserVariableContext,0)


        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def AT_AT_SIGN_SYMBOL(self):
            return self.getToken(MySQLParser.AT_AT_SIGN_SYMBOL, 0)

        def setVarIdentType(self):
            return self.getTypedRuleContext(MySQLParser.SetVarIdentTypeContext,0)


        def NAMES_SYMBOL(self):
            return self.getToken(MySQLParser.NAMES_SYMBOL, 0)

        def charsetName(self):
            return self.getTypedRuleContext(MySQLParser.CharsetNameContext,0)


        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def collate(self):
            return self.getTypedRuleContext(MySQLParser.CollateContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_optionValueNoOptionType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptionValueNoOptionType" ):
                listener.enterOptionValueNoOptionType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptionValueNoOptionType" ):
                listener.exitOptionValueNoOptionType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOptionValueNoOptionType" ):
                return visitor.visitOptionValueNoOptionType(self)
            else:
                return visitor.visitChildren(self)




    def optionValueNoOptionType(self):

        localctx = MySQLParser.OptionValueNoOptionTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 726, self.RULE_optionValueNoOptionType)
        self._la = 0 # Token type
        try:
            self.state = 5582
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,639,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5553
                self.lvalueVariable()
                self.state = 5554
                self.equal()
                self.state = 5555
                self.setExprOrDefault()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5557
                self.charsetClause()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 5558
                self.userVariable()
                self.state = 5559
                self.equal()
                self.state = 5560
                self.expr(0)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 5562
                self.match(MySQLParser.AT_AT_SIGN_SYMBOL)
                self.state = 5564
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,636,self._ctx)
                if la_ == 1:
                    self.state = 5563
                    self.setVarIdentType()


                self.state = 5566
                self.lvalueVariable()
                self.state = 5567
                self.equal()
                self.state = 5568
                self.setExprOrDefault()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 5570
                self.match(MySQLParser.NAMES_SYMBOL)
                self.state = 5580
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,638,self._ctx)
                if la_ == 1:
                    self.state = 5571
                    self.equal()
                    self.state = 5572
                    self.expr(0)
                    pass

                elif la_ == 2:
                    self.state = 5574
                    self.charsetName()
                    self.state = 5576
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==112:
                        self.state = 5575
                        self.collate()


                    pass

                elif la_ == 3:
                    self.state = 5578
                    if not self.isServerVersionGe80011():
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.isServerVersionGe80011()")
                    self.state = 5579
                    self.match(MySQLParser.DEFAULT_SYMBOL)
                    pass


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def optionType(self):
            return self.getTypedRuleContext(MySQLParser.OptionTypeContext,0)


        def lvalueVariable(self):
            return self.getTypedRuleContext(MySQLParser.LvalueVariableContext,0)


        def equal(self):
            return self.getTypedRuleContext(MySQLParser.EqualContext,0)


        def setExprOrDefault(self):
            return self.getTypedRuleContext(MySQLParser.SetExprOrDefaultContext,0)


        def optionValueNoOptionType(self):
            return self.getTypedRuleContext(MySQLParser.OptionValueNoOptionTypeContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_optionValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptionValue" ):
                listener.enterOptionValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptionValue" ):
                listener.exitOptionValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOptionValue" ):
                return visitor.visitOptionValue(self)
            else:
                return visitor.visitChildren(self)




    def optionValue(self):

        localctx = MySQLParser.OptionValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 728, self.RULE_optionValue)
        try:
            self.state = 5590
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,640,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5584
                self.optionType()
                self.state = 5585
                self.lvalueVariable()
                self.state = 5586
                self.equal()
                self.state = 5587
                self.setExprOrDefault()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5589
                self.optionValueNoOptionType()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetSystemVariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT_AT_SIGN_SYMBOL(self):
            return self.getToken(MySQLParser.AT_AT_SIGN_SYMBOL, 0)

        def lvalueVariable(self):
            return self.getTypedRuleContext(MySQLParser.LvalueVariableContext,0)


        def setVarIdentType(self):
            return self.getTypedRuleContext(MySQLParser.SetVarIdentTypeContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_setSystemVariable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetSystemVariable" ):
                listener.enterSetSystemVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetSystemVariable" ):
                listener.exitSetSystemVariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetSystemVariable" ):
                return visitor.visitSetSystemVariable(self)
            else:
                return visitor.visitChildren(self)




    def setSystemVariable(self):

        localctx = MySQLParser.SetSystemVariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 730, self.RULE_setSystemVariable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5592
            self.match(MySQLParser.AT_AT_SIGN_SYMBOL)
            self.state = 5594
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,641,self._ctx)
            if la_ == 1:
                self.state = 5593
                self.setVarIdentType()


            self.state = 5596
            self.lvalueVariable()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StartOptionValueListFollowingOptionTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def optionValueFollowingOptionType(self):
            return self.getTypedRuleContext(MySQLParser.OptionValueFollowingOptionTypeContext,0)


        def optionValueListContinued(self):
            return self.getTypedRuleContext(MySQLParser.OptionValueListContinuedContext,0)


        def TRANSACTION_SYMBOL(self):
            return self.getToken(MySQLParser.TRANSACTION_SYMBOL, 0)

        def transactionCharacteristics(self):
            return self.getTypedRuleContext(MySQLParser.TransactionCharacteristicsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_startOptionValueListFollowingOptionType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartOptionValueListFollowingOptionType" ):
                listener.enterStartOptionValueListFollowingOptionType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartOptionValueListFollowingOptionType" ):
                listener.exitStartOptionValueListFollowingOptionType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartOptionValueListFollowingOptionType" ):
                return visitor.visitStartOptionValueListFollowingOptionType(self)
            else:
                return visitor.visitChildren(self)




    def startOptionValueListFollowingOptionType(self):

        localctx = MySQLParser.StartOptionValueListFollowingOptionTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 732, self.RULE_startOptionValueListFollowingOptionType)
        try:
            self.state = 5603
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,642,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5598
                self.optionValueFollowingOptionType()
                self.state = 5599
                self.optionValueListContinued()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5601
                self.match(MySQLParser.TRANSACTION_SYMBOL)
                self.state = 5602
                self.transactionCharacteristics()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionValueFollowingOptionTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lvalueVariable(self):
            return self.getTypedRuleContext(MySQLParser.LvalueVariableContext,0)


        def equal(self):
            return self.getTypedRuleContext(MySQLParser.EqualContext,0)


        def setExprOrDefault(self):
            return self.getTypedRuleContext(MySQLParser.SetExprOrDefaultContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_optionValueFollowingOptionType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptionValueFollowingOptionType" ):
                listener.enterOptionValueFollowingOptionType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptionValueFollowingOptionType" ):
                listener.exitOptionValueFollowingOptionType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOptionValueFollowingOptionType" ):
                return visitor.visitOptionValueFollowingOptionType(self)
            else:
                return visitor.visitChildren(self)




    def optionValueFollowingOptionType(self):

        localctx = MySQLParser.OptionValueFollowingOptionTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 734, self.RULE_optionValueFollowingOptionType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5605
            self.lvalueVariable()
            self.state = 5606
            self.equal()
            self.state = 5607
            self.setExprOrDefault()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetExprOrDefaultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def ON_SYMBOL(self):
            return self.getToken(MySQLParser.ON_SYMBOL, 0)

        def ALL_SYMBOL(self):
            return self.getToken(MySQLParser.ALL_SYMBOL, 0)

        def BINARY_SYMBOL(self):
            return self.getToken(MySQLParser.BINARY_SYMBOL, 0)

        def ROW_SYMBOL(self):
            return self.getToken(MySQLParser.ROW_SYMBOL, 0)

        def SYSTEM_SYMBOL(self):
            return self.getToken(MySQLParser.SYSTEM_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_setExprOrDefault

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetExprOrDefault" ):
                listener.enterSetExprOrDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetExprOrDefault" ):
                listener.exitSetExprOrDefault(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetExprOrDefault" ):
                return visitor.visitSetExprOrDefault(self)
            else:
                return visitor.visitChildren(self)




    def setExprOrDefault(self):

        localctx = MySQLParser.SetExprOrDefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 736, self.RULE_setExprOrDefault)
        try:
            self.state = 5616
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,643,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5609
                self.expr(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5610
                self.match(MySQLParser.DEFAULT_SYMBOL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 5611
                self.match(MySQLParser.ON_SYMBOL)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 5612
                self.match(MySQLParser.ALL_SYMBOL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 5613
                self.match(MySQLParser.BINARY_SYMBOL)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 5614
                self.match(MySQLParser.ROW_SYMBOL)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 5615
                self.match(MySQLParser.SYSTEM_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowDatabasesStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def DATABASES_SYMBOL(self):
            return self.getToken(MySQLParser.DATABASES_SYMBOL, 0)

        def likeOrWhere(self):
            return self.getTypedRuleContext(MySQLParser.LikeOrWhereContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showDatabasesStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowDatabasesStatement" ):
                listener.enterShowDatabasesStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowDatabasesStatement" ):
                listener.exitShowDatabasesStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowDatabasesStatement" ):
                return visitor.visitShowDatabasesStatement(self)
            else:
                return visitor.visitChildren(self)




    def showDatabasesStatement(self):

        localctx = MySQLParser.ShowDatabasesStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 738, self.RULE_showDatabasesStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5618
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5619
            self.match(MySQLParser.DATABASES_SYMBOL)
            self.state = 5621
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==305 or _la==651:
                self.state = 5620
                self.likeOrWhere()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowTablesStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.value = None # Token

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def TABLES_SYMBOL(self):
            return self.getToken(MySQLParser.TABLES_SYMBOL, 0)

        def showCommandType(self):
            return self.getTypedRuleContext(MySQLParser.ShowCommandTypeContext,0)


        def inDb(self):
            return self.getTypedRuleContext(MySQLParser.InDbContext,0)


        def likeOrWhere(self):
            return self.getTypedRuleContext(MySQLParser.LikeOrWhereContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showTablesStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowTablesStatement" ):
                listener.enterShowTablesStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowTablesStatement" ):
                listener.exitShowTablesStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowTablesStatement" ):
                return visitor.visitShowTablesStatement(self)
            else:
                return visitor.visitChildren(self)




    def showTablesStatement(self):

        localctx = MySQLParser.ShowTablesStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 740, self.RULE_showTablesStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5623
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5625
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==215 or _la==236:
                self.state = 5624
                self.showCommandType()


            self.state = 5627
            localctx.value = self.match(MySQLParser.TABLES_SYMBOL)
            self.state = 5629
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==235 or _la==282:
                self.state = 5628
                self.inDb()


            self.state = 5632
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==305 or _la==651:
                self.state = 5631
                self.likeOrWhere()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowTriggersStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def TRIGGERS_SYMBOL(self):
            return self.getToken(MySQLParser.TRIGGERS_SYMBOL, 0)

        def FULL_SYMBOL(self):
            return self.getToken(MySQLParser.FULL_SYMBOL, 0)

        def inDb(self):
            return self.getTypedRuleContext(MySQLParser.InDbContext,0)


        def likeOrWhere(self):
            return self.getTypedRuleContext(MySQLParser.LikeOrWhereContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showTriggersStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowTriggersStatement" ):
                listener.enterShowTriggersStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowTriggersStatement" ):
                listener.exitShowTriggersStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowTriggersStatement" ):
                return visitor.visitShowTriggersStatement(self)
            else:
                return visitor.visitChildren(self)




    def showTriggersStatement(self):

        localctx = MySQLParser.ShowTriggersStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 742, self.RULE_showTriggersStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5634
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5636
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==236:
                self.state = 5635
                self.match(MySQLParser.FULL_SYMBOL)


            self.state = 5638
            self.match(MySQLParser.TRIGGERS_SYMBOL)
            self.state = 5640
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==235 or _la==282:
                self.state = 5639
                self.inDb()


            self.state = 5643
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==305 or _la==651:
                self.state = 5642
                self.likeOrWhere()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowEventsStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def EVENTS_SYMBOL(self):
            return self.getToken(MySQLParser.EVENTS_SYMBOL, 0)

        def inDb(self):
            return self.getTypedRuleContext(MySQLParser.InDbContext,0)


        def likeOrWhere(self):
            return self.getTypedRuleContext(MySQLParser.LikeOrWhereContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showEventsStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowEventsStatement" ):
                listener.enterShowEventsStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowEventsStatement" ):
                listener.exitShowEventsStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowEventsStatement" ):
                return visitor.visitShowEventsStatement(self)
            else:
                return visitor.visitChildren(self)




    def showEventsStatement(self):

        localctx = MySQLParser.ShowEventsStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 744, self.RULE_showEventsStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5645
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5646
            self.match(MySQLParser.EVENTS_SYMBOL)
            self.state = 5648
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==235 or _la==282:
                self.state = 5647
                self.inDb()


            self.state = 5651
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==305 or _la==651:
                self.state = 5650
                self.likeOrWhere()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowTableStatusStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_SYMBOL, 0)

        def STATUS_SYMBOL(self):
            return self.getToken(MySQLParser.STATUS_SYMBOL, 0)

        def inDb(self):
            return self.getTypedRuleContext(MySQLParser.InDbContext,0)


        def likeOrWhere(self):
            return self.getTypedRuleContext(MySQLParser.LikeOrWhereContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showTableStatusStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowTableStatusStatement" ):
                listener.enterShowTableStatusStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowTableStatusStatement" ):
                listener.exitShowTableStatusStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowTableStatusStatement" ):
                return visitor.visitShowTableStatusStatement(self)
            else:
                return visitor.visitChildren(self)




    def showTableStatusStatement(self):

        localctx = MySQLParser.ShowTableStatusStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 746, self.RULE_showTableStatusStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5653
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5654
            self.match(MySQLParser.TABLE_SYMBOL)
            self.state = 5655
            self.match(MySQLParser.STATUS_SYMBOL)
            self.state = 5657
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==235 or _la==282:
                self.state = 5656
                self.inDb()


            self.state = 5660
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==305 or _la==651:
                self.state = 5659
                self.likeOrWhere()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowOpenTablesStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def OPEN_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_SYMBOL, 0)

        def TABLES_SYMBOL(self):
            return self.getToken(MySQLParser.TABLES_SYMBOL, 0)

        def inDb(self):
            return self.getTypedRuleContext(MySQLParser.InDbContext,0)


        def likeOrWhere(self):
            return self.getTypedRuleContext(MySQLParser.LikeOrWhereContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showOpenTablesStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowOpenTablesStatement" ):
                listener.enterShowOpenTablesStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowOpenTablesStatement" ):
                listener.exitShowOpenTablesStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowOpenTablesStatement" ):
                return visitor.visitShowOpenTablesStatement(self)
            else:
                return visitor.visitChildren(self)




    def showOpenTablesStatement(self):

        localctx = MySQLParser.ShowOpenTablesStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 748, self.RULE_showOpenTablesStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5662
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5663
            self.match(MySQLParser.OPEN_SYMBOL)
            self.state = 5664
            self.match(MySQLParser.TABLES_SYMBOL)
            self.state = 5666
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==235 or _la==282:
                self.state = 5665
                self.inDb()


            self.state = 5669
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==305 or _la==651:
                self.state = 5668
                self.likeOrWhere()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowParseTreeStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def PARSE_TREE_SYMBOL(self):
            return self.getToken(MySQLParser.PARSE_TREE_SYMBOL, 0)

        def simpleStatement(self):
            return self.getTypedRuleContext(MySQLParser.SimpleStatementContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showParseTreeStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowParseTreeStatement" ):
                listener.enterShowParseTreeStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowParseTreeStatement" ):
                listener.exitShowParseTreeStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowParseTreeStatement" ):
                return visitor.visitShowParseTreeStatement(self)
            else:
                return visitor.visitChildren(self)




    def showParseTreeStatement(self):

        localctx = MySQLParser.ShowParseTreeStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 750, self.RULE_showParseTreeStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5671
            if not self.isServerVersionGe80100():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.isServerVersionGe80100()")
            self.state = 5672
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5673
            self.match(MySQLParser.PARSE_TREE_SYMBOL)
            self.state = 5674
            self.simpleStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowPluginsStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def PLUGINS_SYMBOL(self):
            return self.getToken(MySQLParser.PLUGINS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_showPluginsStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowPluginsStatement" ):
                listener.enterShowPluginsStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowPluginsStatement" ):
                listener.exitShowPluginsStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowPluginsStatement" ):
                return visitor.visitShowPluginsStatement(self)
            else:
                return visitor.visitChildren(self)




    def showPluginsStatement(self):

        localctx = MySQLParser.ShowPluginsStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 752, self.RULE_showPluginsStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5676
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5677
            self.match(MySQLParser.PLUGINS_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowEngineLogsStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def ENGINE_SYMBOL(self):
            return self.getToken(MySQLParser.ENGINE_SYMBOL, 0)

        def engineOrAll(self):
            return self.getTypedRuleContext(MySQLParser.EngineOrAllContext,0)


        def LOGS_SYMBOL(self):
            return self.getToken(MySQLParser.LOGS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_showEngineLogsStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowEngineLogsStatement" ):
                listener.enterShowEngineLogsStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowEngineLogsStatement" ):
                listener.exitShowEngineLogsStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowEngineLogsStatement" ):
                return visitor.visitShowEngineLogsStatement(self)
            else:
                return visitor.visitChildren(self)




    def showEngineLogsStatement(self):

        localctx = MySQLParser.ShowEngineLogsStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 754, self.RULE_showEngineLogsStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5679
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5680
            self.match(MySQLParser.ENGINE_SYMBOL)
            self.state = 5681
            self.engineOrAll()
            self.state = 5682
            self.match(MySQLParser.LOGS_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowEngineMutexStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def ENGINE_SYMBOL(self):
            return self.getToken(MySQLParser.ENGINE_SYMBOL, 0)

        def engineOrAll(self):
            return self.getTypedRuleContext(MySQLParser.EngineOrAllContext,0)


        def MUTEX_SYMBOL(self):
            return self.getToken(MySQLParser.MUTEX_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_showEngineMutexStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowEngineMutexStatement" ):
                listener.enterShowEngineMutexStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowEngineMutexStatement" ):
                listener.exitShowEngineMutexStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowEngineMutexStatement" ):
                return visitor.visitShowEngineMutexStatement(self)
            else:
                return visitor.visitChildren(self)




    def showEngineMutexStatement(self):

        localctx = MySQLParser.ShowEngineMutexStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 756, self.RULE_showEngineMutexStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5684
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5685
            self.match(MySQLParser.ENGINE_SYMBOL)
            self.state = 5686
            self.engineOrAll()
            self.state = 5687
            self.match(MySQLParser.MUTEX_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowEngineStatusStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def ENGINE_SYMBOL(self):
            return self.getToken(MySQLParser.ENGINE_SYMBOL, 0)

        def engineOrAll(self):
            return self.getTypedRuleContext(MySQLParser.EngineOrAllContext,0)


        def STATUS_SYMBOL(self):
            return self.getToken(MySQLParser.STATUS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_showEngineStatusStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowEngineStatusStatement" ):
                listener.enterShowEngineStatusStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowEngineStatusStatement" ):
                listener.exitShowEngineStatusStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowEngineStatusStatement" ):
                return visitor.visitShowEngineStatusStatement(self)
            else:
                return visitor.visitChildren(self)




    def showEngineStatusStatement(self):

        localctx = MySQLParser.ShowEngineStatusStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 758, self.RULE_showEngineStatusStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5689
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5690
            self.match(MySQLParser.ENGINE_SYMBOL)
            self.state = 5691
            self.engineOrAll()
            self.state = 5692
            self.match(MySQLParser.STATUS_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowColumnsStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def COLUMNS_SYMBOL(self):
            return self.getToken(MySQLParser.COLUMNS_SYMBOL, 0)

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def FROM_SYMBOL(self):
            return self.getToken(MySQLParser.FROM_SYMBOL, 0)

        def IN_SYMBOL(self):
            return self.getToken(MySQLParser.IN_SYMBOL, 0)

        def showCommandType(self):
            return self.getTypedRuleContext(MySQLParser.ShowCommandTypeContext,0)


        def inDb(self):
            return self.getTypedRuleContext(MySQLParser.InDbContext,0)


        def likeOrWhere(self):
            return self.getTypedRuleContext(MySQLParser.LikeOrWhereContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showColumnsStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowColumnsStatement" ):
                listener.enterShowColumnsStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowColumnsStatement" ):
                listener.exitShowColumnsStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowColumnsStatement" ):
                return visitor.visitShowColumnsStatement(self)
            else:
                return visitor.visitChildren(self)




    def showColumnsStatement(self):

        localctx = MySQLParser.ShowColumnsStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 760, self.RULE_showColumnsStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5694
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5696
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==215 or _la==236:
                self.state = 5695
                self.showCommandType()


            self.state = 5698
            self.match(MySQLParser.COLUMNS_SYMBOL)
            self.state = 5699
            _la = self._input.LA(1)
            if not(_la==235 or _la==282):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 5700
            self.tableRef()
            self.state = 5702
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==235 or _la==282:
                self.state = 5701
                self.inDb()


            self.state = 5705
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==305 or _la==651:
                self.state = 5704
                self.likeOrWhere()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowBinaryLogsStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.value = None # Token

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def BINARY_SYMBOL(self):
            return self.getToken(MySQLParser.BINARY_SYMBOL, 0)

        def MASTER_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SYMBOL, 0)

        def LOGS_SYMBOL(self):
            return self.getToken(MySQLParser.LOGS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_showBinaryLogsStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowBinaryLogsStatement" ):
                listener.enterShowBinaryLogsStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowBinaryLogsStatement" ):
                listener.exitShowBinaryLogsStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowBinaryLogsStatement" ):
                return visitor.visitShowBinaryLogsStatement(self)
            else:
                return visitor.visitChildren(self)




    def showBinaryLogsStatement(self):

        localctx = MySQLParser.ShowBinaryLogsStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 762, self.RULE_showBinaryLogsStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5707
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5708
            _la = self._input.LA(1)
            if not(_la==77 or _la==341):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 5709
            localctx.value = self.match(MySQLParser.LOGS_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowBinaryLogStatusStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def BINARY_SYMBOL(self):
            return self.getToken(MySQLParser.BINARY_SYMBOL, 0)

        def LOG_SYMBOL(self):
            return self.getToken(MySQLParser.LOG_SYMBOL, 0)

        def STATUS_SYMBOL(self):
            return self.getToken(MySQLParser.STATUS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_showBinaryLogStatusStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowBinaryLogStatusStatement" ):
                listener.enterShowBinaryLogStatusStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowBinaryLogStatusStatement" ):
                listener.exitShowBinaryLogStatusStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowBinaryLogStatusStatement" ):
                return visitor.visitShowBinaryLogStatusStatement(self)
            else:
                return visitor.visitChildren(self)




    def showBinaryLogStatusStatement(self):

        localctx = MySQLParser.ShowBinaryLogStatusStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 764, self.RULE_showBinaryLogStatusStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5711
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5712
            self.match(MySQLParser.BINARY_SYMBOL)
            self.state = 5713
            self.match(MySQLParser.LOG_SYMBOL)
            self.state = 5714
            self.match(MySQLParser.STATUS_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowReplicasStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def replica(self):
            return self.getTypedRuleContext(MySQLParser.ReplicaContext,0)


        def HOSTS_SYMBOL(self):
            return self.getToken(MySQLParser.HOSTS_SYMBOL, 0)

        def REPLICAS_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICAS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_showReplicasStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowReplicasStatement" ):
                listener.enterShowReplicasStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowReplicasStatement" ):
                listener.exitShowReplicasStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowReplicasStatement" ):
                return visitor.visitShowReplicasStatement(self)
            else:
                return visitor.visitChildren(self)




    def showReplicasStatement(self):

        localctx = MySQLParser.ShowReplicasStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 766, self.RULE_showReplicasStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5716
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5721
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [526, 762]:
                self.state = 5717
                self.replica()
                self.state = 5718
                self.match(MySQLParser.HOSTS_SYMBOL)
                pass
            elif token in [763]:
                self.state = 5720
                self.match(MySQLParser.REPLICAS_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowBinlogEventsStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def BINLOG_SYMBOL(self):
            return self.getToken(MySQLParser.BINLOG_SYMBOL, 0)

        def EVENTS_SYMBOL(self):
            return self.getToken(MySQLParser.EVENTS_SYMBOL, 0)

        def IN_SYMBOL(self):
            return self.getToken(MySQLParser.IN_SYMBOL, 0)

        def textString(self):
            return self.getTypedRuleContext(MySQLParser.TextStringContext,0)


        def FROM_SYMBOL(self):
            return self.getToken(MySQLParser.FROM_SYMBOL, 0)

        def ulonglongNumber(self):
            return self.getTypedRuleContext(MySQLParser.UlonglongNumberContext,0)


        def limitClause(self):
            return self.getTypedRuleContext(MySQLParser.LimitClauseContext,0)


        def channel(self):
            return self.getTypedRuleContext(MySQLParser.ChannelContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showBinlogEventsStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowBinlogEventsStatement" ):
                listener.enterShowBinlogEventsStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowBinlogEventsStatement" ):
                listener.exitShowBinlogEventsStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowBinlogEventsStatement" ):
                return visitor.visitShowBinlogEventsStatement(self)
            else:
                return visitor.visitChildren(self)




    def showBinlogEventsStatement(self):

        localctx = MySQLParser.ShowBinlogEventsStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 768, self.RULE_showBinlogEventsStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5723
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5724
            self.match(MySQLParser.BINLOG_SYMBOL)
            self.state = 5725
            self.match(MySQLParser.EVENTS_SYMBOL)
            self.state = 5728
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==282:
                self.state = 5726
                self.match(MySQLParser.IN_SYMBOL)
                self.state = 5727
                self.textString()


            self.state = 5732
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==235:
                self.state = 5730
                self.match(MySQLParser.FROM_SYMBOL)
                self.state = 5731
                self.ulonglongNumber()


            self.state = 5735
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==306:
                self.state = 5734
                self.limitClause()


            self.state = 5738
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==232:
                self.state = 5737
                self.channel()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowRelaylogEventsStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def RELAYLOG_SYMBOL(self):
            return self.getToken(MySQLParser.RELAYLOG_SYMBOL, 0)

        def EVENTS_SYMBOL(self):
            return self.getToken(MySQLParser.EVENTS_SYMBOL, 0)

        def IN_SYMBOL(self):
            return self.getToken(MySQLParser.IN_SYMBOL, 0)

        def textString(self):
            return self.getTypedRuleContext(MySQLParser.TextStringContext,0)


        def FROM_SYMBOL(self):
            return self.getToken(MySQLParser.FROM_SYMBOL, 0)

        def ulonglongNumber(self):
            return self.getTypedRuleContext(MySQLParser.UlonglongNumberContext,0)


        def limitClause(self):
            return self.getTypedRuleContext(MySQLParser.LimitClauseContext,0)


        def channel(self):
            return self.getTypedRuleContext(MySQLParser.ChannelContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showRelaylogEventsStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowRelaylogEventsStatement" ):
                listener.enterShowRelaylogEventsStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowRelaylogEventsStatement" ):
                listener.exitShowRelaylogEventsStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowRelaylogEventsStatement" ):
                return visitor.visitShowRelaylogEventsStatement(self)
            else:
                return visitor.visitChildren(self)




    def showRelaylogEventsStatement(self):

        localctx = MySQLParser.ShowRelaylogEventsStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 770, self.RULE_showRelaylogEventsStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5740
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5741
            self.match(MySQLParser.RELAYLOG_SYMBOL)
            self.state = 5742
            self.match(MySQLParser.EVENTS_SYMBOL)
            self.state = 5745
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==282:
                self.state = 5743
                self.match(MySQLParser.IN_SYMBOL)
                self.state = 5744
                self.textString()


            self.state = 5749
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==235:
                self.state = 5747
                self.match(MySQLParser.FROM_SYMBOL)
                self.state = 5748
                self.ulonglongNumber()


            self.state = 5752
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==306:
                self.state = 5751
                self.limitClause()


            self.state = 5755
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==232:
                self.state = 5754
                self.channel()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowKeysStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def fromOrIn(self):
            return self.getTypedRuleContext(MySQLParser.FromOrInContext,0)


        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def INDEX_SYMBOL(self):
            return self.getToken(MySQLParser.INDEX_SYMBOL, 0)

        def INDEXES_SYMBOL(self):
            return self.getToken(MySQLParser.INDEXES_SYMBOL, 0)

        def KEYS_SYMBOL(self):
            return self.getToken(MySQLParser.KEYS_SYMBOL, 0)

        def EXTENDED_SYMBOL(self):
            return self.getToken(MySQLParser.EXTENDED_SYMBOL, 0)

        def inDb(self):
            return self.getTypedRuleContext(MySQLParser.InDbContext,0)


        def whereClause(self):
            return self.getTypedRuleContext(MySQLParser.WhereClauseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showKeysStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowKeysStatement" ):
                listener.enterShowKeysStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowKeysStatement" ):
                listener.exitShowKeysStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowKeysStatement" ):
                return visitor.visitShowKeysStatement(self)
            else:
                return visitor.visitChildren(self)




    def showKeysStatement(self):

        localctx = MySQLParser.ShowKeysStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 772, self.RULE_showKeysStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5757
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5759
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==215:
                self.state = 5758
                self.match(MySQLParser.EXTENDED_SYMBOL)


            self.state = 5761
            _la = self._input.LA(1)
            if not(((((_la - 267)) & ~0x3f) == 0 and ((1 << (_la - 267)) & 67108867) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 5762
            self.fromOrIn()
            self.state = 5763
            self.tableRef()
            self.state = 5765
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==235 or _la==282:
                self.state = 5764
                self.inDb()


            self.state = 5768
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==651:
                self.state = 5767
                self.whereClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowEnginesStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.value = None # Token

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def ENGINES_SYMBOL(self):
            return self.getToken(MySQLParser.ENGINES_SYMBOL, 0)

        def STORAGE_SYMBOL(self):
            return self.getToken(MySQLParser.STORAGE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_showEnginesStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowEnginesStatement" ):
                listener.enterShowEnginesStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowEnginesStatement" ):
                listener.exitShowEnginesStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowEnginesStatement" ):
                return visitor.visitShowEnginesStatement(self)
            else:
                return visitor.visitChildren(self)




    def showEnginesStatement(self):

        localctx = MySQLParser.ShowEnginesStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 774, self.RULE_showEnginesStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5770
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5772
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==563:
                self.state = 5771
                self.match(MySQLParser.STORAGE_SYMBOL)


            self.state = 5774
            localctx.value = self.match(MySQLParser.ENGINES_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowCountWarningsStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def COUNT_SYMBOL(self):
            return self.getToken(MySQLParser.COUNT_SYMBOL, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def MULT_OPERATOR(self):
            return self.getToken(MySQLParser.MULT_OPERATOR, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def WARNINGS_SYMBOL(self):
            return self.getToken(MySQLParser.WARNINGS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_showCountWarningsStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowCountWarningsStatement" ):
                listener.enterShowCountWarningsStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowCountWarningsStatement" ):
                listener.exitShowCountWarningsStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowCountWarningsStatement" ):
                return visitor.visitShowCountWarningsStatement(self)
            else:
                return visitor.visitChildren(self)




    def showCountWarningsStatement(self):

        localctx = MySQLParser.ShowCountWarningsStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 776, self.RULE_showCountWarningsStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5776
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5777
            self.match(MySQLParser.COUNT_SYMBOL)
            self.state = 5778
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 5779
            self.match(MySQLParser.MULT_OPERATOR)
            self.state = 5780
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
            self.state = 5781
            self.match(MySQLParser.WARNINGS_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowCountErrorsStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def COUNT_SYMBOL(self):
            return self.getToken(MySQLParser.COUNT_SYMBOL, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def MULT_OPERATOR(self):
            return self.getToken(MySQLParser.MULT_OPERATOR, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def ERRORS_SYMBOL(self):
            return self.getToken(MySQLParser.ERRORS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_showCountErrorsStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowCountErrorsStatement" ):
                listener.enterShowCountErrorsStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowCountErrorsStatement" ):
                listener.exitShowCountErrorsStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowCountErrorsStatement" ):
                return visitor.visitShowCountErrorsStatement(self)
            else:
                return visitor.visitChildren(self)




    def showCountErrorsStatement(self):

        localctx = MySQLParser.ShowCountErrorsStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 778, self.RULE_showCountErrorsStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5783
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5784
            self.match(MySQLParser.COUNT_SYMBOL)
            self.state = 5785
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 5786
            self.match(MySQLParser.MULT_OPERATOR)
            self.state = 5787
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
            self.state = 5788
            self.match(MySQLParser.ERRORS_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowWarningsStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def WARNINGS_SYMBOL(self):
            return self.getToken(MySQLParser.WARNINGS_SYMBOL, 0)

        def limitClause(self):
            return self.getTypedRuleContext(MySQLParser.LimitClauseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showWarningsStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowWarningsStatement" ):
                listener.enterShowWarningsStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowWarningsStatement" ):
                listener.exitShowWarningsStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowWarningsStatement" ):
                return visitor.visitShowWarningsStatement(self)
            else:
                return visitor.visitChildren(self)




    def showWarningsStatement(self):

        localctx = MySQLParser.ShowWarningsStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 780, self.RULE_showWarningsStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5790
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5791
            self.match(MySQLParser.WARNINGS_SYMBOL)
            self.state = 5793
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==306:
                self.state = 5792
                self.limitClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowErrorsStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def ERRORS_SYMBOL(self):
            return self.getToken(MySQLParser.ERRORS_SYMBOL, 0)

        def limitClause(self):
            return self.getTypedRuleContext(MySQLParser.LimitClauseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showErrorsStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowErrorsStatement" ):
                listener.enterShowErrorsStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowErrorsStatement" ):
                listener.exitShowErrorsStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowErrorsStatement" ):
                return visitor.visitShowErrorsStatement(self)
            else:
                return visitor.visitChildren(self)




    def showErrorsStatement(self):

        localctx = MySQLParser.ShowErrorsStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 782, self.RULE_showErrorsStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5795
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5796
            self.match(MySQLParser.ERRORS_SYMBOL)
            self.state = 5798
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==306:
                self.state = 5797
                self.limitClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowProfilesStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def PROFILES_SYMBOL(self):
            return self.getToken(MySQLParser.PROFILES_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_showProfilesStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowProfilesStatement" ):
                listener.enterShowProfilesStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowProfilesStatement" ):
                listener.exitShowProfilesStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowProfilesStatement" ):
                return visitor.visitShowProfilesStatement(self)
            else:
                return visitor.visitChildren(self)




    def showProfilesStatement(self):

        localctx = MySQLParser.ShowProfilesStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 784, self.RULE_showProfilesStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5800
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5801
            self.match(MySQLParser.PROFILES_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowProfileStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def PROFILE_SYMBOL(self):
            return self.getToken(MySQLParser.PROFILE_SYMBOL, 0)

        def profileDefinitions(self):
            return self.getTypedRuleContext(MySQLParser.ProfileDefinitionsContext,0)


        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def QUERY_SYMBOL(self):
            return self.getToken(MySQLParser.QUERY_SYMBOL, 0)

        def INT_NUMBER(self):
            return self.getToken(MySQLParser.INT_NUMBER, 0)

        def limitClause(self):
            return self.getTypedRuleContext(MySQLParser.LimitClauseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showProfileStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowProfileStatement" ):
                listener.enterShowProfileStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowProfileStatement" ):
                listener.exitShowProfileStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowProfileStatement" ):
                return visitor.visitShowProfileStatement(self)
            else:
                return visitor.visitChildren(self)




    def showProfileStatement(self):

        localctx = MySQLParser.ShowProfileStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 786, self.RULE_showProfileStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5803
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5804
            self.match(MySQLParser.PROFILE_SYMBOL)
            self.state = 5806
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==57 or ((((_la - 84)) & ~0x3f) == 0 and ((1 << (_la - 84)) & 19140298416324609) != 0) or _la==286 or _la==358 or _la==418 or _la==533 or _la==577:
                self.state = 5805
                self.profileDefinitions()


            self.state = 5811
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==232:
                self.state = 5808
                self.match(MySQLParser.FOR_SYMBOL)
                self.state = 5809
                self.match(MySQLParser.QUERY_SYMBOL)
                self.state = 5810
                self.match(MySQLParser.INT_NUMBER)


            self.state = 5814
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==306:
                self.state = 5813
                self.limitClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowStatusStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def STATUS_SYMBOL(self):
            return self.getToken(MySQLParser.STATUS_SYMBOL, 0)

        def optionType(self):
            return self.getTypedRuleContext(MySQLParser.OptionTypeContext,0)


        def likeOrWhere(self):
            return self.getTypedRuleContext(MySQLParser.LikeOrWhereContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showStatusStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowStatusStatement" ):
                listener.enterShowStatusStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowStatusStatement" ):
                listener.exitShowStatusStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowStatusStatement" ):
                return visitor.visitShowStatusStatement(self)
            else:
                return visitor.visitChildren(self)




    def showStatusStatement(self):

        localctx = MySQLParser.ShowStatusStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 788, self.RULE_showStatusStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5816
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5818
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==246 or _la==312 or _la==516 or _la==666 or _la==681:
                self.state = 5817
                self.optionType()


            self.state = 5820
            self.match(MySQLParser.STATUS_SYMBOL)
            self.state = 5822
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==305 or _la==651:
                self.state = 5821
                self.likeOrWhere()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowProcessListStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def PROCESSLIST_SYMBOL(self):
            return self.getToken(MySQLParser.PROCESSLIST_SYMBOL, 0)

        def FULL_SYMBOL(self):
            return self.getToken(MySQLParser.FULL_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_showProcessListStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowProcessListStatement" ):
                listener.enterShowProcessListStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowProcessListStatement" ):
                listener.exitShowProcessListStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowProcessListStatement" ):
                return visitor.visitShowProcessListStatement(self)
            else:
                return visitor.visitChildren(self)




    def showProcessListStatement(self):

        localctx = MySQLParser.ShowProcessListStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 790, self.RULE_showProcessListStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5824
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5826
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==236:
                self.state = 5825
                self.match(MySQLParser.FULL_SYMBOL)


            self.state = 5828
            self.match(MySQLParser.PROCESSLIST_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowVariablesStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def VARIABLES_SYMBOL(self):
            return self.getToken(MySQLParser.VARIABLES_SYMBOL, 0)

        def optionType(self):
            return self.getTypedRuleContext(MySQLParser.OptionTypeContext,0)


        def likeOrWhere(self):
            return self.getTypedRuleContext(MySQLParser.LikeOrWhereContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showVariablesStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowVariablesStatement" ):
                listener.enterShowVariablesStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowVariablesStatement" ):
                listener.exitShowVariablesStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowVariablesStatement" ):
                return visitor.visitShowVariablesStatement(self)
            else:
                return visitor.visitChildren(self)




    def showVariablesStatement(self):

        localctx = MySQLParser.ShowVariablesStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 792, self.RULE_showVariablesStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5830
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5832
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==246 or _la==312 or _la==516 or _la==666 or _la==681:
                self.state = 5831
                self.optionType()


            self.state = 5834
            self.match(MySQLParser.VARIABLES_SYMBOL)
            self.state = 5836
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==305 or _la==651:
                self.state = 5835
                self.likeOrWhere()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowCharacterSetStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def charset(self):
            return self.getTypedRuleContext(MySQLParser.CharsetContext,0)


        def likeOrWhere(self):
            return self.getTypedRuleContext(MySQLParser.LikeOrWhereContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showCharacterSetStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowCharacterSetStatement" ):
                listener.enterShowCharacterSetStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowCharacterSetStatement" ):
                listener.exitShowCharacterSetStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowCharacterSetStatement" ):
                return visitor.visitShowCharacterSetStatement(self)
            else:
                return visitor.visitChildren(self)




    def showCharacterSetStatement(self):

        localctx = MySQLParser.ShowCharacterSetStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 794, self.RULE_showCharacterSetStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5838
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5839
            self.charset()
            self.state = 5841
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==305 or _la==651:
                self.state = 5840
                self.likeOrWhere()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowCollationStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def COLLATION_SYMBOL(self):
            return self.getToken(MySQLParser.COLLATION_SYMBOL, 0)

        def likeOrWhere(self):
            return self.getTypedRuleContext(MySQLParser.LikeOrWhereContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showCollationStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowCollationStatement" ):
                listener.enterShowCollationStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowCollationStatement" ):
                listener.exitShowCollationStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowCollationStatement" ):
                return visitor.visitShowCollationStatement(self)
            else:
                return visitor.visitChildren(self)




    def showCollationStatement(self):

        localctx = MySQLParser.ShowCollationStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 796, self.RULE_showCollationStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5843
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5844
            self.match(MySQLParser.COLLATION_SYMBOL)
            self.state = 5846
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==305 or _la==651:
                self.state = 5845
                self.likeOrWhere()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowPrivilegesStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def PRIVILEGES_SYMBOL(self):
            return self.getToken(MySQLParser.PRIVILEGES_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_showPrivilegesStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowPrivilegesStatement" ):
                listener.enterShowPrivilegesStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowPrivilegesStatement" ):
                listener.exitShowPrivilegesStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowPrivilegesStatement" ):
                return visitor.visitShowPrivilegesStatement(self)
            else:
                return visitor.visitChildren(self)




    def showPrivilegesStatement(self):

        localctx = MySQLParser.ShowPrivilegesStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 798, self.RULE_showPrivilegesStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5848
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5849
            self.match(MySQLParser.PRIVILEGES_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowGrantsStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def GRANTS_SYMBOL(self):
            return self.getToken(MySQLParser.GRANTS_SYMBOL, 0)

        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def user(self):
            return self.getTypedRuleContext(MySQLParser.UserContext,0)


        def USING_SYMBOL(self):
            return self.getToken(MySQLParser.USING_SYMBOL, 0)

        def userList(self):
            return self.getTypedRuleContext(MySQLParser.UserListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showGrantsStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowGrantsStatement" ):
                listener.enterShowGrantsStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowGrantsStatement" ):
                listener.exitShowGrantsStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowGrantsStatement" ):
                return visitor.visitShowGrantsStatement(self)
            else:
                return visitor.visitChildren(self)




    def showGrantsStatement(self):

        localctx = MySQLParser.ShowGrantsStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 800, self.RULE_showGrantsStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5851
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5852
            self.match(MySQLParser.GRANTS_SYMBOL)
            self.state = 5859
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==232:
                self.state = 5853
                self.match(MySQLParser.FOR_SYMBOL)
                self.state = 5854
                self.user()
                self.state = 5857
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==630:
                    self.state = 5855
                    self.match(MySQLParser.USING_SYMBOL)
                    self.state = 5856
                    self.userList()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowCreateDatabaseStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def CREATE_SYMBOL(self):
            return self.getToken(MySQLParser.CREATE_SYMBOL, 0)

        def DATABASE_SYMBOL(self):
            return self.getToken(MySQLParser.DATABASE_SYMBOL, 0)

        def schemaRef(self):
            return self.getTypedRuleContext(MySQLParser.SchemaRefContext,0)


        def ifNotExists(self):
            return self.getTypedRuleContext(MySQLParser.IfNotExistsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showCreateDatabaseStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowCreateDatabaseStatement" ):
                listener.enterShowCreateDatabaseStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowCreateDatabaseStatement" ):
                listener.exitShowCreateDatabaseStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowCreateDatabaseStatement" ):
                return visitor.visitShowCreateDatabaseStatement(self)
            else:
                return visitor.visitChildren(self)




    def showCreateDatabaseStatement(self):

        localctx = MySQLParser.ShowCreateDatabaseStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 802, self.RULE_showCreateDatabaseStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5861
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5862
            self.match(MySQLParser.CREATE_SYMBOL)
            self.state = 5863
            self.match(MySQLParser.DATABASE_SYMBOL)
            self.state = 5865
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,687,self._ctx)
            if la_ == 1:
                self.state = 5864
                self.ifNotExists()


            self.state = 5867
            self.schemaRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowCreateTableStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def CREATE_SYMBOL(self):
            return self.getToken(MySQLParser.CREATE_SYMBOL, 0)

        def TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_SYMBOL, 0)

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showCreateTableStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowCreateTableStatement" ):
                listener.enterShowCreateTableStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowCreateTableStatement" ):
                listener.exitShowCreateTableStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowCreateTableStatement" ):
                return visitor.visitShowCreateTableStatement(self)
            else:
                return visitor.visitChildren(self)




    def showCreateTableStatement(self):

        localctx = MySQLParser.ShowCreateTableStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 804, self.RULE_showCreateTableStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5869
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5870
            self.match(MySQLParser.CREATE_SYMBOL)
            self.state = 5871
            self.match(MySQLParser.TABLE_SYMBOL)
            self.state = 5872
            self.tableRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowCreateViewStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def CREATE_SYMBOL(self):
            return self.getToken(MySQLParser.CREATE_SYMBOL, 0)

        def VIEW_SYMBOL(self):
            return self.getToken(MySQLParser.VIEW_SYMBOL, 0)

        def viewRef(self):
            return self.getTypedRuleContext(MySQLParser.ViewRefContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showCreateViewStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowCreateViewStatement" ):
                listener.enterShowCreateViewStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowCreateViewStatement" ):
                listener.exitShowCreateViewStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowCreateViewStatement" ):
                return visitor.visitShowCreateViewStatement(self)
            else:
                return visitor.visitChildren(self)




    def showCreateViewStatement(self):

        localctx = MySQLParser.ShowCreateViewStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 806, self.RULE_showCreateViewStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5874
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5875
            self.match(MySQLParser.CREATE_SYMBOL)
            self.state = 5876
            self.match(MySQLParser.VIEW_SYMBOL)
            self.state = 5877
            self.viewRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowMasterStatusStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def MASTER_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SYMBOL, 0)

        def STATUS_SYMBOL(self):
            return self.getToken(MySQLParser.STATUS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_showMasterStatusStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowMasterStatusStatement" ):
                listener.enterShowMasterStatusStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowMasterStatusStatement" ):
                listener.exitShowMasterStatusStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowMasterStatusStatement" ):
                return visitor.visitShowMasterStatusStatement(self)
            else:
                return visitor.visitChildren(self)




    def showMasterStatusStatement(self):

        localctx = MySQLParser.ShowMasterStatusStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 808, self.RULE_showMasterStatusStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5879
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5880
            self.match(MySQLParser.MASTER_SYMBOL)
            self.state = 5881
            self.match(MySQLParser.STATUS_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowReplicaStatusStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def replica(self):
            return self.getTypedRuleContext(MySQLParser.ReplicaContext,0)


        def STATUS_SYMBOL(self):
            return self.getToken(MySQLParser.STATUS_SYMBOL, 0)

        def channel(self):
            return self.getTypedRuleContext(MySQLParser.ChannelContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showReplicaStatusStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowReplicaStatusStatement" ):
                listener.enterShowReplicaStatusStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowReplicaStatusStatement" ):
                listener.exitShowReplicaStatusStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowReplicaStatusStatement" ):
                return visitor.visitShowReplicaStatusStatement(self)
            else:
                return visitor.visitChildren(self)




    def showReplicaStatusStatement(self):

        localctx = MySQLParser.ShowReplicaStatusStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 810, self.RULE_showReplicaStatusStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5883
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5884
            self.replica()
            self.state = 5885
            self.match(MySQLParser.STATUS_SYMBOL)
            self.state = 5887
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==232:
                self.state = 5886
                self.channel()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowCreateProcedureStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def CREATE_SYMBOL(self):
            return self.getToken(MySQLParser.CREATE_SYMBOL, 0)

        def PROCEDURE_SYMBOL(self):
            return self.getToken(MySQLParser.PROCEDURE_SYMBOL, 0)

        def procedureRef(self):
            return self.getTypedRuleContext(MySQLParser.ProcedureRefContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showCreateProcedureStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowCreateProcedureStatement" ):
                listener.enterShowCreateProcedureStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowCreateProcedureStatement" ):
                listener.exitShowCreateProcedureStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowCreateProcedureStatement" ):
                return visitor.visitShowCreateProcedureStatement(self)
            else:
                return visitor.visitChildren(self)




    def showCreateProcedureStatement(self):

        localctx = MySQLParser.ShowCreateProcedureStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 812, self.RULE_showCreateProcedureStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5889
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5890
            self.match(MySQLParser.CREATE_SYMBOL)
            self.state = 5891
            self.match(MySQLParser.PROCEDURE_SYMBOL)
            self.state = 5892
            self.procedureRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowCreateFunctionStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def CREATE_SYMBOL(self):
            return self.getToken(MySQLParser.CREATE_SYMBOL, 0)

        def FUNCTION_SYMBOL(self):
            return self.getToken(MySQLParser.FUNCTION_SYMBOL, 0)

        def functionRef(self):
            return self.getTypedRuleContext(MySQLParser.FunctionRefContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showCreateFunctionStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowCreateFunctionStatement" ):
                listener.enterShowCreateFunctionStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowCreateFunctionStatement" ):
                listener.exitShowCreateFunctionStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowCreateFunctionStatement" ):
                return visitor.visitShowCreateFunctionStatement(self)
            else:
                return visitor.visitChildren(self)




    def showCreateFunctionStatement(self):

        localctx = MySQLParser.ShowCreateFunctionStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 814, self.RULE_showCreateFunctionStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5894
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5895
            self.match(MySQLParser.CREATE_SYMBOL)
            self.state = 5896
            self.match(MySQLParser.FUNCTION_SYMBOL)
            self.state = 5897
            self.functionRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowCreateTriggerStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def CREATE_SYMBOL(self):
            return self.getToken(MySQLParser.CREATE_SYMBOL, 0)

        def TRIGGER_SYMBOL(self):
            return self.getToken(MySQLParser.TRIGGER_SYMBOL, 0)

        def triggerRef(self):
            return self.getTypedRuleContext(MySQLParser.TriggerRefContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showCreateTriggerStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowCreateTriggerStatement" ):
                listener.enterShowCreateTriggerStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowCreateTriggerStatement" ):
                listener.exitShowCreateTriggerStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowCreateTriggerStatement" ):
                return visitor.visitShowCreateTriggerStatement(self)
            else:
                return visitor.visitChildren(self)




    def showCreateTriggerStatement(self):

        localctx = MySQLParser.ShowCreateTriggerStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 816, self.RULE_showCreateTriggerStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5899
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5900
            self.match(MySQLParser.CREATE_SYMBOL)
            self.state = 5901
            self.match(MySQLParser.TRIGGER_SYMBOL)
            self.state = 5902
            self.triggerRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowCreateProcedureStatusStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def CREATE_SYMBOL(self):
            return self.getToken(MySQLParser.CREATE_SYMBOL, 0)

        def PROCEDURE_SYMBOL(self):
            return self.getToken(MySQLParser.PROCEDURE_SYMBOL, 0)

        def STATUS_SYMBOL(self):
            return self.getToken(MySQLParser.STATUS_SYMBOL, 0)

        def likeOrWhere(self):
            return self.getTypedRuleContext(MySQLParser.LikeOrWhereContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showCreateProcedureStatusStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowCreateProcedureStatusStatement" ):
                listener.enterShowCreateProcedureStatusStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowCreateProcedureStatusStatement" ):
                listener.exitShowCreateProcedureStatusStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowCreateProcedureStatusStatement" ):
                return visitor.visitShowCreateProcedureStatusStatement(self)
            else:
                return visitor.visitChildren(self)




    def showCreateProcedureStatusStatement(self):

        localctx = MySQLParser.ShowCreateProcedureStatusStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 818, self.RULE_showCreateProcedureStatusStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5904
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5905
            self.match(MySQLParser.CREATE_SYMBOL)
            self.state = 5906
            self.match(MySQLParser.PROCEDURE_SYMBOL)
            self.state = 5907
            self.match(MySQLParser.STATUS_SYMBOL)
            self.state = 5909
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==305 or _la==651:
                self.state = 5908
                self.likeOrWhere()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowCreateFunctionStatusStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def CREATE_SYMBOL(self):
            return self.getToken(MySQLParser.CREATE_SYMBOL, 0)

        def FUNCTION_SYMBOL(self):
            return self.getToken(MySQLParser.FUNCTION_SYMBOL, 0)

        def STATUS_SYMBOL(self):
            return self.getToken(MySQLParser.STATUS_SYMBOL, 0)

        def likeOrWhere(self):
            return self.getTypedRuleContext(MySQLParser.LikeOrWhereContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showCreateFunctionStatusStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowCreateFunctionStatusStatement" ):
                listener.enterShowCreateFunctionStatusStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowCreateFunctionStatusStatement" ):
                listener.exitShowCreateFunctionStatusStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowCreateFunctionStatusStatement" ):
                return visitor.visitShowCreateFunctionStatusStatement(self)
            else:
                return visitor.visitChildren(self)




    def showCreateFunctionStatusStatement(self):

        localctx = MySQLParser.ShowCreateFunctionStatusStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 820, self.RULE_showCreateFunctionStatusStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5911
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5912
            self.match(MySQLParser.CREATE_SYMBOL)
            self.state = 5913
            self.match(MySQLParser.FUNCTION_SYMBOL)
            self.state = 5914
            self.match(MySQLParser.STATUS_SYMBOL)
            self.state = 5916
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==305 or _la==651:
                self.state = 5915
                self.likeOrWhere()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowCreateProcedureCodeStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def CREATE_SYMBOL(self):
            return self.getToken(MySQLParser.CREATE_SYMBOL, 0)

        def PROCEDURE_SYMBOL(self):
            return self.getToken(MySQLParser.PROCEDURE_SYMBOL, 0)

        def CODE_SYMBOL(self):
            return self.getToken(MySQLParser.CODE_SYMBOL, 0)

        def procedureRef(self):
            return self.getTypedRuleContext(MySQLParser.ProcedureRefContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showCreateProcedureCodeStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowCreateProcedureCodeStatement" ):
                listener.enterShowCreateProcedureCodeStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowCreateProcedureCodeStatement" ):
                listener.exitShowCreateProcedureCodeStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowCreateProcedureCodeStatement" ):
                return visitor.visitShowCreateProcedureCodeStatement(self)
            else:
                return visitor.visitChildren(self)




    def showCreateProcedureCodeStatement(self):

        localctx = MySQLParser.ShowCreateProcedureCodeStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 822, self.RULE_showCreateProcedureCodeStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5918
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5919
            self.match(MySQLParser.CREATE_SYMBOL)
            self.state = 5920
            self.match(MySQLParser.PROCEDURE_SYMBOL)
            self.state = 5921
            self.match(MySQLParser.CODE_SYMBOL)
            self.state = 5922
            self.procedureRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowCreateFunctionCodeStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def CREATE_SYMBOL(self):
            return self.getToken(MySQLParser.CREATE_SYMBOL, 0)

        def FUNCTION_SYMBOL(self):
            return self.getToken(MySQLParser.FUNCTION_SYMBOL, 0)

        def CODE_SYMBOL(self):
            return self.getToken(MySQLParser.CODE_SYMBOL, 0)

        def functionRef(self):
            return self.getTypedRuleContext(MySQLParser.FunctionRefContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showCreateFunctionCodeStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowCreateFunctionCodeStatement" ):
                listener.enterShowCreateFunctionCodeStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowCreateFunctionCodeStatement" ):
                listener.exitShowCreateFunctionCodeStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowCreateFunctionCodeStatement" ):
                return visitor.visitShowCreateFunctionCodeStatement(self)
            else:
                return visitor.visitChildren(self)




    def showCreateFunctionCodeStatement(self):

        localctx = MySQLParser.ShowCreateFunctionCodeStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 824, self.RULE_showCreateFunctionCodeStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5924
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5925
            self.match(MySQLParser.CREATE_SYMBOL)
            self.state = 5926
            self.match(MySQLParser.FUNCTION_SYMBOL)
            self.state = 5927
            self.match(MySQLParser.CODE_SYMBOL)
            self.state = 5928
            self.functionRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowCreateEventStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def CREATE_SYMBOL(self):
            return self.getToken(MySQLParser.CREATE_SYMBOL, 0)

        def EVENT_SYMBOL(self):
            return self.getToken(MySQLParser.EVENT_SYMBOL, 0)

        def eventRef(self):
            return self.getTypedRuleContext(MySQLParser.EventRefContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showCreateEventStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowCreateEventStatement" ):
                listener.enterShowCreateEventStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowCreateEventStatement" ):
                listener.exitShowCreateEventStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowCreateEventStatement" ):
                return visitor.visitShowCreateEventStatement(self)
            else:
                return visitor.visitChildren(self)




    def showCreateEventStatement(self):

        localctx = MySQLParser.ShowCreateEventStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 826, self.RULE_showCreateEventStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5930
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5931
            self.match(MySQLParser.CREATE_SYMBOL)
            self.state = 5932
            self.match(MySQLParser.EVENT_SYMBOL)
            self.state = 5933
            self.eventRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowCreateUserStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_SYMBOL(self):
            return self.getToken(MySQLParser.SHOW_SYMBOL, 0)

        def CREATE_SYMBOL(self):
            return self.getToken(MySQLParser.CREATE_SYMBOL, 0)

        def USER_SYMBOL(self):
            return self.getToken(MySQLParser.USER_SYMBOL, 0)

        def user(self):
            return self.getTypedRuleContext(MySQLParser.UserContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_showCreateUserStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowCreateUserStatement" ):
                listener.enterShowCreateUserStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowCreateUserStatement" ):
                listener.exitShowCreateUserStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowCreateUserStatement" ):
                return visitor.visitShowCreateUserStatement(self)
            else:
                return visitor.visitChildren(self)




    def showCreateUserStatement(self):

        localctx = MySQLParser.ShowCreateUserStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 828, self.RULE_showCreateUserStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5935
            self.match(MySQLParser.SHOW_SYMBOL)
            self.state = 5936
            self.match(MySQLParser.CREATE_SYMBOL)
            self.state = 5937
            self.match(MySQLParser.USER_SYMBOL)
            self.state = 5938
            self.user()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowCommandTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FULL_SYMBOL(self):
            return self.getToken(MySQLParser.FULL_SYMBOL, 0)

        def EXTENDED_SYMBOL(self):
            return self.getToken(MySQLParser.EXTENDED_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_showCommandType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowCommandType" ):
                listener.enterShowCommandType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowCommandType" ):
                listener.exitShowCommandType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowCommandType" ):
                return visitor.visitShowCommandType(self)
            else:
                return visitor.visitChildren(self)




    def showCommandType(self):

        localctx = MySQLParser.ShowCommandTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 830, self.RULE_showCommandType)
        self._la = 0 # Token type
        try:
            self.state = 5945
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [236]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5940
                self.match(MySQLParser.FULL_SYMBOL)
                pass
            elif token in [215]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5941
                self.match(MySQLParser.EXTENDED_SYMBOL)
                self.state = 5943
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==236:
                    self.state = 5942
                    self.match(MySQLParser.FULL_SYMBOL)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EngineOrAllContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def engineRef(self):
            return self.getTypedRuleContext(MySQLParser.EngineRefContext,0)


        def ALL_SYMBOL(self):
            return self.getToken(MySQLParser.ALL_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_engineOrAll

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEngineOrAll" ):
                listener.enterEngineOrAll(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEngineOrAll" ):
                listener.exitEngineOrAll(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEngineOrAll" ):
                return visitor.visitEngineOrAll(self)
            else:
                return visitor.visitChildren(self)




    def engineOrAll(self):

        localctx = MySQLParser.EngineOrAllContext(self, self._ctx, self.state)
        self.enterRule(localctx, 832, self.RULE_engineOrAll)
        try:
            self.state = 5949
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,693,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5947
                self.engineRef()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5948
                self.match(MySQLParser.ALL_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FromOrInContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FROM_SYMBOL(self):
            return self.getToken(MySQLParser.FROM_SYMBOL, 0)

        def IN_SYMBOL(self):
            return self.getToken(MySQLParser.IN_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_fromOrIn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFromOrIn" ):
                listener.enterFromOrIn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFromOrIn" ):
                listener.exitFromOrIn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFromOrIn" ):
                return visitor.visitFromOrIn(self)
            else:
                return visitor.visitChildren(self)




    def fromOrIn(self):

        localctx = MySQLParser.FromOrInContext(self, self._ctx, self.state)
        self.enterRule(localctx, 834, self.RULE_fromOrIn)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5951
            _la = self._input.LA(1)
            if not(_la==235 or _la==282):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InDbContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fromOrIn(self):
            return self.getTypedRuleContext(MySQLParser.FromOrInContext,0)


        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_inDb

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInDb" ):
                listener.enterInDb(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInDb" ):
                listener.exitInDb(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInDb" ):
                return visitor.visitInDb(self)
            else:
                return visitor.visitChildren(self)




    def inDb(self):

        localctx = MySQLParser.InDbContext(self, self._ctx, self.state)
        self.enterRule(localctx, 836, self.RULE_inDb)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5953
            self.fromOrIn()
            self.state = 5954
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProfileDefinitionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def profileDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ProfileDefinitionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ProfileDefinitionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_profileDefinitions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProfileDefinitions" ):
                listener.enterProfileDefinitions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProfileDefinitions" ):
                listener.exitProfileDefinitions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProfileDefinitions" ):
                return visitor.visitProfileDefinitions(self)
            else:
                return visitor.visitChildren(self)




    def profileDefinitions(self):

        localctx = MySQLParser.ProfileDefinitionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 838, self.RULE_profileDefinitions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5956
            self.profileDefinition()
            self.state = 5961
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 5957
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 5958
                self.profileDefinition()
                self.state = 5963
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProfileDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BLOCK_SYMBOL(self):
            return self.getToken(MySQLParser.BLOCK_SYMBOL, 0)

        def IO_SYMBOL(self):
            return self.getToken(MySQLParser.IO_SYMBOL, 0)

        def CONTEXT_SYMBOL(self):
            return self.getToken(MySQLParser.CONTEXT_SYMBOL, 0)

        def SWITCHES_SYMBOL(self):
            return self.getToken(MySQLParser.SWITCHES_SYMBOL, 0)

        def PAGE_SYMBOL(self):
            return self.getToken(MySQLParser.PAGE_SYMBOL, 0)

        def FAULTS_SYMBOL(self):
            return self.getToken(MySQLParser.FAULTS_SYMBOL, 0)

        def ALL_SYMBOL(self):
            return self.getToken(MySQLParser.ALL_SYMBOL, 0)

        def CPU_SYMBOL(self):
            return self.getToken(MySQLParser.CPU_SYMBOL, 0)

        def IPC_SYMBOL(self):
            return self.getToken(MySQLParser.IPC_SYMBOL, 0)

        def MEMORY_SYMBOL(self):
            return self.getToken(MySQLParser.MEMORY_SYMBOL, 0)

        def SOURCE_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SYMBOL, 0)

        def SWAPS_SYMBOL(self):
            return self.getToken(MySQLParser.SWAPS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_profileDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProfileDefinition" ):
                listener.enterProfileDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProfileDefinition" ):
                listener.exitProfileDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProfileDefinition" ):
                return visitor.visitProfileDefinition(self)
            else:
                return visitor.visitChildren(self)




    def profileDefinition(self):

        localctx = MySQLParser.ProfileDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 840, self.RULE_profileDefinition)
        self._la = 0 # Token type
        try:
            self.state = 5971
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [84]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5964
                self.match(MySQLParser.BLOCK_SYMBOL)
                self.state = 5965
                self.match(MySQLParser.IO_SYMBOL)
                pass
            elif token in [134]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5966
                self.match(MySQLParser.CONTEXT_SYMBOL)
                self.state = 5967
                self.match(MySQLParser.SWITCHES_SYMBOL)
                pass
            elif token in [418]:
                self.enterOuterAlt(localctx, 3)
                self.state = 5968
                self.match(MySQLParser.PAGE_SYMBOL)
                self.state = 5969
                self.match(MySQLParser.FAULTS_SYMBOL)
                pass
            elif token in [57, 138, 286, 358, 533, 577]:
                self.enterOuterAlt(localctx, 4)
                self.state = 5970
                _la = self._input.LA(1)
                if not(_la==57 or _la==138 or _la==286 or _la==358 or _la==533 or _la==577):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OtherAdministrativeStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # Token

        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def BINLOG_SYMBOL(self):
            return self.getToken(MySQLParser.BINLOG_SYMBOL, 0)

        def INDEX_SYMBOL(self):
            return self.getToken(MySQLParser.INDEX_SYMBOL, 0)

        def keyCacheListOrParts(self):
            return self.getTypedRuleContext(MySQLParser.KeyCacheListOrPartsContext,0)


        def IN_SYMBOL(self):
            return self.getToken(MySQLParser.IN_SYMBOL, 0)

        def CACHE_SYMBOL(self):
            return self.getToken(MySQLParser.CACHE_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def FLUSH_SYMBOL(self):
            return self.getToken(MySQLParser.FLUSH_SYMBOL, 0)

        def flushTables(self):
            return self.getTypedRuleContext(MySQLParser.FlushTablesContext,0)


        def flushOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.FlushOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.FlushOptionContext,i)


        def noWriteToBinLog(self):
            return self.getTypedRuleContext(MySQLParser.NoWriteToBinLogContext,0)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def KILL_SYMBOL(self):
            return self.getToken(MySQLParser.KILL_SYMBOL, 0)

        def CONNECTION_SYMBOL(self):
            return self.getToken(MySQLParser.CONNECTION_SYMBOL, 0)

        def QUERY_SYMBOL(self):
            return self.getToken(MySQLParser.QUERY_SYMBOL, 0)

        def INTO_SYMBOL(self):
            return self.getToken(MySQLParser.INTO_SYMBOL, 0)

        def preloadTail(self):
            return self.getTypedRuleContext(MySQLParser.PreloadTailContext,0)


        def LOAD_SYMBOL(self):
            return self.getToken(MySQLParser.LOAD_SYMBOL, 0)

        def SHUTDOWN_SYMBOL(self):
            return self.getToken(MySQLParser.SHUTDOWN_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_otherAdministrativeStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOtherAdministrativeStatement" ):
                listener.enterOtherAdministrativeStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOtherAdministrativeStatement" ):
                listener.exitOtherAdministrativeStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOtherAdministrativeStatement" ):
                return visitor.visitOtherAdministrativeStatement(self)
            else:
                return visitor.visitChildren(self)




    def otherAdministrativeStatement(self):

        localctx = MySQLParser.OtherAdministrativeStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 842, self.RULE_otherAdministrativeStatement)
        self._la = 0 # Token type
        try:
            self.state = 6009
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [78]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5973
                localctx.type_ = self.match(MySQLParser.BINLOG_SYMBOL)
                self.state = 5974
                self.textLiteral()
                pass
            elif token in [91]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5975
                localctx.type_ = self.match(MySQLParser.CACHE_SYMBOL)
                self.state = 5976
                self.match(MySQLParser.INDEX_SYMBOL)
                self.state = 5977
                self.keyCacheListOrParts()
                self.state = 5978
                self.match(MySQLParser.IN_SYMBOL)
                self.state = 5981
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,696,self._ctx)
                if la_ == 1:
                    self.state = 5979
                    self.identifier()
                    pass

                elif la_ == 2:
                    self.state = 5980
                    self.match(MySQLParser.DEFAULT_SYMBOL)
                    pass


                pass
            elif token in [228]:
                self.enterOuterAlt(localctx, 3)
                self.state = 5983
                localctx.type_ = self.match(MySQLParser.FLUSH_SYMBOL)
                self.state = 5985
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==312 or _la==394:
                    self.state = 5984
                    self.noWriteToBinLog()


                self.state = 5996
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [581, 583]:
                    self.state = 5987
                    self.flushTables()
                    pass
                elif token in [77, 198, 200, 240, 257, 316, 407, 439, 462, 527, 557, 626]:
                    self.state = 5988
                    self.flushOption()
                    self.state = 5993
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==29:
                        self.state = 5989
                        self.match(MySQLParser.COMMA_SYMBOL)
                        self.state = 5990
                        self.flushOption()
                        self.state = 5995
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [296]:
                self.enterOuterAlt(localctx, 4)
                self.state = 5998
                localctx.type_ = self.match(MySQLParser.KILL_SYMBOL)
                self.state = 6000
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,700,self._ctx)
                if la_ == 1:
                    self.state = 5999
                    _la = self._input.LA(1)
                    if not(_la==127 or _la==448):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 6002
                self.expr(0)
                pass
            elif token in [311]:
                self.enterOuterAlt(localctx, 5)
                self.state = 6003
                localctx.type_ = self.match(MySQLParser.LOAD_SYMBOL)
                self.state = 6004
                self.match(MySQLParser.INDEX_SYMBOL)
                self.state = 6005
                self.match(MySQLParser.INTO_SYMBOL)
                self.state = 6006
                self.match(MySQLParser.CACHE_SYMBOL)
                self.state = 6007
                self.preloadTail()
                pass
            elif token in [522]:
                self.enterOuterAlt(localctx, 6)
                self.state = 6008
                localctx.type_ = self.match(MySQLParser.SHUTDOWN_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeyCacheListOrPartsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def keyCacheList(self):
            return self.getTypedRuleContext(MySQLParser.KeyCacheListContext,0)


        def assignToKeycachePartition(self):
            return self.getTypedRuleContext(MySQLParser.AssignToKeycachePartitionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_keyCacheListOrParts

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyCacheListOrParts" ):
                listener.enterKeyCacheListOrParts(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyCacheListOrParts" ):
                listener.exitKeyCacheListOrParts(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKeyCacheListOrParts" ):
                return visitor.visitKeyCacheListOrParts(self)
            else:
                return visitor.visitChildren(self)




    def keyCacheListOrParts(self):

        localctx = MySQLParser.KeyCacheListOrPartsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 844, self.RULE_keyCacheListOrParts)
        try:
            self.state = 6013
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,702,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 6011
                self.keyCacheList()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 6012
                self.assignToKeycachePartition()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeyCacheListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignToKeycache(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.AssignToKeycacheContext)
            else:
                return self.getTypedRuleContext(MySQLParser.AssignToKeycacheContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_keyCacheList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyCacheList" ):
                listener.enterKeyCacheList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyCacheList" ):
                listener.exitKeyCacheList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKeyCacheList" ):
                return visitor.visitKeyCacheList(self)
            else:
                return visitor.visitChildren(self)




    def keyCacheList(self):

        localctx = MySQLParser.KeyCacheListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 846, self.RULE_keyCacheList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6015
            self.assignToKeycache()
            self.state = 6020
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 6016
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6017
                self.assignToKeycache()
                self.state = 6022
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignToKeycacheContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def cacheKeyList(self):
            return self.getTypedRuleContext(MySQLParser.CacheKeyListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_assignToKeycache

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignToKeycache" ):
                listener.enterAssignToKeycache(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignToKeycache" ):
                listener.exitAssignToKeycache(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignToKeycache" ):
                return visitor.visitAssignToKeycache(self)
            else:
                return visitor.visitChildren(self)




    def assignToKeycache(self):

        localctx = MySQLParser.AssignToKeycacheContext(self, self._ctx, self.state)
        self.enterRule(localctx, 848, self.RULE_assignToKeycache)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6023
            self.tableRef()
            self.state = 6025
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==268 or _la==295:
                self.state = 6024
                self.cacheKeyList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignToKeycachePartitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def PARTITION_SYMBOL(self):
            return self.getToken(MySQLParser.PARTITION_SYMBOL, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def allOrPartitionNameList(self):
            return self.getTypedRuleContext(MySQLParser.AllOrPartitionNameListContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def cacheKeyList(self):
            return self.getTypedRuleContext(MySQLParser.CacheKeyListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_assignToKeycachePartition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignToKeycachePartition" ):
                listener.enterAssignToKeycachePartition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignToKeycachePartition" ):
                listener.exitAssignToKeycachePartition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignToKeycachePartition" ):
                return visitor.visitAssignToKeycachePartition(self)
            else:
                return visitor.visitChildren(self)




    def assignToKeycachePartition(self):

        localctx = MySQLParser.AssignToKeycachePartitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 850, self.RULE_assignToKeycachePartition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6027
            self.tableRef()
            self.state = 6028
            self.match(MySQLParser.PARTITION_SYMBOL)
            self.state = 6029
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 6030
            self.allOrPartitionNameList()
            self.state = 6031
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
            self.state = 6033
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==268 or _la==295:
                self.state = 6032
                self.cacheKeyList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CacheKeyListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def keyOrIndex(self):
            return self.getTypedRuleContext(MySQLParser.KeyOrIndexContext,0)


        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def keyUsageList(self):
            return self.getTypedRuleContext(MySQLParser.KeyUsageListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_cacheKeyList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCacheKeyList" ):
                listener.enterCacheKeyList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCacheKeyList" ):
                listener.exitCacheKeyList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCacheKeyList" ):
                return visitor.visitCacheKeyList(self)
            else:
                return visitor.visitChildren(self)




    def cacheKeyList(self):

        localctx = MySQLParser.CacheKeyListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 852, self.RULE_cacheKeyList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6035
            self.keyOrIndex()
            self.state = 6036
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 6038
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,706,self._ctx)
            if la_ == 1:
                self.state = 6037
                self.keyUsageList()


            self.state = 6040
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeyUsageElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def PRIMARY_SYMBOL(self):
            return self.getToken(MySQLParser.PRIMARY_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_keyUsageElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyUsageElement" ):
                listener.enterKeyUsageElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyUsageElement" ):
                listener.exitKeyUsageElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKeyUsageElement" ):
                return visitor.visitKeyUsageElement(self)
            else:
                return visitor.visitChildren(self)




    def keyUsageElement(self):

        localctx = MySQLParser.KeyUsageElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 854, self.RULE_keyUsageElement)
        try:
            self.state = 6044
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,707,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 6042
                self.identifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 6043
                self.match(MySQLParser.PRIMARY_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeyUsageListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def keyUsageElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.KeyUsageElementContext)
            else:
                return self.getTypedRuleContext(MySQLParser.KeyUsageElementContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_keyUsageList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyUsageList" ):
                listener.enterKeyUsageList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyUsageList" ):
                listener.exitKeyUsageList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKeyUsageList" ):
                return visitor.visitKeyUsageList(self)
            else:
                return visitor.visitChildren(self)




    def keyUsageList(self):

        localctx = MySQLParser.KeyUsageListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 856, self.RULE_keyUsageList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6046
            self.keyUsageElement()
            self.state = 6051
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 6047
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6048
                self.keyUsageElement()
                self.state = 6053
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FlushOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.option = None # Token

        def HOSTS_SYMBOL(self):
            return self.getToken(MySQLParser.HOSTS_SYMBOL, 0)

        def PRIVILEGES_SYMBOL(self):
            return self.getToken(MySQLParser.PRIVILEGES_SYMBOL, 0)

        def STATUS_SYMBOL(self):
            return self.getToken(MySQLParser.STATUS_SYMBOL, 0)

        def USER_RESOURCES_SYMBOL(self):
            return self.getToken(MySQLParser.USER_RESOURCES_SYMBOL, 0)

        def LOGS_SYMBOL(self):
            return self.getToken(MySQLParser.LOGS_SYMBOL, 0)

        def logType(self):
            return self.getTypedRuleContext(MySQLParser.LogTypeContext,0)


        def RELAY_SYMBOL(self):
            return self.getToken(MySQLParser.RELAY_SYMBOL, 0)

        def channel(self):
            return self.getTypedRuleContext(MySQLParser.ChannelContext,0)


        def OPTIMIZER_COSTS_SYMBOL(self):
            return self.getToken(MySQLParser.OPTIMIZER_COSTS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_flushOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFlushOption" ):
                listener.enterFlushOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFlushOption" ):
                listener.exitFlushOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFlushOption" ):
                return visitor.visitFlushOption(self)
            else:
                return visitor.visitChildren(self)




    def flushOption(self):

        localctx = MySQLParser.FlushOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 858, self.RULE_flushOption)
        self._la = 0 # Token type
        try:
            self.state = 6065
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [257, 439, 557, 626]:
                self.enterOuterAlt(localctx, 1)
                self.state = 6054
                localctx.option = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==257 or _la==439 or _la==557 or _la==626):
                    localctx.option = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [77, 198, 200, 240, 316, 527]:
                self.enterOuterAlt(localctx, 2)
                self.state = 6056
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==77 or ((((_la - 198)) & ~0x3f) == 0 and ((1 << (_la - 198)) & 4398046511109) != 0) or _la==527:
                    self.state = 6055
                    self.logType()


                self.state = 6058
                localctx.option = self.match(MySQLParser.LOGS_SYMBOL)
                pass
            elif token in [462]:
                self.enterOuterAlt(localctx, 3)
                self.state = 6059
                localctx.option = self.match(MySQLParser.RELAY_SYMBOL)
                self.state = 6060
                self.match(MySQLParser.LOGS_SYMBOL)
                self.state = 6062
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==232:
                    self.state = 6061
                    self.channel()


                pass
            elif token in [407]:
                self.enterOuterAlt(localctx, 4)
                self.state = 6064
                localctx.option = self.match(MySQLParser.OPTIMIZER_COSTS_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BINARY_SYMBOL(self):
            return self.getToken(MySQLParser.BINARY_SYMBOL, 0)

        def ENGINE_SYMBOL(self):
            return self.getToken(MySQLParser.ENGINE_SYMBOL, 0)

        def ERROR_SYMBOL(self):
            return self.getToken(MySQLParser.ERROR_SYMBOL, 0)

        def GENERAL_SYMBOL(self):
            return self.getToken(MySQLParser.GENERAL_SYMBOL, 0)

        def SLOW_SYMBOL(self):
            return self.getToken(MySQLParser.SLOW_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_logType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogType" ):
                listener.enterLogType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogType" ):
                listener.exitLogType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogType" ):
                return visitor.visitLogType(self)
            else:
                return visitor.visitChildren(self)




    def logType(self):

        localctx = MySQLParser.LogTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 860, self.RULE_logType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6067
            _la = self._input.LA(1)
            if not(_la==77 or ((((_la - 198)) & ~0x3f) == 0 and ((1 << (_la - 198)) & 4398046511109) != 0) or _la==527):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FlushTablesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TABLES_SYMBOL(self):
            return self.getToken(MySQLParser.TABLES_SYMBOL, 0)

        def TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_SYMBOL, 0)

        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def READ_SYMBOL(self):
            return self.getToken(MySQLParser.READ_SYMBOL, 0)

        def LOCK_SYMBOL(self):
            return self.getToken(MySQLParser.LOCK_SYMBOL, 0)

        def identifierList(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierListContext,0)


        def flushTablesOptions(self):
            return self.getTypedRuleContext(MySQLParser.FlushTablesOptionsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_flushTables

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFlushTables" ):
                listener.enterFlushTables(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFlushTables" ):
                listener.exitFlushTables(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFlushTables" ):
                return visitor.visitFlushTables(self)
            else:
                return visitor.visitChildren(self)




    def flushTables(self):

        localctx = MySQLParser.FlushTablesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 862, self.RULE_flushTables)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6069
            _la = self._input.LA(1)
            if not(_la==581 or _la==583):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 6077
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,713,self._ctx)
            if la_ == 1:
                self.state = 6070
                self.match(MySQLParser.WITH_SYMBOL)
                self.state = 6071
                self.match(MySQLParser.READ_SYMBOL)
                self.state = 6072
                self.match(MySQLParser.LOCK_SYMBOL)

            elif la_ == 2:
                self.state = 6073
                self.identifierList()
                self.state = 6075
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==232 or _la==653:
                    self.state = 6074
                    self.flushTablesOptions()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FlushTablesOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def EXPORT_SYMBOL(self):
            return self.getToken(MySQLParser.EXPORT_SYMBOL, 0)

        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def READ_SYMBOL(self):
            return self.getToken(MySQLParser.READ_SYMBOL, 0)

        def LOCK_SYMBOL(self):
            return self.getToken(MySQLParser.LOCK_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_flushTablesOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFlushTablesOptions" ):
                listener.enterFlushTablesOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFlushTablesOptions" ):
                listener.exitFlushTablesOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFlushTablesOptions" ):
                return visitor.visitFlushTablesOptions(self)
            else:
                return visitor.visitChildren(self)




    def flushTablesOptions(self):

        localctx = MySQLParser.FlushTablesOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 864, self.RULE_flushTablesOptions)
        try:
            self.state = 6084
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [232]:
                self.enterOuterAlt(localctx, 1)
                self.state = 6079
                self.match(MySQLParser.FOR_SYMBOL)
                self.state = 6080
                self.match(MySQLParser.EXPORT_SYMBOL)
                pass
            elif token in [653]:
                self.enterOuterAlt(localctx, 2)
                self.state = 6081
                self.match(MySQLParser.WITH_SYMBOL)
                self.state = 6082
                self.match(MySQLParser.READ_SYMBOL)
                self.state = 6083
                self.match(MySQLParser.LOCK_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PreloadTailContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def adminPartition(self):
            return self.getTypedRuleContext(MySQLParser.AdminPartitionContext,0)


        def cacheKeyList(self):
            return self.getTypedRuleContext(MySQLParser.CacheKeyListContext,0)


        def IGNORE_SYMBOL(self):
            return self.getToken(MySQLParser.IGNORE_SYMBOL, 0)

        def LEAVES_SYMBOL(self):
            return self.getToken(MySQLParser.LEAVES_SYMBOL, 0)

        def preloadList(self):
            return self.getTypedRuleContext(MySQLParser.PreloadListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_preloadTail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreloadTail" ):
                listener.enterPreloadTail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreloadTail" ):
                listener.exitPreloadTail(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreloadTail" ):
                return visitor.visitPreloadTail(self)
            else:
                return visitor.visitChildren(self)




    def preloadTail(self):

        localctx = MySQLParser.PreloadTailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 866, self.RULE_preloadTail)
        self._la = 0 # Token type
        try:
            self.state = 6096
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,717,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 6086
                self.tableRef()
                self.state = 6087
                self.adminPartition()
                self.state = 6089
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==268 or _la==295:
                    self.state = 6088
                    self.cacheKeyList()


                self.state = 6093
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==264:
                    self.state = 6091
                    self.match(MySQLParser.IGNORE_SYMBOL)
                    self.state = 6092
                    self.match(MySQLParser.LEAVES_SYMBOL)


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 6095
                self.preloadList()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PreloadListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def preloadKeys(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.PreloadKeysContext)
            else:
                return self.getTypedRuleContext(MySQLParser.PreloadKeysContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_preloadList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreloadList" ):
                listener.enterPreloadList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreloadList" ):
                listener.exitPreloadList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreloadList" ):
                return visitor.visitPreloadList(self)
            else:
                return visitor.visitChildren(self)




    def preloadList(self):

        localctx = MySQLParser.PreloadListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 868, self.RULE_preloadList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6098
            self.preloadKeys()
            self.state = 6103
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 6099
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6100
                self.preloadKeys()
                self.state = 6105
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PreloadKeysContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def cacheKeyList(self):
            return self.getTypedRuleContext(MySQLParser.CacheKeyListContext,0)


        def IGNORE_SYMBOL(self):
            return self.getToken(MySQLParser.IGNORE_SYMBOL, 0)

        def LEAVES_SYMBOL(self):
            return self.getToken(MySQLParser.LEAVES_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_preloadKeys

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreloadKeys" ):
                listener.enterPreloadKeys(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreloadKeys" ):
                listener.exitPreloadKeys(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreloadKeys" ):
                return visitor.visitPreloadKeys(self)
            else:
                return visitor.visitChildren(self)




    def preloadKeys(self):

        localctx = MySQLParser.PreloadKeysContext(self, self._ctx, self.state)
        self.enterRule(localctx, 870, self.RULE_preloadKeys)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6106
            self.tableRef()
            self.state = 6108
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==268 or _la==295:
                self.state = 6107
                self.cacheKeyList()


            self.state = 6112
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==264:
                self.state = 6110
                self.match(MySQLParser.IGNORE_SYMBOL)
                self.state = 6111
                self.match(MySQLParser.LEAVES_SYMBOL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdminPartitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARTITION_SYMBOL(self):
            return self.getToken(MySQLParser.PARTITION_SYMBOL, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def allOrPartitionNameList(self):
            return self.getTypedRuleContext(MySQLParser.AllOrPartitionNameListContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_adminPartition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdminPartition" ):
                listener.enterAdminPartition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdminPartition" ):
                listener.exitAdminPartition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdminPartition" ):
                return visitor.visitAdminPartition(self)
            else:
                return visitor.visitChildren(self)




    def adminPartition(self):

        localctx = MySQLParser.AdminPartitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 872, self.RULE_adminPartition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6114
            self.match(MySQLParser.PARTITION_SYMBOL)
            self.state = 6115
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 6116
            self.allOrPartitionNameList()
            self.state = 6117
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResourceGroupManagementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def createResourceGroup(self):
            return self.getTypedRuleContext(MySQLParser.CreateResourceGroupContext,0)


        def alterResourceGroup(self):
            return self.getTypedRuleContext(MySQLParser.AlterResourceGroupContext,0)


        def setResourceGroup(self):
            return self.getTypedRuleContext(MySQLParser.SetResourceGroupContext,0)


        def dropResourceGroup(self):
            return self.getTypedRuleContext(MySQLParser.DropResourceGroupContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_resourceGroupManagement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResourceGroupManagement" ):
                listener.enterResourceGroupManagement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResourceGroupManagement" ):
                listener.exitResourceGroupManagement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResourceGroupManagement" ):
                return visitor.visitResourceGroupManagement(self)
            else:
                return visitor.visitChildren(self)




    def resourceGroupManagement(self):

        localctx = MySQLParser.ResourceGroupManagementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 874, self.RULE_resourceGroupManagement)
        try:
            self.state = 6123
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [139]:
                self.enterOuterAlt(localctx, 1)
                self.state = 6119
                self.createResourceGroup()
                pass
            elif token in [58]:
                self.enterOuterAlt(localctx, 2)
                self.state = 6120
                self.alterResourceGroup()
                pass
            elif token in [519]:
                self.enterOuterAlt(localctx, 3)
                self.state = 6121
                self.setResourceGroup()
                pass
            elif token in [184]:
                self.enterOuterAlt(localctx, 4)
                self.state = 6122
                self.dropResourceGroup()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateResourceGroupContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE_SYMBOL(self):
            return self.getToken(MySQLParser.CREATE_SYMBOL, 0)

        def RESOURCE_SYMBOL(self):
            return self.getToken(MySQLParser.RESOURCE_SYMBOL, 0)

        def GROUP_SYMBOL(self):
            return self.getToken(MySQLParser.GROUP_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def TYPE_SYMBOL(self):
            return self.getToken(MySQLParser.TYPE_SYMBOL, 0)

        def USER_SYMBOL(self):
            return self.getToken(MySQLParser.USER_SYMBOL, 0)

        def SYSTEM_SYMBOL(self):
            return self.getToken(MySQLParser.SYSTEM_SYMBOL, 0)

        def equal(self):
            return self.getTypedRuleContext(MySQLParser.EqualContext,0)


        def resourceGroupVcpuList(self):
            return self.getTypedRuleContext(MySQLParser.ResourceGroupVcpuListContext,0)


        def resourceGroupPriority(self):
            return self.getTypedRuleContext(MySQLParser.ResourceGroupPriorityContext,0)


        def resourceGroupEnableDisable(self):
            return self.getTypedRuleContext(MySQLParser.ResourceGroupEnableDisableContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createResourceGroup

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateResourceGroup" ):
                listener.enterCreateResourceGroup(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateResourceGroup" ):
                listener.exitCreateResourceGroup(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateResourceGroup" ):
                return visitor.visitCreateResourceGroup(self)
            else:
                return visitor.visitChildren(self)




    def createResourceGroup(self):

        localctx = MySQLParser.CreateResourceGroupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 876, self.RULE_createResourceGroup)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6125
            self.match(MySQLParser.CREATE_SYMBOL)
            self.state = 6126
            self.match(MySQLParser.RESOURCE_SYMBOL)
            self.state = 6127
            self.match(MySQLParser.GROUP_SYMBOL)
            self.state = 6128
            self.identifier()
            self.state = 6129
            self.match(MySQLParser.TYPE_SYMBOL)
            self.state = 6131
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==6 or _la==7:
                self.state = 6130
                self.equal()


            self.state = 6133
            _la = self._input.LA(1)
            if not(_la==627 or _la==718):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 6135
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==719:
                self.state = 6134
                self.resourceGroupVcpuList()


            self.state = 6138
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==716:
                self.state = 6137
                self.resourceGroupPriority()


            self.state = 6141
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==177 or _la==192:
                self.state = 6140
                self.resourceGroupEnableDisable()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResourceGroupVcpuListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VCPU_SYMBOL(self):
            return self.getToken(MySQLParser.VCPU_SYMBOL, 0)

        def vcpuNumOrRange(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.VcpuNumOrRangeContext)
            else:
                return self.getTypedRuleContext(MySQLParser.VcpuNumOrRangeContext,i)


        def equal(self):
            return self.getTypedRuleContext(MySQLParser.EqualContext,0)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_resourceGroupVcpuList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResourceGroupVcpuList" ):
                listener.enterResourceGroupVcpuList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResourceGroupVcpuList" ):
                listener.exitResourceGroupVcpuList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResourceGroupVcpuList" ):
                return visitor.visitResourceGroupVcpuList(self)
            else:
                return visitor.visitChildren(self)




    def resourceGroupVcpuList(self):

        localctx = MySQLParser.ResourceGroupVcpuListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 878, self.RULE_resourceGroupVcpuList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6143
            self.match(MySQLParser.VCPU_SYMBOL)
            self.state = 6145
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==6 or _la==7:
                self.state = 6144
                self.equal()


            self.state = 6147
            self.vcpuNumOrRange()
            self.state = 6154
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==3 or _la==29:
                self.state = 6149
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 6148
                    self.match(MySQLParser.COMMA_SYMBOL)


                self.state = 6151
                self.vcpuNumOrRange()
                self.state = 6156
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VcpuNumOrRangeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.INT_NUMBER)
            else:
                return self.getToken(MySQLParser.INT_NUMBER, i)

        def MINUS_OPERATOR(self):
            return self.getToken(MySQLParser.MINUS_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_vcpuNumOrRange

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVcpuNumOrRange" ):
                listener.enterVcpuNumOrRange(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVcpuNumOrRange" ):
                listener.exitVcpuNumOrRange(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVcpuNumOrRange" ):
                return visitor.visitVcpuNumOrRange(self)
            else:
                return visitor.visitChildren(self)




    def vcpuNumOrRange(self):

        localctx = MySQLParser.VcpuNumOrRangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 880, self.RULE_vcpuNumOrRange)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6157
            self.match(MySQLParser.INT_NUMBER)
            self.state = 6160
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==15:
                self.state = 6158
                self.match(MySQLParser.MINUS_OPERATOR)
                self.state = 6159
                self.match(MySQLParser.INT_NUMBER)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResourceGroupPriorityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def THREAD_PRIORITY_SYMBOL(self):
            return self.getToken(MySQLParser.THREAD_PRIORITY_SYMBOL, 0)

        def INT_NUMBER(self):
            return self.getToken(MySQLParser.INT_NUMBER, 0)

        def equal(self):
            return self.getTypedRuleContext(MySQLParser.EqualContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_resourceGroupPriority

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResourceGroupPriority" ):
                listener.enterResourceGroupPriority(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResourceGroupPriority" ):
                listener.exitResourceGroupPriority(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResourceGroupPriority" ):
                return visitor.visitResourceGroupPriority(self)
            else:
                return visitor.visitChildren(self)




    def resourceGroupPriority(self):

        localctx = MySQLParser.ResourceGroupPriorityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 882, self.RULE_resourceGroupPriority)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6162
            self.match(MySQLParser.THREAD_PRIORITY_SYMBOL)
            self.state = 6164
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==6 or _la==7:
                self.state = 6163
                self.equal()


            self.state = 6166
            self.match(MySQLParser.INT_NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResourceGroupEnableDisableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENABLE_SYMBOL(self):
            return self.getToken(MySQLParser.ENABLE_SYMBOL, 0)

        def DISABLE_SYMBOL(self):
            return self.getToken(MySQLParser.DISABLE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_resourceGroupEnableDisable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResourceGroupEnableDisable" ):
                listener.enterResourceGroupEnableDisable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResourceGroupEnableDisable" ):
                listener.exitResourceGroupEnableDisable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResourceGroupEnableDisable" ):
                return visitor.visitResourceGroupEnableDisable(self)
            else:
                return visitor.visitChildren(self)




    def resourceGroupEnableDisable(self):

        localctx = MySQLParser.ResourceGroupEnableDisableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 884, self.RULE_resourceGroupEnableDisable)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6168
            _la = self._input.LA(1)
            if not(_la==177 or _la==192):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterResourceGroupContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALTER_SYMBOL(self):
            return self.getToken(MySQLParser.ALTER_SYMBOL, 0)

        def RESOURCE_SYMBOL(self):
            return self.getToken(MySQLParser.RESOURCE_SYMBOL, 0)

        def GROUP_SYMBOL(self):
            return self.getToken(MySQLParser.GROUP_SYMBOL, 0)

        def resourceGroupRef(self):
            return self.getTypedRuleContext(MySQLParser.ResourceGroupRefContext,0)


        def resourceGroupVcpuList(self):
            return self.getTypedRuleContext(MySQLParser.ResourceGroupVcpuListContext,0)


        def resourceGroupPriority(self):
            return self.getTypedRuleContext(MySQLParser.ResourceGroupPriorityContext,0)


        def resourceGroupEnableDisable(self):
            return self.getTypedRuleContext(MySQLParser.ResourceGroupEnableDisableContext,0)


        def FORCE_SYMBOL(self):
            return self.getToken(MySQLParser.FORCE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_alterResourceGroup

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterResourceGroup" ):
                listener.enterAlterResourceGroup(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterResourceGroup" ):
                listener.exitAlterResourceGroup(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterResourceGroup" ):
                return visitor.visitAlterResourceGroup(self)
            else:
                return visitor.visitChildren(self)




    def alterResourceGroup(self):

        localctx = MySQLParser.AlterResourceGroupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 886, self.RULE_alterResourceGroup)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6170
            self.match(MySQLParser.ALTER_SYMBOL)
            self.state = 6171
            self.match(MySQLParser.RESOURCE_SYMBOL)
            self.state = 6172
            self.match(MySQLParser.GROUP_SYMBOL)
            self.state = 6173
            self.resourceGroupRef()
            self.state = 6175
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==719:
                self.state = 6174
                self.resourceGroupVcpuList()


            self.state = 6178
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==716:
                self.state = 6177
                self.resourceGroupPriority()


            self.state = 6181
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==177 or _la==192:
                self.state = 6180
                self.resourceGroupEnableDisable()


            self.state = 6184
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==230:
                self.state = 6183
                self.match(MySQLParser.FORCE_SYMBOL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetResourceGroupContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET_SYMBOL(self):
            return self.getToken(MySQLParser.SET_SYMBOL, 0)

        def RESOURCE_SYMBOL(self):
            return self.getToken(MySQLParser.RESOURCE_SYMBOL, 0)

        def GROUP_SYMBOL(self):
            return self.getToken(MySQLParser.GROUP_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def threadIdList(self):
            return self.getTypedRuleContext(MySQLParser.ThreadIdListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_setResourceGroup

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetResourceGroup" ):
                listener.enterSetResourceGroup(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetResourceGroup" ):
                listener.exitSetResourceGroup(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetResourceGroup" ):
                return visitor.visitSetResourceGroup(self)
            else:
                return visitor.visitChildren(self)




    def setResourceGroup(self):

        localctx = MySQLParser.SetResourceGroupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 888, self.RULE_setResourceGroup)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6186
            self.match(MySQLParser.SET_SYMBOL)
            self.state = 6187
            self.match(MySQLParser.RESOURCE_SYMBOL)
            self.state = 6188
            self.match(MySQLParser.GROUP_SYMBOL)
            self.state = 6189
            self.identifier()
            self.state = 6192
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==232:
                self.state = 6190
                self.match(MySQLParser.FOR_SYMBOL)
                self.state = 6191
                self.threadIdList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ThreadIdListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def real_ulong_number(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.Real_ulong_numberContext)
            else:
                return self.getTypedRuleContext(MySQLParser.Real_ulong_numberContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_threadIdList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThreadIdList" ):
                listener.enterThreadIdList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThreadIdList" ):
                listener.exitThreadIdList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThreadIdList" ):
                return visitor.visitThreadIdList(self)
            else:
                return visitor.visitChildren(self)




    def threadIdList(self):

        localctx = MySQLParser.ThreadIdListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 890, self.RULE_threadIdList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6194
            self.real_ulong_number()
            self.state = 6201
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 17592722915384) != 0):
                self.state = 6196
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 6195
                    self.match(MySQLParser.COMMA_SYMBOL)


                self.state = 6198
                self.real_ulong_number()
                self.state = 6203
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropResourceGroupContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DROP_SYMBOL(self):
            return self.getToken(MySQLParser.DROP_SYMBOL, 0)

        def RESOURCE_SYMBOL(self):
            return self.getToken(MySQLParser.RESOURCE_SYMBOL, 0)

        def GROUP_SYMBOL(self):
            return self.getToken(MySQLParser.GROUP_SYMBOL, 0)

        def resourceGroupRef(self):
            return self.getTypedRuleContext(MySQLParser.ResourceGroupRefContext,0)


        def FORCE_SYMBOL(self):
            return self.getToken(MySQLParser.FORCE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_dropResourceGroup

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropResourceGroup" ):
                listener.enterDropResourceGroup(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropResourceGroup" ):
                listener.exitDropResourceGroup(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropResourceGroup" ):
                return visitor.visitDropResourceGroup(self)
            else:
                return visitor.visitChildren(self)




    def dropResourceGroup(self):

        localctx = MySQLParser.DropResourceGroupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 892, self.RULE_dropResourceGroup)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6204
            self.match(MySQLParser.DROP_SYMBOL)
            self.state = 6205
            self.match(MySQLParser.RESOURCE_SYMBOL)
            self.state = 6206
            self.match(MySQLParser.GROUP_SYMBOL)
            self.state = 6207
            self.resourceGroupRef()
            self.state = 6209
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==230:
                self.state = 6208
                self.match(MySQLParser.FORCE_SYMBOL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UtilityStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def describeStatement(self):
            return self.getTypedRuleContext(MySQLParser.DescribeStatementContext,0)


        def explainStatement(self):
            return self.getTypedRuleContext(MySQLParser.ExplainStatementContext,0)


        def helpCommand(self):
            return self.getTypedRuleContext(MySQLParser.HelpCommandContext,0)


        def useCommand(self):
            return self.getTypedRuleContext(MySQLParser.UseCommandContext,0)


        def restartServer(self):
            return self.getTypedRuleContext(MySQLParser.RestartServerContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_utilityStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUtilityStatement" ):
                listener.enterUtilityStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUtilityStatement" ):
                listener.exitUtilityStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUtilityStatement" ):
                return visitor.visitUtilityStatement(self)
            else:
                return visitor.visitChildren(self)




    def utilityStatement(self):

        localctx = MySQLParser.UtilityStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 894, self.RULE_utilityStatement)
        try:
            self.state = 6217
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,739,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 6211
                self.describeStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 6212
                self.explainStatement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 6213
                self.helpCommand()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 6214
                self.useCommand()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 6215
                if not self.isServerVersionGe80011():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80011()")
                self.state = 6216
                self.restartServer()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DescribeStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def EXPLAIN_SYMBOL(self):
            return self.getToken(MySQLParser.EXPLAIN_SYMBOL, 0)

        def DESCRIBE_SYMBOL(self):
            return self.getToken(MySQLParser.DESCRIBE_SYMBOL, 0)

        def DESC_SYMBOL(self):
            return self.getToken(MySQLParser.DESC_SYMBOL, 0)

        def textString(self):
            return self.getTypedRuleContext(MySQLParser.TextStringContext,0)


        def columnRef(self):
            return self.getTypedRuleContext(MySQLParser.ColumnRefContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_describeStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDescribeStatement" ):
                listener.enterDescribeStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDescribeStatement" ):
                listener.exitDescribeStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDescribeStatement" ):
                return visitor.visitDescribeStatement(self)
            else:
                return visitor.visitChildren(self)




    def describeStatement(self):

        localctx = MySQLParser.DescribeStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 896, self.RULE_describeStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6219
            _la = self._input.LA(1)
            if not(((((_la - 172)) & ~0x3f) == 0 and ((1 << (_la - 172)) & 2199023255555) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 6220
            self.tableRef()
            self.state = 6223
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,740,self._ctx)
            if la_ == 1:
                self.state = 6221
                self.textString()

            elif la_ == 2:
                self.state = 6222
                self.columnRef()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExplainStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def explainableStatement(self):
            return self.getTypedRuleContext(MySQLParser.ExplainableStatementContext,0)


        def EXPLAIN_SYMBOL(self):
            return self.getToken(MySQLParser.EXPLAIN_SYMBOL, 0)

        def DESCRIBE_SYMBOL(self):
            return self.getToken(MySQLParser.DESCRIBE_SYMBOL, 0)

        def DESC_SYMBOL(self):
            return self.getToken(MySQLParser.DESC_SYMBOL, 0)

        def explainOptions(self):
            return self.getTypedRuleContext(MySQLParser.ExplainOptionsContext,0)


        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def DATABASE_SYMBOL(self):
            return self.getToken(MySQLParser.DATABASE_SYMBOL, 0)

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_explainStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExplainStatement" ):
                listener.enterExplainStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExplainStatement" ):
                listener.exitExplainStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExplainStatement" ):
                return visitor.visitExplainStatement(self)
            else:
                return visitor.visitChildren(self)




    def explainStatement(self):

        localctx = MySQLParser.ExplainStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 898, self.RULE_explainStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6225
            _la = self._input.LA(1)
            if not(((((_la - 172)) & ~0x3f) == 0 and ((1 << (_la - 172)) & 2199023255555) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 6227
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,741,self._ctx)
            if la_ == 1:
                self.state = 6226
                self.explainOptions()


            self.state = 6233
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,742,self._ctx)
            if la_ == 1:
                self.state = 6229
                if not self.isServerVersionGe80032():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80032()")
                self.state = 6230
                self.match(MySQLParser.FOR_SYMBOL)
                self.state = 6231
                self.match(MySQLParser.DATABASE_SYMBOL)
                self.state = 6232
                self.textOrIdentifier()


            self.state = 6235
            self.explainableStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExplainOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FORMAT_SYMBOL(self):
            return self.getToken(MySQLParser.FORMAT_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def explainInto(self):
            return self.getTypedRuleContext(MySQLParser.ExplainIntoContext,0)


        def EXTENDED_SYMBOL(self):
            return self.getToken(MySQLParser.EXTENDED_SYMBOL, 0)

        def ANALYZE_SYMBOL(self):
            return self.getToken(MySQLParser.ANALYZE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_explainOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExplainOptions" ):
                listener.enterExplainOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExplainOptions" ):
                listener.exitExplainOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExplainOptions" ):
                return visitor.visitExplainOptions(self)
            else:
                return visitor.visitChildren(self)




    def explainOptions(self):

        localctx = MySQLParser.ExplainOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 900, self.RULE_explainOptions)
        try:
            self.state = 6253
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,744,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 6237
                self.match(MySQLParser.FORMAT_SYMBOL)
                self.state = 6238
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 6239
                self.textOrIdentifier()
                self.state = 6242
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,743,self._ctx)
                if la_ == 1:
                    self.state = 6240
                    if not self.isServerVersionGe80032():
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.isServerVersionGe80032()")
                    self.state = 6241
                    self.explainInto()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 6244
                if not self.isServerVersionLt80012():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionLt80012()")
                self.state = 6245
                self.match(MySQLParser.EXTENDED_SYMBOL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 6246
                if not self.isServerVersionGe80018():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80018()")
                self.state = 6247
                self.match(MySQLParser.ANALYZE_SYMBOL)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 6248
                if not self.isServerVersionGe80019():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80019()")
                self.state = 6249
                self.match(MySQLParser.ANALYZE_SYMBOL)
                self.state = 6250
                self.match(MySQLParser.FORMAT_SYMBOL)
                self.state = 6251
                self.match(MySQLParser.EQUAL_OPERATOR)
                self.state = 6252
                self.textOrIdentifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExplainableStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selectStatement(self):
            return self.getTypedRuleContext(MySQLParser.SelectStatementContext,0)


        def deleteStatement(self):
            return self.getTypedRuleContext(MySQLParser.DeleteStatementContext,0)


        def insertStatement(self):
            return self.getTypedRuleContext(MySQLParser.InsertStatementContext,0)


        def replaceStatement(self):
            return self.getTypedRuleContext(MySQLParser.ReplaceStatementContext,0)


        def updateStatement(self):
            return self.getTypedRuleContext(MySQLParser.UpdateStatementContext,0)


        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def CONNECTION_SYMBOL(self):
            return self.getToken(MySQLParser.CONNECTION_SYMBOL, 0)

        def real_ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Real_ulong_numberContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_explainableStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExplainableStatement" ):
                listener.enterExplainableStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExplainableStatement" ):
                listener.exitExplainableStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExplainableStatement" ):
                return visitor.visitExplainableStatement(self)
            else:
                return visitor.visitChildren(self)




    def explainableStatement(self):

        localctx = MySQLParser.ExplainableStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 902, self.RULE_explainableStatement)
        try:
            self.state = 6263
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,745,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 6255
                self.selectStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 6256
                self.deleteStatement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 6257
                self.insertStatement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 6258
                self.replaceStatement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 6259
                self.updateStatement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 6260
                self.match(MySQLParser.FOR_SYMBOL)
                self.state = 6261
                self.match(MySQLParser.CONNECTION_SYMBOL)
                self.state = 6262
                self.real_ulong_number()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExplainIntoContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTO_SYMBOL(self):
            return self.getToken(MySQLParser.INTO_SYMBOL, 0)

        def AT_SIGN_SYMBOL(self):
            return self.getToken(MySQLParser.AT_SIGN_SYMBOL, 0)

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_explainInto

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExplainInto" ):
                listener.enterExplainInto(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExplainInto" ):
                listener.exitExplainInto(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExplainInto" ):
                return visitor.visitExplainInto(self)
            else:
                return visitor.visitChildren(self)




    def explainInto(self):

        localctx = MySQLParser.ExplainIntoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 904, self.RULE_explainInto)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6265
            self.match(MySQLParser.INTO_SYMBOL)
            self.state = 6266
            self.match(MySQLParser.AT_SIGN_SYMBOL)
            self.state = 6267
            self.textOrIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HelpCommandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HELP_SYMBOL(self):
            return self.getToken(MySQLParser.HELP_SYMBOL, 0)

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_helpCommand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHelpCommand" ):
                listener.enterHelpCommand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHelpCommand" ):
                listener.exitHelpCommand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHelpCommand" ):
                return visitor.visitHelpCommand(self)
            else:
                return visitor.visitChildren(self)




    def helpCommand(self):

        localctx = MySQLParser.HelpCommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 906, self.RULE_helpCommand)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6269
            self.match(MySQLParser.HELP_SYMBOL)
            self.state = 6270
            self.textOrIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseCommandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USE_SYMBOL(self):
            return self.getToken(MySQLParser.USE_SYMBOL, 0)

        def schemaRef(self):
            return self.getTypedRuleContext(MySQLParser.SchemaRefContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_useCommand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseCommand" ):
                listener.enterUseCommand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseCommand" ):
                listener.exitUseCommand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseCommand" ):
                return visitor.visitUseCommand(self)
            else:
                return visitor.visitChildren(self)




    def useCommand(self):

        localctx = MySQLParser.UseCommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 908, self.RULE_useCommand)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6272
            self.match(MySQLParser.USE_SYMBOL)
            self.state = 6273
            self.schemaRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RestartServerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RESTART_SYMBOL(self):
            return self.getToken(MySQLParser.RESTART_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_restartServer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRestartServer" ):
                listener.enterRestartServer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRestartServer" ):
                listener.exitRestartServer(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRestartServer" ):
                return visitor.visitRestartServer(self)
            else:
                return visitor.visitChildren(self)




    def restartServer(self):

        localctx = MySQLParser.RestartServerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 910, self.RULE_restartServer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6275
            self.match(MySQLParser.RESTART_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MySQLParser.RULE_expr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class ExprOrContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.ExprContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ExprContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ExprContext,i)

        def OR_SYMBOL(self):
            return self.getToken(MySQLParser.OR_SYMBOL, 0)
        def LOGICAL_OR_OPERATOR(self):
            return self.getToken(MySQLParser.LOGICAL_OR_OPERATOR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprOr" ):
                listener.enterExprOr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprOr" ):
                listener.exitExprOr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprOr" ):
                return visitor.visitExprOr(self)
            else:
                return visitor.visitChildren(self)


    class ExprNotContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NOT_SYMBOL(self):
            return self.getToken(MySQLParser.NOT_SYMBOL, 0)
        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprNot" ):
                listener.enterExprNot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprNot" ):
                listener.exitExprNot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprNot" ):
                return visitor.visitExprNot(self)
            else:
                return visitor.visitChildren(self)


    class ExprIsContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.ExprContext
            super().__init__(parser)
            self.type_ = None # Token
            self.copyFrom(ctx)

        def boolPri(self):
            return self.getTypedRuleContext(MySQLParser.BoolPriContext,0)

        def IS_SYMBOL(self):
            return self.getToken(MySQLParser.IS_SYMBOL, 0)
        def TRUE_SYMBOL(self):
            return self.getToken(MySQLParser.TRUE_SYMBOL, 0)
        def FALSE_SYMBOL(self):
            return self.getToken(MySQLParser.FALSE_SYMBOL, 0)
        def UNKNOWN_SYMBOL(self):
            return self.getToken(MySQLParser.UNKNOWN_SYMBOL, 0)
        def notRule(self):
            return self.getTypedRuleContext(MySQLParser.NotRuleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprIs" ):
                listener.enterExprIs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprIs" ):
                listener.exitExprIs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprIs" ):
                return visitor.visitExprIs(self)
            else:
                return visitor.visitChildren(self)


    class ExprAndContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.ExprContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ExprContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ExprContext,i)

        def AND_SYMBOL(self):
            return self.getToken(MySQLParser.AND_SYMBOL, 0)
        def LOGICAL_AND_OPERATOR(self):
            return self.getToken(MySQLParser.LOGICAL_AND_OPERATOR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprAnd" ):
                listener.enterExprAnd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprAnd" ):
                listener.exitExprAnd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprAnd" ):
                return visitor.visitExprAnd(self)
            else:
                return visitor.visitChildren(self)


    class ExprXorContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ExprContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ExprContext,i)

        def XOR_SYMBOL(self):
            return self.getToken(MySQLParser.XOR_SYMBOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprXor" ):
                listener.enterExprXor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprXor" ):
                listener.exitExprXor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprXor" ):
                return visitor.visitExprXor(self)
            else:
                return visitor.visitChildren(self)



    def expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MySQLParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 912
        self.enterRecursionRule(localctx, 912, self.RULE_expr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6288
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,748,self._ctx)
            if la_ == 1:
                localctx = MySQLParser.ExprIsContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 6278
                self.boolPri(0)
                self.state = 6284
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,747,self._ctx)
                if la_ == 1:
                    self.state = 6279
                    self.match(MySQLParser.IS_SYMBOL)
                    self.state = 6281
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==1 or _la==390:
                        self.state = 6280
                        self.notRule()


                    self.state = 6283
                    localctx.type_ = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==218 or _la==605 or _la==619):
                        localctx.type_ = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass

            elif la_ == 2:
                localctx = MySQLParser.ExprNotContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6286
                self.match(MySQLParser.NOT_SYMBOL)
                self.state = 6287
                self.expr(4)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 6301
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,750,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 6299
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,749,self._ctx)
                    if la_ == 1:
                        localctx = MySQLParser.ExprAndContext(self, MySQLParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 6290
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 6291
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==23 or _la==61):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 6292
                        self.expr(4)
                        pass

                    elif la_ == 2:
                        localctx = MySQLParser.ExprXorContext(self, MySQLParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 6293
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 6294
                        self.match(MySQLParser.XOR_SYMBOL)
                        self.state = 6295
                        self.expr(3)
                        pass

                    elif la_ == 3:
                        localctx = MySQLParser.ExprOrContext(self, MySQLParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 6296
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 6297
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==26 or _la==412):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 6298
                        self.expr(2)
                        pass

             
                self.state = 6303
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,750,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class BoolPriContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MySQLParser.RULE_boolPri

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class PrimaryExprPredicateContext(BoolPriContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.BoolPriContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def predicate(self):
            return self.getTypedRuleContext(MySQLParser.PredicateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimaryExprPredicate" ):
                listener.enterPrimaryExprPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimaryExprPredicate" ):
                listener.exitPrimaryExprPredicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimaryExprPredicate" ):
                return visitor.visitPrimaryExprPredicate(self)
            else:
                return visitor.visitChildren(self)


    class PrimaryExprCompareContext(BoolPriContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.BoolPriContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def boolPri(self):
            return self.getTypedRuleContext(MySQLParser.BoolPriContext,0)

        def compOp(self):
            return self.getTypedRuleContext(MySQLParser.CompOpContext,0)

        def predicate(self):
            return self.getTypedRuleContext(MySQLParser.PredicateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimaryExprCompare" ):
                listener.enterPrimaryExprCompare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimaryExprCompare" ):
                listener.exitPrimaryExprCompare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimaryExprCompare" ):
                return visitor.visitPrimaryExprCompare(self)
            else:
                return visitor.visitChildren(self)


    class PrimaryExprAllAnyContext(BoolPriContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.BoolPriContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def boolPri(self):
            return self.getTypedRuleContext(MySQLParser.BoolPriContext,0)

        def compOp(self):
            return self.getTypedRuleContext(MySQLParser.CompOpContext,0)

        def subquery(self):
            return self.getTypedRuleContext(MySQLParser.SubqueryContext,0)

        def ALL_SYMBOL(self):
            return self.getToken(MySQLParser.ALL_SYMBOL, 0)
        def ANY_SYMBOL(self):
            return self.getToken(MySQLParser.ANY_SYMBOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimaryExprAllAny" ):
                listener.enterPrimaryExprAllAny(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimaryExprAllAny" ):
                listener.exitPrimaryExprAllAny(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimaryExprAllAny" ):
                return visitor.visitPrimaryExprAllAny(self)
            else:
                return visitor.visitChildren(self)


    class PrimaryExprIsNullContext(BoolPriContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.BoolPriContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def boolPri(self):
            return self.getTypedRuleContext(MySQLParser.BoolPriContext,0)

        def IS_SYMBOL(self):
            return self.getToken(MySQLParser.IS_SYMBOL, 0)
        def NULL_SYMBOL(self):
            return self.getToken(MySQLParser.NULL_SYMBOL, 0)
        def notRule(self):
            return self.getTypedRuleContext(MySQLParser.NotRuleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimaryExprIsNull" ):
                listener.enterPrimaryExprIsNull(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimaryExprIsNull" ):
                listener.exitPrimaryExprIsNull(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimaryExprIsNull" ):
                return visitor.visitPrimaryExprIsNull(self)
            else:
                return visitor.visitChildren(self)



    def boolPri(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MySQLParser.BoolPriContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 914
        self.enterRecursionRule(localctx, 914, self.RULE_boolPri, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = MySQLParser.PrimaryExprPredicateContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 6305
            self.predicate()
            self._ctx.stop = self._input.LT(-1)
            self.state = 6324
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,753,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 6322
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,752,self._ctx)
                    if la_ == 1:
                        localctx = MySQLParser.PrimaryExprIsNullContext(self, MySQLParser.BoolPriContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_boolPri)
                        self.state = 6307
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 6308
                        self.match(MySQLParser.IS_SYMBOL)
                        self.state = 6310
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==1 or _la==390:
                            self.state = 6309
                            self.notRule()


                        self.state = 6312
                        self.match(MySQLParser.NULL_SYMBOL)
                        pass

                    elif la_ == 2:
                        localctx = MySQLParser.PrimaryExprCompareContext(self, MySQLParser.BoolPriContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_boolPri)
                        self.state = 6313
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 6314
                        self.compOp()
                        self.state = 6315
                        self.predicate()
                        pass

                    elif la_ == 3:
                        localctx = MySQLParser.PrimaryExprAllAnyContext(self, MySQLParser.BoolPriContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_boolPri)
                        self.state = 6317
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 6318
                        self.compOp()
                        self.state = 6319
                        _la = self._input.LA(1)
                        if not(_la==57 or _la==62):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 6320
                        self.subquery()
                        pass

             
                self.state = 6326
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,753,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class CompOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def NULL_SAFE_EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.NULL_SAFE_EQUAL_OPERATOR, 0)

        def GREATER_OR_EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.GREATER_OR_EQUAL_OPERATOR, 0)

        def GREATER_THAN_OPERATOR(self):
            return self.getToken(MySQLParser.GREATER_THAN_OPERATOR, 0)

        def LESS_OR_EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.LESS_OR_EQUAL_OPERATOR, 0)

        def LESS_THAN_OPERATOR(self):
            return self.getToken(MySQLParser.LESS_THAN_OPERATOR, 0)

        def NOT_EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.NOT_EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_compOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompOp" ):
                listener.enterCompOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompOp" ):
                listener.exitCompOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompOp" ):
                return visitor.visitCompOp(self)
            else:
                return visitor.visitChildren(self)




    def compOp(self):

        localctx = MySQLParser.CompOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 916, self.RULE_compOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6327
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 16192) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredicateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def bitExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.BitExprContext)
            else:
                return self.getTypedRuleContext(MySQLParser.BitExprContext,i)


        def predicateOperations(self):
            return self.getTypedRuleContext(MySQLParser.PredicateOperationsContext,0)


        def MEMBER_SYMBOL(self):
            return self.getToken(MySQLParser.MEMBER_SYMBOL, 0)

        def simpleExprWithParentheses(self):
            return self.getTypedRuleContext(MySQLParser.SimpleExprWithParenthesesContext,0)


        def SOUNDS_SYMBOL(self):
            return self.getToken(MySQLParser.SOUNDS_SYMBOL, 0)

        def LIKE_SYMBOL(self):
            return self.getToken(MySQLParser.LIKE_SYMBOL, 0)

        def notRule(self):
            return self.getTypedRuleContext(MySQLParser.NotRuleContext,0)


        def OF_SYMBOL(self):
            return self.getToken(MySQLParser.OF_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_predicate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicate" ):
                listener.enterPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicate" ):
                listener.exitPredicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicate" ):
                return visitor.visitPredicate(self)
            else:
                return visitor.visitChildren(self)




    def predicate(self):

        localctx = MySQLParser.PredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 918, self.RULE_predicate)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6329
            self.bitExpr(0)
            self.state = 6343
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,756,self._ctx)
            if la_ == 1:
                self.state = 6331
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==1 or _la==390:
                    self.state = 6330
                    self.notRule()


                self.state = 6333
                self.predicateOperations()

            elif la_ == 2:
                self.state = 6334
                if not self.isServerVersionGe80017():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80017()")
                self.state = 6335
                self.match(MySQLParser.MEMBER_SYMBOL)
                self.state = 6337
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==676:
                    self.state = 6336
                    self.match(MySQLParser.OF_SYMBOL)


                self.state = 6339
                self.simpleExprWithParentheses()

            elif la_ == 3:
                self.state = 6340
                self.match(MySQLParser.SOUNDS_SYMBOL)
                self.state = 6341
                self.match(MySQLParser.LIKE_SYMBOL)
                self.state = 6342
                self.bitExpr(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredicateOperationsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MySQLParser.RULE_predicateOperations

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class PredicateExprRegexContext(PredicateOperationsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.PredicateOperationsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def REGEXP_SYMBOL(self):
            return self.getToken(MySQLParser.REGEXP_SYMBOL, 0)
        def bitExpr(self):
            return self.getTypedRuleContext(MySQLParser.BitExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicateExprRegex" ):
                listener.enterPredicateExprRegex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicateExprRegex" ):
                listener.exitPredicateExprRegex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicateExprRegex" ):
                return visitor.visitPredicateExprRegex(self)
            else:
                return visitor.visitChildren(self)


    class PredicateExprBetweenContext(PredicateOperationsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.PredicateOperationsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BETWEEN_SYMBOL(self):
            return self.getToken(MySQLParser.BETWEEN_SYMBOL, 0)
        def bitExpr(self):
            return self.getTypedRuleContext(MySQLParser.BitExprContext,0)

        def AND_SYMBOL(self):
            return self.getToken(MySQLParser.AND_SYMBOL, 0)
        def predicate(self):
            return self.getTypedRuleContext(MySQLParser.PredicateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicateExprBetween" ):
                listener.enterPredicateExprBetween(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicateExprBetween" ):
                listener.exitPredicateExprBetween(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicateExprBetween" ):
                return visitor.visitPredicateExprBetween(self)
            else:
                return visitor.visitChildren(self)


    class PredicateExprInContext(PredicateOperationsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.PredicateOperationsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IN_SYMBOL(self):
            return self.getToken(MySQLParser.IN_SYMBOL, 0)
        def subquery(self):
            return self.getTypedRuleContext(MySQLParser.SubqueryContext,0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)
        def exprList(self):
            return self.getTypedRuleContext(MySQLParser.ExprListContext,0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicateExprIn" ):
                listener.enterPredicateExprIn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicateExprIn" ):
                listener.exitPredicateExprIn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicateExprIn" ):
                return visitor.visitPredicateExprIn(self)
            else:
                return visitor.visitChildren(self)


    class PredicateExprLikeContext(PredicateOperationsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.PredicateOperationsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LIKE_SYMBOL(self):
            return self.getToken(MySQLParser.LIKE_SYMBOL, 0)
        def simpleExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.SimpleExprContext)
            else:
                return self.getTypedRuleContext(MySQLParser.SimpleExprContext,i)

        def ESCAPE_SYMBOL(self):
            return self.getToken(MySQLParser.ESCAPE_SYMBOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicateExprLike" ):
                listener.enterPredicateExprLike(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicateExprLike" ):
                listener.exitPredicateExprLike(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicateExprLike" ):
                return visitor.visitPredicateExprLike(self)
            else:
                return visitor.visitChildren(self)



    def predicateOperations(self):

        localctx = MySQLParser.PredicateOperationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 920, self.RULE_predicateOperations)
        try:
            self.state = 6366
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [282]:
                localctx = MySQLParser.PredicateExprInContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 6345
                self.match(MySQLParser.IN_SYMBOL)
                self.state = 6351
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,757,self._ctx)
                if la_ == 1:
                    self.state = 6346
                    self.subquery()
                    pass

                elif la_ == 2:
                    self.state = 6347
                    self.match(MySQLParser.OPEN_PAR_SYMBOL)
                    self.state = 6348
                    self.exprList()
                    self.state = 6349
                    self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                    pass


                pass
            elif token in [75]:
                localctx = MySQLParser.PredicateExprBetweenContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 6353
                self.match(MySQLParser.BETWEEN_SYMBOL)
                self.state = 6354
                self.bitExpr(0)
                self.state = 6355
                self.match(MySQLParser.AND_SYMBOL)
                self.state = 6356
                self.predicate()
                pass
            elif token in [305]:
                localctx = MySQLParser.PredicateExprLikeContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 6358
                self.match(MySQLParser.LIKE_SYMBOL)
                self.state = 6359
                self.simpleExpr(0)
                self.state = 6362
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,758,self._ctx)
                if la_ == 1:
                    self.state = 6360
                    self.match(MySQLParser.ESCAPE_SYMBOL)
                    self.state = 6361
                    self.simpleExpr(0)


                pass
            elif token in [461]:
                localctx = MySQLParser.PredicateExprRegexContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 6364
                self.match(MySQLParser.REGEXP_SYMBOL)
                self.state = 6365
                self.bitExpr(0)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BitExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.op = None # Token

        def simpleExpr(self):
            return self.getTypedRuleContext(MySQLParser.SimpleExprContext,0)


        def bitExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.BitExprContext)
            else:
                return self.getTypedRuleContext(MySQLParser.BitExprContext,i)


        def BITWISE_XOR_OPERATOR(self):
            return self.getToken(MySQLParser.BITWISE_XOR_OPERATOR, 0)

        def MULT_OPERATOR(self):
            return self.getToken(MySQLParser.MULT_OPERATOR, 0)

        def DIV_OPERATOR(self):
            return self.getToken(MySQLParser.DIV_OPERATOR, 0)

        def MOD_OPERATOR(self):
            return self.getToken(MySQLParser.MOD_OPERATOR, 0)

        def DIV_SYMBOL(self):
            return self.getToken(MySQLParser.DIV_SYMBOL, 0)

        def MOD_SYMBOL(self):
            return self.getToken(MySQLParser.MOD_SYMBOL, 0)

        def PLUS_OPERATOR(self):
            return self.getToken(MySQLParser.PLUS_OPERATOR, 0)

        def MINUS_OPERATOR(self):
            return self.getToken(MySQLParser.MINUS_OPERATOR, 0)

        def SHIFT_LEFT_OPERATOR(self):
            return self.getToken(MySQLParser.SHIFT_LEFT_OPERATOR, 0)

        def SHIFT_RIGHT_OPERATOR(self):
            return self.getToken(MySQLParser.SHIFT_RIGHT_OPERATOR, 0)

        def BITWISE_AND_OPERATOR(self):
            return self.getToken(MySQLParser.BITWISE_AND_OPERATOR, 0)

        def BITWISE_OR_OPERATOR(self):
            return self.getToken(MySQLParser.BITWISE_OR_OPERATOR, 0)

        def INTERVAL_SYMBOL(self):
            return self.getToken(MySQLParser.INTERVAL_SYMBOL, 0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def interval(self):
            return self.getTypedRuleContext(MySQLParser.IntervalContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_bitExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitExpr" ):
                listener.enterBitExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitExpr" ):
                listener.exitBitExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBitExpr" ):
                return visitor.visitBitExpr(self)
            else:
                return visitor.visitChildren(self)



    def bitExpr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MySQLParser.BitExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 922
        self.enterRecursionRule(localctx, 922, self.RULE_bitExpr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6369
            self.simpleExpr(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 6397
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,761,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 6395
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,760,self._ctx)
                    if la_ == 1:
                        localctx = MySQLParser.BitExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_bitExpr)
                        self.state = 6371
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 6372
                        localctx.op = self.match(MySQLParser.BITWISE_XOR_OPERATOR)
                        self.state = 6373
                        self.bitExpr(8)
                        pass

                    elif la_ == 2:
                        localctx = MySQLParser.BitExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_bitExpr)
                        self.state = 6374
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 6375
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 458752) != 0) or _la==181 or _la==372):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 6376
                        self.bitExpr(7)
                        pass

                    elif la_ == 3:
                        localctx = MySQLParser.BitExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_bitExpr)
                        self.state = 6377
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 6378
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==14 or _la==15):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 6379
                        self.bitExpr(6)
                        pass

                    elif la_ == 4:
                        localctx = MySQLParser.BitExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_bitExpr)
                        self.state = 6380
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 6381
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==21 or _la==22):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 6382
                        self.bitExpr(4)
                        pass

                    elif la_ == 5:
                        localctx = MySQLParser.BitExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_bitExpr)
                        self.state = 6383
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 6384
                        localctx.op = self.match(MySQLParser.BITWISE_AND_OPERATOR)
                        self.state = 6385
                        self.bitExpr(3)
                        pass

                    elif la_ == 6:
                        localctx = MySQLParser.BitExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_bitExpr)
                        self.state = 6386
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 6387
                        localctx.op = self.match(MySQLParser.BITWISE_OR_OPERATOR)
                        self.state = 6388
                        self.bitExpr(2)
                        pass

                    elif la_ == 7:
                        localctx = MySQLParser.BitExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_bitExpr)
                        self.state = 6389
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 6390
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==14 or _la==15):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 6391
                        self.match(MySQLParser.INTERVAL_SYMBOL)
                        self.state = 6392
                        self.expr(0)
                        self.state = 6393
                        self.interval()
                        pass

             
                self.state = 6399
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,761,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class SimpleExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MySQLParser.RULE_simpleExpr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class SimpleExprConvertContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CONVERT_SYMBOL(self):
            return self.getToken(MySQLParser.CONVERT_SYMBOL, 0)
        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)
        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)

        def COMMA_SYMBOL(self):
            return self.getToken(MySQLParser.COMMA_SYMBOL, 0)
        def castType(self):
            return self.getTypedRuleContext(MySQLParser.CastTypeContext,0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprConvert" ):
                listener.enterSimpleExprConvert(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprConvert" ):
                listener.exitSimpleExprConvert(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprConvert" ):
                return visitor.visitSimpleExprConvert(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprCastContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CAST_SYMBOL(self):
            return self.getToken(MySQLParser.CAST_SYMBOL, 0)
        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)
        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)

        def AS_SYMBOL(self):
            return self.getToken(MySQLParser.AS_SYMBOL, 0)
        def castType(self):
            return self.getTypedRuleContext(MySQLParser.CastTypeContext,0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)
        def AT_SYMBOL(self):
            return self.getToken(MySQLParser.AT_SYMBOL, 0)
        def LOCAL_SYMBOL(self):
            return self.getToken(MySQLParser.LOCAL_SYMBOL, 0)
        def arrayCast(self):
            return self.getTypedRuleContext(MySQLParser.ArrayCastContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprCast" ):
                listener.enterSimpleExprCast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprCast" ):
                listener.exitSimpleExprCast(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprCast" ):
                return visitor.visitSimpleExprCast(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprUnaryContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def simpleExpr(self):
            return self.getTypedRuleContext(MySQLParser.SimpleExprContext,0)

        def PLUS_OPERATOR(self):
            return self.getToken(MySQLParser.PLUS_OPERATOR, 0)
        def MINUS_OPERATOR(self):
            return self.getToken(MySQLParser.MINUS_OPERATOR, 0)
        def BITWISE_NOT_OPERATOR(self):
            return self.getToken(MySQLParser.BITWISE_NOT_OPERATOR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprUnary" ):
                listener.enterSimpleExprUnary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprUnary" ):
                listener.exitSimpleExprUnary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprUnary" ):
                return visitor.visitSimpleExprUnary(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExpressionRValueContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def rvalueSystemOrUserVariable(self):
            return self.getTypedRuleContext(MySQLParser.RvalueSystemOrUserVariableContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExpressionRValue" ):
                listener.enterSimpleExpressionRValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExpressionRValue" ):
                listener.exitSimpleExpressionRValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExpressionRValue" ):
                return visitor.visitSimpleExpressionRValue(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprOdbcContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OPEN_CURLY_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_CURLY_SYMBOL, 0)
        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)

        def CLOSE_CURLY_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_CURLY_SYMBOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprOdbc" ):
                listener.enterSimpleExprOdbc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprOdbc" ):
                listener.exitSimpleExprOdbc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprOdbc" ):
                return visitor.visitSimpleExprOdbc(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprRuntimeFunctionContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def runtimeFunctionCall(self):
            return self.getTypedRuleContext(MySQLParser.RuntimeFunctionCallContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprRuntimeFunction" ):
                listener.enterSimpleExprRuntimeFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprRuntimeFunction" ):
                listener.exitSimpleExprRuntimeFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprRuntimeFunction" ):
                return visitor.visitSimpleExprRuntimeFunction(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprFunctionContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def functionCall(self):
            return self.getTypedRuleContext(MySQLParser.FunctionCallContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprFunction" ):
                listener.enterSimpleExprFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprFunction" ):
                listener.exitSimpleExprFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprFunction" ):
                return visitor.visitSimpleExprFunction(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprCollateContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def simpleExpr(self):
            return self.getTypedRuleContext(MySQLParser.SimpleExprContext,0)

        def COLLATE_SYMBOL(self):
            return self.getToken(MySQLParser.COLLATE_SYMBOL, 0)
        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprCollate" ):
                listener.enterSimpleExprCollate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprCollate" ):
                listener.exitSimpleExprCollate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprCollate" ):
                return visitor.visitSimpleExprCollate(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprMatchContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MATCH_SYMBOL(self):
            return self.getToken(MySQLParser.MATCH_SYMBOL, 0)
        def identListArg(self):
            return self.getTypedRuleContext(MySQLParser.IdentListArgContext,0)

        def AGAINST_SYMBOL(self):
            return self.getToken(MySQLParser.AGAINST_SYMBOL, 0)
        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)
        def bitExpr(self):
            return self.getTypedRuleContext(MySQLParser.BitExprContext,0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)
        def fulltextOptions(self):
            return self.getTypedRuleContext(MySQLParser.FulltextOptionsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprMatch" ):
                listener.enterSimpleExprMatch(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprMatch" ):
                listener.exitSimpleExprMatch(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprMatch" ):
                return visitor.visitSimpleExprMatch(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprWindowingFunctionContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def windowFunctionCall(self):
            return self.getTypedRuleContext(MySQLParser.WindowFunctionCallContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprWindowingFunction" ):
                listener.enterSimpleExprWindowingFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprWindowingFunction" ):
                listener.exitSimpleExprWindowingFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprWindowingFunction" ):
                return visitor.visitSimpleExprWindowingFunction(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprBinaryContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BINARY_SYMBOL(self):
            return self.getToken(MySQLParser.BINARY_SYMBOL, 0)
        def simpleExpr(self):
            return self.getTypedRuleContext(MySQLParser.SimpleExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprBinary" ):
                listener.enterSimpleExprBinary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprBinary" ):
                listener.exitSimpleExprBinary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprBinary" ):
                return visitor.visitSimpleExprBinary(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprColumnRefContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def columnRef(self):
            return self.getTypedRuleContext(MySQLParser.ColumnRefContext,0)

        def jsonOperator(self):
            return self.getTypedRuleContext(MySQLParser.JsonOperatorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprColumnRef" ):
                listener.enterSimpleExprColumnRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprColumnRef" ):
                listener.exitSimpleExprColumnRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprColumnRef" ):
                return visitor.visitSimpleExprColumnRef(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprParamMarkerContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PARAM_MARKER(self):
            return self.getToken(MySQLParser.PARAM_MARKER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprParamMarker" ):
                listener.enterSimpleExprParamMarker(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprParamMarker" ):
                listener.exitSimpleExprParamMarker(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprParamMarker" ):
                return visitor.visitSimpleExprParamMarker(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprSumContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def sumExpr(self):
            return self.getTypedRuleContext(MySQLParser.SumExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprSum" ):
                listener.enterSimpleExprSum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprSum" ):
                listener.exitSimpleExprSum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprSum" ):
                return visitor.visitSimpleExprSum(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprCastTimeContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CAST_SYMBOL(self):
            return self.getToken(MySQLParser.CAST_SYMBOL, 0)
        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)
        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)

        def AT_SYMBOL(self):
            return self.getToken(MySQLParser.AT_SYMBOL, 0)
        def TIME_SYMBOL(self):
            return self.getToken(MySQLParser.TIME_SYMBOL, 0)
        def ZONE_SYMBOL(self):
            return self.getToken(MySQLParser.ZONE_SYMBOL, 0)
        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)

        def AS_SYMBOL(self):
            return self.getToken(MySQLParser.AS_SYMBOL, 0)
        def DATETIME_SYMBOL(self):
            return self.getToken(MySQLParser.DATETIME_SYMBOL, 0)
        def typeDatetimePrecision(self):
            return self.getTypedRuleContext(MySQLParser.TypeDatetimePrecisionContext,0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)
        def INTERVAL_SYMBOL(self):
            return self.getToken(MySQLParser.INTERVAL_SYMBOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprCastTime" ):
                listener.enterSimpleExprCastTime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprCastTime" ):
                listener.exitSimpleExprCastTime(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprCastTime" ):
                return visitor.visitSimpleExprCastTime(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprConvertUsingContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CONVERT_SYMBOL(self):
            return self.getToken(MySQLParser.CONVERT_SYMBOL, 0)
        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)
        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)

        def USING_SYMBOL(self):
            return self.getToken(MySQLParser.USING_SYMBOL, 0)
        def charsetName(self):
            return self.getTypedRuleContext(MySQLParser.CharsetNameContext,0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprConvertUsing" ):
                listener.enterSimpleExprConvertUsing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprConvertUsing" ):
                listener.exitSimpleExprConvertUsing(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprConvertUsing" ):
                return visitor.visitSimpleExprConvertUsing(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprSubQueryContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def subquery(self):
            return self.getTypedRuleContext(MySQLParser.SubqueryContext,0)

        def EXISTS_SYMBOL(self):
            return self.getToken(MySQLParser.EXISTS_SYMBOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprSubQuery" ):
                listener.enterSimpleExprSubQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprSubQuery" ):
                listener.exitSimpleExprSubQuery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprSubQuery" ):
                return visitor.visitSimpleExprSubQuery(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprGroupingOperationContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def groupingOperation(self):
            return self.getTypedRuleContext(MySQLParser.GroupingOperationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprGroupingOperation" ):
                listener.enterSimpleExprGroupingOperation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprGroupingOperation" ):
                listener.exitSimpleExprGroupingOperation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprGroupingOperation" ):
                return visitor.visitSimpleExprGroupingOperation(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprNotContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def not2Rule(self):
            return self.getTypedRuleContext(MySQLParser.Not2RuleContext,0)

        def simpleExpr(self):
            return self.getTypedRuleContext(MySQLParser.SimpleExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprNot" ):
                listener.enterSimpleExprNot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprNot" ):
                listener.exitSimpleExprNot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprNot" ):
                return visitor.visitSimpleExprNot(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprValuesContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VALUES_SYMBOL(self):
            return self.getToken(MySQLParser.VALUES_SYMBOL, 0)
        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)
        def simpleIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.SimpleIdentifierContext,0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprValues" ):
                listener.enterSimpleExprValues(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprValues" ):
                listener.exitSimpleExprValues(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprValues" ):
                return visitor.visitSimpleExprValues(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprUserVariableAssignmentContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def inExpressionUserVariableAssignment(self):
            return self.getTypedRuleContext(MySQLParser.InExpressionUserVariableAssignmentContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprUserVariableAssignment" ):
                listener.enterSimpleExprUserVariableAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprUserVariableAssignment" ):
                listener.exitSimpleExprUserVariableAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprUserVariableAssignment" ):
                return visitor.visitSimpleExprUserVariableAssignment(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprDefaultContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)
        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)
        def simpleIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.SimpleIdentifierContext,0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprDefault" ):
                listener.enterSimpleExprDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprDefault" ):
                listener.exitSimpleExprDefault(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprDefault" ):
                return visitor.visitSimpleExprDefault(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprListContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)
        def exprList(self):
            return self.getTypedRuleContext(MySQLParser.ExprListContext,0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)
        def ROW_SYMBOL(self):
            return self.getToken(MySQLParser.ROW_SYMBOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprList" ):
                listener.enterSimpleExprList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprList" ):
                listener.exitSimpleExprList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprList" ):
                return visitor.visitSimpleExprList(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprIntervalContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INTERVAL_SYMBOL(self):
            return self.getToken(MySQLParser.INTERVAL_SYMBOL, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ExprContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ExprContext,i)

        def interval(self):
            return self.getTypedRuleContext(MySQLParser.IntervalContext,0)

        def PLUS_OPERATOR(self):
            return self.getToken(MySQLParser.PLUS_OPERATOR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprInterval" ):
                listener.enterSimpleExprInterval(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprInterval" ):
                listener.exitSimpleExprInterval(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprInterval" ):
                return visitor.visitSimpleExprInterval(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprCaseContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CASE_SYMBOL(self):
            return self.getToken(MySQLParser.CASE_SYMBOL, 0)
        def END_SYMBOL(self):
            return self.getToken(MySQLParser.END_SYMBOL, 0)
        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)

        def whenExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.WhenExpressionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.WhenExpressionContext,i)

        def thenExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ThenExpressionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ThenExpressionContext,i)

        def elseExpression(self):
            return self.getTypedRuleContext(MySQLParser.ElseExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprCase" ):
                listener.enterSimpleExprCase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprCase" ):
                listener.exitSimpleExprCase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprCase" ):
                return visitor.visitSimpleExprCase(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprConcatContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def simpleExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.SimpleExprContext)
            else:
                return self.getTypedRuleContext(MySQLParser.SimpleExprContext,i)

        def CONCAT_PIPES_SYMBOL(self):
            return self.getToken(MySQLParser.CONCAT_PIPES_SYMBOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprConcat" ):
                listener.enterSimpleExprConcat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprConcat" ):
                listener.exitSimpleExprConcat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprConcat" ):
                return visitor.visitSimpleExprConcat(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprLiteralContext(SimpleExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.SimpleExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def literalOrNull(self):
            return self.getTypedRuleContext(MySQLParser.LiteralOrNullContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprLiteral" ):
                listener.enterSimpleExprLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprLiteral" ):
                listener.exitSimpleExprLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprLiteral" ):
                return visitor.visitSimpleExprLiteral(self)
            else:
                return visitor.visitChildren(self)



    def simpleExpr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MySQLParser.SimpleExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 924
        self.enterRecursionRule(localctx, 924, self.RULE_simpleExpr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6522
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,772,self._ctx)
            if la_ == 1:
                localctx = MySQLParser.SimpleExprColumnRefContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 6401
                self.columnRef()
                self.state = 6403
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,762,self._ctx)
                if la_ == 1:
                    self.state = 6402
                    self.jsonOperator()


                pass

            elif la_ == 2:
                localctx = MySQLParser.SimpleExprRuntimeFunctionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6405
                self.runtimeFunctionCall()
                pass

            elif la_ == 3:
                localctx = MySQLParser.SimpleExprFunctionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6406
                self.functionCall()
                pass

            elif la_ == 4:
                localctx = MySQLParser.SimpleExprLiteralContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6407
                self.literalOrNull()
                pass

            elif la_ == 5:
                localctx = MySQLParser.SimpleExprParamMarkerContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6408
                self.match(MySQLParser.PARAM_MARKER)
                pass

            elif la_ == 6:
                localctx = MySQLParser.SimpleExpressionRValueContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6409
                self.rvalueSystemOrUserVariable()
                pass

            elif la_ == 7:
                localctx = MySQLParser.SimpleExprUserVariableAssignmentContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6410
                self.inExpressionUserVariableAssignment()
                pass

            elif la_ == 8:
                localctx = MySQLParser.SimpleExprSumContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6411
                self.sumExpr()
                pass

            elif la_ == 9:
                localctx = MySQLParser.SimpleExprGroupingOperationContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6412
                self.groupingOperation()
                pass

            elif la_ == 10:
                localctx = MySQLParser.SimpleExprWindowingFunctionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6413
                self.windowFunctionCall()
                pass

            elif la_ == 11:
                localctx = MySQLParser.SimpleExprUnaryContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6414
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1097728) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 6415
                self.simpleExpr(15)
                pass

            elif la_ == 12:
                localctx = MySQLParser.SimpleExprNotContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6416
                self.not2Rule()
                self.state = 6417
                self.simpleExpr(14)
                pass

            elif la_ == 13:
                localctx = MySQLParser.SimpleExprListContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6420
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==503:
                    self.state = 6419
                    self.match(MySQLParser.ROW_SYMBOL)


                self.state = 6422
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6423
                self.exprList()
                self.state = 6424
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 14:
                localctx = MySQLParser.SimpleExprSubQueryContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6427
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==209:
                    self.state = 6426
                    self.match(MySQLParser.EXISTS_SYMBOL)


                self.state = 6429
                self.subquery()
                pass

            elif la_ == 15:
                localctx = MySQLParser.SimpleExprOdbcContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6430
                self.match(MySQLParser.OPEN_CURLY_SYMBOL)
                self.state = 6431
                self.identifier()
                self.state = 6432
                self.expr(0)
                self.state = 6433
                self.match(MySQLParser.CLOSE_CURLY_SYMBOL)
                pass

            elif la_ == 16:
                localctx = MySQLParser.SimpleExprMatchContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6435
                self.match(MySQLParser.MATCH_SYMBOL)
                self.state = 6436
                self.identListArg()
                self.state = 6437
                self.match(MySQLParser.AGAINST_SYMBOL)
                self.state = 6438
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6439
                self.bitExpr(0)
                self.state = 6441
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==282 or _la==653:
                    self.state = 6440
                    self.fulltextOptions()


                self.state = 6443
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 17:
                localctx = MySQLParser.SimpleExprBinaryContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6445
                self.match(MySQLParser.BINARY_SYMBOL)
                self.state = 6446
                self.simpleExpr(9)
                pass

            elif la_ == 18:
                localctx = MySQLParser.SimpleExprCastContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6447
                self.match(MySQLParser.CAST_SYMBOL)
                self.state = 6448
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6449
                self.expr(0)
                self.state = 6452
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==67:
                    self.state = 6450
                    self.match(MySQLParser.AT_SYMBOL)
                    self.state = 6451
                    self.match(MySQLParser.LOCAL_SYMBOL)


                self.state = 6454
                self.match(MySQLParser.AS_SYMBOL)
                self.state = 6455
                self.castType()
                self.state = 6457
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,767,self._ctx)
                if la_ == 1:
                    self.state = 6456
                    self.arrayCast()


                self.state = 6459
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 19:
                localctx = MySQLParser.SimpleExprCastTimeContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6461
                self.match(MySQLParser.CAST_SYMBOL)
                self.state = 6462
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6463
                self.expr(0)
                self.state = 6464
                self.match(MySQLParser.AT_SYMBOL)
                self.state = 6465
                self.match(MySQLParser.TIME_SYMBOL)
                self.state = 6466
                self.match(MySQLParser.ZONE_SYMBOL)
                self.state = 6468
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,768,self._ctx)
                if la_ == 1:
                    self.state = 6467
                    self.match(MySQLParser.INTERVAL_SYMBOL)


                self.state = 6470
                self.textStringLiteral()
                self.state = 6471
                self.match(MySQLParser.AS_SYMBOL)
                self.state = 6472
                self.match(MySQLParser.DATETIME_SYMBOL)
                self.state = 6473
                self.typeDatetimePrecision()
                self.state = 6474
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 20:
                localctx = MySQLParser.SimpleExprCaseContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6476
                self.match(MySQLParser.CASE_SYMBOL)
                self.state = 6478
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,769,self._ctx)
                if la_ == 1:
                    self.state = 6477
                    self.expr(0)


                self.state = 6483 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 6480
                    self.whenExpression()
                    self.state = 6481
                    self.thenExpression()
                    self.state = 6485 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==650):
                        break

                self.state = 6488
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==190:
                    self.state = 6487
                    self.elseExpression()


                self.state = 6490
                self.match(MySQLParser.END_SYMBOL)
                pass

            elif la_ == 21:
                localctx = MySQLParser.SimpleExprConvertContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6492
                self.match(MySQLParser.CONVERT_SYMBOL)
                self.state = 6493
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6494
                self.expr(0)
                self.state = 6495
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6496
                self.castType()
                self.state = 6497
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 22:
                localctx = MySQLParser.SimpleExprConvertUsingContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6499
                self.match(MySQLParser.CONVERT_SYMBOL)
                self.state = 6500
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6501
                self.expr(0)
                self.state = 6502
                self.match(MySQLParser.USING_SYMBOL)
                self.state = 6503
                self.charsetName()
                self.state = 6504
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 23:
                localctx = MySQLParser.SimpleExprDefaultContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6506
                self.match(MySQLParser.DEFAULT_SYMBOL)
                self.state = 6507
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6508
                self.simpleIdentifier()
                self.state = 6509
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 24:
                localctx = MySQLParser.SimpleExprValuesContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6511
                self.match(MySQLParser.VALUES_SYMBOL)
                self.state = 6512
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6513
                self.simpleIdentifier()
                self.state = 6514
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 25:
                localctx = MySQLParser.SimpleExprIntervalContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 6516
                self.match(MySQLParser.INTERVAL_SYMBOL)
                self.state = 6517
                self.expr(0)
                self.state = 6518
                self.interval()
                self.state = 6519
                self.match(MySQLParser.PLUS_OPERATOR)
                self.state = 6520
                self.expr(0)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 6532
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,774,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 6530
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,773,self._ctx)
                    if la_ == 1:
                        localctx = MySQLParser.SimpleExprConcatContext(self, MySQLParser.SimpleExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_simpleExpr)
                        self.state = 6524
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 6525
                        self.match(MySQLParser.CONCAT_PIPES_SYMBOL)
                        self.state = 6526
                        self.simpleExpr(17)
                        pass

                    elif la_ == 2:
                        localctx = MySQLParser.SimpleExprCollateContext(self, MySQLParser.SimpleExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_simpleExpr)
                        self.state = 6527
                        if not self.precpred(self._ctx, 24):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 24)")
                        self.state = 6528
                        self.match(MySQLParser.COLLATE_SYMBOL)
                        self.state = 6529
                        self.textOrIdentifier()
                        pass

             
                self.state = 6534
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,774,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ArrayCastContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ARRAY_SYMBOL(self):
            return self.getToken(MySQLParser.ARRAY_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_arrayCast

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayCast" ):
                listener.enterArrayCast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayCast" ):
                listener.exitArrayCast(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayCast" ):
                return visitor.visitArrayCast(self)
            else:
                return visitor.visitChildren(self)




    def arrayCast(self):

        localctx = MySQLParser.ArrayCastContext(self, self._ctx, self.state)
        self.enterRule(localctx, 926, self.RULE_arrayCast)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6535
            if not self.isServerVersionGe80017():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.isServerVersionGe80017()")
            self.state = 6536
            self.match(MySQLParser.ARRAY_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JsonOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def JSON_SEPARATOR_SYMBOL(self):
            return self.getToken(MySQLParser.JSON_SEPARATOR_SYMBOL, 0)

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def JSON_UNQUOTED_SEPARATOR_SYMBOL(self):
            return self.getToken(MySQLParser.JSON_UNQUOTED_SEPARATOR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_jsonOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJsonOperator" ):
                listener.enterJsonOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJsonOperator" ):
                listener.exitJsonOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJsonOperator" ):
                return visitor.visitJsonOperator(self)
            else:
                return visitor.visitChildren(self)




    def jsonOperator(self):

        localctx = MySQLParser.JsonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 928, self.RULE_jsonOperator)
        try:
            self.state = 6542
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [37]:
                self.enterOuterAlt(localctx, 1)
                self.state = 6538
                self.match(MySQLParser.JSON_SEPARATOR_SYMBOL)
                self.state = 6539
                self.textStringLiteral()
                pass
            elif token in [38]:
                self.enterOuterAlt(localctx, 2)
                self.state = 6540
                self.match(MySQLParser.JSON_UNQUOTED_SEPARATOR_SYMBOL)
                self.state = 6541
                self.textStringLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SumExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def inSumExpr(self):
            return self.getTypedRuleContext(MySQLParser.InSumExprContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def AVG_SYMBOL(self):
            return self.getToken(MySQLParser.AVG_SYMBOL, 0)

        def DISTINCT_SYMBOL(self):
            return self.getToken(MySQLParser.DISTINCT_SYMBOL, 0)

        def windowingClause(self):
            return self.getTypedRuleContext(MySQLParser.WindowingClauseContext,0)


        def BIT_AND_SYMBOL(self):
            return self.getToken(MySQLParser.BIT_AND_SYMBOL, 0)

        def BIT_OR_SYMBOL(self):
            return self.getToken(MySQLParser.BIT_OR_SYMBOL, 0)

        def BIT_XOR_SYMBOL(self):
            return self.getToken(MySQLParser.BIT_XOR_SYMBOL, 0)

        def jsonFunction(self):
            return self.getTypedRuleContext(MySQLParser.JsonFunctionContext,0)


        def ST_COLLECT_SYMBOL(self):
            return self.getToken(MySQLParser.ST_COLLECT_SYMBOL, 0)

        def COUNT_SYMBOL(self):
            return self.getToken(MySQLParser.COUNT_SYMBOL, 0)

        def MULT_OPERATOR(self):
            return self.getToken(MySQLParser.MULT_OPERATOR, 0)

        def exprList(self):
            return self.getTypedRuleContext(MySQLParser.ExprListContext,0)


        def ALL_SYMBOL(self):
            return self.getToken(MySQLParser.ALL_SYMBOL, 0)

        def MIN_SYMBOL(self):
            return self.getToken(MySQLParser.MIN_SYMBOL, 0)

        def MAX_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_SYMBOL, 0)

        def STD_SYMBOL(self):
            return self.getToken(MySQLParser.STD_SYMBOL, 0)

        def VARIANCE_SYMBOL(self):
            return self.getToken(MySQLParser.VARIANCE_SYMBOL, 0)

        def STDDEV_SAMP_SYMBOL(self):
            return self.getToken(MySQLParser.STDDEV_SAMP_SYMBOL, 0)

        def VAR_SAMP_SYMBOL(self):
            return self.getToken(MySQLParser.VAR_SAMP_SYMBOL, 0)

        def SUM_SYMBOL(self):
            return self.getToken(MySQLParser.SUM_SYMBOL, 0)

        def GROUP_CONCAT_SYMBOL(self):
            return self.getToken(MySQLParser.GROUP_CONCAT_SYMBOL, 0)

        def orderClause(self):
            return self.getTypedRuleContext(MySQLParser.OrderClauseContext,0)


        def SEPARATOR_SYMBOL(self):
            return self.getToken(MySQLParser.SEPARATOR_SYMBOL, 0)

        def textString(self):
            return self.getTypedRuleContext(MySQLParser.TextStringContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_sumExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSumExpr" ):
                listener.enterSumExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSumExpr" ):
                listener.exitSumExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSumExpr" ):
                return visitor.visitSumExpr(self)
            else:
                return visitor.visitChildren(self)




    def sumExpr(self):

        localctx = MySQLParser.SumExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 930, self.RULE_sumExpr)
        self._la = 0 # Token type
        try:
            self.state = 6629
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,792,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 6544
                localctx.name = self.match(MySQLParser.AVG_SYMBOL)
                self.state = 6545
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6547
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,776,self._ctx)
                if la_ == 1:
                    self.state = 6546
                    self.match(MySQLParser.DISTINCT_SYMBOL)


                self.state = 6549
                self.inSumExpr()
                self.state = 6550
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                self.state = 6552
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,777,self._ctx)
                if la_ == 1:
                    self.state = 6551
                    self.windowingClause()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 6554
                localctx.name = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 79)) & ~0x3f) == 0 and ((1 << (_la - 79)) & 11) != 0)):
                    localctx.name = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 6555
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6556
                self.inSumExpr()
                self.state = 6557
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                self.state = 6559
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,778,self._ctx)
                if la_ == 1:
                    self.state = 6558
                    self.windowingClause()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 6561
                self.jsonFunction()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 6562
                localctx.name = self.match(MySQLParser.ST_COLLECT_SYMBOL)
                self.state = 6563
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6565
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,779,self._ctx)
                if la_ == 1:
                    self.state = 6564
                    self.match(MySQLParser.DISTINCT_SYMBOL)


                self.state = 6567
                self.inSumExpr()
                self.state = 6568
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                self.state = 6570
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,780,self._ctx)
                if la_ == 1:
                    self.state = 6569
                    self.windowingClause()


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 6572
                localctx.name = self.match(MySQLParser.COUNT_SYMBOL)
                self.state = 6573
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6581
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,782,self._ctx)
                if la_ == 1:
                    self.state = 6575
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==57:
                        self.state = 6574
                        self.match(MySQLParser.ALL_SYMBOL)


                    self.state = 6577
                    self.match(MySQLParser.MULT_OPERATOR)
                    pass

                elif la_ == 2:
                    self.state = 6578
                    self.inSumExpr()
                    pass

                elif la_ == 3:
                    self.state = 6579
                    self.match(MySQLParser.DISTINCT_SYMBOL)
                    self.state = 6580
                    self.exprList()
                    pass


                self.state = 6583
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                self.state = 6585
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,783,self._ctx)
                if la_ == 1:
                    self.state = 6584
                    self.windowingClause()


                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 6587
                localctx.name = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==350 or _la==368):
                    localctx.name = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 6588
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6590
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,784,self._ctx)
                if la_ == 1:
                    self.state = 6589
                    self.match(MySQLParser.DISTINCT_SYMBOL)


                self.state = 6592
                self.inSumExpr()
                self.state = 6593
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                self.state = 6595
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,785,self._ctx)
                if la_ == 1:
                    self.state = 6594
                    self.windowingClause()


                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 6597
                localctx.name = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 558)) & ~0x3f) == 0 and ((1 << (_la - 558)) & 65545) != 0) or _la==640 or _la==643):
                    localctx.name = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 6598
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6599
                self.inSumExpr()
                self.state = 6600
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                self.state = 6602
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,786,self._ctx)
                if la_ == 1:
                    self.state = 6601
                    self.windowingClause()


                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 6604
                localctx.name = self.match(MySQLParser.SUM_SYMBOL)
                self.state = 6605
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6606
                self.match(MySQLParser.DISTINCT_SYMBOL)
                self.state = 6607
                self.inSumExpr()
                self.state = 6608
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                self.state = 6610
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,787,self._ctx)
                if la_ == 1:
                    self.state = 6609
                    self.windowingClause()


                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 6612
                localctx.name = self.match(MySQLParser.GROUP_CONCAT_SYMBOL)
                self.state = 6613
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6615
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,788,self._ctx)
                if la_ == 1:
                    self.state = 6614
                    self.match(MySQLParser.DISTINCT_SYMBOL)


                self.state = 6617
                self.exprList()
                self.state = 6619
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==411:
                    self.state = 6618
                    self.orderClause()


                self.state = 6623
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==513:
                    self.state = 6621
                    self.match(MySQLParser.SEPARATOR_SYMBOL)
                    self.state = 6622
                    self.textString()


                self.state = 6625
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                self.state = 6627
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,791,self._ctx)
                if la_ == 1:
                    self.state = 6626
                    self.windowingClause()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupingOperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GROUPING_SYMBOL(self):
            return self.getToken(MySQLParser.GROUPING_SYMBOL, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def exprList(self):
            return self.getTypedRuleContext(MySQLParser.ExprListContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_groupingOperation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupingOperation" ):
                listener.enterGroupingOperation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupingOperation" ):
                listener.exitGroupingOperation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupingOperation" ):
                return visitor.visitGroupingOperation(self)
            else:
                return visitor.visitChildren(self)




    def groupingOperation(self):

        localctx = MySQLParser.GroupingOperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 932, self.RULE_groupingOperation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6631
            self.match(MySQLParser.GROUPING_SYMBOL)
            self.state = 6632
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 6633
            self.exprList()
            self.state = 6634
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowFunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parentheses(self):
            return self.getTypedRuleContext(MySQLParser.ParenthesesContext,0)


        def windowingClause(self):
            return self.getTypedRuleContext(MySQLParser.WindowingClauseContext,0)


        def ROW_NUMBER_SYMBOL(self):
            return self.getToken(MySQLParser.ROW_NUMBER_SYMBOL, 0)

        def RANK_SYMBOL(self):
            return self.getToken(MySQLParser.RANK_SYMBOL, 0)

        def DENSE_RANK_SYMBOL(self):
            return self.getToken(MySQLParser.DENSE_RANK_SYMBOL, 0)

        def CUME_DIST_SYMBOL(self):
            return self.getToken(MySQLParser.CUME_DIST_SYMBOL, 0)

        def PERCENT_RANK_SYMBOL(self):
            return self.getToken(MySQLParser.PERCENT_RANK_SYMBOL, 0)

        def NTILE_SYMBOL(self):
            return self.getToken(MySQLParser.NTILE_SYMBOL, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def stableInteger(self):
            return self.getTypedRuleContext(MySQLParser.StableIntegerContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def simpleExprWithParentheses(self):
            return self.getTypedRuleContext(MySQLParser.SimpleExprWithParenthesesContext,0)


        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def LEAD_SYMBOL(self):
            return self.getToken(MySQLParser.LEAD_SYMBOL, 0)

        def LAG_SYMBOL(self):
            return self.getToken(MySQLParser.LAG_SYMBOL, 0)

        def leadLagInfo(self):
            return self.getTypedRuleContext(MySQLParser.LeadLagInfoContext,0)


        def nullTreatment(self):
            return self.getTypedRuleContext(MySQLParser.NullTreatmentContext,0)


        def exprWithParentheses(self):
            return self.getTypedRuleContext(MySQLParser.ExprWithParenthesesContext,0)


        def FIRST_VALUE_SYMBOL(self):
            return self.getToken(MySQLParser.FIRST_VALUE_SYMBOL, 0)

        def LAST_VALUE_SYMBOL(self):
            return self.getToken(MySQLParser.LAST_VALUE_SYMBOL, 0)

        def NTH_VALUE_SYMBOL(self):
            return self.getToken(MySQLParser.NTH_VALUE_SYMBOL, 0)

        def COMMA_SYMBOL(self):
            return self.getToken(MySQLParser.COMMA_SYMBOL, 0)

        def simpleExpr(self):
            return self.getTypedRuleContext(MySQLParser.SimpleExprContext,0)


        def FROM_SYMBOL(self):
            return self.getToken(MySQLParser.FROM_SYMBOL, 0)

        def FIRST_SYMBOL(self):
            return self.getToken(MySQLParser.FIRST_SYMBOL, 0)

        def LAST_SYMBOL(self):
            return self.getToken(MySQLParser.LAST_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_windowFunctionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowFunctionCall" ):
                listener.enterWindowFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowFunctionCall" ):
                listener.exitWindowFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowFunctionCall" ):
                return visitor.visitWindowFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def windowFunctionCall(self):

        localctx = MySQLParser.WindowFunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 934, self.RULE_windowFunctionCall)
        self._la = 0 # Token type
        try:
            self.state = 6685
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [686, 687, 700, 702, 704]:
                self.enterOuterAlt(localctx, 1)
                self.state = 6636
                _la = self._input.LA(1)
                if not(((((_la - 686)) & ~0x3f) == 0 and ((1 << (_la - 686)) & 344067) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 6637
                self.parentheses()
                self.state = 6638
                self.windowingClause()
                pass
            elif token in [696]:
                self.enterOuterAlt(localctx, 2)
                self.state = 6640
                self.match(MySQLParser.NTILE_SYMBOL)
                self.state = 6647
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,793,self._ctx)
                if la_ == 1:
                    self.state = 6641
                    self.match(MySQLParser.OPEN_PAR_SYMBOL)
                    self.state = 6642
                    self.stableInteger()
                    self.state = 6643
                    self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                    pass

                elif la_ == 2:
                    self.state = 6645
                    if not self.isServerVersionLt80024():
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.isServerVersionLt80024()")
                    self.state = 6646
                    self.simpleExprWithParentheses()
                    pass


                self.state = 6649
                self.windowingClause()
                pass
            elif token in [692, 694]:
                self.enterOuterAlt(localctx, 3)
                self.state = 6651
                _la = self._input.LA(1)
                if not(_la==692 or _la==694):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 6652
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6653
                self.expr(0)
                self.state = 6655
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 6654
                    self.leadLagInfo()


                self.state = 6657
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                self.state = 6659
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==264 or _la==703:
                    self.state = 6658
                    self.nullTreatment()


                self.state = 6661
                self.windowingClause()
                pass
            elif token in [689, 693]:
                self.enterOuterAlt(localctx, 4)
                self.state = 6663
                _la = self._input.LA(1)
                if not(_la==689 or _la==693):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 6664
                self.exprWithParentheses()
                self.state = 6666
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==264 or _la==703:
                    self.state = 6665
                    self.nullTreatment()


                self.state = 6668
                self.windowingClause()
                pass
            elif token in [695]:
                self.enterOuterAlt(localctx, 5)
                self.state = 6670
                self.match(MySQLParser.NTH_VALUE_SYMBOL)
                self.state = 6671
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6672
                self.expr(0)
                self.state = 6673
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6674
                self.simpleExpr(0)
                self.state = 6675
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                self.state = 6678
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==235:
                    self.state = 6676
                    self.match(MySQLParser.FROM_SYMBOL)
                    self.state = 6677
                    _la = self._input.LA(1)
                    if not(_la==225 or _la==298):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 6681
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==264 or _la==703:
                    self.state = 6680
                    self.nullTreatment()


                self.state = 6683
                self.windowingClause()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SamplingMethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SYSTEM_SYMBOL(self):
            return self.getToken(MySQLParser.SYSTEM_SYMBOL, 0)

        def BERNOULLI_SYMBOL(self):
            return self.getToken(MySQLParser.BERNOULLI_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_samplingMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSamplingMethod" ):
                listener.enterSamplingMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSamplingMethod" ):
                listener.exitSamplingMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSamplingMethod" ):
                return visitor.visitSamplingMethod(self)
            else:
                return visitor.visitChildren(self)




    def samplingMethod(self):

        localctx = MySQLParser.SamplingMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 936, self.RULE_samplingMethod)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6687
            _la = self._input.LA(1)
            if not(_la==718 or _la==815):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SamplingPercentageContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ulonglongNumber(self):
            return self.getTypedRuleContext(MySQLParser.UlonglongNumberContext,0)


        def AT_SIGN_SYMBOL(self):
            return self.getToken(MySQLParser.AT_SIGN_SYMBOL, 0)

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def PARAM_MARKER(self):
            return self.getToken(MySQLParser.PARAM_MARKER, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_samplingPercentage

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSamplingPercentage" ):
                listener.enterSamplingPercentage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSamplingPercentage" ):
                listener.exitSamplingPercentage(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSamplingPercentage" ):
                return visitor.visitSamplingPercentage(self)
            else:
                return visitor.visitChildren(self)




    def samplingPercentage(self):

        localctx = MySQLParser.SamplingPercentageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 938, self.RULE_samplingPercentage)
        try:
            self.state = 6693
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 4, 5, 46, 47]:
                self.enterOuterAlt(localctx, 1)
                self.state = 6689
                self.ulonglongNumber()
                pass
            elif token in [39]:
                self.enterOuterAlt(localctx, 2)
                self.state = 6690
                self.match(MySQLParser.AT_SIGN_SYMBOL)
                self.state = 6691
                self.textOrIdentifier()
                pass
            elif token in [43]:
                self.enterOuterAlt(localctx, 3)
                self.state = 6692
                self.match(MySQLParser.PARAM_MARKER)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TablesampleClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TABLESAMPLE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLESAMPLE_SYMBOL, 0)

        def samplingMethod(self):
            return self.getTypedRuleContext(MySQLParser.SamplingMethodContext,0)


        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def samplingPercentage(self):
            return self.getTypedRuleContext(MySQLParser.SamplingPercentageContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_tablesampleClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTablesampleClause" ):
                listener.enterTablesampleClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTablesampleClause" ):
                listener.exitTablesampleClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTablesampleClause" ):
                return visitor.visitTablesampleClause(self)
            else:
                return visitor.visitChildren(self)




    def tablesampleClause(self):

        localctx = MySQLParser.TablesampleClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 940, self.RULE_tablesampleClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6695
            if not self.isServerVersionGe80200():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.isServerVersionGe80200()")
            self.state = 6696
            self.match(MySQLParser.TABLESAMPLE_SYMBOL)
            self.state = 6697
            self.samplingMethod()
            self.state = 6698
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 6699
            self.samplingPercentage()
            self.state = 6700
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowingClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OVER_SYMBOL(self):
            return self.getToken(MySQLParser.OVER_SYMBOL, 0)

        def windowName(self):
            return self.getTypedRuleContext(MySQLParser.WindowNameContext,0)


        def windowSpec(self):
            return self.getTypedRuleContext(MySQLParser.WindowSpecContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_windowingClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowingClause" ):
                listener.enterWindowingClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowingClause" ):
                listener.exitWindowingClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowingClause" ):
                return visitor.visitWindowingClause(self)
            else:
                return visitor.visitChildren(self)




    def windowingClause(self):

        localctx = MySQLParser.WindowingClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 942, self.RULE_windowingClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6702
            self.match(MySQLParser.OVER_SYMBOL)
            self.state = 6705
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,801,self._ctx)
            if la_ == 1:
                self.state = 6703
                self.windowName()
                pass

            elif la_ == 2:
                self.state = 6704
                self.windowSpec()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LeadLagInfoContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def ulonglongNumber(self):
            return self.getTypedRuleContext(MySQLParser.UlonglongNumberContext,0)


        def PARAM_MARKER(self):
            return self.getToken(MySQLParser.PARAM_MARKER, 0)

        def stableInteger(self):
            return self.getTypedRuleContext(MySQLParser.StableIntegerContext,0)


        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_leadLagInfo

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLeadLagInfo" ):
                listener.enterLeadLagInfo(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLeadLagInfo" ):
                listener.exitLeadLagInfo(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLeadLagInfo" ):
                return visitor.visitLeadLagInfo(self)
            else:
                return visitor.visitChildren(self)




    def leadLagInfo(self):

        localctx = MySQLParser.LeadLagInfoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 944, self.RULE_leadLagInfo)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6707
            self.match(MySQLParser.COMMA_SYMBOL)
            self.state = 6712
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,802,self._ctx)
            if la_ == 1:
                self.state = 6708
                self.ulonglongNumber()
                pass

            elif la_ == 2:
                self.state = 6709
                self.match(MySQLParser.PARAM_MARKER)
                pass

            elif la_ == 3:
                self.state = 6710
                if not self.isServerVersionGe80024():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                self.state = 6711
                self.stableInteger()
                pass


            self.state = 6716
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==29:
                self.state = 6714
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6715
                self.expr(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StableIntegerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def int64Literal(self):
            return self.getTypedRuleContext(MySQLParser.Int64LiteralContext,0)


        def paramOrVar(self):
            return self.getTypedRuleContext(MySQLParser.ParamOrVarContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_stableInteger

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStableInteger" ):
                listener.enterStableInteger(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStableInteger" ):
                listener.exitStableInteger(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStableInteger" ):
                return visitor.visitStableInteger(self)
            else:
                return visitor.visitChildren(self)




    def stableInteger(self):

        localctx = MySQLParser.StableIntegerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 946, self.RULE_stableInteger)
        try:
            self.state = 6720
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,804,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 6718
                self.int64Literal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 6719
                self.paramOrVar()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParamOrVarContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARAM_MARKER(self):
            return self.getToken(MySQLParser.PARAM_MARKER, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def AT_SIGN_SYMBOL(self):
            return self.getToken(MySQLParser.AT_SIGN_SYMBOL, 0)

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_paramOrVar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParamOrVar" ):
                listener.enterParamOrVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParamOrVar" ):
                listener.exitParamOrVar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParamOrVar" ):
                return visitor.visitParamOrVar(self)
            else:
                return visitor.visitChildren(self)




    def paramOrVar(self):

        localctx = MySQLParser.ParamOrVarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 948, self.RULE_paramOrVar)
        try:
            self.state = 6726
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,805,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 6722
                self.match(MySQLParser.PARAM_MARKER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 6723
                self.identifier()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 6724
                self.match(MySQLParser.AT_SIGN_SYMBOL)
                self.state = 6725
                self.textOrIdentifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NullTreatmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NULLS_SYMBOL(self):
            return self.getToken(MySQLParser.NULLS_SYMBOL, 0)

        def RESPECT_SYMBOL(self):
            return self.getToken(MySQLParser.RESPECT_SYMBOL, 0)

        def IGNORE_SYMBOL(self):
            return self.getToken(MySQLParser.IGNORE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_nullTreatment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNullTreatment" ):
                listener.enterNullTreatment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNullTreatment" ):
                listener.exitNullTreatment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNullTreatment" ):
                return visitor.visitNullTreatment(self)
            else:
                return visitor.visitChildren(self)




    def nullTreatment(self):

        localctx = MySQLParser.NullTreatmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 950, self.RULE_nullTreatment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6728
            _la = self._input.LA(1)
            if not(_la==264 or _la==703):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 6729
            self.match(MySQLParser.NULLS_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JsonFunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def JSON_ARRAYAGG_SYMBOL(self):
            return self.getToken(MySQLParser.JSON_ARRAYAGG_SYMBOL, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def inSumExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.InSumExprContext)
            else:
                return self.getTypedRuleContext(MySQLParser.InSumExprContext,i)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def windowingClause(self):
            return self.getTypedRuleContext(MySQLParser.WindowingClauseContext,0)


        def JSON_OBJECTAGG_SYMBOL(self):
            return self.getToken(MySQLParser.JSON_OBJECTAGG_SYMBOL, 0)

        def COMMA_SYMBOL(self):
            return self.getToken(MySQLParser.COMMA_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_jsonFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJsonFunction" ):
                listener.enterJsonFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJsonFunction" ):
                listener.exitJsonFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJsonFunction" ):
                return visitor.visitJsonFunction(self)
            else:
                return visitor.visitChildren(self)




    def jsonFunction(self):

        localctx = MySQLParser.JsonFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 952, self.RULE_jsonFunction)
        try:
            self.state = 6747
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [675]:
                self.enterOuterAlt(localctx, 1)
                self.state = 6731
                self.match(MySQLParser.JSON_ARRAYAGG_SYMBOL)
                self.state = 6732
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6733
                self.inSumExpr()
                self.state = 6734
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                self.state = 6736
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,806,self._ctx)
                if la_ == 1:
                    self.state = 6735
                    self.windowingClause()


                pass
            elif token in [674]:
                self.enterOuterAlt(localctx, 2)
                self.state = 6738
                self.match(MySQLParser.JSON_OBJECTAGG_SYMBOL)
                self.state = 6739
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6740
                self.inSumExpr()
                self.state = 6741
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6742
                self.inSumExpr()
                self.state = 6743
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                self.state = 6745
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,807,self._ctx)
                if la_ == 1:
                    self.state = 6744
                    self.windowingClause()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InSumExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def ALL_SYMBOL(self):
            return self.getToken(MySQLParser.ALL_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_inSumExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInSumExpr" ):
                listener.enterInSumExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInSumExpr" ):
                listener.exitInSumExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInSumExpr" ):
                return visitor.visitInSumExpr(self)
            else:
                return visitor.visitChildren(self)




    def inSumExpr(self):

        localctx = MySQLParser.InSumExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 954, self.RULE_inSumExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6750
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,809,self._ctx)
            if la_ == 1:
                self.state = 6749
                self.match(MySQLParser.ALL_SYMBOL)


            self.state = 6752
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentListArgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identList(self):
            return self.getTypedRuleContext(MySQLParser.IdentListContext,0)


        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_identListArg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentListArg" ):
                listener.enterIdentListArg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentListArg" ):
                listener.exitIdentListArg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentListArg" ):
                return visitor.visitIdentListArg(self)
            else:
                return visitor.visitChildren(self)




    def identListArg(self):

        localctx = MySQLParser.IdentListArgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 956, self.RULE_identListArg)
        try:
            self.state = 6759
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,810,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 6754
                self.identList()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 6755
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6756
                self.identList()
                self.state = 6757
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.SimpleIdentifierContext)
            else:
                return self.getTypedRuleContext(MySQLParser.SimpleIdentifierContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_identList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentList" ):
                listener.enterIdentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentList" ):
                listener.exitIdentList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentList" ):
                return visitor.visitIdentList(self)
            else:
                return visitor.visitChildren(self)




    def identList(self):

        localctx = MySQLParser.IdentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 958, self.RULE_identList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6761
            self.simpleIdentifier()
            self.state = 6766
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 6762
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6763
                self.simpleIdentifier()
                self.state = 6768
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FulltextOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IN_SYMBOL(self):
            return self.getToken(MySQLParser.IN_SYMBOL, 0)

        def BOOLEAN_SYMBOL(self):
            return self.getToken(MySQLParser.BOOLEAN_SYMBOL, 0)

        def MODE_SYMBOL(self):
            return self.getToken(MySQLParser.MODE_SYMBOL, 0)

        def NATURAL_SYMBOL(self):
            return self.getToken(MySQLParser.NATURAL_SYMBOL, 0)

        def LANGUAGE_SYMBOL(self):
            return self.getToken(MySQLParser.LANGUAGE_SYMBOL, 0)

        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def QUERY_SYMBOL(self):
            return self.getToken(MySQLParser.QUERY_SYMBOL, 0)

        def EXPANSION_SYMBOL(self):
            return self.getToken(MySQLParser.EXPANSION_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_fulltextOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFulltextOptions" ):
                listener.enterFulltextOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFulltextOptions" ):
                listener.exitFulltextOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFulltextOptions" ):
                return visitor.visitFulltextOptions(self)
            else:
                return visitor.visitChildren(self)




    def fulltextOptions(self):

        localctx = MySQLParser.FulltextOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 960, self.RULE_fulltextOptions)
        self._la = 0 # Token type
        try:
            self.state = 6784
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,813,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 6769
                self.match(MySQLParser.IN_SYMBOL)
                self.state = 6770
                self.match(MySQLParser.BOOLEAN_SYMBOL)
                self.state = 6771
                self.match(MySQLParser.MODE_SYMBOL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 6772
                self.match(MySQLParser.IN_SYMBOL)
                self.state = 6773
                self.match(MySQLParser.NATURAL_SYMBOL)
                self.state = 6774
                self.match(MySQLParser.LANGUAGE_SYMBOL)
                self.state = 6775
                self.match(MySQLParser.MODE_SYMBOL)
                self.state = 6779
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==653:
                    self.state = 6776
                    self.match(MySQLParser.WITH_SYMBOL)
                    self.state = 6777
                    self.match(MySQLParser.QUERY_SYMBOL)
                    self.state = 6778
                    self.match(MySQLParser.EXPANSION_SYMBOL)


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 6781
                self.match(MySQLParser.WITH_SYMBOL)
                self.state = 6782
                self.match(MySQLParser.QUERY_SYMBOL)
                self.state = 6783
                self.match(MySQLParser.EXPANSION_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuntimeFunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHAR_SYMBOL(self):
            return self.getToken(MySQLParser.CHAR_SYMBOL, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def exprList(self):
            return self.getTypedRuleContext(MySQLParser.ExprListContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def USING_SYMBOL(self):
            return self.getToken(MySQLParser.USING_SYMBOL, 0)

        def charsetName(self):
            return self.getTypedRuleContext(MySQLParser.CharsetNameContext,0)


        def CURRENT_USER_SYMBOL(self):
            return self.getToken(MySQLParser.CURRENT_USER_SYMBOL, 0)

        def parentheses(self):
            return self.getTypedRuleContext(MySQLParser.ParenthesesContext,0)


        def DATE_SYMBOL(self):
            return self.getToken(MySQLParser.DATE_SYMBOL, 0)

        def exprWithParentheses(self):
            return self.getTypedRuleContext(MySQLParser.ExprWithParenthesesContext,0)


        def DAY_SYMBOL(self):
            return self.getToken(MySQLParser.DAY_SYMBOL, 0)

        def HOUR_SYMBOL(self):
            return self.getToken(MySQLParser.HOUR_SYMBOL, 0)

        def INSERT_SYMBOL(self):
            return self.getToken(MySQLParser.INSERT_SYMBOL, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ExprContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ExprContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def INTERVAL_SYMBOL(self):
            return self.getToken(MySQLParser.INTERVAL_SYMBOL, 0)

        def JSON_VALUE_SYMBOL(self):
            return self.getToken(MySQLParser.JSON_VALUE_SYMBOL, 0)

        def simpleExpr(self):
            return self.getTypedRuleContext(MySQLParser.SimpleExprContext,0)


        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def onEmptyOrError(self):
            return self.getTypedRuleContext(MySQLParser.OnEmptyOrErrorContext,0)


        def returningType(self):
            return self.getTypedRuleContext(MySQLParser.ReturningTypeContext,0)


        def LEFT_SYMBOL(self):
            return self.getToken(MySQLParser.LEFT_SYMBOL, 0)

        def MINUTE_SYMBOL(self):
            return self.getToken(MySQLParser.MINUTE_SYMBOL, 0)

        def MONTH_SYMBOL(self):
            return self.getToken(MySQLParser.MONTH_SYMBOL, 0)

        def RIGHT_SYMBOL(self):
            return self.getToken(MySQLParser.RIGHT_SYMBOL, 0)

        def SECOND_SYMBOL(self):
            return self.getToken(MySQLParser.SECOND_SYMBOL, 0)

        def TIME_SYMBOL(self):
            return self.getToken(MySQLParser.TIME_SYMBOL, 0)

        def TIMESTAMP_SYMBOL(self):
            return self.getToken(MySQLParser.TIMESTAMP_SYMBOL, 0)

        def trimFunction(self):
            return self.getTypedRuleContext(MySQLParser.TrimFunctionContext,0)


        def userFunction(self):
            return self.getTypedRuleContext(MySQLParser.UserFunctionContext,0)


        def VALUES_SYMBOL(self):
            return self.getToken(MySQLParser.VALUES_SYMBOL, 0)

        def YEAR_SYMBOL(self):
            return self.getToken(MySQLParser.YEAR_SYMBOL, 0)

        def ADDDATE_SYMBOL(self):
            return self.getToken(MySQLParser.ADDDATE_SYMBOL, 0)

        def SUBDATE_SYMBOL(self):
            return self.getToken(MySQLParser.SUBDATE_SYMBOL, 0)

        def interval(self):
            return self.getTypedRuleContext(MySQLParser.IntervalContext,0)


        def CURDATE_SYMBOL(self):
            return self.getToken(MySQLParser.CURDATE_SYMBOL, 0)

        def CURTIME_SYMBOL(self):
            return self.getToken(MySQLParser.CURTIME_SYMBOL, 0)

        def timeFunctionParameters(self):
            return self.getTypedRuleContext(MySQLParser.TimeFunctionParametersContext,0)


        def DATE_ADD_SYMBOL(self):
            return self.getToken(MySQLParser.DATE_ADD_SYMBOL, 0)

        def DATE_SUB_SYMBOL(self):
            return self.getToken(MySQLParser.DATE_SUB_SYMBOL, 0)

        def EXTRACT_SYMBOL(self):
            return self.getToken(MySQLParser.EXTRACT_SYMBOL, 0)

        def FROM_SYMBOL(self):
            return self.getToken(MySQLParser.FROM_SYMBOL, 0)

        def GET_FORMAT_SYMBOL(self):
            return self.getToken(MySQLParser.GET_FORMAT_SYMBOL, 0)

        def dateTimeTtype(self):
            return self.getTypedRuleContext(MySQLParser.DateTimeTtypeContext,0)


        def LOG_SYMBOL(self):
            return self.getToken(MySQLParser.LOG_SYMBOL, 0)

        def NOW_SYMBOL(self):
            return self.getToken(MySQLParser.NOW_SYMBOL, 0)

        def POSITION_SYMBOL(self):
            return self.getToken(MySQLParser.POSITION_SYMBOL, 0)

        def bitExpr(self):
            return self.getTypedRuleContext(MySQLParser.BitExprContext,0)


        def IN_SYMBOL(self):
            return self.getToken(MySQLParser.IN_SYMBOL, 0)

        def substringFunction(self):
            return self.getTypedRuleContext(MySQLParser.SubstringFunctionContext,0)


        def SYSDATE_SYMBOL(self):
            return self.getToken(MySQLParser.SYSDATE_SYMBOL, 0)

        def intervalTimeStamp(self):
            return self.getTypedRuleContext(MySQLParser.IntervalTimeStampContext,0)


        def TIMESTAMPADD_SYMBOL(self):
            return self.getToken(MySQLParser.TIMESTAMPADD_SYMBOL, 0)

        def TIMESTAMPDIFF_SYMBOL(self):
            return self.getToken(MySQLParser.TIMESTAMPDIFF_SYMBOL, 0)

        def UTC_DATE_SYMBOL(self):
            return self.getToken(MySQLParser.UTC_DATE_SYMBOL, 0)

        def UTC_TIME_SYMBOL(self):
            return self.getToken(MySQLParser.UTC_TIME_SYMBOL, 0)

        def UTC_TIMESTAMP_SYMBOL(self):
            return self.getToken(MySQLParser.UTC_TIMESTAMP_SYMBOL, 0)

        def ASCII_SYMBOL(self):
            return self.getToken(MySQLParser.ASCII_SYMBOL, 0)

        def CHARSET_SYMBOL(self):
            return self.getToken(MySQLParser.CHARSET_SYMBOL, 0)

        def COALESCE_SYMBOL(self):
            return self.getToken(MySQLParser.COALESCE_SYMBOL, 0)

        def exprListWithParentheses(self):
            return self.getTypedRuleContext(MySQLParser.ExprListWithParenthesesContext,0)


        def COLLATION_SYMBOL(self):
            return self.getToken(MySQLParser.COLLATION_SYMBOL, 0)

        def DATABASE_SYMBOL(self):
            return self.getToken(MySQLParser.DATABASE_SYMBOL, 0)

        def IF_SYMBOL(self):
            return self.getToken(MySQLParser.IF_SYMBOL, 0)

        def FORMAT_SYMBOL(self):
            return self.getToken(MySQLParser.FORMAT_SYMBOL, 0)

        def MICROSECOND_SYMBOL(self):
            return self.getToken(MySQLParser.MICROSECOND_SYMBOL, 0)

        def MOD_SYMBOL(self):
            return self.getToken(MySQLParser.MOD_SYMBOL, 0)

        def PASSWORD_SYMBOL(self):
            return self.getToken(MySQLParser.PASSWORD_SYMBOL, 0)

        def QUARTER_SYMBOL(self):
            return self.getToken(MySQLParser.QUARTER_SYMBOL, 0)

        def REPEAT_SYMBOL(self):
            return self.getToken(MySQLParser.REPEAT_SYMBOL, 0)

        def REPLACE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLACE_SYMBOL, 0)

        def REVERSE_SYMBOL(self):
            return self.getToken(MySQLParser.REVERSE_SYMBOL, 0)

        def ROW_COUNT_SYMBOL(self):
            return self.getToken(MySQLParser.ROW_COUNT_SYMBOL, 0)

        def TRUNCATE_SYMBOL(self):
            return self.getToken(MySQLParser.TRUNCATE_SYMBOL, 0)

        def WEEK_SYMBOL(self):
            return self.getToken(MySQLParser.WEEK_SYMBOL, 0)

        def WEIGHT_STRING_SYMBOL(self):
            return self.getToken(MySQLParser.WEIGHT_STRING_SYMBOL, 0)

        def AS_SYMBOL(self):
            return self.getToken(MySQLParser.AS_SYMBOL, 0)

        def BINARY_SYMBOL(self):
            return self.getToken(MySQLParser.BINARY_SYMBOL, 0)

        def wsNumCodepoints(self):
            return self.getTypedRuleContext(MySQLParser.WsNumCodepointsContext,0)


        def ulong_number(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.Ulong_numberContext)
            else:
                return self.getTypedRuleContext(MySQLParser.Ulong_numberContext,i)


        def geometryFunction(self):
            return self.getTypedRuleContext(MySQLParser.GeometryFunctionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_runtimeFunctionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuntimeFunctionCall" ):
                listener.enterRuntimeFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuntimeFunctionCall" ):
                listener.exitRuntimeFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRuntimeFunctionCall" ):
                return visitor.visitRuntimeFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def runtimeFunctionCall(self):

        localctx = MySQLParser.RuntimeFunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 962, self.RULE_runtimeFunctionCall)
        self._la = 0 # Token type
        try:
            self.state = 7069
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,832,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 6786
                self.match(MySQLParser.CHAR_SYMBOL)
                self.state = 6787
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6788
                self.exprList()
                self.state = 6791
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==630:
                    self.state = 6789
                    self.match(MySQLParser.USING_SYMBOL)
                    self.state = 6790
                    self.charsetName()


                self.state = 6793
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 6795
                self.match(MySQLParser.CURRENT_USER_SYMBOL)
                self.state = 6797
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,815,self._ctx)
                if la_ == 1:
                    self.state = 6796
                    self.parentheses()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 6799
                self.match(MySQLParser.DATE_SYMBOL)
                self.state = 6800
                self.exprWithParentheses()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 6801
                self.match(MySQLParser.DAY_SYMBOL)
                self.state = 6802
                self.exprWithParentheses()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 6803
                self.match(MySQLParser.HOUR_SYMBOL)
                self.state = 6804
                self.exprWithParentheses()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 6805
                self.match(MySQLParser.INSERT_SYMBOL)
                self.state = 6806
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6807
                self.expr(0)
                self.state = 6808
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6809
                self.expr(0)
                self.state = 6810
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6811
                self.expr(0)
                self.state = 6812
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6813
                self.expr(0)
                self.state = 6814
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 6816
                self.match(MySQLParser.INTERVAL_SYMBOL)
                self.state = 6817
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6818
                self.expr(0)
                self.state = 6821 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 6819
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 6820
                    self.expr(0)
                    self.state = 6823 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==29):
                        break

                self.state = 6825
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 6827
                self.match(MySQLParser.JSON_VALUE_SYMBOL)
                self.state = 6828
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6829
                self.simpleExpr(0)
                self.state = 6830
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6831
                self.textLiteral()
                self.state = 6833
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==753:
                    self.state = 6832
                    self.returningType()


                self.state = 6835
                self.onEmptyOrError()
                self.state = 6836
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 6838
                self.match(MySQLParser.LEFT_SYMBOL)
                self.state = 6839
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6840
                self.expr(0)
                self.state = 6841
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6842
                self.expr(0)
                self.state = 6843
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 6845
                self.match(MySQLParser.MINUTE_SYMBOL)
                self.state = 6846
                self.exprWithParentheses()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 6847
                self.match(MySQLParser.MONTH_SYMBOL)
                self.state = 6848
                self.exprWithParentheses()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 6849
                self.match(MySQLParser.RIGHT_SYMBOL)
                self.state = 6850
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6851
                self.expr(0)
                self.state = 6852
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6853
                self.expr(0)
                self.state = 6854
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 6856
                self.match(MySQLParser.SECOND_SYMBOL)
                self.state = 6857
                self.exprWithParentheses()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 6858
                self.match(MySQLParser.TIME_SYMBOL)
                self.state = 6859
                self.exprWithParentheses()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 6860
                self.match(MySQLParser.TIMESTAMP_SYMBOL)
                self.state = 6861
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6862
                self.expr(0)
                self.state = 6865
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 6863
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 6864
                    self.expr(0)


                self.state = 6867
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 6869
                self.trimFunction()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 6870
                self.userFunction()
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 6871
                self.match(MySQLParser.VALUES_SYMBOL)
                self.state = 6872
                self.exprWithParentheses()
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 6873
                self.match(MySQLParser.YEAR_SYMBOL)
                self.state = 6874
                self.exprWithParentheses()
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 6875
                _la = self._input.LA(1)
                if not(_la==52 or _la==568):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 6876
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6877
                self.expr(0)
                self.state = 6878
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6884
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,819,self._ctx)
                if la_ == 1:
                    self.state = 6879
                    self.expr(0)
                    pass

                elif la_ == 2:
                    self.state = 6880
                    self.match(MySQLParser.INTERVAL_SYMBOL)
                    self.state = 6881
                    self.expr(0)
                    self.state = 6882
                    self.interval()
                    pass


                self.state = 6886
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 6888
                self.match(MySQLParser.CURDATE_SYMBOL)
                self.state = 6890
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,820,self._ctx)
                if la_ == 1:
                    self.state = 6889
                    self.parentheses()


                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 6892
                self.match(MySQLParser.CURTIME_SYMBOL)
                self.state = 6894
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,821,self._ctx)
                if la_ == 1:
                    self.state = 6893
                    self.timeFunctionParameters()


                pass

            elif la_ == 23:
                self.enterOuterAlt(localctx, 23)
                self.state = 6896
                _la = self._input.LA(1)
                if not(_la==155 or _la==156):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 6897
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6898
                self.expr(0)
                self.state = 6899
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6900
                self.match(MySQLParser.INTERVAL_SYMBOL)
                self.state = 6901
                self.expr(0)
                self.state = 6902
                self.interval()
                self.state = 6903
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 24:
                self.enterOuterAlt(localctx, 24)
                self.state = 6905
                self.match(MySQLParser.EXTRACT_SYMBOL)
                self.state = 6906
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6907
                self.interval()
                self.state = 6908
                self.match(MySQLParser.FROM_SYMBOL)
                self.state = 6909
                self.expr(0)
                self.state = 6910
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 25:
                self.enterOuterAlt(localctx, 25)
                self.state = 6912
                self.match(MySQLParser.GET_FORMAT_SYMBOL)
                self.state = 6913
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6914
                self.dateTimeTtype()
                self.state = 6915
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6916
                self.expr(0)
                self.state = 6917
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 26:
                self.enterOuterAlt(localctx, 26)
                self.state = 6919
                if not self.isServerVersionGe80032():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80032()")
                self.state = 6920
                self.match(MySQLParser.LOG_SYMBOL)
                self.state = 6921
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6922
                self.expr(0)
                self.state = 6925
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 6923
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 6924
                    self.expr(0)


                self.state = 6927
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 27:
                self.enterOuterAlt(localctx, 27)
                self.state = 6929
                self.match(MySQLParser.NOW_SYMBOL)
                self.state = 6931
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,823,self._ctx)
                if la_ == 1:
                    self.state = 6930
                    self.timeFunctionParameters()


                pass

            elif la_ == 28:
                self.enterOuterAlt(localctx, 28)
                self.state = 6933
                self.match(MySQLParser.POSITION_SYMBOL)
                self.state = 6934
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6935
                self.bitExpr(0)
                self.state = 6936
                self.match(MySQLParser.IN_SYMBOL)
                self.state = 6937
                self.expr(0)
                self.state = 6938
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 29:
                self.enterOuterAlt(localctx, 29)
                self.state = 6940
                self.substringFunction()
                pass

            elif la_ == 30:
                self.enterOuterAlt(localctx, 30)
                self.state = 6941
                self.match(MySQLParser.SYSDATE_SYMBOL)
                self.state = 6943
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,824,self._ctx)
                if la_ == 1:
                    self.state = 6942
                    self.timeFunctionParameters()


                pass

            elif la_ == 31:
                self.enterOuterAlt(localctx, 31)
                self.state = 6945
                _la = self._input.LA(1)
                if not(_la==593 or _la==594):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 6946
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6947
                self.intervalTimeStamp()
                self.state = 6948
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6949
                self.expr(0)
                self.state = 6950
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6951
                self.expr(0)
                self.state = 6952
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 32:
                self.enterOuterAlt(localctx, 32)
                self.state = 6954
                self.match(MySQLParser.UTC_DATE_SYMBOL)
                self.state = 6956
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,825,self._ctx)
                if la_ == 1:
                    self.state = 6955
                    self.parentheses()


                pass

            elif la_ == 33:
                self.enterOuterAlt(localctx, 33)
                self.state = 6958
                self.match(MySQLParser.UTC_TIME_SYMBOL)
                self.state = 6960
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,826,self._ctx)
                if la_ == 1:
                    self.state = 6959
                    self.timeFunctionParameters()


                pass

            elif la_ == 34:
                self.enterOuterAlt(localctx, 34)
                self.state = 6962
                self.match(MySQLParser.UTC_TIMESTAMP_SYMBOL)
                self.state = 6964
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,827,self._ctx)
                if la_ == 1:
                    self.state = 6963
                    self.timeFunctionParameters()


                pass

            elif la_ == 35:
                self.enterOuterAlt(localctx, 35)
                self.state = 6966
                self.match(MySQLParser.ASCII_SYMBOL)
                self.state = 6967
                self.exprWithParentheses()
                pass

            elif la_ == 36:
                self.enterOuterAlt(localctx, 36)
                self.state = 6968
                self.match(MySQLParser.CHARSET_SYMBOL)
                self.state = 6969
                self.exprWithParentheses()
                pass

            elif la_ == 37:
                self.enterOuterAlt(localctx, 37)
                self.state = 6970
                self.match(MySQLParser.COALESCE_SYMBOL)
                self.state = 6971
                self.exprListWithParentheses()
                pass

            elif la_ == 38:
                self.enterOuterAlt(localctx, 38)
                self.state = 6972
                self.match(MySQLParser.COLLATION_SYMBOL)
                self.state = 6973
                self.exprWithParentheses()
                pass

            elif la_ == 39:
                self.enterOuterAlt(localctx, 39)
                self.state = 6974
                self.match(MySQLParser.DATABASE_SYMBOL)
                self.state = 6975
                self.parentheses()
                pass

            elif la_ == 40:
                self.enterOuterAlt(localctx, 40)
                self.state = 6976
                self.match(MySQLParser.IF_SYMBOL)
                self.state = 6977
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6978
                self.expr(0)
                self.state = 6979
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6980
                self.expr(0)
                self.state = 6981
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6982
                self.expr(0)
                self.state = 6983
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 41:
                self.enterOuterAlt(localctx, 41)
                self.state = 6985
                self.match(MySQLParser.FORMAT_SYMBOL)
                self.state = 6986
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 6987
                self.expr(0)
                self.state = 6988
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 6989
                self.expr(0)
                self.state = 6992
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 6990
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 6991
                    self.expr(0)


                self.state = 6994
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 42:
                self.enterOuterAlt(localctx, 42)
                self.state = 6996
                self.match(MySQLParser.MICROSECOND_SYMBOL)
                self.state = 6997
                self.exprWithParentheses()
                pass

            elif la_ == 43:
                self.enterOuterAlt(localctx, 43)
                self.state = 6998
                self.match(MySQLParser.MOD_SYMBOL)
                self.state = 6999
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 7000
                self.expr(0)
                self.state = 7001
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 7002
                self.expr(0)
                self.state = 7003
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 44:
                self.enterOuterAlt(localctx, 44)
                self.state = 7005
                if not self.isServerVersionLt80011():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionLt80011()")
                self.state = 7006
                self.match(MySQLParser.PASSWORD_SYMBOL)
                self.state = 7007
                self.exprWithParentheses()
                pass

            elif la_ == 45:
                self.enterOuterAlt(localctx, 45)
                self.state = 7008
                self.match(MySQLParser.QUARTER_SYMBOL)
                self.state = 7009
                self.exprWithParentheses()
                pass

            elif la_ == 46:
                self.enterOuterAlt(localctx, 46)
                self.state = 7010
                self.match(MySQLParser.REPEAT_SYMBOL)
                self.state = 7011
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 7012
                self.expr(0)
                self.state = 7013
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 7014
                self.expr(0)
                self.state = 7015
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 47:
                self.enterOuterAlt(localctx, 47)
                self.state = 7017
                self.match(MySQLParser.REPLACE_SYMBOL)
                self.state = 7018
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 7019
                self.expr(0)
                self.state = 7020
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 7021
                self.expr(0)
                self.state = 7022
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 7023
                self.expr(0)
                self.state = 7024
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 48:
                self.enterOuterAlt(localctx, 48)
                self.state = 7026
                self.match(MySQLParser.REVERSE_SYMBOL)
                self.state = 7027
                self.exprWithParentheses()
                pass

            elif la_ == 49:
                self.enterOuterAlt(localctx, 49)
                self.state = 7028
                self.match(MySQLParser.ROW_COUNT_SYMBOL)
                self.state = 7029
                self.parentheses()
                pass

            elif la_ == 50:
                self.enterOuterAlt(localctx, 50)
                self.state = 7030
                self.match(MySQLParser.TRUNCATE_SYMBOL)
                self.state = 7031
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 7032
                self.expr(0)
                self.state = 7033
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 7034
                self.expr(0)
                self.state = 7035
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 51:
                self.enterOuterAlt(localctx, 51)
                self.state = 7037
                self.match(MySQLParser.WEEK_SYMBOL)
                self.state = 7038
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 7039
                self.expr(0)
                self.state = 7042
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 7040
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 7041
                    self.expr(0)


                self.state = 7044
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 52:
                self.enterOuterAlt(localctx, 52)
                self.state = 7046
                self.match(MySQLParser.WEIGHT_STRING_SYMBOL)
                self.state = 7047
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 7048
                self.expr(0)
                self.state = 7064
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,831,self._ctx)
                if la_ == 1:
                    self.state = 7052
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==63:
                        self.state = 7049
                        self.match(MySQLParser.AS_SYMBOL)
                        self.state = 7050
                        self.match(MySQLParser.CHAR_SYMBOL)
                        self.state = 7051
                        self.wsNumCodepoints()


                    pass

                elif la_ == 2:
                    self.state = 7054
                    self.match(MySQLParser.AS_SYMBOL)
                    self.state = 7055
                    self.match(MySQLParser.BINARY_SYMBOL)
                    self.state = 7056
                    self.wsNumCodepoints()
                    pass

                elif la_ == 3:
                    self.state = 7057
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 7058
                    self.ulong_number()
                    self.state = 7059
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 7060
                    self.ulong_number()
                    self.state = 7061
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 7062
                    self.ulong_number()
                    pass


                self.state = 7066
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 53:
                self.enterOuterAlt(localctx, 53)
                self.state = 7068
                self.geometryFunction()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturningTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURNING_SYMBOL(self):
            return self.getToken(MySQLParser.RETURNING_SYMBOL, 0)

        def castType(self):
            return self.getTypedRuleContext(MySQLParser.CastTypeContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_returningType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturningType" ):
                listener.enterReturningType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturningType" ):
                listener.exitReturningType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturningType" ):
                return visitor.visitReturningType(self)
            else:
                return visitor.visitChildren(self)




    def returningType(self):

        localctx = MySQLParser.ReturningTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 964, self.RULE_returningType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7071
            self.match(MySQLParser.RETURNING_SYMBOL)
            self.state = 7072
            self.castType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GeometryFunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GEOMETRYCOLLECTION_SYMBOL(self):
            return self.getToken(MySQLParser.GEOMETRYCOLLECTION_SYMBOL, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def exprList(self):
            return self.getTypedRuleContext(MySQLParser.ExprListContext,0)


        def LINESTRING_SYMBOL(self):
            return self.getToken(MySQLParser.LINESTRING_SYMBOL, 0)

        def exprListWithParentheses(self):
            return self.getTypedRuleContext(MySQLParser.ExprListWithParenthesesContext,0)


        def MULTILINESTRING_SYMBOL(self):
            return self.getToken(MySQLParser.MULTILINESTRING_SYMBOL, 0)

        def MULTIPOINT_SYMBOL(self):
            return self.getToken(MySQLParser.MULTIPOINT_SYMBOL, 0)

        def MULTIPOLYGON_SYMBOL(self):
            return self.getToken(MySQLParser.MULTIPOLYGON_SYMBOL, 0)

        def POINT_SYMBOL(self):
            return self.getToken(MySQLParser.POINT_SYMBOL, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ExprContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ExprContext,i)


        def COMMA_SYMBOL(self):
            return self.getToken(MySQLParser.COMMA_SYMBOL, 0)

        def POLYGON_SYMBOL(self):
            return self.getToken(MySQLParser.POLYGON_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_geometryFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeometryFunction" ):
                listener.enterGeometryFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeometryFunction" ):
                listener.exitGeometryFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGeometryFunction" ):
                return visitor.visitGeometryFunction(self)
            else:
                return visitor.visitChildren(self)




    def geometryFunction(self):

        localctx = MySQLParser.GeometryFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 966, self.RULE_geometryFunction)
        try:
            self.state = 7097
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [243]:
                self.enterOuterAlt(localctx, 1)
                self.state = 7074
                self.match(MySQLParser.GEOMETRYCOLLECTION_SYMBOL)
                self.state = 7075
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 7077
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,833,self._ctx)
                if la_ == 1:
                    self.state = 7076
                    self.exprList()


                self.state = 7079
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass
            elif token in [309]:
                self.enterOuterAlt(localctx, 2)
                self.state = 7080
                self.match(MySQLParser.LINESTRING_SYMBOL)
                self.state = 7081
                self.exprListWithParentheses()
                pass
            elif token in [374]:
                self.enterOuterAlt(localctx, 3)
                self.state = 7082
                self.match(MySQLParser.MULTILINESTRING_SYMBOL)
                self.state = 7083
                self.exprListWithParentheses()
                pass
            elif token in [375]:
                self.enterOuterAlt(localctx, 4)
                self.state = 7084
                self.match(MySQLParser.MULTIPOINT_SYMBOL)
                self.state = 7085
                self.exprListWithParentheses()
                pass
            elif token in [376]:
                self.enterOuterAlt(localctx, 5)
                self.state = 7086
                self.match(MySQLParser.MULTIPOLYGON_SYMBOL)
                self.state = 7087
                self.exprListWithParentheses()
                pass
            elif token in [429]:
                self.enterOuterAlt(localctx, 6)
                self.state = 7088
                self.match(MySQLParser.POINT_SYMBOL)
                self.state = 7089
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 7090
                self.expr(0)
                self.state = 7091
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 7092
                self.expr(0)
                self.state = 7093
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass
            elif token in [430]:
                self.enterOuterAlt(localctx, 7)
                self.state = 7095
                self.match(MySQLParser.POLYGON_SYMBOL)
                self.state = 7096
                self.exprListWithParentheses()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeFunctionParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def fractionalPrecision(self):
            return self.getTypedRuleContext(MySQLParser.FractionalPrecisionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_timeFunctionParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeFunctionParameters" ):
                listener.enterTimeFunctionParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeFunctionParameters" ):
                listener.exitTimeFunctionParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTimeFunctionParameters" ):
                return visitor.visitTimeFunctionParameters(self)
            else:
                return visitor.visitChildren(self)




    def timeFunctionParameters(self):

        localctx = MySQLParser.TimeFunctionParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 968, self.RULE_timeFunctionParameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7099
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 7101
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==3:
                self.state = 7100
                self.fractionalPrecision()


            self.state = 7103
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FractionalPrecisionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_NUMBER(self):
            return self.getToken(MySQLParser.INT_NUMBER, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_fractionalPrecision

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFractionalPrecision" ):
                listener.enterFractionalPrecision(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFractionalPrecision" ):
                listener.exitFractionalPrecision(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFractionalPrecision" ):
                return visitor.visitFractionalPrecision(self)
            else:
                return visitor.visitChildren(self)




    def fractionalPrecision(self):

        localctx = MySQLParser.FractionalPrecisionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 970, self.RULE_fractionalPrecision)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7105
            self.match(MySQLParser.INT_NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WeightStringLevelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEVEL_SYMBOL(self):
            return self.getToken(MySQLParser.LEVEL_SYMBOL, 0)

        def real_ulong_number(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.Real_ulong_numberContext)
            else:
                return self.getTypedRuleContext(MySQLParser.Real_ulong_numberContext,i)


        def MINUS_OPERATOR(self):
            return self.getToken(MySQLParser.MINUS_OPERATOR, 0)

        def weightStringLevelListItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.WeightStringLevelListItemContext)
            else:
                return self.getTypedRuleContext(MySQLParser.WeightStringLevelListItemContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_weightStringLevels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeightStringLevels" ):
                listener.enterWeightStringLevels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeightStringLevels" ):
                listener.exitWeightStringLevels(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWeightStringLevels" ):
                return visitor.visitWeightStringLevels(self)
            else:
                return visitor.visitChildren(self)




    def weightStringLevels(self):

        localctx = MySQLParser.WeightStringLevelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 972, self.RULE_weightStringLevels)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7107
            self.match(MySQLParser.LEVEL_SYMBOL)
            self.state = 7120
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,837,self._ctx)
            if la_ == 1:
                self.state = 7108
                self.real_ulong_number()
                self.state = 7109
                self.match(MySQLParser.MINUS_OPERATOR)
                self.state = 7110
                self.real_ulong_number()
                pass

            elif la_ == 2:
                self.state = 7112
                self.weightStringLevelListItem()
                self.state = 7117
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==29:
                    self.state = 7113
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 7114
                    self.weightStringLevelListItem()
                    self.state = 7119
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WeightStringLevelListItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def real_ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Real_ulong_numberContext,0)


        def REVERSE_SYMBOL(self):
            return self.getToken(MySQLParser.REVERSE_SYMBOL, 0)

        def ASC_SYMBOL(self):
            return self.getToken(MySQLParser.ASC_SYMBOL, 0)

        def DESC_SYMBOL(self):
            return self.getToken(MySQLParser.DESC_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_weightStringLevelListItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeightStringLevelListItem" ):
                listener.enterWeightStringLevelListItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeightStringLevelListItem" ):
                listener.exitWeightStringLevelListItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWeightStringLevelListItem" ):
                return visitor.visitWeightStringLevelListItem(self)
            else:
                return visitor.visitChildren(self)




    def weightStringLevelListItem(self):

        localctx = MySQLParser.WeightStringLevelListItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 974, self.RULE_weightStringLevelListItem)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7122
            self.real_ulong_number()
            self.state = 7128
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [64, 172]:
                self.state = 7123
                _la = self._input.LA(1)
                if not(_la==64 or _la==172):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 7125
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==493:
                    self.state = 7124
                    self.match(MySQLParser.REVERSE_SYMBOL)


                pass
            elif token in [493]:
                self.state = 7127
                self.match(MySQLParser.REVERSE_SYMBOL)
                pass
            elif token in [-1, 29]:
                pass
            else:
                pass
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateTimeTtypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATE_SYMBOL(self):
            return self.getToken(MySQLParser.DATE_SYMBOL, 0)

        def TIME_SYMBOL(self):
            return self.getToken(MySQLParser.TIME_SYMBOL, 0)

        def DATETIME_SYMBOL(self):
            return self.getToken(MySQLParser.DATETIME_SYMBOL, 0)

        def TIMESTAMP_SYMBOL(self):
            return self.getToken(MySQLParser.TIMESTAMP_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_dateTimeTtype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDateTimeTtype" ):
                listener.enterDateTimeTtype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDateTimeTtype" ):
                listener.exitDateTimeTtype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDateTimeTtype" ):
                return visitor.visitDateTimeTtype(self)
            else:
                return visitor.visitChildren(self)




    def dateTimeTtype(self):

        localctx = MySQLParser.DateTimeTtypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 976, self.RULE_dateTimeTtype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7130
            _la = self._input.LA(1)
            if not(_la==154 or _la==157 or _la==592 or _la==595):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TrimFunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRIM_SYMBOL(self):
            return self.getToken(MySQLParser.TRIM_SYMBOL, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ExprContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ExprContext,i)


        def LEADING_SYMBOL(self):
            return self.getToken(MySQLParser.LEADING_SYMBOL, 0)

        def FROM_SYMBOL(self):
            return self.getToken(MySQLParser.FROM_SYMBOL, 0)

        def TRAILING_SYMBOL(self):
            return self.getToken(MySQLParser.TRAILING_SYMBOL, 0)

        def BOTH_SYMBOL(self):
            return self.getToken(MySQLParser.BOTH_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_trimFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrimFunction" ):
                listener.enterTrimFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrimFunction" ):
                listener.exitTrimFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrimFunction" ):
                return visitor.visitTrimFunction(self)
            else:
                return visitor.visitChildren(self)




    def trimFunction(self):

        localctx = MySQLParser.TrimFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 978, self.RULE_trimFunction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7132
            self.match(MySQLParser.TRIM_SYMBOL)
            self.state = 7133
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 7157
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,844,self._ctx)
            if la_ == 1:
                self.state = 7134
                self.expr(0)
                self.state = 7137
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==235:
                    self.state = 7135
                    self.match(MySQLParser.FROM_SYMBOL)
                    self.state = 7136
                    self.expr(0)


                pass

            elif la_ == 2:
                self.state = 7139
                self.match(MySQLParser.LEADING_SYMBOL)
                self.state = 7141
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,841,self._ctx)
                if la_ == 1:
                    self.state = 7140
                    self.expr(0)


                self.state = 7143
                self.match(MySQLParser.FROM_SYMBOL)
                self.state = 7144
                self.expr(0)
                pass

            elif la_ == 3:
                self.state = 7145
                self.match(MySQLParser.TRAILING_SYMBOL)
                self.state = 7147
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,842,self._ctx)
                if la_ == 1:
                    self.state = 7146
                    self.expr(0)


                self.state = 7149
                self.match(MySQLParser.FROM_SYMBOL)
                self.state = 7150
                self.expr(0)
                pass

            elif la_ == 4:
                self.state = 7151
                self.match(MySQLParser.BOTH_SYMBOL)
                self.state = 7153
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,843,self._ctx)
                if la_ == 1:
                    self.state = 7152
                    self.expr(0)


                self.state = 7155
                self.match(MySQLParser.FROM_SYMBOL)
                self.state = 7156
                self.expr(0)
                pass


            self.state = 7159
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubstringFunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUBSTRING_SYMBOL(self):
            return self.getToken(MySQLParser.SUBSTRING_SYMBOL, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ExprContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ExprContext,i)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def FROM_SYMBOL(self):
            return self.getToken(MySQLParser.FROM_SYMBOL, 0)

        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_substringFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubstringFunction" ):
                listener.enterSubstringFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubstringFunction" ):
                listener.exitSubstringFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubstringFunction" ):
                return visitor.visitSubstringFunction(self)
            else:
                return visitor.visitChildren(self)




    def substringFunction(self):

        localctx = MySQLParser.SubstringFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 980, self.RULE_substringFunction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7161
            self.match(MySQLParser.SUBSTRING_SYMBOL)
            self.state = 7162
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 7163
            self.expr(0)
            self.state = 7176
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [29]:
                self.state = 7164
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 7165
                self.expr(0)
                self.state = 7168
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 7166
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 7167
                    self.expr(0)


                pass
            elif token in [235]:
                self.state = 7170
                self.match(MySQLParser.FROM_SYMBOL)
                self.state = 7171
                self.expr(0)
                self.state = 7174
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==232:
                    self.state = 7172
                    self.match(MySQLParser.FOR_SYMBOL)
                    self.state = 7173
                    self.expr(0)


                pass
            else:
                raise NoViableAltException(self)

            self.state = 7178
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pureIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.PureIdentifierContext,0)


        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def udfExprList(self):
            return self.getTypedRuleContext(MySQLParser.UdfExprListContext,0)


        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.QualifiedIdentifierContext,0)


        def exprList(self):
            return self.getTypedRuleContext(MySQLParser.ExprListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_functionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCall" ):
                listener.enterFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCall" ):
                listener.exitFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCall" ):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def functionCall(self):

        localctx = MySQLParser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 982, self.RULE_functionCall)
        try:
            self.state = 7194
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,850,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7180
                self.pureIdentifier()
                self.state = 7181
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 7183
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,848,self._ctx)
                if la_ == 1:
                    self.state = 7182
                    self.udfExprList()


                self.state = 7185
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7187
                self.qualifiedIdentifier()
                self.state = 7188
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 7190
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,849,self._ctx)
                if la_ == 1:
                    self.state = 7189
                    self.exprList()


                self.state = 7192
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UdfExprListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def udfExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.UdfExprContext)
            else:
                return self.getTypedRuleContext(MySQLParser.UdfExprContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_udfExprList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUdfExprList" ):
                listener.enterUdfExprList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUdfExprList" ):
                listener.exitUdfExprList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUdfExprList" ):
                return visitor.visitUdfExprList(self)
            else:
                return visitor.visitChildren(self)




    def udfExprList(self):

        localctx = MySQLParser.UdfExprListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 984, self.RULE_udfExprList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7196
            self.udfExpr()
            self.state = 7201
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 7197
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 7198
                self.udfExpr()
                self.state = 7203
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UdfExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def selectAlias(self):
            return self.getTypedRuleContext(MySQLParser.SelectAliasContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_udfExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUdfExpr" ):
                listener.enterUdfExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUdfExpr" ):
                listener.exitUdfExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUdfExpr" ):
                return visitor.visitUdfExpr(self)
            else:
                return visitor.visitChildren(self)




    def udfExpr(self):

        localctx = MySQLParser.UdfExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 986, self.RULE_udfExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7204
            self.expr(0)
            self.state = 7206
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,852,self._ctx)
            if la_ == 1:
                self.state = 7205
                self.selectAlias()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UserVariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT_SIGN_SYMBOL(self):
            return self.getToken(MySQLParser.AT_SIGN_SYMBOL, 0)

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def AT_TEXT_SUFFIX(self):
            return self.getToken(MySQLParser.AT_TEXT_SUFFIX, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_userVariable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUserVariable" ):
                listener.enterUserVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUserVariable" ):
                listener.exitUserVariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUserVariable" ):
                return visitor.visitUserVariable(self)
            else:
                return visitor.visitChildren(self)




    def userVariable(self):

        localctx = MySQLParser.UserVariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 988, self.RULE_userVariable)
        try:
            self.state = 7211
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [39]:
                self.enterOuterAlt(localctx, 1)
                self.state = 7208
                self.match(MySQLParser.AT_SIGN_SYMBOL)
                self.state = 7209
                self.textOrIdentifier()
                pass
            elif token in [40]:
                self.enterOuterAlt(localctx, 2)
                self.state = 7210
                self.match(MySQLParser.AT_TEXT_SUFFIX)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InExpressionUserVariableAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def userVariable(self):
            return self.getTypedRuleContext(MySQLParser.UserVariableContext,0)


        def ASSIGN_OPERATOR(self):
            return self.getToken(MySQLParser.ASSIGN_OPERATOR, 0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_inExpressionUserVariableAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInExpressionUserVariableAssignment" ):
                listener.enterInExpressionUserVariableAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInExpressionUserVariableAssignment" ):
                listener.exitInExpressionUserVariableAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInExpressionUserVariableAssignment" ):
                return visitor.visitInExpressionUserVariableAssignment(self)
            else:
                return visitor.visitChildren(self)




    def inExpressionUserVariableAssignment(self):

        localctx = MySQLParser.InExpressionUserVariableAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 990, self.RULE_inExpressionUserVariableAssignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7213
            self.userVariable()
            self.state = 7214
            self.match(MySQLParser.ASSIGN_OPERATOR)
            self.state = 7215
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RvalueSystemOrUserVariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def userVariable(self):
            return self.getTypedRuleContext(MySQLParser.UserVariableContext,0)


        def AT_AT_SIGN_SYMBOL(self):
            return self.getToken(MySQLParser.AT_AT_SIGN_SYMBOL, 0)

        def rvalueSystemVariable(self):
            return self.getTypedRuleContext(MySQLParser.RvalueSystemVariableContext,0)


        def rvalueSystemVariableType(self):
            return self.getTypedRuleContext(MySQLParser.RvalueSystemVariableTypeContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_rvalueSystemOrUserVariable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRvalueSystemOrUserVariable" ):
                listener.enterRvalueSystemOrUserVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRvalueSystemOrUserVariable" ):
                listener.exitRvalueSystemOrUserVariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRvalueSystemOrUserVariable" ):
                return visitor.visitRvalueSystemOrUserVariable(self)
            else:
                return visitor.visitChildren(self)




    def rvalueSystemOrUserVariable(self):

        localctx = MySQLParser.RvalueSystemOrUserVariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 992, self.RULE_rvalueSystemOrUserVariable)
        try:
            self.state = 7223
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [39, 40]:
                self.enterOuterAlt(localctx, 1)
                self.state = 7217
                self.userVariable()
                pass
            elif token in [41]:
                self.enterOuterAlt(localctx, 2)
                self.state = 7218
                self.match(MySQLParser.AT_AT_SIGN_SYMBOL)
                self.state = 7220
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,854,self._ctx)
                if la_ == 1:
                    self.state = 7219
                    self.rvalueSystemVariableType()


                self.state = 7222
                self.rvalueSystemVariable()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LvalueVariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def lValueIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.LValueIdentifierContext,0)


        def dotIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.DotIdentifierContext,0)


        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_lvalueVariable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLvalueVariable" ):
                listener.enterLvalueVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLvalueVariable" ):
                listener.exitLvalueVariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLvalueVariable" ):
                return visitor.visitLvalueVariable(self)
            else:
                return visitor.visitChildren(self)




    def lvalueVariable(self):

        localctx = MySQLParser.LvalueVariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 994, self.RULE_lvalueVariable)
        self._la = 0 # Token type
        try:
            self.state = 7238
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,859,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7234
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,858,self._ctx)
                if la_ == 1:
                    self.state = 7225
                    self.identifier()
                    self.state = 7227
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==28:
                        self.state = 7226
                        self.dotIdentifier()


                    pass

                elif la_ == 2:
                    self.state = 7229
                    if not self.isServerVersionGe80017():
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.isServerVersionGe80017()")
                    self.state = 7230
                    self.lValueIdentifier()
                    self.state = 7232
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==28:
                        self.state = 7231
                        self.dotIdentifier()


                    pass


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7236
                self.match(MySQLParser.DEFAULT_SYMBOL)
                self.state = 7237
                self.dotIdentifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RvalueSystemVariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def dotIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.DotIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_rvalueSystemVariable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRvalueSystemVariable" ):
                listener.enterRvalueSystemVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRvalueSystemVariable" ):
                listener.exitRvalueSystemVariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRvalueSystemVariable" ):
                return visitor.visitRvalueSystemVariable(self)
            else:
                return visitor.visitChildren(self)




    def rvalueSystemVariable(self):

        localctx = MySQLParser.RvalueSystemVariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 996, self.RULE_rvalueSystemVariable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7240
            self.textOrIdentifier()
            self.state = 7242
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,860,self._ctx)
            if la_ == 1:
                self.state = 7241
                self.dotIdentifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhenExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHEN_SYMBOL(self):
            return self.getToken(MySQLParser.WHEN_SYMBOL, 0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_whenExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhenExpression" ):
                listener.enterWhenExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhenExpression" ):
                listener.exitWhenExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhenExpression" ):
                return visitor.visitWhenExpression(self)
            else:
                return visitor.visitChildren(self)




    def whenExpression(self):

        localctx = MySQLParser.WhenExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 998, self.RULE_whenExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7244
            self.match(MySQLParser.WHEN_SYMBOL)
            self.state = 7245
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ThenExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def THEN_SYMBOL(self):
            return self.getToken(MySQLParser.THEN_SYMBOL, 0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_thenExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThenExpression" ):
                listener.enterThenExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThenExpression" ):
                listener.exitThenExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThenExpression" ):
                return visitor.visitThenExpression(self)
            else:
                return visitor.visitChildren(self)




    def thenExpression(self):

        localctx = MySQLParser.ThenExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1000, self.RULE_thenExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7247
            self.match(MySQLParser.THEN_SYMBOL)
            self.state = 7248
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElseExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELSE_SYMBOL(self):
            return self.getToken(MySQLParser.ELSE_SYMBOL, 0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_elseExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElseExpression" ):
                listener.enterElseExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElseExpression" ):
                listener.exitElseExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElseExpression" ):
                return visitor.visitElseExpression(self)
            else:
                return visitor.visitChildren(self)




    def elseExpression(self):

        localctx = MySQLParser.ElseExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1002, self.RULE_elseExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7250
            self.match(MySQLParser.ELSE_SYMBOL)
            self.state = 7251
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CastTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BINARY_SYMBOL(self):
            return self.getToken(MySQLParser.BINARY_SYMBOL, 0)

        def fieldLength(self):
            return self.getTypedRuleContext(MySQLParser.FieldLengthContext,0)


        def CHAR_SYMBOL(self):
            return self.getToken(MySQLParser.CHAR_SYMBOL, 0)

        def charsetWithOptBinary(self):
            return self.getTypedRuleContext(MySQLParser.CharsetWithOptBinaryContext,0)


        def nchar(self):
            return self.getTypedRuleContext(MySQLParser.NcharContext,0)


        def SIGNED_SYMBOL(self):
            return self.getToken(MySQLParser.SIGNED_SYMBOL, 0)

        def INT_SYMBOL(self):
            return self.getToken(MySQLParser.INT_SYMBOL, 0)

        def UNSIGNED_SYMBOL(self):
            return self.getToken(MySQLParser.UNSIGNED_SYMBOL, 0)

        def DATE_SYMBOL(self):
            return self.getToken(MySQLParser.DATE_SYMBOL, 0)

        def YEAR_SYMBOL(self):
            return self.getToken(MySQLParser.YEAR_SYMBOL, 0)

        def TIME_SYMBOL(self):
            return self.getToken(MySQLParser.TIME_SYMBOL, 0)

        def typeDatetimePrecision(self):
            return self.getTypedRuleContext(MySQLParser.TypeDatetimePrecisionContext,0)


        def DATETIME_SYMBOL(self):
            return self.getToken(MySQLParser.DATETIME_SYMBOL, 0)

        def DECIMAL_SYMBOL(self):
            return self.getToken(MySQLParser.DECIMAL_SYMBOL, 0)

        def floatOptions(self):
            return self.getTypedRuleContext(MySQLParser.FloatOptionsContext,0)


        def JSON_SYMBOL(self):
            return self.getToken(MySQLParser.JSON_SYMBOL, 0)

        def realType(self):
            return self.getTypedRuleContext(MySQLParser.RealTypeContext,0)


        def FLOAT_SYMBOL(self):
            return self.getToken(MySQLParser.FLOAT_SYMBOL, 0)

        def standardFloatOptions(self):
            return self.getTypedRuleContext(MySQLParser.StandardFloatOptionsContext,0)


        def POINT_SYMBOL(self):
            return self.getToken(MySQLParser.POINT_SYMBOL, 0)

        def LINESTRING_SYMBOL(self):
            return self.getToken(MySQLParser.LINESTRING_SYMBOL, 0)

        def POLYGON_SYMBOL(self):
            return self.getToken(MySQLParser.POLYGON_SYMBOL, 0)

        def MULTIPOINT_SYMBOL(self):
            return self.getToken(MySQLParser.MULTIPOINT_SYMBOL, 0)

        def MULTILINESTRING_SYMBOL(self):
            return self.getToken(MySQLParser.MULTILINESTRING_SYMBOL, 0)

        def MULTIPOLYGON_SYMBOL(self):
            return self.getToken(MySQLParser.MULTIPOLYGON_SYMBOL, 0)

        def GEOMETRYCOLLECTION_SYMBOL(self):
            return self.getToken(MySQLParser.GEOMETRYCOLLECTION_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_castType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCastType" ):
                listener.enterCastType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCastType" ):
                listener.exitCastType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCastType" ):
                return visitor.visitCastType(self)
            else:
                return visitor.visitChildren(self)




    def castType(self):

        localctx = MySQLParser.CastTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1004, self.RULE_castType)
        self._la = 0 # Token type
        try:
            self.state = 7301
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,871,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7253
                self.match(MySQLParser.BINARY_SYMBOL)
                self.state = 7255
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,861,self._ctx)
                if la_ == 1:
                    self.state = 7254
                    self.fieldLength()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7257
                self.match(MySQLParser.CHAR_SYMBOL)
                self.state = 7259
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,862,self._ctx)
                if la_ == 1:
                    self.state = 7258
                    self.fieldLength()


                self.state = 7262
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,863,self._ctx)
                if la_ == 1:
                    self.state = 7261
                    self.charsetWithOptBinary()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 7264
                self.nchar()
                self.state = 7266
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,864,self._ctx)
                if la_ == 1:
                    self.state = 7265
                    self.fieldLength()


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 7268
                self.match(MySQLParser.SIGNED_SYMBOL)
                self.state = 7270
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,865,self._ctx)
                if la_ == 1:
                    self.state = 7269
                    self.match(MySQLParser.INT_SYMBOL)


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 7272
                self.match(MySQLParser.UNSIGNED_SYMBOL)
                self.state = 7274
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,866,self._ctx)
                if la_ == 1:
                    self.state = 7273
                    self.match(MySQLParser.INT_SYMBOL)


                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 7276
                self.match(MySQLParser.DATE_SYMBOL)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 7277
                if not self.isServerVersionGe80024():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                self.state = 7278
                self.match(MySQLParser.YEAR_SYMBOL)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 7279
                self.match(MySQLParser.TIME_SYMBOL)
                self.state = 7281
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,867,self._ctx)
                if la_ == 1:
                    self.state = 7280
                    self.typeDatetimePrecision()


                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 7283
                self.match(MySQLParser.DATETIME_SYMBOL)
                self.state = 7285
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,868,self._ctx)
                if la_ == 1:
                    self.state = 7284
                    self.typeDatetimePrecision()


                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 7287
                self.match(MySQLParser.DECIMAL_SYMBOL)
                self.state = 7289
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,869,self._ctx)
                if la_ == 1:
                    self.state = 7288
                    self.floatOptions()


                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 7291
                self.match(MySQLParser.JSON_SYMBOL)
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 7292
                if not self.isServerVersionGe80017():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80017()")
                self.state = 7293
                self.realType()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 7294
                if not self.isServerVersionGe80017():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80017()")
                self.state = 7295
                self.match(MySQLParser.FLOAT_SYMBOL)
                self.state = 7297
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,870,self._ctx)
                if la_ == 1:
                    self.state = 7296
                    self.standardFloatOptions()


                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 7299
                if not self.isServerVersionGe80027():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80027()")
                self.state = 7300
                _la = self._input.LA(1)
                if not(_la==243 or _la==309 or ((((_la - 374)) & ~0x3f) == 0 and ((1 << (_la - 374)) & 108086391056891911) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ExprContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ExprContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_exprList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprList" ):
                listener.enterExprList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprList" ):
                listener.exitExprList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprList" ):
                return visitor.visitExprList(self)
            else:
                return visitor.visitChildren(self)




    def exprList(self):

        localctx = MySQLParser.ExprListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1006, self.RULE_exprList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7303
            self.expr(0)
            self.state = 7308
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 7304
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 7305
                self.expr(0)
                self.state = 7310
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CharsetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHAR_SYMBOL(self):
            return self.getToken(MySQLParser.CHAR_SYMBOL, 0)

        def SET_SYMBOL(self):
            return self.getToken(MySQLParser.SET_SYMBOL, 0)

        def CHARSET_SYMBOL(self):
            return self.getToken(MySQLParser.CHARSET_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_charset

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCharset" ):
                listener.enterCharset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCharset" ):
                listener.exitCharset(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCharset" ):
                return visitor.visitCharset(self)
            else:
                return visitor.visitChildren(self)




    def charset(self):

        localctx = MySQLParser.CharsetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1008, self.RULE_charset)
        try:
            self.state = 7314
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [103]:
                self.enterOuterAlt(localctx, 1)
                self.state = 7311
                self.match(MySQLParser.CHAR_SYMBOL)
                self.state = 7312
                self.match(MySQLParser.SET_SYMBOL)
                pass
            elif token in [102]:
                self.enterOuterAlt(localctx, 2)
                self.state = 7313
                self.match(MySQLParser.CHARSET_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NotRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOT_SYMBOL(self):
            return self.getToken(MySQLParser.NOT_SYMBOL, 0)

        def NOT2_SYMBOL(self):
            return self.getToken(MySQLParser.NOT2_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_notRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNotRule" ):
                listener.enterNotRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNotRule" ):
                listener.exitNotRule(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNotRule" ):
                return visitor.visitNotRule(self)
            else:
                return visitor.visitChildren(self)




    def notRule(self):

        localctx = MySQLParser.NotRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1010, self.RULE_notRule)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7316
            _la = self._input.LA(1)
            if not(_la==1 or _la==390):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Not2RuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOGICAL_NOT_OPERATOR(self):
            return self.getToken(MySQLParser.LOGICAL_NOT_OPERATOR, 0)

        def NOT2_SYMBOL(self):
            return self.getToken(MySQLParser.NOT2_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_not2Rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNot2Rule" ):
                listener.enterNot2Rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNot2Rule" ):
                listener.exitNot2Rule(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNot2Rule" ):
                return visitor.visitNot2Rule(self)
            else:
                return visitor.visitChildren(self)




    def not2Rule(self):

        localctx = MySQLParser.Not2RuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1012, self.RULE_not2Rule)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7318
            _la = self._input.LA(1)
            if not(_la==1 or _la==19):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntervalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def intervalTimeStamp(self):
            return self.getTypedRuleContext(MySQLParser.IntervalTimeStampContext,0)


        def SECOND_MICROSECOND_SYMBOL(self):
            return self.getToken(MySQLParser.SECOND_MICROSECOND_SYMBOL, 0)

        def MINUTE_MICROSECOND_SYMBOL(self):
            return self.getToken(MySQLParser.MINUTE_MICROSECOND_SYMBOL, 0)

        def MINUTE_SECOND_SYMBOL(self):
            return self.getToken(MySQLParser.MINUTE_SECOND_SYMBOL, 0)

        def HOUR_MICROSECOND_SYMBOL(self):
            return self.getToken(MySQLParser.HOUR_MICROSECOND_SYMBOL, 0)

        def HOUR_SECOND_SYMBOL(self):
            return self.getToken(MySQLParser.HOUR_SECOND_SYMBOL, 0)

        def HOUR_MINUTE_SYMBOL(self):
            return self.getToken(MySQLParser.HOUR_MINUTE_SYMBOL, 0)

        def DAY_MICROSECOND_SYMBOL(self):
            return self.getToken(MySQLParser.DAY_MICROSECOND_SYMBOL, 0)

        def DAY_SECOND_SYMBOL(self):
            return self.getToken(MySQLParser.DAY_SECOND_SYMBOL, 0)

        def DAY_MINUTE_SYMBOL(self):
            return self.getToken(MySQLParser.DAY_MINUTE_SYMBOL, 0)

        def DAY_HOUR_SYMBOL(self):
            return self.getToken(MySQLParser.DAY_HOUR_SYMBOL, 0)

        def YEAR_MONTH_SYMBOL(self):
            return self.getToken(MySQLParser.YEAR_MONTH_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_interval

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterval" ):
                listener.enterInterval(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterval" ):
                listener.exitInterval(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterval" ):
                return visitor.visitInterval(self)
            else:
                return visitor.visitChildren(self)




    def interval(self):

        localctx = MySQLParser.IntervalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1014, self.RULE_interval)
        self._la = 0 # Token type
        try:
            self.state = 7322
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [162, 261, 361, 366, 373, 447, 509, 648, 664]:
                self.enterOuterAlt(localctx, 1)
                self.state = 7320
                self.intervalTimeStamp()
                pass
            elif token in [158, 159, 160, 161, 258, 259, 260, 364, 365, 508, 663]:
                self.enterOuterAlt(localctx, 2)
                self.state = 7321
                _la = self._input.LA(1)
                if not(((((_la - 158)) & ~0x3f) == 0 and ((1 << (_la - 158)) & 15) != 0) or ((((_la - 258)) & ~0x3f) == 0 and ((1 << (_la - 258)) & 7) != 0) or _la==364 or _la==365 or _la==508 or _la==663):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntervalTimeStampContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MICROSECOND_SYMBOL(self):
            return self.getToken(MySQLParser.MICROSECOND_SYMBOL, 0)

        def SECOND_SYMBOL(self):
            return self.getToken(MySQLParser.SECOND_SYMBOL, 0)

        def MINUTE_SYMBOL(self):
            return self.getToken(MySQLParser.MINUTE_SYMBOL, 0)

        def HOUR_SYMBOL(self):
            return self.getToken(MySQLParser.HOUR_SYMBOL, 0)

        def DAY_SYMBOL(self):
            return self.getToken(MySQLParser.DAY_SYMBOL, 0)

        def WEEK_SYMBOL(self):
            return self.getToken(MySQLParser.WEEK_SYMBOL, 0)

        def MONTH_SYMBOL(self):
            return self.getToken(MySQLParser.MONTH_SYMBOL, 0)

        def QUARTER_SYMBOL(self):
            return self.getToken(MySQLParser.QUARTER_SYMBOL, 0)

        def YEAR_SYMBOL(self):
            return self.getToken(MySQLParser.YEAR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_intervalTimeStamp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntervalTimeStamp" ):
                listener.enterIntervalTimeStamp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntervalTimeStamp" ):
                listener.exitIntervalTimeStamp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntervalTimeStamp" ):
                return visitor.visitIntervalTimeStamp(self)
            else:
                return visitor.visitChildren(self)




    def intervalTimeStamp(self):

        localctx = MySQLParser.IntervalTimeStampContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1016, self.RULE_intervalTimeStamp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7324
            _la = self._input.LA(1)
            if not(_la==162 or _la==261 or ((((_la - 361)) & ~0x3f) == 0 and ((1 << (_la - 361)) & 4129) != 0) or _la==447 or _la==509 or _la==648 or _la==664):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprListWithParenthesesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def exprList(self):
            return self.getTypedRuleContext(MySQLParser.ExprListContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_exprListWithParentheses

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprListWithParentheses" ):
                listener.enterExprListWithParentheses(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprListWithParentheses" ):
                listener.exitExprListWithParentheses(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprListWithParentheses" ):
                return visitor.visitExprListWithParentheses(self)
            else:
                return visitor.visitChildren(self)




    def exprListWithParentheses(self):

        localctx = MySQLParser.ExprListWithParenthesesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1018, self.RULE_exprListWithParentheses)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7326
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 7327
            self.exprList()
            self.state = 7328
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprWithParenthesesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_exprWithParentheses

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprWithParentheses" ):
                listener.enterExprWithParentheses(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprWithParentheses" ):
                listener.exitExprWithParentheses(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprWithParentheses" ):
                return visitor.visitExprWithParentheses(self)
            else:
                return visitor.visitChildren(self)




    def exprWithParentheses(self):

        localctx = MySQLParser.ExprWithParenthesesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1020, self.RULE_exprWithParentheses)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7330
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 7331
            self.expr(0)
            self.state = 7332
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleExprWithParenthesesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def simpleExpr(self):
            return self.getTypedRuleContext(MySQLParser.SimpleExprContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_simpleExprWithParentheses

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprWithParentheses" ):
                listener.enterSimpleExprWithParentheses(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprWithParentheses" ):
                listener.exitSimpleExprWithParentheses(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprWithParentheses" ):
                return visitor.visitSimpleExprWithParentheses(self)
            else:
                return visitor.visitChildren(self)




    def simpleExprWithParentheses(self):

        localctx = MySQLParser.SimpleExprWithParenthesesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1022, self.RULE_simpleExprWithParentheses)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7334
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 7335
            self.simpleExpr(0)
            self.state = 7336
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.OrderExpressionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.OrderExpressionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_orderList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderList" ):
                listener.enterOrderList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderList" ):
                listener.exitOrderList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrderList" ):
                return visitor.visitOrderList(self)
            else:
                return visitor.visitChildren(self)




    def orderList(self):

        localctx = MySQLParser.OrderListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1024, self.RULE_orderList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7338
            self.orderExpression()
            self.state = 7343
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,875,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 7339
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 7340
                    self.orderExpression() 
                self.state = 7345
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,875,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def direction(self):
            return self.getTypedRuleContext(MySQLParser.DirectionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_orderExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderExpression" ):
                listener.enterOrderExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderExpression" ):
                listener.exitOrderExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrderExpression" ):
                return visitor.visitOrderExpression(self)
            else:
                return visitor.visitChildren(self)




    def orderExpression(self):

        localctx = MySQLParser.OrderExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1026, self.RULE_orderExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7346
            self.expr(0)
            self.state = 7348
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,876,self._ctx)
            if la_ == 1:
                self.state = 7347
                self.direction()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def groupingExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.GroupingExpressionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.GroupingExpressionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_groupList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupList" ):
                listener.enterGroupList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupList" ):
                listener.exitGroupList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupList" ):
                return visitor.visitGroupList(self)
            else:
                return visitor.visitChildren(self)




    def groupList(self):

        localctx = MySQLParser.GroupListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1028, self.RULE_groupList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7350
            self.groupingExpression()
            self.state = 7355
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 7351
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 7352
                self.groupingExpression()
                self.state = 7357
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupingExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_groupingExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupingExpression" ):
                listener.enterGroupingExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupingExpression" ):
                listener.exitGroupingExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupingExpression" ):
                return visitor.visitGroupingExpression(self)
            else:
                return visitor.visitChildren(self)




    def groupingExpression(self):

        localctx = MySQLParser.GroupingExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1030, self.RULE_groupingExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7358
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChannelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def CHANNEL_SYMBOL(self):
            return self.getToken(MySQLParser.CHANNEL_SYMBOL, 0)

        def textStringNoLinebreak(self):
            return self.getTypedRuleContext(MySQLParser.TextStringNoLinebreakContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_channel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChannel" ):
                listener.enterChannel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChannel" ):
                listener.exitChannel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChannel" ):
                return visitor.visitChannel(self)
            else:
                return visitor.visitChildren(self)




    def channel(self):

        localctx = MySQLParser.ChannelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1032, self.RULE_channel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7360
            self.match(MySQLParser.FOR_SYMBOL)
            self.state = 7361
            self.match(MySQLParser.CHANNEL_SYMBOL)
            self.state = 7362
            self.textStringNoLinebreak()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompoundStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleStatement(self):
            return self.getTypedRuleContext(MySQLParser.SimpleStatementContext,0)


        def returnStatement(self):
            return self.getTypedRuleContext(MySQLParser.ReturnStatementContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(MySQLParser.IfStatementContext,0)


        def caseStatement(self):
            return self.getTypedRuleContext(MySQLParser.CaseStatementContext,0)


        def labeledBlock(self):
            return self.getTypedRuleContext(MySQLParser.LabeledBlockContext,0)


        def unlabeledBlock(self):
            return self.getTypedRuleContext(MySQLParser.UnlabeledBlockContext,0)


        def labeledControl(self):
            return self.getTypedRuleContext(MySQLParser.LabeledControlContext,0)


        def unlabeledControl(self):
            return self.getTypedRuleContext(MySQLParser.UnlabeledControlContext,0)


        def leaveStatement(self):
            return self.getTypedRuleContext(MySQLParser.LeaveStatementContext,0)


        def iterateStatement(self):
            return self.getTypedRuleContext(MySQLParser.IterateStatementContext,0)


        def cursorOpen(self):
            return self.getTypedRuleContext(MySQLParser.CursorOpenContext,0)


        def cursorFetch(self):
            return self.getTypedRuleContext(MySQLParser.CursorFetchContext,0)


        def cursorClose(self):
            return self.getTypedRuleContext(MySQLParser.CursorCloseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_compoundStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompoundStatement" ):
                listener.enterCompoundStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompoundStatement" ):
                listener.exitCompoundStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompoundStatement" ):
                return visitor.visitCompoundStatement(self)
            else:
                return visitor.visitChildren(self)




    def compoundStatement(self):

        localctx = MySQLParser.CompoundStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1034, self.RULE_compoundStatement)
        try:
            self.state = 7377
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,878,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7364
                self.simpleStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7365
                self.returnStatement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 7366
                self.ifStatement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 7367
                self.caseStatement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 7368
                self.labeledBlock()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 7369
                self.unlabeledBlock()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 7370
                self.labeledControl()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 7371
                self.unlabeledControl()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 7372
                self.leaveStatement()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 7373
                self.iterateStatement()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 7374
                self.cursorOpen()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 7375
                self.cursorFetch()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 7376
                self.cursorClose()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN_SYMBOL(self):
            return self.getToken(MySQLParser.RETURN_SYMBOL, 0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_returnStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnStatement" ):
                listener.enterReturnStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnStatement" ):
                listener.exitReturnStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnStatement" ):
                return visitor.visitReturnStatement(self)
            else:
                return visitor.visitChildren(self)




    def returnStatement(self):

        localctx = MySQLParser.ReturnStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1036, self.RULE_returnStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7379
            self.match(MySQLParser.RETURN_SYMBOL)
            self.state = 7380
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.IF_SYMBOL)
            else:
                return self.getToken(MySQLParser.IF_SYMBOL, i)

        def ifBody(self):
            return self.getTypedRuleContext(MySQLParser.IfBodyContext,0)


        def END_SYMBOL(self):
            return self.getToken(MySQLParser.END_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_ifStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStatement" ):
                listener.enterIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStatement" ):
                listener.exitIfStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfStatement" ):
                return visitor.visitIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def ifStatement(self):

        localctx = MySQLParser.IfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1038, self.RULE_ifStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7382
            self.match(MySQLParser.IF_SYMBOL)
            self.state = 7383
            self.ifBody()
            self.state = 7384
            self.match(MySQLParser.END_SYMBOL)
            self.state = 7385
            self.match(MySQLParser.IF_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def thenStatement(self):
            return self.getTypedRuleContext(MySQLParser.ThenStatementContext,0)


        def ELSEIF_SYMBOL(self):
            return self.getToken(MySQLParser.ELSEIF_SYMBOL, 0)

        def ifBody(self):
            return self.getTypedRuleContext(MySQLParser.IfBodyContext,0)


        def ELSE_SYMBOL(self):
            return self.getToken(MySQLParser.ELSE_SYMBOL, 0)

        def compoundStatementList(self):
            return self.getTypedRuleContext(MySQLParser.CompoundStatementListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_ifBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfBody" ):
                listener.enterIfBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfBody" ):
                listener.exitIfBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfBody" ):
                return visitor.visitIfBody(self)
            else:
                return visitor.visitChildren(self)




    def ifBody(self):

        localctx = MySQLParser.IfBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1040, self.RULE_ifBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7387
            self.expr(0)
            self.state = 7388
            self.thenStatement()
            self.state = 7393
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [191]:
                self.state = 7389
                self.match(MySQLParser.ELSEIF_SYMBOL)
                self.state = 7390
                self.ifBody()
                pass
            elif token in [190]:
                self.state = 7391
                self.match(MySQLParser.ELSE_SYMBOL)
                self.state = 7392
                self.compoundStatementList()
                pass
            elif token in [195]:
                pass
            else:
                pass
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ThenStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def THEN_SYMBOL(self):
            return self.getToken(MySQLParser.THEN_SYMBOL, 0)

        def compoundStatementList(self):
            return self.getTypedRuleContext(MySQLParser.CompoundStatementListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_thenStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThenStatement" ):
                listener.enterThenStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThenStatement" ):
                listener.exitThenStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThenStatement" ):
                return visitor.visitThenStatement(self)
            else:
                return visitor.visitChildren(self)




    def thenStatement(self):

        localctx = MySQLParser.ThenStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1042, self.RULE_thenStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7395
            self.match(MySQLParser.THEN_SYMBOL)
            self.state = 7396
            self.compoundStatementList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompoundStatementListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compoundStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.CompoundStatementContext)
            else:
                return self.getTypedRuleContext(MySQLParser.CompoundStatementContext,i)


        def SEMICOLON_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.SEMICOLON_SYMBOL)
            else:
                return self.getToken(MySQLParser.SEMICOLON_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_compoundStatementList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompoundStatementList" ):
                listener.enterCompoundStatementList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompoundStatementList" ):
                listener.exitCompoundStatementList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompoundStatementList" ):
                return visitor.visitCompoundStatementList(self)
            else:
                return visitor.visitChildren(self)




    def compoundStatementList(self):

        localctx = MySQLParser.CompoundStatementListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1044, self.RULE_compoundStatementList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7401 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 7398
                    self.compoundStatement()
                    self.state = 7399
                    self.match(MySQLParser.SEMICOLON_SYMBOL)

                else:
                    raise NoViableAltException(self)
                self.state = 7403 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,880,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CASE_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.CASE_SYMBOL)
            else:
                return self.getToken(MySQLParser.CASE_SYMBOL, i)

        def END_SYMBOL(self):
            return self.getToken(MySQLParser.END_SYMBOL, 0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def whenExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.WhenExpressionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.WhenExpressionContext,i)


        def thenStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ThenStatementContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ThenStatementContext,i)


        def elseStatement(self):
            return self.getTypedRuleContext(MySQLParser.ElseStatementContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_caseStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseStatement" ):
                listener.enterCaseStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseStatement" ):
                listener.exitCaseStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseStatement" ):
                return visitor.visitCaseStatement(self)
            else:
                return visitor.visitChildren(self)




    def caseStatement(self):

        localctx = MySQLParser.CaseStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1046, self.RULE_caseStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7405
            self.match(MySQLParser.CASE_SYMBOL)
            self.state = 7407
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,881,self._ctx)
            if la_ == 1:
                self.state = 7406
                self.expr(0)


            self.state = 7412 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 7409
                self.whenExpression()
                self.state = 7410
                self.thenStatement()
                self.state = 7414 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==650):
                    break

            self.state = 7417
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==190:
                self.state = 7416
                self.elseStatement()


            self.state = 7419
            self.match(MySQLParser.END_SYMBOL)
            self.state = 7420
            self.match(MySQLParser.CASE_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElseStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELSE_SYMBOL(self):
            return self.getToken(MySQLParser.ELSE_SYMBOL, 0)

        def compoundStatementList(self):
            return self.getTypedRuleContext(MySQLParser.CompoundStatementListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_elseStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElseStatement" ):
                listener.enterElseStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElseStatement" ):
                listener.exitElseStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElseStatement" ):
                return visitor.visitElseStatement(self)
            else:
                return visitor.visitChildren(self)




    def elseStatement(self):

        localctx = MySQLParser.ElseStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1048, self.RULE_elseStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7422
            self.match(MySQLParser.ELSE_SYMBOL)
            self.state = 7423
            self.compoundStatementList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabeledBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def label(self):
            return self.getTypedRuleContext(MySQLParser.LabelContext,0)


        def beginEndBlock(self):
            return self.getTypedRuleContext(MySQLParser.BeginEndBlockContext,0)


        def labelRef(self):
            return self.getTypedRuleContext(MySQLParser.LabelRefContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_labeledBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabeledBlock" ):
                listener.enterLabeledBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabeledBlock" ):
                listener.exitLabeledBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabeledBlock" ):
                return visitor.visitLabeledBlock(self)
            else:
                return visitor.visitChildren(self)




    def labeledBlock(self):

        localctx = MySQLParser.LabeledBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1050, self.RULE_labeledBlock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7425
            self.label()
            self.state = 7426
            self.beginEndBlock()
            self.state = 7428
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,884,self._ctx)
            if la_ == 1:
                self.state = 7427
                self.labelRef()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnlabeledBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def beginEndBlock(self):
            return self.getTypedRuleContext(MySQLParser.BeginEndBlockContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_unlabeledBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnlabeledBlock" ):
                listener.enterUnlabeledBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnlabeledBlock" ):
                listener.exitUnlabeledBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnlabeledBlock" ):
                return visitor.visitUnlabeledBlock(self)
            else:
                return visitor.visitChildren(self)




    def unlabeledBlock(self):

        localctx = MySQLParser.UnlabeledBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1052, self.RULE_unlabeledBlock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7430
            self.beginEndBlock()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def labelIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.LabelIdentifierContext,0)


        def COLON_SYMBOL(self):
            return self.getToken(MySQLParser.COLON_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_label

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabel" ):
                listener.enterLabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabel" ):
                listener.exitLabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabel" ):
                return visitor.visitLabel(self)
            else:
                return visitor.visitChildren(self)




    def label(self):

        localctx = MySQLParser.LabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1054, self.RULE_label)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7432
            self.labelIdentifier()
            self.state = 7433
            self.match(MySQLParser.COLON_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeginEndBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BEGIN_SYMBOL(self):
            return self.getToken(MySQLParser.BEGIN_SYMBOL, 0)

        def END_SYMBOL(self):
            return self.getToken(MySQLParser.END_SYMBOL, 0)

        def spDeclarations(self):
            return self.getTypedRuleContext(MySQLParser.SpDeclarationsContext,0)


        def compoundStatementList(self):
            return self.getTypedRuleContext(MySQLParser.CompoundStatementListContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_beginEndBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeginEndBlock" ):
                listener.enterBeginEndBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeginEndBlock" ):
                listener.exitBeginEndBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeginEndBlock" ):
                return visitor.visitBeginEndBlock(self)
            else:
                return visitor.visitChildren(self)




    def beginEndBlock(self):

        localctx = MySQLParser.BeginEndBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1056, self.RULE_beginEndBlock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7435
            self.match(MySQLParser.BEGIN_SYMBOL)
            self.state = 7437
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,885,self._ctx)
            if la_ == 1:
                self.state = 7436
                self.spDeclarations()


            self.state = 7440
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,886,self._ctx)
            if la_ == 1:
                self.state = 7439
                self.compoundStatementList()


            self.state = 7442
            self.match(MySQLParser.END_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabeledControlContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def label(self):
            return self.getTypedRuleContext(MySQLParser.LabelContext,0)


        def unlabeledControl(self):
            return self.getTypedRuleContext(MySQLParser.UnlabeledControlContext,0)


        def labelRef(self):
            return self.getTypedRuleContext(MySQLParser.LabelRefContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_labeledControl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabeledControl" ):
                listener.enterLabeledControl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabeledControl" ):
                listener.exitLabeledControl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabeledControl" ):
                return visitor.visitLabeledControl(self)
            else:
                return visitor.visitChildren(self)




    def labeledControl(self):

        localctx = MySQLParser.LabeledControlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1058, self.RULE_labeledControl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7444
            self.label()
            self.state = 7445
            self.unlabeledControl()
            self.state = 7447
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,887,self._ctx)
            if la_ == 1:
                self.state = 7446
                self.labelRef()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnlabeledControlContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopBlock(self):
            return self.getTypedRuleContext(MySQLParser.LoopBlockContext,0)


        def whileDoBlock(self):
            return self.getTypedRuleContext(MySQLParser.WhileDoBlockContext,0)


        def repeatUntilBlock(self):
            return self.getTypedRuleContext(MySQLParser.RepeatUntilBlockContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_unlabeledControl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnlabeledControl" ):
                listener.enterUnlabeledControl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnlabeledControl" ):
                listener.exitUnlabeledControl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnlabeledControl" ):
                return visitor.visitUnlabeledControl(self)
            else:
                return visitor.visitChildren(self)




    def unlabeledControl(self):

        localctx = MySQLParser.UnlabeledControlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1060, self.RULE_unlabeledControl)
        try:
            self.state = 7452
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [320]:
                self.enterOuterAlt(localctx, 1)
                self.state = 7449
                self.loopBlock()
                pass
            elif token in [652]:
                self.enterOuterAlt(localctx, 2)
                self.state = 7450
                self.whileDoBlock()
                pass
            elif token in [474]:
                self.enterOuterAlt(localctx, 3)
                self.state = 7451
                self.repeatUntilBlock()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOOP_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.LOOP_SYMBOL)
            else:
                return self.getToken(MySQLParser.LOOP_SYMBOL, i)

        def compoundStatementList(self):
            return self.getTypedRuleContext(MySQLParser.CompoundStatementListContext,0)


        def END_SYMBOL(self):
            return self.getToken(MySQLParser.END_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_loopBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopBlock" ):
                listener.enterLoopBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopBlock" ):
                listener.exitLoopBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopBlock" ):
                return visitor.visitLoopBlock(self)
            else:
                return visitor.visitChildren(self)




    def loopBlock(self):

        localctx = MySQLParser.LoopBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1062, self.RULE_loopBlock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7454
            self.match(MySQLParser.LOOP_SYMBOL)
            self.state = 7455
            self.compoundStatementList()
            self.state = 7456
            self.match(MySQLParser.END_SYMBOL)
            self.state = 7457
            self.match(MySQLParser.LOOP_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhileDoBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.WHILE_SYMBOL)
            else:
                return self.getToken(MySQLParser.WHILE_SYMBOL, i)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def DO_SYMBOL(self):
            return self.getToken(MySQLParser.DO_SYMBOL, 0)

        def compoundStatementList(self):
            return self.getTypedRuleContext(MySQLParser.CompoundStatementListContext,0)


        def END_SYMBOL(self):
            return self.getToken(MySQLParser.END_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_whileDoBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileDoBlock" ):
                listener.enterWhileDoBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileDoBlock" ):
                listener.exitWhileDoBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhileDoBlock" ):
                return visitor.visitWhileDoBlock(self)
            else:
                return visitor.visitChildren(self)




    def whileDoBlock(self):

        localctx = MySQLParser.WhileDoBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1064, self.RULE_whileDoBlock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7459
            self.match(MySQLParser.WHILE_SYMBOL)
            self.state = 7460
            self.expr(0)
            self.state = 7461
            self.match(MySQLParser.DO_SYMBOL)
            self.state = 7462
            self.compoundStatementList()
            self.state = 7463
            self.match(MySQLParser.END_SYMBOL)
            self.state = 7464
            self.match(MySQLParser.WHILE_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RepeatUntilBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPEAT_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.REPEAT_SYMBOL)
            else:
                return self.getToken(MySQLParser.REPEAT_SYMBOL, i)

        def compoundStatementList(self):
            return self.getTypedRuleContext(MySQLParser.CompoundStatementListContext,0)


        def UNTIL_SYMBOL(self):
            return self.getToken(MySQLParser.UNTIL_SYMBOL, 0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def END_SYMBOL(self):
            return self.getToken(MySQLParser.END_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_repeatUntilBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRepeatUntilBlock" ):
                listener.enterRepeatUntilBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRepeatUntilBlock" ):
                listener.exitRepeatUntilBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRepeatUntilBlock" ):
                return visitor.visitRepeatUntilBlock(self)
            else:
                return visitor.visitChildren(self)




    def repeatUntilBlock(self):

        localctx = MySQLParser.RepeatUntilBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1066, self.RULE_repeatUntilBlock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7466
            self.match(MySQLParser.REPEAT_SYMBOL)
            self.state = 7467
            self.compoundStatementList()
            self.state = 7468
            self.match(MySQLParser.UNTIL_SYMBOL)
            self.state = 7469
            self.expr(0)
            self.state = 7470
            self.match(MySQLParser.END_SYMBOL)
            self.state = 7471
            self.match(MySQLParser.REPEAT_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SpDeclarationsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def spDeclaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.SpDeclarationContext)
            else:
                return self.getTypedRuleContext(MySQLParser.SpDeclarationContext,i)


        def SEMICOLON_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.SEMICOLON_SYMBOL)
            else:
                return self.getToken(MySQLParser.SEMICOLON_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_spDeclarations

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpDeclarations" ):
                listener.enterSpDeclarations(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpDeclarations" ):
                listener.exitSpDeclarations(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSpDeclarations" ):
                return visitor.visitSpDeclarations(self)
            else:
                return visitor.visitChildren(self)




    def spDeclarations(self):

        localctx = MySQLParser.SpDeclarationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1068, self.RULE_spDeclarations)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7476 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 7473
                    self.spDeclaration()
                    self.state = 7474
                    self.match(MySQLParser.SEMICOLON_SYMBOL)

                else:
                    raise NoViableAltException(self)
                self.state = 7478 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,889,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SpDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclaration(self):
            return self.getTypedRuleContext(MySQLParser.VariableDeclarationContext,0)


        def conditionDeclaration(self):
            return self.getTypedRuleContext(MySQLParser.ConditionDeclarationContext,0)


        def handlerDeclaration(self):
            return self.getTypedRuleContext(MySQLParser.HandlerDeclarationContext,0)


        def cursorDeclaration(self):
            return self.getTypedRuleContext(MySQLParser.CursorDeclarationContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_spDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpDeclaration" ):
                listener.enterSpDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpDeclaration" ):
                listener.exitSpDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSpDeclaration" ):
                return visitor.visitSpDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def spDeclaration(self):

        localctx = MySQLParser.SpDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1070, self.RULE_spDeclaration)
        try:
            self.state = 7484
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,890,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7480
                self.variableDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7481
                self.conditionDeclaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 7482
                self.handlerDeclaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 7483
                self.cursorDeclaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DECLARE_SYMBOL(self):
            return self.getToken(MySQLParser.DECLARE_SYMBOL, 0)

        def identifierList(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierListContext,0)


        def dataType(self):
            return self.getTypedRuleContext(MySQLParser.DataTypeContext,0)


        def collate(self):
            return self.getTypedRuleContext(MySQLParser.CollateContext,0)


        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_variableDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableDeclaration" ):
                listener.enterVariableDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableDeclaration" ):
                listener.exitVariableDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableDeclaration" ):
                return visitor.visitVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def variableDeclaration(self):

        localctx = MySQLParser.VariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1072, self.RULE_variableDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7486
            self.match(MySQLParser.DECLARE_SYMBOL)
            self.state = 7487
            self.identifierList()
            self.state = 7488
            self.dataType()
            self.state = 7490
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==112:
                self.state = 7489
                self.collate()


            self.state = 7494
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==166:
                self.state = 7492
                self.match(MySQLParser.DEFAULT_SYMBOL)
                self.state = 7493
                self.expr(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DECLARE_SYMBOL(self):
            return self.getToken(MySQLParser.DECLARE_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def CONDITION_SYMBOL(self):
            return self.getToken(MySQLParser.CONDITION_SYMBOL, 0)

        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def spCondition(self):
            return self.getTypedRuleContext(MySQLParser.SpConditionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_conditionDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditionDeclaration" ):
                listener.enterConditionDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditionDeclaration" ):
                listener.exitConditionDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditionDeclaration" ):
                return visitor.visitConditionDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def conditionDeclaration(self):

        localctx = MySQLParser.ConditionDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1074, self.RULE_conditionDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7496
            self.match(MySQLParser.DECLARE_SYMBOL)
            self.state = 7497
            self.identifier()
            self.state = 7498
            self.match(MySQLParser.CONDITION_SYMBOL)
            self.state = 7499
            self.match(MySQLParser.FOR_SYMBOL)
            self.state = 7500
            self.spCondition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SpConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Ulong_numberContext,0)


        def sqlstate(self):
            return self.getTypedRuleContext(MySQLParser.SqlstateContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_spCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpCondition" ):
                listener.enterSpCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpCondition" ):
                listener.exitSpCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSpCondition" ):
                return visitor.visitSpCondition(self)
            else:
                return visitor.visitChildren(self)




    def spCondition(self):

        localctx = MySQLParser.SpConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1076, self.RULE_spCondition)
        try:
            self.state = 7504
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 4, 5, 44, 46, 47]:
                self.enterOuterAlt(localctx, 1)
                self.state = 7502
                self.ulong_number()
                pass
            elif token in [537]:
                self.enterOuterAlt(localctx, 2)
                self.state = 7503
                self.sqlstate()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SqlstateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SQLSTATE_SYMBOL(self):
            return self.getToken(MySQLParser.SQLSTATE_SYMBOL, 0)

        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def VALUE_SYMBOL(self):
            return self.getToken(MySQLParser.VALUE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_sqlstate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSqlstate" ):
                listener.enterSqlstate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSqlstate" ):
                listener.exitSqlstate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSqlstate" ):
                return visitor.visitSqlstate(self)
            else:
                return visitor.visitChildren(self)




    def sqlstate(self):

        localctx = MySQLParser.SqlstateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1078, self.RULE_sqlstate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7506
            self.match(MySQLParser.SQLSTATE_SYMBOL)
            self.state = 7508
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,894,self._ctx)
            if la_ == 1:
                self.state = 7507
                self.match(MySQLParser.VALUE_SYMBOL)


            self.state = 7510
            self.textLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HandlerDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DECLARE_SYMBOL(self):
            return self.getToken(MySQLParser.DECLARE_SYMBOL, 0)

        def HANDLER_SYMBOL(self):
            return self.getToken(MySQLParser.HANDLER_SYMBOL, 0)

        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def handlerCondition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.HandlerConditionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.HandlerConditionContext,i)


        def compoundStatement(self):
            return self.getTypedRuleContext(MySQLParser.CompoundStatementContext,0)


        def CONTINUE_SYMBOL(self):
            return self.getToken(MySQLParser.CONTINUE_SYMBOL, 0)

        def EXIT_SYMBOL(self):
            return self.getToken(MySQLParser.EXIT_SYMBOL, 0)

        def UNDO_SYMBOL(self):
            return self.getToken(MySQLParser.UNDO_SYMBOL, 0)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_handlerDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHandlerDeclaration" ):
                listener.enterHandlerDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHandlerDeclaration" ):
                listener.exitHandlerDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHandlerDeclaration" ):
                return visitor.visitHandlerDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def handlerDeclaration(self):

        localctx = MySQLParser.HandlerDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1080, self.RULE_handlerDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7512
            self.match(MySQLParser.DECLARE_SYMBOL)
            self.state = 7513
            _la = self._input.LA(1)
            if not(_la==135 or _la==210 or _la==614):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 7514
            self.match(MySQLParser.HANDLER_SYMBOL)
            self.state = 7515
            self.match(MySQLParser.FOR_SYMBOL)
            self.state = 7516
            self.handlerCondition()
            self.state = 7521
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,895,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 7517
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 7518
                    self.handlerCondition() 
                self.state = 7523
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,895,self._ctx)

            self.state = 7524
            self.compoundStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HandlerConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def spCondition(self):
            return self.getTypedRuleContext(MySQLParser.SpConditionContext,0)


        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def SQLWARNING_SYMBOL(self):
            return self.getToken(MySQLParser.SQLWARNING_SYMBOL, 0)

        def notRule(self):
            return self.getTypedRuleContext(MySQLParser.NotRuleContext,0)


        def FOUND_SYMBOL(self):
            return self.getToken(MySQLParser.FOUND_SYMBOL, 0)

        def SQLEXCEPTION_SYMBOL(self):
            return self.getToken(MySQLParser.SQLEXCEPTION_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_handlerCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHandlerCondition" ):
                listener.enterHandlerCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHandlerCondition" ):
                listener.exitHandlerCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHandlerCondition" ):
                return visitor.visitHandlerCondition(self)
            else:
                return visitor.visitChildren(self)




    def handlerCondition(self):

        localctx = MySQLParser.HandlerConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1082, self.RULE_handlerCondition)
        try:
            self.state = 7533
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,896,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7526
                self.spCondition()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7527
                self.identifier()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 7528
                self.match(MySQLParser.SQLWARNING_SYMBOL)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 7529
                self.notRule()
                self.state = 7530
                self.match(MySQLParser.FOUND_SYMBOL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 7532
                self.match(MySQLParser.SQLEXCEPTION_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CursorDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DECLARE_SYMBOL(self):
            return self.getToken(MySQLParser.DECLARE_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def CURSOR_SYMBOL(self):
            return self.getToken(MySQLParser.CURSOR_SYMBOL, 0)

        def FOR_SYMBOL(self):
            return self.getToken(MySQLParser.FOR_SYMBOL, 0)

        def selectStatement(self):
            return self.getTypedRuleContext(MySQLParser.SelectStatementContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_cursorDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCursorDeclaration" ):
                listener.enterCursorDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCursorDeclaration" ):
                listener.exitCursorDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCursorDeclaration" ):
                return visitor.visitCursorDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def cursorDeclaration(self):

        localctx = MySQLParser.CursorDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1084, self.RULE_cursorDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7535
            self.match(MySQLParser.DECLARE_SYMBOL)
            self.state = 7536
            self.identifier()
            self.state = 7537
            self.match(MySQLParser.CURSOR_SYMBOL)
            self.state = 7538
            self.match(MySQLParser.FOR_SYMBOL)
            self.state = 7539
            self.selectStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IterateStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ITERATE_SYMBOL(self):
            return self.getToken(MySQLParser.ITERATE_SYMBOL, 0)

        def labelRef(self):
            return self.getTypedRuleContext(MySQLParser.LabelRefContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_iterateStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIterateStatement" ):
                listener.enterIterateStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIterateStatement" ):
                listener.exitIterateStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIterateStatement" ):
                return visitor.visitIterateStatement(self)
            else:
                return visitor.visitChildren(self)




    def iterateStatement(self):

        localctx = MySQLParser.IterateStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1086, self.RULE_iterateStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7541
            self.match(MySQLParser.ITERATE_SYMBOL)
            self.state = 7542
            self.labelRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LeaveStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEAVE_SYMBOL(self):
            return self.getToken(MySQLParser.LEAVE_SYMBOL, 0)

        def labelRef(self):
            return self.getTypedRuleContext(MySQLParser.LabelRefContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_leaveStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLeaveStatement" ):
                listener.enterLeaveStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLeaveStatement" ):
                listener.exitLeaveStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLeaveStatement" ):
                return visitor.visitLeaveStatement(self)
            else:
                return visitor.visitChildren(self)




    def leaveStatement(self):

        localctx = MySQLParser.LeaveStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1088, self.RULE_leaveStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7544
            self.match(MySQLParser.LEAVE_SYMBOL)
            self.state = 7545
            self.labelRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetDiagnosticsStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GET_SYMBOL(self):
            return self.getToken(MySQLParser.GET_SYMBOL, 0)

        def DIAGNOSTICS_SYMBOL(self):
            return self.getToken(MySQLParser.DIAGNOSTICS_SYMBOL, 0)

        def statementInformationItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.StatementInformationItemContext)
            else:
                return self.getTypedRuleContext(MySQLParser.StatementInformationItemContext,i)


        def CONDITION_SYMBOL(self):
            return self.getToken(MySQLParser.CONDITION_SYMBOL, 0)

        def signalAllowedExpr(self):
            return self.getTypedRuleContext(MySQLParser.SignalAllowedExprContext,0)


        def conditionInformationItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ConditionInformationItemContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ConditionInformationItemContext,i)


        def CURRENT_SYMBOL(self):
            return self.getToken(MySQLParser.CURRENT_SYMBOL, 0)

        def STACKED_SYMBOL(self):
            return self.getToken(MySQLParser.STACKED_SYMBOL, 0)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_getDiagnosticsStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetDiagnosticsStatement" ):
                listener.enterGetDiagnosticsStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetDiagnosticsStatement" ):
                listener.exitGetDiagnosticsStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetDiagnosticsStatement" ):
                return visitor.visitGetDiagnosticsStatement(self)
            else:
                return visitor.visitChildren(self)




    def getDiagnosticsStatement(self):

        localctx = MySQLParser.GetDiagnosticsStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1090, self.RULE_getDiagnosticsStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7547
            self.match(MySQLParser.GET_SYMBOL)
            self.state = 7549
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==143 or _la==550:
                self.state = 7548
                _la = self._input.LA(1)
                if not(_la==143 or _la==550):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 7551
            self.match(MySQLParser.DIAGNOSTICS_SYMBOL)
            self.state = 7570
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,900,self._ctx)
            if la_ == 1:
                self.state = 7552
                self.statementInformationItem()
                self.state = 7557
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==29:
                    self.state = 7553
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 7554
                    self.statementInformationItem()
                    self.state = 7559
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.state = 7560
                self.match(MySQLParser.CONDITION_SYMBOL)
                self.state = 7561
                self.signalAllowedExpr()
                self.state = 7562
                self.conditionInformationItem()
                self.state = 7567
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==29:
                    self.state = 7563
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 7564
                    self.conditionInformationItem()
                    self.state = 7569
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SignalAllowedExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self):
            return self.getTypedRuleContext(MySQLParser.LiteralContext,0)


        def rvalueSystemOrUserVariable(self):
            return self.getTypedRuleContext(MySQLParser.RvalueSystemOrUserVariableContext,0)


        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_signalAllowedExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignalAllowedExpr" ):
                listener.enterSignalAllowedExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignalAllowedExpr" ):
                listener.exitSignalAllowedExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignalAllowedExpr" ):
                return visitor.visitSignalAllowedExpr(self)
            else:
                return visitor.visitChildren(self)




    def signalAllowedExpr(self):

        localctx = MySQLParser.SignalAllowedExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1092, self.RULE_signalAllowedExpr)
        try:
            self.state = 7575
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,901,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7572
                self.literal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7573
                self.rvalueSystemOrUserVariable()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 7574
                self.qualifiedIdentifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementInformationItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def NUMBER_SYMBOL(self):
            return self.getToken(MySQLParser.NUMBER_SYMBOL, 0)

        def ROW_COUNT_SYMBOL(self):
            return self.getToken(MySQLParser.ROW_COUNT_SYMBOL, 0)

        def userVariable(self):
            return self.getTypedRuleContext(MySQLParser.UserVariableContext,0)


        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_statementInformationItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatementInformationItem" ):
                listener.enterStatementInformationItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatementInformationItem" ):
                listener.exitStatementInformationItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatementInformationItem" ):
                return visitor.visitStatementInformationItem(self)
            else:
                return visitor.visitChildren(self)




    def statementInformationItem(self):

        localctx = MySQLParser.StatementInformationItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1094, self.RULE_statementInformationItem)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7579
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,902,self._ctx)
            if la_ == 1:
                self.state = 7577
                self.userVariable()
                pass

            elif la_ == 2:
                self.state = 7578
                self.identifier()
                pass


            self.state = 7581
            self.match(MySQLParser.EQUAL_OPERATOR)
            self.state = 7582
            _la = self._input.LA(1)
            if not(_la==396 or _la==501):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionInformationItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def userVariable(self):
            return self.getTypedRuleContext(MySQLParser.UserVariableContext,0)


        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def signalInformationItemName(self):
            return self.getTypedRuleContext(MySQLParser.SignalInformationItemNameContext,0)


        def RETURNED_SQLSTATE_SYMBOL(self):
            return self.getToken(MySQLParser.RETURNED_SQLSTATE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_conditionInformationItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditionInformationItem" ):
                listener.enterConditionInformationItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditionInformationItem" ):
                listener.exitConditionInformationItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditionInformationItem" ):
                return visitor.visitConditionInformationItem(self)
            else:
                return visitor.visitChildren(self)




    def conditionInformationItem(self):

        localctx = MySQLParser.ConditionInformationItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1096, self.RULE_conditionInformationItem)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7586
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,903,self._ctx)
            if la_ == 1:
                self.state = 7584
                self.userVariable()
                pass

            elif la_ == 2:
                self.state = 7585
                self.identifier()
                pass


            self.state = 7588
            self.match(MySQLParser.EQUAL_OPERATOR)
            self.state = 7591
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [97, 107, 116, 130, 131, 132, 148, 360, 378, 507, 567, 585]:
                self.state = 7589
                self.signalInformationItemName()
                pass
            elif token in [490]:
                self.state = 7590
                self.match(MySQLParser.RETURNED_SQLSTATE_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SignalInformationItemNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CLASS_ORIGIN_SYMBOL(self):
            return self.getToken(MySQLParser.CLASS_ORIGIN_SYMBOL, 0)

        def SUBCLASS_ORIGIN_SYMBOL(self):
            return self.getToken(MySQLParser.SUBCLASS_ORIGIN_SYMBOL, 0)

        def CONSTRAINT_CATALOG_SYMBOL(self):
            return self.getToken(MySQLParser.CONSTRAINT_CATALOG_SYMBOL, 0)

        def CONSTRAINT_SCHEMA_SYMBOL(self):
            return self.getToken(MySQLParser.CONSTRAINT_SCHEMA_SYMBOL, 0)

        def CONSTRAINT_NAME_SYMBOL(self):
            return self.getToken(MySQLParser.CONSTRAINT_NAME_SYMBOL, 0)

        def CATALOG_NAME_SYMBOL(self):
            return self.getToken(MySQLParser.CATALOG_NAME_SYMBOL, 0)

        def SCHEMA_NAME_SYMBOL(self):
            return self.getToken(MySQLParser.SCHEMA_NAME_SYMBOL, 0)

        def TABLE_NAME_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_NAME_SYMBOL, 0)

        def COLUMN_NAME_SYMBOL(self):
            return self.getToken(MySQLParser.COLUMN_NAME_SYMBOL, 0)

        def CURSOR_NAME_SYMBOL(self):
            return self.getToken(MySQLParser.CURSOR_NAME_SYMBOL, 0)

        def MESSAGE_TEXT_SYMBOL(self):
            return self.getToken(MySQLParser.MESSAGE_TEXT_SYMBOL, 0)

        def MYSQL_ERRNO_SYMBOL(self):
            return self.getToken(MySQLParser.MYSQL_ERRNO_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_signalInformationItemName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignalInformationItemName" ):
                listener.enterSignalInformationItemName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignalInformationItemName" ):
                listener.exitSignalInformationItemName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignalInformationItemName" ):
                return visitor.visitSignalInformationItemName(self)
            else:
                return visitor.visitChildren(self)




    def signalInformationItemName(self):

        localctx = MySQLParser.SignalInformationItemNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1098, self.RULE_signalInformationItemName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7593
            _la = self._input.LA(1)
            if not(((((_la - 97)) & ~0x3f) == 0 and ((1 << (_la - 97)) & 2251859943752705) != 0) or _la==360 or _la==378 or _la==507 or _la==567 or _la==585):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SignalStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNAL_SYMBOL(self):
            return self.getToken(MySQLParser.SIGNAL_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def sqlstate(self):
            return self.getTypedRuleContext(MySQLParser.SqlstateContext,0)


        def SET_SYMBOL(self):
            return self.getToken(MySQLParser.SET_SYMBOL, 0)

        def signalInformationItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.SignalInformationItemContext)
            else:
                return self.getTypedRuleContext(MySQLParser.SignalInformationItemContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_signalStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignalStatement" ):
                listener.enterSignalStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignalStatement" ):
                listener.exitSignalStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignalStatement" ):
                return visitor.visitSignalStatement(self)
            else:
                return visitor.visitChildren(self)




    def signalStatement(self):

        localctx = MySQLParser.SignalStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1100, self.RULE_signalStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7595
            self.match(MySQLParser.SIGNAL_SYMBOL)
            self.state = 7598
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,905,self._ctx)
            if la_ == 1:
                self.state = 7596
                self.identifier()
                pass

            elif la_ == 2:
                self.state = 7597
                self.sqlstate()
                pass


            self.state = 7609
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==519:
                self.state = 7600
                self.match(MySQLParser.SET_SYMBOL)
                self.state = 7601
                self.signalInformationItem()
                self.state = 7606
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==29:
                    self.state = 7602
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 7603
                    self.signalInformationItem()
                    self.state = 7608
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResignalStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RESIGNAL_SYMBOL(self):
            return self.getToken(MySQLParser.RESIGNAL_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def sqlstate(self):
            return self.getTypedRuleContext(MySQLParser.SqlstateContext,0)


        def SET_SYMBOL(self):
            return self.getToken(MySQLParser.SET_SYMBOL, 0)

        def signalInformationItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.SignalInformationItemContext)
            else:
                return self.getTypedRuleContext(MySQLParser.SignalInformationItemContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_resignalStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResignalStatement" ):
                listener.enterResignalStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResignalStatement" ):
                listener.exitResignalStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResignalStatement" ):
                return visitor.visitResignalStatement(self)
            else:
                return visitor.visitChildren(self)




    def resignalStatement(self):

        localctx = MySQLParser.ResignalStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1102, self.RULE_resignalStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7611
            self.match(MySQLParser.RESIGNAL_SYMBOL)
            self.state = 7614
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,908,self._ctx)
            if la_ == 1:
                self.state = 7612
                self.identifier()

            elif la_ == 2:
                self.state = 7613
                self.sqlstate()


            self.state = 7625
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==519:
                self.state = 7616
                self.match(MySQLParser.SET_SYMBOL)
                self.state = 7617
                self.signalInformationItem()
                self.state = 7622
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==29:
                    self.state = 7618
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 7619
                    self.signalInformationItem()
                    self.state = 7624
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SignalInformationItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def signalInformationItemName(self):
            return self.getTypedRuleContext(MySQLParser.SignalInformationItemNameContext,0)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def signalAllowedExpr(self):
            return self.getTypedRuleContext(MySQLParser.SignalAllowedExprContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_signalInformationItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignalInformationItem" ):
                listener.enterSignalInformationItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignalInformationItem" ):
                listener.exitSignalInformationItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignalInformationItem" ):
                return visitor.visitSignalInformationItem(self)
            else:
                return visitor.visitChildren(self)




    def signalInformationItem(self):

        localctx = MySQLParser.SignalInformationItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1104, self.RULE_signalInformationItem)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7627
            self.signalInformationItemName()
            self.state = 7628
            self.match(MySQLParser.EQUAL_OPERATOR)
            self.state = 7629
            self.signalAllowedExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CursorOpenContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_cursorOpen

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCursorOpen" ):
                listener.enterCursorOpen(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCursorOpen" ):
                listener.exitCursorOpen(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCursorOpen" ):
                return visitor.visitCursorOpen(self)
            else:
                return visitor.visitChildren(self)




    def cursorOpen(self):

        localctx = MySQLParser.CursorOpenContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1106, self.RULE_cursorOpen)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7631
            self.match(MySQLParser.OPEN_SYMBOL)
            self.state = 7632
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CursorCloseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CLOSE_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_cursorClose

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCursorClose" ):
                listener.enterCursorClose(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCursorClose" ):
                listener.exitCursorClose(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCursorClose" ):
                return visitor.visitCursorClose(self)
            else:
                return visitor.visitChildren(self)




    def cursorClose(self):

        localctx = MySQLParser.CursorCloseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1108, self.RULE_cursorClose)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7634
            self.match(MySQLParser.CLOSE_SYMBOL)
            self.state = 7635
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CursorFetchContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FETCH_SYMBOL(self):
            return self.getToken(MySQLParser.FETCH_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def INTO_SYMBOL(self):
            return self.getToken(MySQLParser.INTO_SYMBOL, 0)

        def identifierList(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierListContext,0)


        def FROM_SYMBOL(self):
            return self.getToken(MySQLParser.FROM_SYMBOL, 0)

        def NEXT_SYMBOL(self):
            return self.getToken(MySQLParser.NEXT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_cursorFetch

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCursorFetch" ):
                listener.enterCursorFetch(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCursorFetch" ):
                listener.exitCursorFetch(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCursorFetch" ):
                return visitor.visitCursorFetch(self)
            else:
                return visitor.visitChildren(self)




    def cursorFetch(self):

        localctx = MySQLParser.CursorFetchContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1110, self.RULE_cursorFetch)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7637
            self.match(MySQLParser.FETCH_SYMBOL)
            self.state = 7642
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,912,self._ctx)
            if la_ == 1:
                self.state = 7639
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==387:
                    self.state = 7638
                    self.match(MySQLParser.NEXT_SYMBOL)


                self.state = 7641
                self.match(MySQLParser.FROM_SYMBOL)


            self.state = 7644
            self.identifier()
            self.state = 7645
            self.match(MySQLParser.INTO_SYMBOL)
            self.state = 7646
            self.identifierList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScheduleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT_SYMBOL(self):
            return self.getToken(MySQLParser.AT_SYMBOL, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ExprContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ExprContext,i)


        def EVERY_SYMBOL(self):
            return self.getToken(MySQLParser.EVERY_SYMBOL, 0)

        def interval(self):
            return self.getTypedRuleContext(MySQLParser.IntervalContext,0)


        def STARTS_SYMBOL(self):
            return self.getToken(MySQLParser.STARTS_SYMBOL, 0)

        def ENDS_SYMBOL(self):
            return self.getToken(MySQLParser.ENDS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_schedule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchedule" ):
                listener.enterSchedule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchedule" ):
                listener.exitSchedule(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSchedule" ):
                return visitor.visitSchedule(self)
            else:
                return visitor.visitChildren(self)




    def schedule(self):

        localctx = MySQLParser.ScheduleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1112, self.RULE_schedule)
        self._la = 0 # Token type
        try:
            self.state = 7661
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [67]:
                self.enterOuterAlt(localctx, 1)
                self.state = 7648
                self.match(MySQLParser.AT_SYMBOL)
                self.state = 7649
                self.expr(0)
                pass
            elif token in [206]:
                self.enterOuterAlt(localctx, 2)
                self.state = 7650
                self.match(MySQLParser.EVERY_SYMBOL)
                self.state = 7651
                self.expr(0)
                self.state = 7652
                self.interval()
                self.state = 7655
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==552:
                    self.state = 7653
                    self.match(MySQLParser.STARTS_SYMBOL)
                    self.state = 7654
                    self.expr(0)


                self.state = 7659
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==196:
                    self.state = 7657
                    self.match(MySQLParser.ENDS_SYMBOL)
                    self.state = 7658
                    self.expr(0)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def columnName(self):
            return self.getTypedRuleContext(MySQLParser.ColumnNameContext,0)


        def fieldDefinition(self):
            return self.getTypedRuleContext(MySQLParser.FieldDefinitionContext,0)


        def checkOrReferences(self):
            return self.getTypedRuleContext(MySQLParser.CheckOrReferencesContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_columnDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnDefinition" ):
                listener.enterColumnDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnDefinition" ):
                listener.exitColumnDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnDefinition" ):
                return visitor.visitColumnDefinition(self)
            else:
                return visitor.visitChildren(self)




    def columnDefinition(self):

        localctx = MySQLParser.ColumnDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1114, self.RULE_columnDefinition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7663
            self.columnName()
            self.state = 7664
            self.fieldDefinition()
            self.state = 7666
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,916,self._ctx)
            if la_ == 1:
                self.state = 7665
                self.checkOrReferences()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CheckOrReferencesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def checkConstraint(self):
            return self.getTypedRuleContext(MySQLParser.CheckConstraintContext,0)


        def references(self):
            return self.getTypedRuleContext(MySQLParser.ReferencesContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_checkOrReferences

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCheckOrReferences" ):
                listener.enterCheckOrReferences(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCheckOrReferences" ):
                listener.exitCheckOrReferences(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCheckOrReferences" ):
                return visitor.visitCheckOrReferences(self)
            else:
                return visitor.visitChildren(self)




    def checkOrReferences(self):

        localctx = MySQLParser.CheckOrReferencesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1116, self.RULE_checkOrReferences)
        try:
            self.state = 7671
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,917,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7668
                if not self.isServerVersionLt80016():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionLt80016()")
                self.state = 7669
                self.checkConstraint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7670
                self.references()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CheckConstraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHECK_SYMBOL(self):
            return self.getToken(MySQLParser.CHECK_SYMBOL, 0)

        def exprWithParentheses(self):
            return self.getTypedRuleContext(MySQLParser.ExprWithParenthesesContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_checkConstraint

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCheckConstraint" ):
                listener.enterCheckConstraint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCheckConstraint" ):
                listener.exitCheckConstraint(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCheckConstraint" ):
                return visitor.visitCheckConstraint(self)
            else:
                return visitor.visitChildren(self)




    def checkConstraint(self):

        localctx = MySQLParser.CheckConstraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1118, self.RULE_checkConstraint)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7673
            self.match(MySQLParser.CHECK_SYMBOL)
            self.state = 7674
            self.exprWithParentheses()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstraintEnforcementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENFORCED_SYMBOL(self):
            return self.getToken(MySQLParser.ENFORCED_SYMBOL, 0)

        def NOT_SYMBOL(self):
            return self.getToken(MySQLParser.NOT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_constraintEnforcement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstraintEnforcement" ):
                listener.enterConstraintEnforcement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstraintEnforcement" ):
                listener.exitConstraintEnforcement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstraintEnforcement" ):
                return visitor.visitConstraintEnforcement(self)
            else:
                return visitor.visitChildren(self)




    def constraintEnforcement(self):

        localctx = MySQLParser.ConstraintEnforcementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1120, self.RULE_constraintEnforcement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7676
            if not self.isServerVersionGe80017():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.isServerVersionGe80017()")
            self.state = 7678
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==390:
                self.state = 7677
                self.match(MySQLParser.NOT_SYMBOL)


            self.state = 7680
            self.match(MySQLParser.ENFORCED_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableConstraintDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # Token

        def keyListWithExpression(self):
            return self.getTypedRuleContext(MySQLParser.KeyListWithExpressionContext,0)


        def KEY_SYMBOL(self):
            return self.getToken(MySQLParser.KEY_SYMBOL, 0)

        def INDEX_SYMBOL(self):
            return self.getToken(MySQLParser.INDEX_SYMBOL, 0)

        def indexNameAndType(self):
            return self.getTypedRuleContext(MySQLParser.IndexNameAndTypeContext,0)


        def indexOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.IndexOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.IndexOptionContext,i)


        def FULLTEXT_SYMBOL(self):
            return self.getToken(MySQLParser.FULLTEXT_SYMBOL, 0)

        def keyOrIndex(self):
            return self.getTypedRuleContext(MySQLParser.KeyOrIndexContext,0)


        def indexName(self):
            return self.getTypedRuleContext(MySQLParser.IndexNameContext,0)


        def fulltextIndexOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.FulltextIndexOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.FulltextIndexOptionContext,i)


        def SPATIAL_SYMBOL(self):
            return self.getToken(MySQLParser.SPATIAL_SYMBOL, 0)

        def spatialIndexOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.SpatialIndexOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.SpatialIndexOptionContext,i)


        def keyList(self):
            return self.getTypedRuleContext(MySQLParser.KeyListContext,0)


        def references(self):
            return self.getTypedRuleContext(MySQLParser.ReferencesContext,0)


        def checkConstraint(self):
            return self.getTypedRuleContext(MySQLParser.CheckConstraintContext,0)


        def constraintName(self):
            return self.getTypedRuleContext(MySQLParser.ConstraintNameContext,0)


        def FOREIGN_SYMBOL(self):
            return self.getToken(MySQLParser.FOREIGN_SYMBOL, 0)

        def PRIMARY_SYMBOL(self):
            return self.getToken(MySQLParser.PRIMARY_SYMBOL, 0)

        def UNIQUE_SYMBOL(self):
            return self.getToken(MySQLParser.UNIQUE_SYMBOL, 0)

        def constraintEnforcement(self):
            return self.getTypedRuleContext(MySQLParser.ConstraintEnforcementContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_tableConstraintDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableConstraintDef" ):
                listener.enterTableConstraintDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableConstraintDef" ):
                listener.exitTableConstraintDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableConstraintDef" ):
                return visitor.visitTableConstraintDef(self)
            else:
                return visitor.visitChildren(self)




    def tableConstraintDef(self):

        localctx = MySQLParser.TableConstraintDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1122, self.RULE_tableConstraintDef)
        self._la = 0 # Token type
        try:
            self.state = 7756
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [268, 295]:
                self.enterOuterAlt(localctx, 1)
                self.state = 7682
                localctx.type_ = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==268 or _la==295):
                    localctx.type_ = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 7684
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,919,self._ctx)
                if la_ == 1:
                    self.state = 7683
                    self.indexNameAndType()


                self.state = 7686
                self.keyListWithExpression()
                self.state = 7690
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,920,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 7687
                        self.indexOption() 
                    self.state = 7692
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,920,self._ctx)

                pass
            elif token in [237]:
                self.enterOuterAlt(localctx, 2)
                self.state = 7693
                localctx.type_ = self.match(MySQLParser.FULLTEXT_SYMBOL)
                self.state = 7695
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,921,self._ctx)
                if la_ == 1:
                    self.state = 7694
                    self.keyOrIndex()


                self.state = 7698
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,922,self._ctx)
                if la_ == 1:
                    self.state = 7697
                    self.indexName()


                self.state = 7700
                self.keyListWithExpression()
                self.state = 7704
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,923,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 7701
                        self.fulltextIndexOption() 
                    self.state = 7706
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,923,self._ctx)

                pass
            elif token in [534]:
                self.enterOuterAlt(localctx, 3)
                self.state = 7707
                localctx.type_ = self.match(MySQLParser.SPATIAL_SYMBOL)
                self.state = 7709
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,924,self._ctx)
                if la_ == 1:
                    self.state = 7708
                    self.keyOrIndex()


                self.state = 7712
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,925,self._ctx)
                if la_ == 1:
                    self.state = 7711
                    self.indexName()


                self.state = 7714
                self.keyListWithExpression()
                self.state = 7718
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,926,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 7715
                        self.spatialIndexOption() 
                    self.state = 7720
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,926,self._ctx)

                pass
            elif token in [105, 129, 231, 438, 618]:
                self.enterOuterAlt(localctx, 4)
                self.state = 7722
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==129:
                    self.state = 7721
                    self.constraintName()


                self.state = 7754
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [438, 618]:
                    self.state = 7730
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [438]:
                        self.state = 7724
                        localctx.type_ = self.match(MySQLParser.PRIMARY_SYMBOL)
                        self.state = 7725
                        self.match(MySQLParser.KEY_SYMBOL)
                        pass
                    elif token in [618]:
                        self.state = 7726
                        localctx.type_ = self.match(MySQLParser.UNIQUE_SYMBOL)
                        self.state = 7728
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,928,self._ctx)
                        if la_ == 1:
                            self.state = 7727
                            self.keyOrIndex()


                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 7733
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,930,self._ctx)
                    if la_ == 1:
                        self.state = 7732
                        self.indexNameAndType()


                    self.state = 7735
                    self.keyListWithExpression()
                    self.state = 7739
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,931,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
                            self.state = 7736
                            self.indexOption() 
                        self.state = 7741
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,931,self._ctx)

                    pass
                elif token in [231]:
                    self.state = 7742
                    localctx.type_ = self.match(MySQLParser.FOREIGN_SYMBOL)
                    self.state = 7743
                    self.match(MySQLParser.KEY_SYMBOL)
                    self.state = 7745
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,932,self._ctx)
                    if la_ == 1:
                        self.state = 7744
                        self.indexName()


                    self.state = 7747
                    self.keyList()
                    self.state = 7748
                    self.references()
                    pass
                elif token in [105]:
                    self.state = 7750
                    self.checkConstraint()
                    self.state = 7752
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,933,self._ctx)
                    if la_ == 1:
                        self.state = 7751
                        self.constraintEnforcement()


                    pass
                else:
                    raise NoViableAltException(self)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstraintNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONSTRAINT_SYMBOL(self):
            return self.getToken(MySQLParser.CONSTRAINT_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_constraintName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstraintName" ):
                listener.enterConstraintName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstraintName" ):
                listener.exitConstraintName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstraintName" ):
                return visitor.visitConstraintName(self)
            else:
                return visitor.visitChildren(self)




    def constraintName(self):

        localctx = MySQLParser.ConstraintNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1124, self.RULE_constraintName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7758
            self.match(MySQLParser.CONSTRAINT_SYMBOL)
            self.state = 7760
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,936,self._ctx)
            if la_ == 1:
                self.state = 7759
                self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FieldDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dataType(self):
            return self.getTypedRuleContext(MySQLParser.DataTypeContext,0)


        def AS_SYMBOL(self):
            return self.getToken(MySQLParser.AS_SYMBOL, 0)

        def exprWithParentheses(self):
            return self.getTypedRuleContext(MySQLParser.ExprWithParenthesesContext,0)


        def columnAttribute(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ColumnAttributeContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ColumnAttributeContext,i)


        def collate(self):
            return self.getTypedRuleContext(MySQLParser.CollateContext,0)


        def GENERATED_SYMBOL(self):
            return self.getToken(MySQLParser.GENERATED_SYMBOL, 0)

        def ALWAYS_SYMBOL(self):
            return self.getToken(MySQLParser.ALWAYS_SYMBOL, 0)

        def VIRTUAL_SYMBOL(self):
            return self.getToken(MySQLParser.VIRTUAL_SYMBOL, 0)

        def STORED_SYMBOL(self):
            return self.getToken(MySQLParser.STORED_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_fieldDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFieldDefinition" ):
                listener.enterFieldDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFieldDefinition" ):
                listener.exitFieldDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFieldDefinition" ):
                return visitor.visitFieldDefinition(self)
            else:
                return visitor.visitChildren(self)




    def fieldDefinition(self):

        localctx = MySQLParser.FieldDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1126, self.RULE_fieldDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7762
            self.dataType()
            self.state = 7787
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,942,self._ctx)
            if la_ == 1:
                self.state = 7766
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,937,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 7763
                        self.columnAttribute() 
                    self.state = 7768
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,937,self._ctx)

                pass

            elif la_ == 2:
                self.state = 7770
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==112:
                    self.state = 7769
                    self.collate()


                self.state = 7774
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==241:
                    self.state = 7772
                    self.match(MySQLParser.GENERATED_SYMBOL)
                    self.state = 7773
                    self.match(MySQLParser.ALWAYS_SYMBOL)


                self.state = 7776
                self.match(MySQLParser.AS_SYMBOL)
                self.state = 7777
                self.exprWithParentheses()
                self.state = 7779
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,940,self._ctx)
                if la_ == 1:
                    self.state = 7778
                    _la = self._input.LA(1)
                    if not(_la==564 or _la==645):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 7784
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,941,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 7781
                        self.columnAttribute() 
                    self.state = 7786
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,941,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.value = None # Token

        def nullLiteral(self):
            return self.getTypedRuleContext(MySQLParser.NullLiteralContext,0)


        def NOT_SYMBOL(self):
            return self.getToken(MySQLParser.NOT_SYMBOL, 0)

        def SECONDARY_SYMBOL(self):
            return self.getToken(MySQLParser.SECONDARY_SYMBOL, 0)

        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def nowOrSignedLiteral(self):
            return self.getTypedRuleContext(MySQLParser.NowOrSignedLiteralContext,0)


        def exprWithParentheses(self):
            return self.getTypedRuleContext(MySQLParser.ExprWithParenthesesContext,0)


        def UPDATE_SYMBOL(self):
            return self.getToken(MySQLParser.UPDATE_SYMBOL, 0)

        def NOW_SYMBOL(self):
            return self.getToken(MySQLParser.NOW_SYMBOL, 0)

        def ON_SYMBOL(self):
            return self.getToken(MySQLParser.ON_SYMBOL, 0)

        def timeFunctionParameters(self):
            return self.getTypedRuleContext(MySQLParser.TimeFunctionParametersContext,0)


        def AUTO_INCREMENT_SYMBOL(self):
            return self.getToken(MySQLParser.AUTO_INCREMENT_SYMBOL, 0)

        def VALUE_SYMBOL(self):
            return self.getToken(MySQLParser.VALUE_SYMBOL, 0)

        def SERIAL_SYMBOL(self):
            return self.getToken(MySQLParser.SERIAL_SYMBOL, 0)

        def KEY_SYMBOL(self):
            return self.getToken(MySQLParser.KEY_SYMBOL, 0)

        def PRIMARY_SYMBOL(self):
            return self.getToken(MySQLParser.PRIMARY_SYMBOL, 0)

        def UNIQUE_SYMBOL(self):
            return self.getToken(MySQLParser.UNIQUE_SYMBOL, 0)

        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def COMMENT_SYMBOL(self):
            return self.getToken(MySQLParser.COMMENT_SYMBOL, 0)

        def collate(self):
            return self.getTypedRuleContext(MySQLParser.CollateContext,0)


        def columnFormat(self):
            return self.getTypedRuleContext(MySQLParser.ColumnFormatContext,0)


        def COLUMN_FORMAT_SYMBOL(self):
            return self.getToken(MySQLParser.COLUMN_FORMAT_SYMBOL, 0)

        def storageMedia(self):
            return self.getTypedRuleContext(MySQLParser.StorageMediaContext,0)


        def STORAGE_SYMBOL(self):
            return self.getToken(MySQLParser.STORAGE_SYMBOL, 0)

        def real_ulonglong_number(self):
            return self.getTypedRuleContext(MySQLParser.Real_ulonglong_numberContext,0)


        def SRID_SYMBOL(self):
            return self.getToken(MySQLParser.SRID_SYMBOL, 0)

        def checkConstraint(self):
            return self.getTypedRuleContext(MySQLParser.CheckConstraintContext,0)


        def constraintName(self):
            return self.getTypedRuleContext(MySQLParser.ConstraintNameContext,0)


        def constraintEnforcement(self):
            return self.getTypedRuleContext(MySQLParser.ConstraintEnforcementContext,0)


        def jsonAttribute(self):
            return self.getTypedRuleContext(MySQLParser.JsonAttributeContext,0)


        def ENGINE_ATTRIBUTE_SYMBOL(self):
            return self.getToken(MySQLParser.ENGINE_ATTRIBUTE_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def SECONDARY_ENGINE_ATTRIBUTE_SYMBOL(self):
            return self.getToken(MySQLParser.SECONDARY_ENGINE_ATTRIBUTE_SYMBOL, 0)

        def visibility(self):
            return self.getTypedRuleContext(MySQLParser.VisibilityContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_columnAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnAttribute" ):
                listener.enterColumnAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnAttribute" ):
                listener.exitColumnAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnAttribute" ):
                return visitor.visitColumnAttribute(self)
            else:
                return visitor.visitChildren(self)




    def columnAttribute(self):

        localctx = MySQLParser.ColumnAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1128, self.RULE_columnAttribute)
        self._la = 0 # Token type
        try:
            self.state = 7850
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,951,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7790
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==390:
                    self.state = 7789
                    self.match(MySQLParser.NOT_SYMBOL)


                self.state = 7792
                self.nullLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7793
                if not self.isServerVersionGe80014():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80014()")
                self.state = 7794
                self.match(MySQLParser.NOT_SYMBOL)
                self.state = 7795
                self.match(MySQLParser.SECONDARY_SYMBOL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 7796
                localctx.value = self.match(MySQLParser.DEFAULT_SYMBOL)
                self.state = 7800
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,944,self._ctx)
                if la_ == 1:
                    self.state = 7797
                    self.nowOrSignedLiteral()
                    pass

                elif la_ == 2:
                    self.state = 7798
                    if not self.isServerVersionGe80013():
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.isServerVersionGe80013()")
                    self.state = 7799
                    self.exprWithParentheses()
                    pass


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 7802
                localctx.value = self.match(MySQLParser.ON_SYMBOL)
                self.state = 7803
                self.match(MySQLParser.UPDATE_SYMBOL)
                self.state = 7804
                self.match(MySQLParser.NOW_SYMBOL)
                self.state = 7806
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,945,self._ctx)
                if la_ == 1:
                    self.state = 7805
                    self.timeFunctionParameters()


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 7808
                localctx.value = self.match(MySQLParser.AUTO_INCREMENT_SYMBOL)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 7809
                localctx.value = self.match(MySQLParser.SERIAL_SYMBOL)
                self.state = 7810
                self.match(MySQLParser.DEFAULT_SYMBOL)
                self.state = 7811
                self.match(MySQLParser.VALUE_SYMBOL)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 7813
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==438:
                    self.state = 7812
                    self.match(MySQLParser.PRIMARY_SYMBOL)


                self.state = 7815
                localctx.value = self.match(MySQLParser.KEY_SYMBOL)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 7816
                localctx.value = self.match(MySQLParser.UNIQUE_SYMBOL)
                self.state = 7818
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,947,self._ctx)
                if la_ == 1:
                    self.state = 7817
                    self.match(MySQLParser.KEY_SYMBOL)


                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 7820
                localctx.value = self.match(MySQLParser.COMMENT_SYMBOL)
                self.state = 7821
                self.textLiteral()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 7822
                self.collate()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 7823
                localctx.value = self.match(MySQLParser.COLUMN_FORMAT_SYMBOL)
                self.state = 7824
                self.columnFormat()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 7825
                localctx.value = self.match(MySQLParser.STORAGE_SYMBOL)
                self.state = 7826
                self.storageMedia()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 7827
                localctx.value = self.match(MySQLParser.SRID_SYMBOL)
                self.state = 7828
                self.real_ulonglong_number()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 7829
                if not self.isServerVersionGe80017():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80017()")
                self.state = 7831
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==129:
                    self.state = 7830
                    self.constraintName()


                self.state = 7833
                self.checkConstraint()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 7834
                if not self.isServerVersionGe80017():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80017()")
                self.state = 7835
                self.constraintEnforcement()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 7836
                if not self.isServerVersionGe80024():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                self.state = 7837
                localctx.value = self.match(MySQLParser.ENGINE_ATTRIBUTE_SYMBOL)
                self.state = 7839
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,949,self._ctx)
                if la_ == 1:
                    self.state = 7838
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 7841
                self.jsonAttribute()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 7842
                if not self.isServerVersionGe80024():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                self.state = 7843
                localctx.value = self.match(MySQLParser.SECONDARY_ENGINE_ATTRIBUTE_SYMBOL)
                self.state = 7845
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,950,self._ctx)
                if la_ == 1:
                    self.state = 7844
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 7847
                self.jsonAttribute()
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 7848
                if not self.isServerVersionGe80024():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                self.state = 7849
                self.visibility()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnFormatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FIXED_SYMBOL(self):
            return self.getToken(MySQLParser.FIXED_SYMBOL, 0)

        def DYNAMIC_SYMBOL(self):
            return self.getToken(MySQLParser.DYNAMIC_SYMBOL, 0)

        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_columnFormat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnFormat" ):
                listener.enterColumnFormat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnFormat" ):
                listener.exitColumnFormat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnFormat" ):
                return visitor.visitColumnFormat(self)
            else:
                return visitor.visitChildren(self)




    def columnFormat(self):

        localctx = MySQLParser.ColumnFormatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1130, self.RULE_columnFormat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7852
            _la = self._input.LA(1)
            if not(((((_la - 166)) & ~0x3f) == 0 and ((1 << (_la - 166)) & 1152921504611041281) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StorageMediaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISK_SYMBOL(self):
            return self.getToken(MySQLParser.DISK_SYMBOL, 0)

        def MEMORY_SYMBOL(self):
            return self.getToken(MySQLParser.MEMORY_SYMBOL, 0)

        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_storageMedia

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStorageMedia" ):
                listener.enterStorageMedia(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStorageMedia" ):
                listener.exitStorageMedia(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStorageMedia" ):
                return visitor.visitStorageMedia(self)
            else:
                return visitor.visitChildren(self)




    def storageMedia(self):

        localctx = MySQLParser.StorageMediaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1132, self.RULE_storageMedia)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7854
            _la = self._input.LA(1)
            if not(_la==166 or _la==179 or _la==358):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NowContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOW_SYMBOL(self):
            return self.getToken(MySQLParser.NOW_SYMBOL, 0)

        def functionDatetimePrecision(self):
            return self.getTypedRuleContext(MySQLParser.FunctionDatetimePrecisionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_now

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNow" ):
                listener.enterNow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNow" ):
                listener.exitNow(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNow" ):
                return visitor.visitNow(self)
            else:
                return visitor.visitChildren(self)




    def now(self):

        localctx = MySQLParser.NowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1134, self.RULE_now)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7856
            self.match(MySQLParser.NOW_SYMBOL)
            self.state = 7857
            self.functionDatetimePrecision()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NowOrSignedLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def now(self):
            return self.getTypedRuleContext(MySQLParser.NowContext,0)


        def signedLiteralOrNull(self):
            return self.getTypedRuleContext(MySQLParser.SignedLiteralOrNullContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_nowOrSignedLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNowOrSignedLiteral" ):
                listener.enterNowOrSignedLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNowOrSignedLiteral" ):
                listener.exitNowOrSignedLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNowOrSignedLiteral" ):
                return visitor.visitNowOrSignedLiteral(self)
            else:
                return visitor.visitChildren(self)




    def nowOrSignedLiteral(self):

        localctx = MySQLParser.NowOrSignedLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1136, self.RULE_nowOrSignedLiteral)
        try:
            self.state = 7861
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,952,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7859
                self.now()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7860
                self.signedLiteralOrNull()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GcolAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNIQUE_SYMBOL(self):
            return self.getToken(MySQLParser.UNIQUE_SYMBOL, 0)

        def KEY_SYMBOL(self):
            return self.getToken(MySQLParser.KEY_SYMBOL, 0)

        def COMMENT_SYMBOL(self):
            return self.getToken(MySQLParser.COMMENT_SYMBOL, 0)

        def textString(self):
            return self.getTypedRuleContext(MySQLParser.TextStringContext,0)


        def NULL_SYMBOL(self):
            return self.getToken(MySQLParser.NULL_SYMBOL, 0)

        def notRule(self):
            return self.getTypedRuleContext(MySQLParser.NotRuleContext,0)


        def PRIMARY_SYMBOL(self):
            return self.getToken(MySQLParser.PRIMARY_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_gcolAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGcolAttribute" ):
                listener.enterGcolAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGcolAttribute" ):
                listener.exitGcolAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGcolAttribute" ):
                return visitor.visitGcolAttribute(self)
            else:
                return visitor.visitChildren(self)




    def gcolAttribute(self):

        localctx = MySQLParser.GcolAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1138, self.RULE_gcolAttribute)
        self._la = 0 # Token type
        try:
            self.state = 7877
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [618]:
                self.enterOuterAlt(localctx, 1)
                self.state = 7863
                self.match(MySQLParser.UNIQUE_SYMBOL)
                self.state = 7865
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 7864
                    self.match(MySQLParser.KEY_SYMBOL)


                pass
            elif token in [118]:
                self.enterOuterAlt(localctx, 2)
                self.state = 7867
                self.match(MySQLParser.COMMENT_SYMBOL)
                self.state = 7868
                self.textString()
                pass
            elif token in [1, 390, 395]:
                self.enterOuterAlt(localctx, 3)
                self.state = 7870
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==1 or _la==390:
                    self.state = 7869
                    self.notRule()


                self.state = 7872
                self.match(MySQLParser.NULL_SYMBOL)
                pass
            elif token in [295, 438]:
                self.enterOuterAlt(localctx, 4)
                self.state = 7874
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==438:
                    self.state = 7873
                    self.match(MySQLParser.PRIMARY_SYMBOL)


                self.state = 7876
                self.match(MySQLParser.KEY_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReferencesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.match = None # Token
            self.option = None # Token

        def REFERENCES_SYMBOL(self):
            return self.getToken(MySQLParser.REFERENCES_SYMBOL, 0)

        def tableRef(self):
            return self.getTypedRuleContext(MySQLParser.TableRefContext,0)


        def identifierListWithParentheses(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierListWithParenthesesContext,0)


        def MATCH_SYMBOL(self):
            return self.getToken(MySQLParser.MATCH_SYMBOL, 0)

        def ON_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.ON_SYMBOL)
            else:
                return self.getToken(MySQLParser.ON_SYMBOL, i)

        def deleteOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.DeleteOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.DeleteOptionContext,i)


        def UPDATE_SYMBOL(self):
            return self.getToken(MySQLParser.UPDATE_SYMBOL, 0)

        def DELETE_SYMBOL(self):
            return self.getToken(MySQLParser.DELETE_SYMBOL, 0)

        def FULL_SYMBOL(self):
            return self.getToken(MySQLParser.FULL_SYMBOL, 0)

        def PARTIAL_SYMBOL(self):
            return self.getToken(MySQLParser.PARTIAL_SYMBOL, 0)

        def SIMPLE_SYMBOL(self):
            return self.getToken(MySQLParser.SIMPLE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_references

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReferences" ):
                listener.enterReferences(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReferences" ):
                listener.exitReferences(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReferences" ):
                return visitor.visitReferences(self)
            else:
                return visitor.visitChildren(self)




    def references(self):

        localctx = MySQLParser.ReferencesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1140, self.RULE_references)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7879
            self.match(MySQLParser.REFERENCES_SYMBOL)
            self.state = 7880
            self.tableRef()
            self.state = 7882
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==32:
                self.state = 7881
                self.identifierListWithParentheses()


            self.state = 7886
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==345:
                self.state = 7884
                self.match(MySQLParser.MATCH_SYMBOL)
                self.state = 7885
                localctx.match = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==236 or _la==420 or _la==525):
                    localctx.match = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 7904
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,961,self._ctx)
            if la_ == 1:
                self.state = 7888
                self.match(MySQLParser.ON_SYMBOL)
                self.state = 7889
                localctx.option = self.match(MySQLParser.UPDATE_SYMBOL)
                self.state = 7890
                self.deleteOption()
                self.state = 7894
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==401:
                    self.state = 7891
                    self.match(MySQLParser.ON_SYMBOL)
                    self.state = 7892
                    self.match(MySQLParser.DELETE_SYMBOL)
                    self.state = 7893
                    self.deleteOption()



            elif la_ == 2:
                self.state = 7896
                self.match(MySQLParser.ON_SYMBOL)
                self.state = 7897
                localctx.option = self.match(MySQLParser.DELETE_SYMBOL)
                self.state = 7898
                self.deleteOption()
                self.state = 7902
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==401:
                    self.state = 7899
                    self.match(MySQLParser.ON_SYMBOL)
                    self.state = 7900
                    self.match(MySQLParser.UPDATE_SYMBOL)
                    self.state = 7901
                    self.deleteOption()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeleteOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RESTRICT_SYMBOL(self):
            return self.getToken(MySQLParser.RESTRICT_SYMBOL, 0)

        def CASCADE_SYMBOL(self):
            return self.getToken(MySQLParser.CASCADE_SYMBOL, 0)

        def SET_SYMBOL(self):
            return self.getToken(MySQLParser.SET_SYMBOL, 0)

        def nullLiteral(self):
            return self.getTypedRuleContext(MySQLParser.NullLiteralContext,0)


        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def NO_SYMBOL(self):
            return self.getToken(MySQLParser.NO_SYMBOL, 0)

        def ACTION_SYMBOL(self):
            return self.getToken(MySQLParser.ACTION_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_deleteOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeleteOption" ):
                listener.enterDeleteOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeleteOption" ):
                listener.exitDeleteOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeleteOption" ):
                return visitor.visitDeleteOption(self)
            else:
                return visitor.visitChildren(self)




    def deleteOption(self):

        localctx = MySQLParser.DeleteOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1142, self.RULE_deleteOption)
        self._la = 0 # Token type
        try:
            self.state = 7913
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,962,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7906
                _la = self._input.LA(1)
                if not(_la==93 or _la==488):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7907
                self.match(MySQLParser.SET_SYMBOL)
                self.state = 7908
                self.nullLiteral()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 7909
                self.match(MySQLParser.SET_SYMBOL)
                self.state = 7910
                self.match(MySQLParser.DEFAULT_SYMBOL)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 7911
                self.match(MySQLParser.NO_SYMBOL)
                self.state = 7912
                self.match(MySQLParser.ACTION_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeyListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def keyPart(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.KeyPartContext)
            else:
                return self.getTypedRuleContext(MySQLParser.KeyPartContext,i)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_keyList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyList" ):
                listener.enterKeyList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyList" ):
                listener.exitKeyList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKeyList" ):
                return visitor.visitKeyList(self)
            else:
                return visitor.visitChildren(self)




    def keyList(self):

        localctx = MySQLParser.KeyListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1144, self.RULE_keyList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7915
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 7916
            self.keyPart()
            self.state = 7921
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 7917
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 7918
                self.keyPart()
                self.state = 7923
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 7924
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeyPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def fieldLength(self):
            return self.getTypedRuleContext(MySQLParser.FieldLengthContext,0)


        def direction(self):
            return self.getTypedRuleContext(MySQLParser.DirectionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_keyPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyPart" ):
                listener.enterKeyPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyPart" ):
                listener.exitKeyPart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKeyPart" ):
                return visitor.visitKeyPart(self)
            else:
                return visitor.visitChildren(self)




    def keyPart(self):

        localctx = MySQLParser.KeyPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1146, self.RULE_keyPart)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7926
            self.identifier()
            self.state = 7928
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==32:
                self.state = 7927
                self.fieldLength()


            self.state = 7931
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==64 or _la==172:
                self.state = 7930
                self.direction()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeyListWithExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def keyPartOrExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.KeyPartOrExpressionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.KeyPartOrExpressionContext,i)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_keyListWithExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyListWithExpression" ):
                listener.enterKeyListWithExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyListWithExpression" ):
                listener.exitKeyListWithExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKeyListWithExpression" ):
                return visitor.visitKeyListWithExpression(self)
            else:
                return visitor.visitChildren(self)




    def keyListWithExpression(self):

        localctx = MySQLParser.KeyListWithExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1148, self.RULE_keyListWithExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7933
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 7934
            self.keyPartOrExpression()
            self.state = 7939
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 7935
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 7936
                self.keyPartOrExpression()
                self.state = 7941
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 7942
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeyPartOrExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def keyPart(self):
            return self.getTypedRuleContext(MySQLParser.KeyPartContext,0)


        def exprWithParentheses(self):
            return self.getTypedRuleContext(MySQLParser.ExprWithParenthesesContext,0)


        def direction(self):
            return self.getTypedRuleContext(MySQLParser.DirectionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_keyPartOrExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyPartOrExpression" ):
                listener.enterKeyPartOrExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyPartOrExpression" ):
                listener.exitKeyPartOrExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKeyPartOrExpression" ):
                return visitor.visitKeyPartOrExpression(self)
            else:
                return visitor.visitChildren(self)




    def keyPartOrExpression(self):

        localctx = MySQLParser.KeyPartOrExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1150, self.RULE_keyPartOrExpression)
        self._la = 0 # Token type
        try:
            self.state = 7950
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,968,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7944
                self.keyPart()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7945
                if not self.isServerVersionGe80013():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80013()")
                self.state = 7946
                self.exprWithParentheses()
                self.state = 7948
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==64 or _la==172:
                    self.state = 7947
                    self.direction()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndexTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.algorithm = None # Token

        def BTREE_SYMBOL(self):
            return self.getToken(MySQLParser.BTREE_SYMBOL, 0)

        def RTREE_SYMBOL(self):
            return self.getToken(MySQLParser.RTREE_SYMBOL, 0)

        def HASH_SYMBOL(self):
            return self.getToken(MySQLParser.HASH_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_indexType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndexType" ):
                listener.enterIndexType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndexType" ):
                listener.exitIndexType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndexType" ):
                return visitor.visitIndexType(self)
            else:
                return visitor.visitChildren(self)




    def indexType(self):

        localctx = MySQLParser.IndexTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1152, self.RULE_indexType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7952
            localctx.algorithm = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==88 or _la==252 or _la==504):
                localctx.algorithm = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndexOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def commonIndexOption(self):
            return self.getTypedRuleContext(MySQLParser.CommonIndexOptionContext,0)


        def indexTypeClause(self):
            return self.getTypedRuleContext(MySQLParser.IndexTypeClauseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_indexOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndexOption" ):
                listener.enterIndexOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndexOption" ):
                listener.exitIndexOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndexOption" ):
                return visitor.visitIndexOption(self)
            else:
                return visitor.visitChildren(self)




    def indexOption(self):

        localctx = MySQLParser.IndexOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1154, self.RULE_indexOption)
        try:
            self.state = 7956
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,969,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7954
                self.commonIndexOption()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7955
                self.indexTypeClause()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CommonIndexOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KEY_BLOCK_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.KEY_BLOCK_SIZE_SYMBOL, 0)

        def ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Ulong_numberContext,0)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def COMMENT_SYMBOL(self):
            return self.getToken(MySQLParser.COMMENT_SYMBOL, 0)

        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def visibility(self):
            return self.getTypedRuleContext(MySQLParser.VisibilityContext,0)


        def ENGINE_ATTRIBUTE_SYMBOL(self):
            return self.getToken(MySQLParser.ENGINE_ATTRIBUTE_SYMBOL, 0)

        def jsonAttribute(self):
            return self.getTypedRuleContext(MySQLParser.JsonAttributeContext,0)


        def SECONDARY_ENGINE_ATTRIBUTE_SYMBOL(self):
            return self.getToken(MySQLParser.SECONDARY_ENGINE_ATTRIBUTE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_commonIndexOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCommonIndexOption" ):
                listener.enterCommonIndexOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCommonIndexOption" ):
                listener.exitCommonIndexOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCommonIndexOption" ):
                return visitor.visitCommonIndexOption(self)
            else:
                return visitor.visitChildren(self)




    def commonIndexOption(self):

        localctx = MySQLParser.CommonIndexOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1156, self.RULE_commonIndexOption)
        self._la = 0 # Token type
        try:
            self.state = 7978
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,973,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7958
                self.match(MySQLParser.KEY_BLOCK_SIZE_SYMBOL)
                self.state = 7960
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 7959
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 7962
                self.ulong_number()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7963
                self.match(MySQLParser.COMMENT_SYMBOL)
                self.state = 7964
                self.textLiteral()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 7965
                self.visibility()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 7966
                if not self.isServerVersionGe80024():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                self.state = 7967
                self.match(MySQLParser.ENGINE_ATTRIBUTE_SYMBOL)
                self.state = 7969
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,971,self._ctx)
                if la_ == 1:
                    self.state = 7968
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 7971
                self.jsonAttribute()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 7972
                if not self.isServerVersionGe80024():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                self.state = 7973
                self.match(MySQLParser.SECONDARY_ENGINE_ATTRIBUTE_SYMBOL)
                self.state = 7975
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,972,self._ctx)
                if la_ == 1:
                    self.state = 7974
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 7977
                self.jsonAttribute()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VisibilityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VISIBLE_SYMBOL(self):
            return self.getToken(MySQLParser.VISIBLE_SYMBOL, 0)

        def INVISIBLE_SYMBOL(self):
            return self.getToken(MySQLParser.INVISIBLE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_visibility

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVisibility" ):
                listener.enterVisibility(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVisibility" ):
                listener.exitVisibility(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVisibility" ):
                return visitor.visitVisibility(self)
            else:
                return visitor.visitChildren(self)




    def visibility(self):

        localctx = MySQLParser.VisibilityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1158, self.RULE_visibility)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7980
            _la = self._input.LA(1)
            if not(_la==669 or _la==670):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndexTypeClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def indexType(self):
            return self.getTypedRuleContext(MySQLParser.IndexTypeContext,0)


        def USING_SYMBOL(self):
            return self.getToken(MySQLParser.USING_SYMBOL, 0)

        def TYPE_SYMBOL(self):
            return self.getToken(MySQLParser.TYPE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_indexTypeClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndexTypeClause" ):
                listener.enterIndexTypeClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndexTypeClause" ):
                listener.exitIndexTypeClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndexTypeClause" ):
                return visitor.visitIndexTypeClause(self)
            else:
                return visitor.visitChildren(self)




    def indexTypeClause(self):

        localctx = MySQLParser.IndexTypeClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1160, self.RULE_indexTypeClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7982
            _la = self._input.LA(1)
            if not(_la==608 or _la==630):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 7983
            self.indexType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FulltextIndexOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def commonIndexOption(self):
            return self.getTypedRuleContext(MySQLParser.CommonIndexOptionContext,0)


        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def PARSER_SYMBOL(self):
            return self.getToken(MySQLParser.PARSER_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_fulltextIndexOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFulltextIndexOption" ):
                listener.enterFulltextIndexOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFulltextIndexOption" ):
                listener.exitFulltextIndexOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFulltextIndexOption" ):
                return visitor.visitFulltextIndexOption(self)
            else:
                return visitor.visitChildren(self)




    def fulltextIndexOption(self):

        localctx = MySQLParser.FulltextIndexOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1162, self.RULE_fulltextIndexOption)
        try:
            self.state = 7989
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,974,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7985
                self.commonIndexOption()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7986
                self.match(MySQLParser.WITH_SYMBOL)
                self.state = 7987
                self.match(MySQLParser.PARSER_SYMBOL)
                self.state = 7988
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SpatialIndexOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def commonIndexOption(self):
            return self.getTypedRuleContext(MySQLParser.CommonIndexOptionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_spatialIndexOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpatialIndexOption" ):
                listener.enterSpatialIndexOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpatialIndexOption" ):
                listener.exitSpatialIndexOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSpatialIndexOption" ):
                return visitor.visitSpatialIndexOption(self)
            else:
                return visitor.visitChildren(self)




    def spatialIndexOption(self):

        localctx = MySQLParser.SpatialIndexOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1164, self.RULE_spatialIndexOption)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7991
            self.commonIndexOption()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataTypeDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dataType(self):
            return self.getTypedRuleContext(MySQLParser.DataTypeContext,0)


        def EOF(self):
            return self.getToken(MySQLParser.EOF, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_dataTypeDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataTypeDefinition" ):
                listener.enterDataTypeDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataTypeDefinition" ):
                listener.exitDataTypeDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataTypeDefinition" ):
                return visitor.visitDataTypeDefinition(self)
            else:
                return visitor.visitChildren(self)




    def dataTypeDefinition(self):

        localctx = MySQLParser.DataTypeDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1166, self.RULE_dataTypeDefinition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7993
            self.dataType()
            self.state = 7994
            self.match(MySQLParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # Token

        def INT_SYMBOL(self):
            return self.getToken(MySQLParser.INT_SYMBOL, 0)

        def TINYINT_SYMBOL(self):
            return self.getToken(MySQLParser.TINYINT_SYMBOL, 0)

        def SMALLINT_SYMBOL(self):
            return self.getToken(MySQLParser.SMALLINT_SYMBOL, 0)

        def MEDIUMINT_SYMBOL(self):
            return self.getToken(MySQLParser.MEDIUMINT_SYMBOL, 0)

        def BIGINT_SYMBOL(self):
            return self.getToken(MySQLParser.BIGINT_SYMBOL, 0)

        def fieldLength(self):
            return self.getTypedRuleContext(MySQLParser.FieldLengthContext,0)


        def fieldOptions(self):
            return self.getTypedRuleContext(MySQLParser.FieldOptionsContext,0)


        def REAL_SYMBOL(self):
            return self.getToken(MySQLParser.REAL_SYMBOL, 0)

        def DOUBLE_SYMBOL(self):
            return self.getToken(MySQLParser.DOUBLE_SYMBOL, 0)

        def precision(self):
            return self.getTypedRuleContext(MySQLParser.PrecisionContext,0)


        def PRECISION_SYMBOL(self):
            return self.getToken(MySQLParser.PRECISION_SYMBOL, 0)

        def FLOAT_SYMBOL(self):
            return self.getToken(MySQLParser.FLOAT_SYMBOL, 0)

        def DECIMAL_SYMBOL(self):
            return self.getToken(MySQLParser.DECIMAL_SYMBOL, 0)

        def NUMERIC_SYMBOL(self):
            return self.getToken(MySQLParser.NUMERIC_SYMBOL, 0)

        def FIXED_SYMBOL(self):
            return self.getToken(MySQLParser.FIXED_SYMBOL, 0)

        def floatOptions(self):
            return self.getTypedRuleContext(MySQLParser.FloatOptionsContext,0)


        def BIT_SYMBOL(self):
            return self.getToken(MySQLParser.BIT_SYMBOL, 0)

        def BOOL_SYMBOL(self):
            return self.getToken(MySQLParser.BOOL_SYMBOL, 0)

        def BOOLEAN_SYMBOL(self):
            return self.getToken(MySQLParser.BOOLEAN_SYMBOL, 0)

        def CHAR_SYMBOL(self):
            return self.getToken(MySQLParser.CHAR_SYMBOL, 0)

        def charsetWithOptBinary(self):
            return self.getTypedRuleContext(MySQLParser.CharsetWithOptBinaryContext,0)


        def nchar(self):
            return self.getTypedRuleContext(MySQLParser.NcharContext,0)


        def BINARY_SYMBOL(self):
            return self.getToken(MySQLParser.BINARY_SYMBOL, 0)

        def VARYING_SYMBOL(self):
            return self.getToken(MySQLParser.VARYING_SYMBOL, 0)

        def VARCHAR_SYMBOL(self):
            return self.getToken(MySQLParser.VARCHAR_SYMBOL, 0)

        def NATIONAL_SYMBOL(self):
            return self.getToken(MySQLParser.NATIONAL_SYMBOL, 0)

        def NVARCHAR_SYMBOL(self):
            return self.getToken(MySQLParser.NVARCHAR_SYMBOL, 0)

        def NCHAR_SYMBOL(self):
            return self.getToken(MySQLParser.NCHAR_SYMBOL, 0)

        def VARBINARY_SYMBOL(self):
            return self.getToken(MySQLParser.VARBINARY_SYMBOL, 0)

        def YEAR_SYMBOL(self):
            return self.getToken(MySQLParser.YEAR_SYMBOL, 0)

        def DATE_SYMBOL(self):
            return self.getToken(MySQLParser.DATE_SYMBOL, 0)

        def TIME_SYMBOL(self):
            return self.getToken(MySQLParser.TIME_SYMBOL, 0)

        def typeDatetimePrecision(self):
            return self.getTypedRuleContext(MySQLParser.TypeDatetimePrecisionContext,0)


        def TIMESTAMP_SYMBOL(self):
            return self.getToken(MySQLParser.TIMESTAMP_SYMBOL, 0)

        def DATETIME_SYMBOL(self):
            return self.getToken(MySQLParser.DATETIME_SYMBOL, 0)

        def TINYBLOB_SYMBOL(self):
            return self.getToken(MySQLParser.TINYBLOB_SYMBOL, 0)

        def BLOB_SYMBOL(self):
            return self.getToken(MySQLParser.BLOB_SYMBOL, 0)

        def MEDIUMBLOB_SYMBOL(self):
            return self.getToken(MySQLParser.MEDIUMBLOB_SYMBOL, 0)

        def LONGBLOB_SYMBOL(self):
            return self.getToken(MySQLParser.LONGBLOB_SYMBOL, 0)

        def LONG_SYMBOL(self):
            return self.getToken(MySQLParser.LONG_SYMBOL, 0)

        def TINYTEXT_SYMBOL(self):
            return self.getToken(MySQLParser.TINYTEXT_SYMBOL, 0)

        def TEXT_SYMBOL(self):
            return self.getToken(MySQLParser.TEXT_SYMBOL, 0)

        def MEDIUMTEXT_SYMBOL(self):
            return self.getToken(MySQLParser.MEDIUMTEXT_SYMBOL, 0)

        def LONGTEXT_SYMBOL(self):
            return self.getToken(MySQLParser.LONGTEXT_SYMBOL, 0)

        def stringList(self):
            return self.getTypedRuleContext(MySQLParser.StringListContext,0)


        def ENUM_SYMBOL(self):
            return self.getToken(MySQLParser.ENUM_SYMBOL, 0)

        def SET_SYMBOL(self):
            return self.getToken(MySQLParser.SET_SYMBOL, 0)

        def SERIAL_SYMBOL(self):
            return self.getToken(MySQLParser.SERIAL_SYMBOL, 0)

        def JSON_SYMBOL(self):
            return self.getToken(MySQLParser.JSON_SYMBOL, 0)

        def GEOMETRY_SYMBOL(self):
            return self.getToken(MySQLParser.GEOMETRY_SYMBOL, 0)

        def GEOMETRYCOLLECTION_SYMBOL(self):
            return self.getToken(MySQLParser.GEOMETRYCOLLECTION_SYMBOL, 0)

        def POINT_SYMBOL(self):
            return self.getToken(MySQLParser.POINT_SYMBOL, 0)

        def MULTIPOINT_SYMBOL(self):
            return self.getToken(MySQLParser.MULTIPOINT_SYMBOL, 0)

        def LINESTRING_SYMBOL(self):
            return self.getToken(MySQLParser.LINESTRING_SYMBOL, 0)

        def MULTILINESTRING_SYMBOL(self):
            return self.getToken(MySQLParser.MULTILINESTRING_SYMBOL, 0)

        def POLYGON_SYMBOL(self):
            return self.getToken(MySQLParser.POLYGON_SYMBOL, 0)

        def MULTIPOLYGON_SYMBOL(self):
            return self.getToken(MySQLParser.MULTIPOLYGON_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_dataType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataType" ):
                listener.enterDataType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataType" ):
                listener.exitDataType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataType" ):
                return visitor.visitDataType(self)
            else:
                return visitor.visitChildren(self)




    def dataType(self):

        localctx = MySQLParser.DataTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1168, self.RULE_dataType)
        self._la = 0 # Token type
        try:
            self.state = 8142
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1008,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7996
                localctx.type_ = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==76 or _la==280 or _la==355 or _la==528 or _la==597):
                    localctx.type_ = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 7998
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,975,self._ctx)
                if la_ == 1:
                    self.state = 7997
                    self.fieldLength()


                self.state = 8001
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,976,self._ctx)
                if la_ == 1:
                    self.state = 8000
                    self.fieldOptions()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8008
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [455]:
                    self.state = 8003
                    localctx.type_ = self.match(MySQLParser.REAL_SYMBOL)
                    pass
                elif token in [182]:
                    self.state = 8004
                    localctx.type_ = self.match(MySQLParser.DOUBLE_SYMBOL)
                    self.state = 8006
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,977,self._ctx)
                    if la_ == 1:
                        self.state = 8005
                        self.match(MySQLParser.PRECISION_SYMBOL)


                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 8011
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,979,self._ctx)
                if la_ == 1:
                    self.state = 8010
                    self.precision()


                self.state = 8014
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,980,self._ctx)
                if la_ == 1:
                    self.state = 8013
                    self.fieldOptions()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 8016
                localctx.type_ = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & -4611686018427387903) != 0) or _la==397):
                    localctx.type_ = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 8018
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,981,self._ctx)
                if la_ == 1:
                    self.state = 8017
                    self.floatOptions()


                self.state = 8021
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,982,self._ctx)
                if la_ == 1:
                    self.state = 8020
                    self.fieldOptions()


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 8023
                localctx.type_ = self.match(MySQLParser.BIT_SYMBOL)
                self.state = 8025
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,983,self._ctx)
                if la_ == 1:
                    self.state = 8024
                    self.fieldLength()


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 8027
                localctx.type_ = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==85 or _la==86):
                    localctx.type_ = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 8028
                localctx.type_ = self.match(MySQLParser.CHAR_SYMBOL)
                self.state = 8030
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,984,self._ctx)
                if la_ == 1:
                    self.state = 8029
                    self.fieldLength()


                self.state = 8033
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,985,self._ctx)
                if la_ == 1:
                    self.state = 8032
                    self.charsetWithOptBinary()


                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 8035
                self.nchar()
                self.state = 8037
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,986,self._ctx)
                if la_ == 1:
                    self.state = 8036
                    self.fieldLength()


                self.state = 8040
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,987,self._ctx)
                if la_ == 1:
                    self.state = 8039
                    self.match(MySQLParser.BINARY_SYMBOL)


                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 8042
                localctx.type_ = self.match(MySQLParser.BINARY_SYMBOL)
                self.state = 8044
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,988,self._ctx)
                if la_ == 1:
                    self.state = 8043
                    self.fieldLength()


                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 8049
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [103]:
                    self.state = 8046
                    localctx.type_ = self.match(MySQLParser.CHAR_SYMBOL)
                    self.state = 8047
                    self.match(MySQLParser.VARYING_SYMBOL)
                    pass
                elif token in [638]:
                    self.state = 8048
                    localctx.type_ = self.match(MySQLParser.VARCHAR_SYMBOL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 8051
                self.fieldLength()
                self.state = 8053
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,990,self._ctx)
                if la_ == 1:
                    self.state = 8052
                    self.charsetWithOptBinary()


                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 8065
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,991,self._ctx)
                if la_ == 1:
                    self.state = 8055
                    localctx.type_ = self.match(MySQLParser.NATIONAL_SYMBOL)
                    self.state = 8056
                    self.match(MySQLParser.VARCHAR_SYMBOL)
                    pass

                elif la_ == 2:
                    self.state = 8057
                    localctx.type_ = self.match(MySQLParser.NVARCHAR_SYMBOL)
                    pass

                elif la_ == 3:
                    self.state = 8058
                    localctx.type_ = self.match(MySQLParser.NCHAR_SYMBOL)
                    self.state = 8059
                    self.match(MySQLParser.VARCHAR_SYMBOL)
                    pass

                elif la_ == 4:
                    self.state = 8060
                    localctx.type_ = self.match(MySQLParser.NATIONAL_SYMBOL)
                    self.state = 8061
                    self.match(MySQLParser.CHAR_SYMBOL)
                    self.state = 8062
                    self.match(MySQLParser.VARYING_SYMBOL)
                    pass

                elif la_ == 5:
                    self.state = 8063
                    localctx.type_ = self.match(MySQLParser.NCHAR_SYMBOL)
                    self.state = 8064
                    self.match(MySQLParser.VARYING_SYMBOL)
                    pass


                self.state = 8067
                self.fieldLength()
                self.state = 8069
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,992,self._ctx)
                if la_ == 1:
                    self.state = 8068
                    self.match(MySQLParser.BINARY_SYMBOL)


                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 8071
                localctx.type_ = self.match(MySQLParser.VARBINARY_SYMBOL)
                self.state = 8072
                self.fieldLength()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 8073
                localctx.type_ = self.match(MySQLParser.YEAR_SYMBOL)
                self.state = 8075
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,993,self._ctx)
                if la_ == 1:
                    self.state = 8074
                    self.fieldLength()


                self.state = 8078
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,994,self._ctx)
                if la_ == 1:
                    self.state = 8077
                    self.fieldOptions()


                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 8080
                localctx.type_ = self.match(MySQLParser.DATE_SYMBOL)
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 8081
                localctx.type_ = self.match(MySQLParser.TIME_SYMBOL)
                self.state = 8083
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,995,self._ctx)
                if la_ == 1:
                    self.state = 8082
                    self.typeDatetimePrecision()


                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 8085
                localctx.type_ = self.match(MySQLParser.TIMESTAMP_SYMBOL)
                self.state = 8087
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,996,self._ctx)
                if la_ == 1:
                    self.state = 8086
                    self.typeDatetimePrecision()


                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 8089
                localctx.type_ = self.match(MySQLParser.DATETIME_SYMBOL)
                self.state = 8091
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,997,self._ctx)
                if la_ == 1:
                    self.state = 8090
                    self.typeDatetimePrecision()


                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 8093
                localctx.type_ = self.match(MySQLParser.TINYBLOB_SYMBOL)
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 8094
                localctx.type_ = self.match(MySQLParser.BLOB_SYMBOL)
                self.state = 8096
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,998,self._ctx)
                if la_ == 1:
                    self.state = 8095
                    self.fieldLength()


                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 8098
                localctx.type_ = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==317 or _la==354):
                    localctx.type_ = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 8099
                localctx.type_ = self.match(MySQLParser.LONG_SYMBOL)
                self.state = 8100
                self.match(MySQLParser.VARBINARY_SYMBOL)
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 8101
                localctx.type_ = self.match(MySQLParser.LONG_SYMBOL)
                self.state = 8105
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,999,self._ctx)
                if la_ == 1:
                    self.state = 8102
                    self.match(MySQLParser.CHAR_SYMBOL)
                    self.state = 8103
                    self.match(MySQLParser.VARYING_SYMBOL)

                elif la_ == 2:
                    self.state = 8104
                    self.match(MySQLParser.VARCHAR_SYMBOL)


                self.state = 8108
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1000,self._ctx)
                if la_ == 1:
                    self.state = 8107
                    self.charsetWithOptBinary()


                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 8110
                localctx.type_ = self.match(MySQLParser.TINYTEXT_SYMBOL)
                self.state = 8112
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1001,self._ctx)
                if la_ == 1:
                    self.state = 8111
                    self.charsetWithOptBinary()


                pass

            elif la_ == 23:
                self.enterOuterAlt(localctx, 23)
                self.state = 8114
                localctx.type_ = self.match(MySQLParser.TEXT_SYMBOL)
                self.state = 8116
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1002,self._ctx)
                if la_ == 1:
                    self.state = 8115
                    self.fieldLength()


                self.state = 8119
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1003,self._ctx)
                if la_ == 1:
                    self.state = 8118
                    self.charsetWithOptBinary()


                pass

            elif la_ == 24:
                self.enterOuterAlt(localctx, 24)
                self.state = 8121
                localctx.type_ = self.match(MySQLParser.MEDIUMTEXT_SYMBOL)
                self.state = 8123
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1004,self._ctx)
                if la_ == 1:
                    self.state = 8122
                    self.charsetWithOptBinary()


                pass

            elif la_ == 25:
                self.enterOuterAlt(localctx, 25)
                self.state = 8125
                localctx.type_ = self.match(MySQLParser.LONGTEXT_SYMBOL)
                self.state = 8127
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1005,self._ctx)
                if la_ == 1:
                    self.state = 8126
                    self.charsetWithOptBinary()


                pass

            elif la_ == 26:
                self.enterOuterAlt(localctx, 26)
                self.state = 8129
                localctx.type_ = self.match(MySQLParser.ENUM_SYMBOL)
                self.state = 8130
                self.stringList()
                self.state = 8132
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1006,self._ctx)
                if la_ == 1:
                    self.state = 8131
                    self.charsetWithOptBinary()


                pass

            elif la_ == 27:
                self.enterOuterAlt(localctx, 27)
                self.state = 8134
                localctx.type_ = self.match(MySQLParser.SET_SYMBOL)
                self.state = 8135
                self.stringList()
                self.state = 8137
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1007,self._ctx)
                if la_ == 1:
                    self.state = 8136
                    self.charsetWithOptBinary()


                pass

            elif la_ == 28:
                self.enterOuterAlt(localctx, 28)
                self.state = 8139
                localctx.type_ = self.match(MySQLParser.SERIAL_SYMBOL)
                pass

            elif la_ == 29:
                self.enterOuterAlt(localctx, 29)
                self.state = 8140
                localctx.type_ = self.match(MySQLParser.JSON_SYMBOL)
                pass

            elif la_ == 30:
                self.enterOuterAlt(localctx, 30)
                self.state = 8141
                localctx.type_ = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==243 or _la==244 or _la==309 or ((((_la - 374)) & ~0x3f) == 0 and ((1 << (_la - 374)) & 108086391056891911) != 0)):
                    localctx.type_ = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NcharContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # Token

        def NCHAR_SYMBOL(self):
            return self.getToken(MySQLParser.NCHAR_SYMBOL, 0)

        def CHAR_SYMBOL(self):
            return self.getToken(MySQLParser.CHAR_SYMBOL, 0)

        def NATIONAL_SYMBOL(self):
            return self.getToken(MySQLParser.NATIONAL_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_nchar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNchar" ):
                listener.enterNchar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNchar" ):
                listener.exitNchar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNchar" ):
                return visitor.visitNchar(self)
            else:
                return visitor.visitChildren(self)




    def nchar(self):

        localctx = MySQLParser.NcharContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1170, self.RULE_nchar)
        try:
            self.state = 8147
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [383]:
                self.enterOuterAlt(localctx, 1)
                self.state = 8144
                localctx.type_ = self.match(MySQLParser.NCHAR_SYMBOL)
                pass
            elif token in [381]:
                self.enterOuterAlt(localctx, 2)
                self.state = 8145
                localctx.type_ = self.match(MySQLParser.NATIONAL_SYMBOL)
                self.state = 8146
                self.match(MySQLParser.CHAR_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RealTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # Token

        def REAL_SYMBOL(self):
            return self.getToken(MySQLParser.REAL_SYMBOL, 0)

        def DOUBLE_SYMBOL(self):
            return self.getToken(MySQLParser.DOUBLE_SYMBOL, 0)

        def PRECISION_SYMBOL(self):
            return self.getToken(MySQLParser.PRECISION_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_realType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRealType" ):
                listener.enterRealType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRealType" ):
                listener.exitRealType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRealType" ):
                return visitor.visitRealType(self)
            else:
                return visitor.visitChildren(self)




    def realType(self):

        localctx = MySQLParser.RealTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1172, self.RULE_realType)
        try:
            self.state = 8154
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [455]:
                self.enterOuterAlt(localctx, 1)
                self.state = 8149
                localctx.type_ = self.match(MySQLParser.REAL_SYMBOL)
                pass
            elif token in [182]:
                self.enterOuterAlt(localctx, 2)
                self.state = 8150
                localctx.type_ = self.match(MySQLParser.DOUBLE_SYMBOL)
                self.state = 8152
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1010,self._ctx)
                if la_ == 1:
                    self.state = 8151
                    self.match(MySQLParser.PRECISION_SYMBOL)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FieldLengthContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def real_ulonglong_number(self):
            return self.getTypedRuleContext(MySQLParser.Real_ulonglong_numberContext,0)


        def DECIMAL_NUMBER(self):
            return self.getToken(MySQLParser.DECIMAL_NUMBER, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_fieldLength

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFieldLength" ):
                listener.enterFieldLength(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFieldLength" ):
                listener.exitFieldLength(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFieldLength" ):
                return visitor.visitFieldLength(self)
            else:
                return visitor.visitChildren(self)




    def fieldLength(self):

        localctx = MySQLParser.FieldLengthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1174, self.RULE_fieldLength)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8156
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 8159
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1012,self._ctx)
            if la_ == 1:
                self.state = 8157
                self.real_ulonglong_number()
                pass

            elif la_ == 2:
                self.state = 8158
                self.match(MySQLParser.DECIMAL_NUMBER)
                pass


            self.state = 8161
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FieldOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.SIGNED_SYMBOL)
            else:
                return self.getToken(MySQLParser.SIGNED_SYMBOL, i)

        def UNSIGNED_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.UNSIGNED_SYMBOL)
            else:
                return self.getToken(MySQLParser.UNSIGNED_SYMBOL, i)

        def ZEROFILL_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.ZEROFILL_SYMBOL)
            else:
                return self.getToken(MySQLParser.ZEROFILL_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_fieldOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFieldOptions" ):
                listener.enterFieldOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFieldOptions" ):
                listener.exitFieldOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFieldOptions" ):
                return visitor.visitFieldOptions(self)
            else:
                return visitor.visitChildren(self)




    def fieldOptions(self):

        localctx = MySQLParser.FieldOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1176, self.RULE_fieldOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8164 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 8163
                    _la = self._input.LA(1)
                    if not(_la==524 or _la==621 or _la==665):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                else:
                    raise NoViableAltException(self)
                self.state = 8166 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1013,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CharsetWithOptBinaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ascii(self):
            return self.getTypedRuleContext(MySQLParser.AsciiContext,0)


        def unicode_(self):
            return self.getTypedRuleContext(MySQLParser.UnicodeContext,0)


        def BYTE_SYMBOL(self):
            return self.getToken(MySQLParser.BYTE_SYMBOL, 0)

        def charset(self):
            return self.getTypedRuleContext(MySQLParser.CharsetContext,0)


        def charsetName(self):
            return self.getTypedRuleContext(MySQLParser.CharsetNameContext,0)


        def BINARY_SYMBOL(self):
            return self.getToken(MySQLParser.BINARY_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_charsetWithOptBinary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCharsetWithOptBinary" ):
                listener.enterCharsetWithOptBinary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCharsetWithOptBinary" ):
                listener.exitCharsetWithOptBinary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCharsetWithOptBinary" ):
                return visitor.visitCharsetWithOptBinary(self)
            else:
                return visitor.visitChildren(self)




    def charsetWithOptBinary(self):

        localctx = MySQLParser.CharsetWithOptBinaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1178, self.RULE_charsetWithOptBinary)
        try:
            self.state = 8182
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1016,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8168
                self.ascii()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8169
                self.unicode_()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 8170
                self.match(MySQLParser.BYTE_SYMBOL)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 8171
                self.charset()
                self.state = 8172
                self.charsetName()
                self.state = 8174
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1014,self._ctx)
                if la_ == 1:
                    self.state = 8173
                    self.match(MySQLParser.BINARY_SYMBOL)


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 8176
                self.match(MySQLParser.BINARY_SYMBOL)
                self.state = 8180
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1015,self._ctx)
                if la_ == 1:
                    self.state = 8177
                    self.charset()
                    self.state = 8178
                    self.charsetName()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AsciiContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASCII_SYMBOL(self):
            return self.getToken(MySQLParser.ASCII_SYMBOL, 0)

        def BINARY_SYMBOL(self):
            return self.getToken(MySQLParser.BINARY_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_ascii

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAscii" ):
                listener.enterAscii(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAscii" ):
                listener.exitAscii(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAscii" ):
                return visitor.visitAscii(self)
            else:
                return visitor.visitChildren(self)




    def ascii(self):

        localctx = MySQLParser.AsciiContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1180, self.RULE_ascii)
        try:
            self.state = 8190
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [65]:
                self.enterOuterAlt(localctx, 1)
                self.state = 8184
                self.match(MySQLParser.ASCII_SYMBOL)
                self.state = 8186
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1017,self._ctx)
                if la_ == 1:
                    self.state = 8185
                    self.match(MySQLParser.BINARY_SYMBOL)


                pass
            elif token in [77]:
                self.enterOuterAlt(localctx, 2)
                self.state = 8188
                self.match(MySQLParser.BINARY_SYMBOL)
                self.state = 8189
                self.match(MySQLParser.ASCII_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnicodeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNICODE_SYMBOL(self):
            return self.getToken(MySQLParser.UNICODE_SYMBOL, 0)

        def BINARY_SYMBOL(self):
            return self.getToken(MySQLParser.BINARY_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_unicode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnicode" ):
                listener.enterUnicode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnicode" ):
                listener.exitUnicode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnicode" ):
                return visitor.visitUnicode(self)
            else:
                return visitor.visitChildren(self)




    def unicode_(self):

        localctx = MySQLParser.UnicodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1182, self.RULE_unicode)
        try:
            self.state = 8198
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [615]:
                self.enterOuterAlt(localctx, 1)
                self.state = 8192
                self.match(MySQLParser.UNICODE_SYMBOL)
                self.state = 8194
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1019,self._ctx)
                if la_ == 1:
                    self.state = 8193
                    self.match(MySQLParser.BINARY_SYMBOL)


                pass
            elif token in [77]:
                self.enterOuterAlt(localctx, 2)
                self.state = 8196
                self.match(MySQLParser.BINARY_SYMBOL)
                self.state = 8197
                self.match(MySQLParser.UNICODE_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WsNumCodepointsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def real_ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Real_ulong_numberContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_wsNumCodepoints

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWsNumCodepoints" ):
                listener.enterWsNumCodepoints(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWsNumCodepoints" ):
                listener.exitWsNumCodepoints(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWsNumCodepoints" ):
                return visitor.visitWsNumCodepoints(self)
            else:
                return visitor.visitChildren(self)




    def wsNumCodepoints(self):

        localctx = MySQLParser.WsNumCodepointsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1184, self.RULE_wsNumCodepoints)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8200
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 8201
            self.real_ulong_number()
            self.state = 8202
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeDatetimePrecisionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def INT_NUMBER(self):
            return self.getToken(MySQLParser.INT_NUMBER, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_typeDatetimePrecision

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeDatetimePrecision" ):
                listener.enterTypeDatetimePrecision(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeDatetimePrecision" ):
                listener.exitTypeDatetimePrecision(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeDatetimePrecision" ):
                return visitor.visitTypeDatetimePrecision(self)
            else:
                return visitor.visitChildren(self)




    def typeDatetimePrecision(self):

        localctx = MySQLParser.TypeDatetimePrecisionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1186, self.RULE_typeDatetimePrecision)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8204
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 8205
            self.match(MySQLParser.INT_NUMBER)
            self.state = 8206
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDatetimePrecisionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parentheses(self):
            return self.getTypedRuleContext(MySQLParser.ParenthesesContext,0)


        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def INT_NUMBER(self):
            return self.getToken(MySQLParser.INT_NUMBER, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_functionDatetimePrecision

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDatetimePrecision" ):
                listener.enterFunctionDatetimePrecision(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDatetimePrecision" ):
                listener.exitFunctionDatetimePrecision(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionDatetimePrecision" ):
                return visitor.visitFunctionDatetimePrecision(self)
            else:
                return visitor.visitChildren(self)




    def functionDatetimePrecision(self):

        localctx = MySQLParser.FunctionDatetimePrecisionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1188, self.RULE_functionDatetimePrecision)
        try:
            self.state = 8213
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1021,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8209
                self.parentheses()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 8210
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 8211
                self.match(MySQLParser.INT_NUMBER)
                self.state = 8212
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CharsetNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def BINARY_SYMBOL(self):
            return self.getToken(MySQLParser.BINARY_SYMBOL, 0)

        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_charsetName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCharsetName" ):
                listener.enterCharsetName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCharsetName" ):
                listener.exitCharsetName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCharsetName" ):
                return visitor.visitCharsetName(self)
            else:
                return visitor.visitChildren(self)




    def charsetName(self):

        localctx = MySQLParser.CharsetNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1190, self.RULE_charsetName)
        try:
            self.state = 8219
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1022,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8215
                self.textOrIdentifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8216
                self.match(MySQLParser.BINARY_SYMBOL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 8217
                if not self.isServerVersionLt80011():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionLt80011()")
                self.state = 8218
                self.match(MySQLParser.DEFAULT_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CollationNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def BINARY_SYMBOL(self):
            return self.getToken(MySQLParser.BINARY_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_collationName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCollationName" ):
                listener.enterCollationName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCollationName" ):
                listener.exitCollationName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCollationName" ):
                return visitor.visitCollationName(self)
            else:
                return visitor.visitChildren(self)




    def collationName(self):

        localctx = MySQLParser.CollationNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1192, self.RULE_collationName)
        try:
            self.state = 8226
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1023,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8221
                self.textOrIdentifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8222
                if not self.isServerVersionLt80011():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionLt80011()")
                self.state = 8223
                self.match(MySQLParser.DEFAULT_SYMBOL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 8224
                if not self.isServerVersionGe80018():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80018()")
                self.state = 8225
                self.match(MySQLParser.BINARY_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateTableOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def createTableOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.CreateTableOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.CreateTableOptionContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_createTableOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateTableOptions" ):
                listener.enterCreateTableOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateTableOptions" ):
                listener.exitCreateTableOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateTableOptions" ):
                return visitor.visitCreateTableOptions(self)
            else:
                return visitor.visitChildren(self)




    def createTableOptions(self):

        localctx = MySQLParser.CreateTableOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1194, self.RULE_createTableOptions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8228
            self.createTableOption()
            self.state = 8235
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,1025,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 8230
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,1024,self._ctx)
                    if la_ == 1:
                        self.state = 8229
                        self.match(MySQLParser.COMMA_SYMBOL)


                    self.state = 8232
                    self.createTableOption() 
                self.state = 8237
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1025,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateTableOptionsEtcContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def createTableOptions(self):
            return self.getTypedRuleContext(MySQLParser.CreateTableOptionsContext,0)


        def createPartitioningEtc(self):
            return self.getTypedRuleContext(MySQLParser.CreatePartitioningEtcContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createTableOptionsEtc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateTableOptionsEtc" ):
                listener.enterCreateTableOptionsEtc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateTableOptionsEtc" ):
                listener.exitCreateTableOptionsEtc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateTableOptionsEtc" ):
                return visitor.visitCreateTableOptionsEtc(self)
            else:
                return visitor.visitChildren(self)




    def createTableOptionsEtc(self):

        localctx = MySQLParser.CreateTableOptionsEtcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1196, self.RULE_createTableOptionsEtc)
        try:
            self.state = 8243
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1027,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8238
                self.createTableOptions()
                self.state = 8240
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1026,self._ctx)
                if la_ == 1:
                    self.state = 8239
                    self.createPartitioningEtc()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8242
                self.createPartitioningEtc()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreatePartitioningEtcContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def partitionClause(self):
            return self.getTypedRuleContext(MySQLParser.PartitionClauseContext,0)


        def duplicateAsQe(self):
            return self.getTypedRuleContext(MySQLParser.DuplicateAsQeContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createPartitioningEtc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreatePartitioningEtc" ):
                listener.enterCreatePartitioningEtc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreatePartitioningEtc" ):
                listener.exitCreatePartitioningEtc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreatePartitioningEtc" ):
                return visitor.visitCreatePartitioningEtc(self)
            else:
                return visitor.visitChildren(self)




    def createPartitioningEtc(self):

        localctx = MySQLParser.CreatePartitioningEtcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1198, self.RULE_createPartitioningEtc)
        try:
            self.state = 8250
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1029,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8245
                self.partitionClause()
                self.state = 8247
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1028,self._ctx)
                if la_ == 1:
                    self.state = 8246
                    self.duplicateAsQe()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8249
                self.duplicateAsQe()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateTableOptionsSpaceSeparatedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def createTableOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.CreateTableOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.CreateTableOptionContext,i)


        def getRuleIndex(self):
            return MySQLParser.RULE_createTableOptionsSpaceSeparated

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateTableOptionsSpaceSeparated" ):
                listener.enterCreateTableOptionsSpaceSeparated(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateTableOptionsSpaceSeparated" ):
                listener.exitCreateTableOptionsSpaceSeparated(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateTableOptionsSpaceSeparated" ):
                return visitor.visitCreateTableOptionsSpaceSeparated(self)
            else:
                return visitor.visitChildren(self)




    def createTableOptionsSpaceSeparated(self):

        localctx = MySQLParser.CreateTableOptionsSpaceSeparatedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1200, self.RULE_createTableOptionsSpaceSeparated)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8253 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 8252
                    self.createTableOption()

                else:
                    raise NoViableAltException(self)
                self.state = 8255 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1030,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateTableOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.option = None # Token
            self.format_ = None # Token
            self.method = None # Token

        def engineRef(self):
            return self.getTypedRuleContext(MySQLParser.EngineRefContext,0)


        def ENGINE_SYMBOL(self):
            return self.getToken(MySQLParser.ENGINE_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def SECONDARY_ENGINE_SYMBOL(self):
            return self.getToken(MySQLParser.SECONDARY_ENGINE_SYMBOL, 0)

        def NULL_SYMBOL(self):
            return self.getToken(MySQLParser.NULL_SYMBOL, 0)

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def equal(self):
            return self.getTypedRuleContext(MySQLParser.EqualContext,0)


        def ulonglongNumber(self):
            return self.getTypedRuleContext(MySQLParser.UlonglongNumberContext,0)


        def MAX_ROWS_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_ROWS_SYMBOL, 0)

        def MIN_ROWS_SYMBOL(self):
            return self.getToken(MySQLParser.MIN_ROWS_SYMBOL, 0)

        def AVG_ROW_LENGTH_SYMBOL(self):
            return self.getToken(MySQLParser.AVG_ROW_LENGTH_SYMBOL, 0)

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def PASSWORD_SYMBOL(self):
            return self.getToken(MySQLParser.PASSWORD_SYMBOL, 0)

        def COMMENT_SYMBOL(self):
            return self.getToken(MySQLParser.COMMENT_SYMBOL, 0)

        def textString(self):
            return self.getTypedRuleContext(MySQLParser.TextStringContext,0)


        def COMPRESSION_SYMBOL(self):
            return self.getToken(MySQLParser.COMPRESSION_SYMBOL, 0)

        def ENCRYPTION_SYMBOL(self):
            return self.getToken(MySQLParser.ENCRYPTION_SYMBOL, 0)

        def AUTO_INCREMENT_SYMBOL(self):
            return self.getToken(MySQLParser.AUTO_INCREMENT_SYMBOL, 0)

        def ternaryOption(self):
            return self.getTypedRuleContext(MySQLParser.TernaryOptionContext,0)


        def PACK_KEYS_SYMBOL(self):
            return self.getToken(MySQLParser.PACK_KEYS_SYMBOL, 0)

        def STATS_AUTO_RECALC_SYMBOL(self):
            return self.getToken(MySQLParser.STATS_AUTO_RECALC_SYMBOL, 0)

        def STATS_PERSISTENT_SYMBOL(self):
            return self.getToken(MySQLParser.STATS_PERSISTENT_SYMBOL, 0)

        def STATS_SAMPLE_PAGES_SYMBOL(self):
            return self.getToken(MySQLParser.STATS_SAMPLE_PAGES_SYMBOL, 0)

        def ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Ulong_numberContext,0)


        def CHECKSUM_SYMBOL(self):
            return self.getToken(MySQLParser.CHECKSUM_SYMBOL, 0)

        def TABLE_CHECKSUM_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_CHECKSUM_SYMBOL, 0)

        def DELAY_KEY_WRITE_SYMBOL(self):
            return self.getToken(MySQLParser.DELAY_KEY_WRITE_SYMBOL, 0)

        def ROW_FORMAT_SYMBOL(self):
            return self.getToken(MySQLParser.ROW_FORMAT_SYMBOL, 0)

        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def DYNAMIC_SYMBOL(self):
            return self.getToken(MySQLParser.DYNAMIC_SYMBOL, 0)

        def FIXED_SYMBOL(self):
            return self.getToken(MySQLParser.FIXED_SYMBOL, 0)

        def COMPRESSED_SYMBOL(self):
            return self.getToken(MySQLParser.COMPRESSED_SYMBOL, 0)

        def REDUNDANT_SYMBOL(self):
            return self.getToken(MySQLParser.REDUNDANT_SYMBOL, 0)

        def COMPACT_SYMBOL(self):
            return self.getToken(MySQLParser.COMPACT_SYMBOL, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def tableRefList(self):
            return self.getTypedRuleContext(MySQLParser.TableRefListContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def UNION_SYMBOL(self):
            return self.getToken(MySQLParser.UNION_SYMBOL, 0)

        def defaultCharset(self):
            return self.getTypedRuleContext(MySQLParser.DefaultCharsetContext,0)


        def defaultCollation(self):
            return self.getTypedRuleContext(MySQLParser.DefaultCollationContext,0)


        def INSERT_METHOD_SYMBOL(self):
            return self.getToken(MySQLParser.INSERT_METHOD_SYMBOL, 0)

        def NO_SYMBOL(self):
            return self.getToken(MySQLParser.NO_SYMBOL, 0)

        def FIRST_SYMBOL(self):
            return self.getToken(MySQLParser.FIRST_SYMBOL, 0)

        def LAST_SYMBOL(self):
            return self.getToken(MySQLParser.LAST_SYMBOL, 0)

        def DIRECTORY_SYMBOL(self):
            return self.getToken(MySQLParser.DIRECTORY_SYMBOL, 0)

        def DATA_SYMBOL(self):
            return self.getToken(MySQLParser.DATA_SYMBOL, 0)

        def INDEX_SYMBOL(self):
            return self.getToken(MySQLParser.INDEX_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def TABLESPACE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLESPACE_SYMBOL, 0)

        def STORAGE_SYMBOL(self):
            return self.getToken(MySQLParser.STORAGE_SYMBOL, 0)

        def DISK_SYMBOL(self):
            return self.getToken(MySQLParser.DISK_SYMBOL, 0)

        def MEMORY_SYMBOL(self):
            return self.getToken(MySQLParser.MEMORY_SYMBOL, 0)

        def CONNECTION_SYMBOL(self):
            return self.getToken(MySQLParser.CONNECTION_SYMBOL, 0)

        def KEY_BLOCK_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.KEY_BLOCK_SIZE_SYMBOL, 0)

        def TRANSACTION_SYMBOL(self):
            return self.getToken(MySQLParser.TRANSACTION_SYMBOL, 0)

        def START_SYMBOL(self):
            return self.getToken(MySQLParser.START_SYMBOL, 0)

        def jsonAttribute(self):
            return self.getTypedRuleContext(MySQLParser.JsonAttributeContext,0)


        def ENGINE_ATTRIBUTE_SYMBOL(self):
            return self.getToken(MySQLParser.ENGINE_ATTRIBUTE_SYMBOL, 0)

        def SECONDARY_ENGINE_ATTRIBUTE_SYMBOL(self):
            return self.getToken(MySQLParser.SECONDARY_ENGINE_ATTRIBUTE_SYMBOL, 0)

        def tsOptionAutoextendSize(self):
            return self.getTypedRuleContext(MySQLParser.TsOptionAutoextendSizeContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createTableOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateTableOption" ):
                listener.enterCreateTableOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateTableOption" ):
                listener.exitCreateTableOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateTableOption" ):
                return visitor.visitCreateTableOption(self)
            else:
                return visitor.visitChildren(self)




    def createTableOption(self):

        localctx = MySQLParser.CreateTableOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1202, self.RULE_createTableOption)
        self._la = 0 # Token type
        try:
            self.state = 8397
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1056,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8257
                localctx.option = self.match(MySQLParser.ENGINE_SYMBOL)
                self.state = 8259
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1031,self._ctx)
                if la_ == 1:
                    self.state = 8258
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8261
                self.engineRef()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8262
                if not self.isServerVersionGe80014():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80014()")
                self.state = 8263
                localctx.option = self.match(MySQLParser.SECONDARY_ENGINE_SYMBOL)
                self.state = 8265
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1032,self._ctx)
                if la_ == 1:
                    self.state = 8264
                    self.equal()


                self.state = 8269
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1033,self._ctx)
                if la_ == 1:
                    self.state = 8267
                    self.match(MySQLParser.NULL_SYMBOL)
                    pass

                elif la_ == 2:
                    self.state = 8268
                    self.textOrIdentifier()
                    pass


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 8271
                localctx.option = self.match(MySQLParser.MAX_ROWS_SYMBOL)
                self.state = 8273
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 8272
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8275
                self.ulonglongNumber()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 8276
                localctx.option = self.match(MySQLParser.MIN_ROWS_SYMBOL)
                self.state = 8278
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 8277
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8280
                self.ulonglongNumber()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 8281
                localctx.option = self.match(MySQLParser.AVG_ROW_LENGTH_SYMBOL)
                self.state = 8283
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 8282
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8285
                self.ulonglongNumber()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 8286
                localctx.option = self.match(MySQLParser.PASSWORD_SYMBOL)
                self.state = 8288
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1037,self._ctx)
                if la_ == 1:
                    self.state = 8287
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8290
                self.textStringLiteral()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 8291
                localctx.option = self.match(MySQLParser.COMMENT_SYMBOL)
                self.state = 8293
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1038,self._ctx)
                if la_ == 1:
                    self.state = 8292
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8295
                self.textStringLiteral()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 8296
                localctx.option = self.match(MySQLParser.COMPRESSION_SYMBOL)
                self.state = 8298
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1039,self._ctx)
                if la_ == 1:
                    self.state = 8297
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8300
                self.textString()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 8301
                localctx.option = self.match(MySQLParser.ENCRYPTION_SYMBOL)
                self.state = 8303
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1040,self._ctx)
                if la_ == 1:
                    self.state = 8302
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8305
                self.textString()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 8306
                localctx.option = self.match(MySQLParser.AUTO_INCREMENT_SYMBOL)
                self.state = 8308
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 8307
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8310
                self.ulonglongNumber()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 8311
                localctx.option = self.match(MySQLParser.PACK_KEYS_SYMBOL)
                self.state = 8313
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 8312
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8315
                self.ternaryOption()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 8316
                localctx.option = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 554)) & ~0x3f) == 0 and ((1 << (_la - 554)) & 7) != 0)):
                    localctx.option = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 8318
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 8317
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8320
                self.ternaryOption()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 8321
                localctx.option = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==104 or _la==584):
                    localctx.option = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 8323
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 8322
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8325
                self.ulong_number()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 8326
                localctx.option = self.match(MySQLParser.DELAY_KEY_WRITE_SYMBOL)
                self.state = 8328
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 8327
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8330
                self.ulong_number()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 8331
                localctx.option = self.match(MySQLParser.ROW_FORMAT_SYMBOL)
                self.state = 8333
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 8332
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8335
                localctx.format_ = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 121)) & ~0x3f) == 0 and ((1 << (_la - 121)) & 35184372088837) != 0) or _la==188 or _la==226 or _la==459):
                    localctx.format_ = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 8336
                localctx.option = self.match(MySQLParser.UNION_SYMBOL)
                self.state = 8338
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 8337
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8340
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 8341
                self.tableRefList()
                self.state = 8342
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 8344
                self.defaultCharset()
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 8345
                self.defaultCollation()
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 8346
                localctx.option = self.match(MySQLParser.INSERT_METHOD_SYMBOL)
                self.state = 8348
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 8347
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8350
                localctx.method = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==225 or _la==298 or _la==392):
                    localctx.method = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 8351
                localctx.option = self.match(MySQLParser.DATA_SYMBOL)
                self.state = 8352
                self.match(MySQLParser.DIRECTORY_SYMBOL)
                self.state = 8354
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1049,self._ctx)
                if la_ == 1:
                    self.state = 8353
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8356
                self.textString()
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 8357
                localctx.option = self.match(MySQLParser.INDEX_SYMBOL)
                self.state = 8358
                self.match(MySQLParser.DIRECTORY_SYMBOL)
                self.state = 8360
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1050,self._ctx)
                if la_ == 1:
                    self.state = 8359
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8362
                self.textString()
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 8363
                localctx.option = self.match(MySQLParser.TABLESPACE_SYMBOL)
                self.state = 8365
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1051,self._ctx)
                if la_ == 1:
                    self.state = 8364
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8367
                self.identifier()
                pass

            elif la_ == 23:
                self.enterOuterAlt(localctx, 23)
                self.state = 8368
                localctx.option = self.match(MySQLParser.STORAGE_SYMBOL)
                self.state = 8369
                _la = self._input.LA(1)
                if not(_la==179 or _la==358):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 24:
                self.enterOuterAlt(localctx, 24)
                self.state = 8370
                localctx.option = self.match(MySQLParser.CONNECTION_SYMBOL)
                self.state = 8372
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1052,self._ctx)
                if la_ == 1:
                    self.state = 8371
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8374
                self.textString()
                pass

            elif la_ == 25:
                self.enterOuterAlt(localctx, 25)
                self.state = 8375
                localctx.option = self.match(MySQLParser.KEY_BLOCK_SIZE_SYMBOL)
                self.state = 8377
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 8376
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8379
                self.ulonglongNumber()
                pass

            elif la_ == 26:
                self.enterOuterAlt(localctx, 26)
                self.state = 8380
                if not self.isServerVersionGe80024():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                self.state = 8381
                localctx.option = self.match(MySQLParser.START_SYMBOL)
                self.state = 8382
                self.match(MySQLParser.TRANSACTION_SYMBOL)
                pass

            elif la_ == 27:
                self.enterOuterAlt(localctx, 27)
                self.state = 8383
                if not self.isServerVersionGe80024():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                self.state = 8384
                localctx.option = self.match(MySQLParser.ENGINE_ATTRIBUTE_SYMBOL)
                self.state = 8386
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1054,self._ctx)
                if la_ == 1:
                    self.state = 8385
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8388
                self.jsonAttribute()
                pass

            elif la_ == 28:
                self.enterOuterAlt(localctx, 28)
                self.state = 8389
                if not self.isServerVersionGe80024():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                self.state = 8390
                localctx.option = self.match(MySQLParser.SECONDARY_ENGINE_ATTRIBUTE_SYMBOL)
                self.state = 8392
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1055,self._ctx)
                if la_ == 1:
                    self.state = 8391
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8394
                self.jsonAttribute()
                pass

            elif la_ == 29:
                self.enterOuterAlt(localctx, 29)
                self.state = 8395
                if not self.isServerVersionGe80024():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                self.state = 8396
                self.tsOptionAutoextendSize()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TernaryOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Ulong_numberContext,0)


        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_ternaryOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTernaryOption" ):
                listener.enterTernaryOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTernaryOption" ):
                listener.exitTernaryOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTernaryOption" ):
                return visitor.visitTernaryOption(self)
            else:
                return visitor.visitChildren(self)




    def ternaryOption(self):

        localctx = MySQLParser.TernaryOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1204, self.RULE_ternaryOption)
        try:
            self.state = 8401
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 4, 5, 44, 46, 47]:
                self.enterOuterAlt(localctx, 1)
                self.state = 8399
                self.ulong_number()
                pass
            elif token in [166]:
                self.enterOuterAlt(localctx, 2)
                self.state = 8400
                self.match(MySQLParser.DEFAULT_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultCollationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLLATE_SYMBOL(self):
            return self.getToken(MySQLParser.COLLATE_SYMBOL, 0)

        def collationName(self):
            return self.getTypedRuleContext(MySQLParser.CollationNameContext,0)


        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_defaultCollation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefaultCollation" ):
                listener.enterDefaultCollation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefaultCollation" ):
                listener.exitDefaultCollation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefaultCollation" ):
                return visitor.visitDefaultCollation(self)
            else:
                return visitor.visitChildren(self)




    def defaultCollation(self):

        localctx = MySQLParser.DefaultCollationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1206, self.RULE_defaultCollation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8404
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==166:
                self.state = 8403
                self.match(MySQLParser.DEFAULT_SYMBOL)


            self.state = 8406
            self.match(MySQLParser.COLLATE_SYMBOL)
            self.state = 8408
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1059,self._ctx)
            if la_ == 1:
                self.state = 8407
                self.match(MySQLParser.EQUAL_OPERATOR)


            self.state = 8410
            self.collationName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultEncryptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENCRYPTION_SYMBOL(self):
            return self.getToken(MySQLParser.ENCRYPTION_SYMBOL, 0)

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_defaultEncryption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefaultEncryption" ):
                listener.enterDefaultEncryption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefaultEncryption" ):
                listener.exitDefaultEncryption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefaultEncryption" ):
                return visitor.visitDefaultEncryption(self)
            else:
                return visitor.visitChildren(self)




    def defaultEncryption(self):

        localctx = MySQLParser.DefaultEncryptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1208, self.RULE_defaultEncryption)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8413
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==166:
                self.state = 8412
                self.match(MySQLParser.DEFAULT_SYMBOL)


            self.state = 8415
            self.match(MySQLParser.ENCRYPTION_SYMBOL)
            self.state = 8417
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1061,self._ctx)
            if la_ == 1:
                self.state = 8416
                self.match(MySQLParser.EQUAL_OPERATOR)


            self.state = 8419
            self.textStringLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultCharsetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def charset(self):
            return self.getTypedRuleContext(MySQLParser.CharsetContext,0)


        def charsetName(self):
            return self.getTypedRuleContext(MySQLParser.CharsetNameContext,0)


        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_defaultCharset

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefaultCharset" ):
                listener.enterDefaultCharset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefaultCharset" ):
                listener.exitDefaultCharset(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefaultCharset" ):
                return visitor.visitDefaultCharset(self)
            else:
                return visitor.visitChildren(self)




    def defaultCharset(self):

        localctx = MySQLParser.DefaultCharsetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1210, self.RULE_defaultCharset)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8422
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==166:
                self.state = 8421
                self.match(MySQLParser.DEFAULT_SYMBOL)


            self.state = 8424
            self.charset()
            self.state = 8426
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1063,self._ctx)
            if la_ == 1:
                self.state = 8425
                self.match(MySQLParser.EQUAL_OPERATOR)


            self.state = 8428
            self.charsetName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartitionClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARTITION_SYMBOL(self):
            return self.getToken(MySQLParser.PARTITION_SYMBOL, 0)

        def BY_SYMBOL(self):
            return self.getToken(MySQLParser.BY_SYMBOL, 0)

        def partitionTypeDef(self):
            return self.getTypedRuleContext(MySQLParser.PartitionTypeDefContext,0)


        def PARTITIONS_SYMBOL(self):
            return self.getToken(MySQLParser.PARTITIONS_SYMBOL, 0)

        def real_ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Real_ulong_numberContext,0)


        def subPartitions(self):
            return self.getTypedRuleContext(MySQLParser.SubPartitionsContext,0)


        def partitionDefinitions(self):
            return self.getTypedRuleContext(MySQLParser.PartitionDefinitionsContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_partitionClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartitionClause" ):
                listener.enterPartitionClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartitionClause" ):
                listener.exitPartitionClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPartitionClause" ):
                return visitor.visitPartitionClause(self)
            else:
                return visitor.visitChildren(self)




    def partitionClause(self):

        localctx = MySQLParser.PartitionClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1212, self.RULE_partitionClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8430
            self.match(MySQLParser.PARTITION_SYMBOL)
            self.state = 8431
            self.match(MySQLParser.BY_SYMBOL)
            self.state = 8432
            self.partitionTypeDef()
            self.state = 8435
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1064,self._ctx)
            if la_ == 1:
                self.state = 8433
                self.match(MySQLParser.PARTITIONS_SYMBOL)
                self.state = 8434
                self.real_ulong_number()


            self.state = 8438
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1065,self._ctx)
            if la_ == 1:
                self.state = 8437
                self.subPartitions()


            self.state = 8441
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1066,self._ctx)
            if la_ == 1:
                self.state = 8440
                self.partitionDefinitions()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartitionTypeDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MySQLParser.RULE_partitionTypeDef

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class PartitionDefRangeListContext(PartitionTypeDefContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.PartitionTypeDefContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def RANGE_SYMBOL(self):
            return self.getToken(MySQLParser.RANGE_SYMBOL, 0)
        def LIST_SYMBOL(self):
            return self.getToken(MySQLParser.LIST_SYMBOL, 0)
        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)
        def bitExpr(self):
            return self.getTypedRuleContext(MySQLParser.BitExprContext,0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)
        def COLUMNS_SYMBOL(self):
            return self.getToken(MySQLParser.COLUMNS_SYMBOL, 0)
        def identifierList(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartitionDefRangeList" ):
                listener.enterPartitionDefRangeList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartitionDefRangeList" ):
                listener.exitPartitionDefRangeList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPartitionDefRangeList" ):
                return visitor.visitPartitionDefRangeList(self)
            else:
                return visitor.visitChildren(self)


    class PartitionDefKeyContext(PartitionTypeDefContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.PartitionTypeDefContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def KEY_SYMBOL(self):
            return self.getToken(MySQLParser.KEY_SYMBOL, 0)
        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)
        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)
        def LINEAR_SYMBOL(self):
            return self.getToken(MySQLParser.LINEAR_SYMBOL, 0)
        def partitionKeyAlgorithm(self):
            return self.getTypedRuleContext(MySQLParser.PartitionKeyAlgorithmContext,0)

        def identifierList(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartitionDefKey" ):
                listener.enterPartitionDefKey(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartitionDefKey" ):
                listener.exitPartitionDefKey(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPartitionDefKey" ):
                return visitor.visitPartitionDefKey(self)
            else:
                return visitor.visitChildren(self)


    class PartitionDefHashContext(PartitionTypeDefContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a MySQLParser.PartitionTypeDefContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HASH_SYMBOL(self):
            return self.getToken(MySQLParser.HASH_SYMBOL, 0)
        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)
        def bitExpr(self):
            return self.getTypedRuleContext(MySQLParser.BitExprContext,0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)
        def LINEAR_SYMBOL(self):
            return self.getToken(MySQLParser.LINEAR_SYMBOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartitionDefHash" ):
                listener.enterPartitionDefHash(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartitionDefHash" ):
                listener.exitPartitionDefHash(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPartitionDefHash" ):
                return visitor.visitPartitionDefHash(self)
            else:
                return visitor.visitChildren(self)



    def partitionTypeDef(self):

        localctx = MySQLParser.PartitionTypeDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1214, self.RULE_partitionTypeDef)
        self._la = 0 # Token type
        try:
            self.state = 8476
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1073,self._ctx)
            if la_ == 1:
                localctx = MySQLParser.PartitionDefKeyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 8444
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==307:
                    self.state = 8443
                    self.match(MySQLParser.LINEAR_SYMBOL)


                self.state = 8446
                self.match(MySQLParser.KEY_SYMBOL)
                self.state = 8448
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==56:
                    self.state = 8447
                    self.partitionKeyAlgorithm()


                self.state = 8450
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 8452
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1069,self._ctx)
                if la_ == 1:
                    self.state = 8451
                    self.identifierList()


                self.state = 8454
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 2:
                localctx = MySQLParser.PartitionDefHashContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 8456
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==307:
                    self.state = 8455
                    self.match(MySQLParser.LINEAR_SYMBOL)


                self.state = 8458
                self.match(MySQLParser.HASH_SYMBOL)
                self.state = 8459
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 8460
                self.bitExpr(0)
                self.state = 8461
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass

            elif la_ == 3:
                localctx = MySQLParser.PartitionDefRangeListContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 8463
                _la = self._input.LA(1)
                if not(_la==310 or _la==450):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 8474
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [32]:
                    self.state = 8464
                    self.match(MySQLParser.OPEN_PAR_SYMBOL)
                    self.state = 8465
                    self.bitExpr(0)
                    self.state = 8466
                    self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                    pass
                elif token in [114]:
                    self.state = 8468
                    self.match(MySQLParser.COLUMNS_SYMBOL)
                    self.state = 8469
                    self.match(MySQLParser.OPEN_PAR_SYMBOL)
                    self.state = 8471
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,1071,self._ctx)
                    if la_ == 1:
                        self.state = 8470
                        self.identifierList()


                    self.state = 8473
                    self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                    pass
                else:
                    raise NoViableAltException(self)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubPartitionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUBPARTITION_SYMBOL(self):
            return self.getToken(MySQLParser.SUBPARTITION_SYMBOL, 0)

        def BY_SYMBOL(self):
            return self.getToken(MySQLParser.BY_SYMBOL, 0)

        def HASH_SYMBOL(self):
            return self.getToken(MySQLParser.HASH_SYMBOL, 0)

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def bitExpr(self):
            return self.getTypedRuleContext(MySQLParser.BitExprContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def KEY_SYMBOL(self):
            return self.getToken(MySQLParser.KEY_SYMBOL, 0)

        def identifierListWithParentheses(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierListWithParenthesesContext,0)


        def LINEAR_SYMBOL(self):
            return self.getToken(MySQLParser.LINEAR_SYMBOL, 0)

        def SUBPARTITIONS_SYMBOL(self):
            return self.getToken(MySQLParser.SUBPARTITIONS_SYMBOL, 0)

        def real_ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Real_ulong_numberContext,0)


        def partitionKeyAlgorithm(self):
            return self.getTypedRuleContext(MySQLParser.PartitionKeyAlgorithmContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_subPartitions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubPartitions" ):
                listener.enterSubPartitions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubPartitions" ):
                listener.exitSubPartitions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubPartitions" ):
                return visitor.visitSubPartitions(self)
            else:
                return visitor.visitChildren(self)




    def subPartitions(self):

        localctx = MySQLParser.SubPartitionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1216, self.RULE_subPartitions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8478
            self.match(MySQLParser.SUBPARTITION_SYMBOL)
            self.state = 8479
            self.match(MySQLParser.BY_SYMBOL)
            self.state = 8481
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==307:
                self.state = 8480
                self.match(MySQLParser.LINEAR_SYMBOL)


            self.state = 8493
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [252]:
                self.state = 8483
                self.match(MySQLParser.HASH_SYMBOL)
                self.state = 8484
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 8485
                self.bitExpr(0)
                self.state = 8486
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass
            elif token in [295]:
                self.state = 8488
                self.match(MySQLParser.KEY_SYMBOL)
                self.state = 8490
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==56:
                    self.state = 8489
                    self.partitionKeyAlgorithm()


                self.state = 8492
                self.identifierListWithParentheses()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 8497
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1077,self._ctx)
            if la_ == 1:
                self.state = 8495
                self.match(MySQLParser.SUBPARTITIONS_SYMBOL)
                self.state = 8496
                self.real_ulong_number()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartitionKeyAlgorithmContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALGORITHM_SYMBOL(self):
            return self.getToken(MySQLParser.ALGORITHM_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def real_ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Real_ulong_numberContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_partitionKeyAlgorithm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartitionKeyAlgorithm" ):
                listener.enterPartitionKeyAlgorithm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartitionKeyAlgorithm" ):
                listener.exitPartitionKeyAlgorithm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPartitionKeyAlgorithm" ):
                return visitor.visitPartitionKeyAlgorithm(self)
            else:
                return visitor.visitChildren(self)




    def partitionKeyAlgorithm(self):

        localctx = MySQLParser.PartitionKeyAlgorithmContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1218, self.RULE_partitionKeyAlgorithm)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8499
            self.match(MySQLParser.ALGORITHM_SYMBOL)
            self.state = 8500
            self.match(MySQLParser.EQUAL_OPERATOR)
            self.state = 8501
            self.real_ulong_number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartitionDefinitionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def partitionDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.PartitionDefinitionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.PartitionDefinitionContext,i)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_partitionDefinitions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartitionDefinitions" ):
                listener.enterPartitionDefinitions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartitionDefinitions" ):
                listener.exitPartitionDefinitions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPartitionDefinitions" ):
                return visitor.visitPartitionDefinitions(self)
            else:
                return visitor.visitChildren(self)




    def partitionDefinitions(self):

        localctx = MySQLParser.PartitionDefinitionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1220, self.RULE_partitionDefinitions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8503
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 8504
            self.partitionDefinition()
            self.state = 8509
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 8505
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 8506
                self.partitionDefinition()
                self.state = 8511
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 8512
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartitionDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARTITION_SYMBOL(self):
            return self.getToken(MySQLParser.PARTITION_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def VALUES_SYMBOL(self):
            return self.getToken(MySQLParser.VALUES_SYMBOL, 0)

        def LESS_SYMBOL(self):
            return self.getToken(MySQLParser.LESS_SYMBOL, 0)

        def THAN_SYMBOL(self):
            return self.getToken(MySQLParser.THAN_SYMBOL, 0)

        def IN_SYMBOL(self):
            return self.getToken(MySQLParser.IN_SYMBOL, 0)

        def partitionValuesIn(self):
            return self.getTypedRuleContext(MySQLParser.PartitionValuesInContext,0)


        def partitionOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.PartitionOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.PartitionOptionContext,i)


        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def subpartitionDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.SubpartitionDefinitionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.SubpartitionDefinitionContext,i)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def partitionValueItemListParen(self):
            return self.getTypedRuleContext(MySQLParser.PartitionValueItemListParenContext,0)


        def MAXVALUE_SYMBOL(self):
            return self.getToken(MySQLParser.MAXVALUE_SYMBOL, 0)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_partitionDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartitionDefinition" ):
                listener.enterPartitionDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartitionDefinition" ):
                listener.exitPartitionDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPartitionDefinition" ):
                return visitor.visitPartitionDefinition(self)
            else:
                return visitor.visitChildren(self)




    def partitionDefinition(self):

        localctx = MySQLParser.PartitionDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1222, self.RULE_partitionDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8514
            self.match(MySQLParser.PARTITION_SYMBOL)
            self.state = 8515
            self.identifier()
            self.state = 8526
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1080,self._ctx)
            if la_ == 1:
                self.state = 8516
                self.match(MySQLParser.VALUES_SYMBOL)
                self.state = 8517
                self.match(MySQLParser.LESS_SYMBOL)
                self.state = 8518
                self.match(MySQLParser.THAN_SYMBOL)
                self.state = 8521
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [32]:
                    self.state = 8519
                    self.partitionValueItemListParen()
                    pass
                elif token in [353]:
                    self.state = 8520
                    self.match(MySQLParser.MAXVALUE_SYMBOL)
                    pass
                else:
                    raise NoViableAltException(self)


            elif la_ == 2:
                self.state = 8523
                self.match(MySQLParser.VALUES_SYMBOL)
                self.state = 8524
                self.match(MySQLParser.IN_SYMBOL)
                self.state = 8525
                self.partitionValuesIn()


            self.state = 8531
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==118 or _la==153 or _la==198 or _la==268 or ((((_la - 348)) & ~0x3f) == 0 and ((1 << (_la - 348)) & 1099512152065) != 0) or _la==563 or _la==582:
                self.state = 8528
                self.partitionOption()
                self.state = 8533
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 8545
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==32:
                self.state = 8534
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 8535
                self.subpartitionDefinition()
                self.state = 8540
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==29:
                    self.state = 8536
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 8537
                    self.subpartitionDefinition()
                    self.state = 8542
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 8543
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartitionValuesInContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def partitionValueItemListParen(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.PartitionValueItemListParenContext)
            else:
                return self.getTypedRuleContext(MySQLParser.PartitionValueItemListParenContext,i)


        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_partitionValuesIn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartitionValuesIn" ):
                listener.enterPartitionValuesIn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartitionValuesIn" ):
                listener.exitPartitionValuesIn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPartitionValuesIn" ):
                return visitor.visitPartitionValuesIn(self)
            else:
                return visitor.visitChildren(self)




    def partitionValuesIn(self):

        localctx = MySQLParser.PartitionValuesInContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1224, self.RULE_partitionValuesIn)
        self._la = 0 # Token type
        try:
            self.state = 8559
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1085,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8547
                self.partitionValueItemListParen()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8548
                self.match(MySQLParser.OPEN_PAR_SYMBOL)
                self.state = 8549
                self.partitionValueItemListParen()
                self.state = 8554
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==29:
                    self.state = 8550
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 8551
                    self.partitionValueItemListParen()
                    self.state = 8556
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 8557
                self.match(MySQLParser.CLOSE_PAR_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartitionOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.option = None # Token

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def TABLESPACE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLESPACE_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def engineRef(self):
            return self.getTypedRuleContext(MySQLParser.EngineRefContext,0)


        def ENGINE_SYMBOL(self):
            return self.getToken(MySQLParser.ENGINE_SYMBOL, 0)

        def STORAGE_SYMBOL(self):
            return self.getToken(MySQLParser.STORAGE_SYMBOL, 0)

        def real_ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Real_ulong_numberContext,0)


        def NODEGROUP_SYMBOL(self):
            return self.getToken(MySQLParser.NODEGROUP_SYMBOL, 0)

        def MAX_ROWS_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_ROWS_SYMBOL, 0)

        def MIN_ROWS_SYMBOL(self):
            return self.getToken(MySQLParser.MIN_ROWS_SYMBOL, 0)

        def DIRECTORY_SYMBOL(self):
            return self.getToken(MySQLParser.DIRECTORY_SYMBOL, 0)

        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def DATA_SYMBOL(self):
            return self.getToken(MySQLParser.DATA_SYMBOL, 0)

        def INDEX_SYMBOL(self):
            return self.getToken(MySQLParser.INDEX_SYMBOL, 0)

        def COMMENT_SYMBOL(self):
            return self.getToken(MySQLParser.COMMENT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_partitionOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartitionOption" ):
                listener.enterPartitionOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartitionOption" ):
                listener.exitPartitionOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPartitionOption" ):
                return visitor.visitPartitionOption(self)
            else:
                return visitor.visitChildren(self)




    def partitionOption(self):

        localctx = MySQLParser.PartitionOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1226, self.RULE_partitionOption)
        self._la = 0 # Token type
        try:
            self.state = 8595
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [582]:
                self.enterOuterAlt(localctx, 1)
                self.state = 8561
                localctx.option = self.match(MySQLParser.TABLESPACE_SYMBOL)
                self.state = 8563
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1086,self._ctx)
                if la_ == 1:
                    self.state = 8562
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8565
                self.identifier()
                pass
            elif token in [198, 563]:
                self.enterOuterAlt(localctx, 2)
                self.state = 8567
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==563:
                    self.state = 8566
                    self.match(MySQLParser.STORAGE_SYMBOL)


                self.state = 8569
                localctx.option = self.match(MySQLParser.ENGINE_SYMBOL)
                self.state = 8571
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1088,self._ctx)
                if la_ == 1:
                    self.state = 8570
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8573
                self.engineRef()
                pass
            elif token in [388]:
                self.enterOuterAlt(localctx, 3)
                self.state = 8574
                localctx.option = self.match(MySQLParser.NODEGROUP_SYMBOL)
                self.state = 8576
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 8575
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8578
                self.real_ulong_number()
                pass
            elif token in [348, 367]:
                self.enterOuterAlt(localctx, 4)
                self.state = 8579
                localctx.option = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==348 or _la==367):
                    localctx.option = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 8581
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 8580
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8583
                self.real_ulong_number()
                pass
            elif token in [153, 268]:
                self.enterOuterAlt(localctx, 5)
                self.state = 8584
                localctx.option = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==153 or _la==268):
                    localctx.option = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 8585
                self.match(MySQLParser.DIRECTORY_SYMBOL)
                self.state = 8587
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1091,self._ctx)
                if la_ == 1:
                    self.state = 8586
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8589
                self.textLiteral()
                pass
            elif token in [118]:
                self.enterOuterAlt(localctx, 6)
                self.state = 8590
                localctx.option = self.match(MySQLParser.COMMENT_SYMBOL)
                self.state = 8592
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1092,self._ctx)
                if la_ == 1:
                    self.state = 8591
                    self.match(MySQLParser.EQUAL_OPERATOR)


                self.state = 8594
                self.textLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubpartitionDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUBPARTITION_SYMBOL(self):
            return self.getToken(MySQLParser.SUBPARTITION_SYMBOL, 0)

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def partitionOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.PartitionOptionContext)
            else:
                return self.getTypedRuleContext(MySQLParser.PartitionOptionContext,i)


        def getRuleIndex(self):
            return MySQLParser.RULE_subpartitionDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubpartitionDefinition" ):
                listener.enterSubpartitionDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubpartitionDefinition" ):
                listener.exitSubpartitionDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubpartitionDefinition" ):
                return visitor.visitSubpartitionDefinition(self)
            else:
                return visitor.visitChildren(self)




    def subpartitionDefinition(self):

        localctx = MySQLParser.SubpartitionDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1228, self.RULE_subpartitionDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8597
            self.match(MySQLParser.SUBPARTITION_SYMBOL)
            self.state = 8598
            self.textOrIdentifier()
            self.state = 8602
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==118 or _la==153 or _la==198 or _la==268 or ((((_la - 348)) & ~0x3f) == 0 and ((1 << (_la - 348)) & 1099512152065) != 0) or _la==563 or _la==582:
                self.state = 8599
                self.partitionOption()
                self.state = 8604
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartitionValueItemListParenContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def partitionValueItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.PartitionValueItemContext)
            else:
                return self.getTypedRuleContext(MySQLParser.PartitionValueItemContext,i)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_partitionValueItemListParen

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartitionValueItemListParen" ):
                listener.enterPartitionValueItemListParen(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartitionValueItemListParen" ):
                listener.exitPartitionValueItemListParen(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPartitionValueItemListParen" ):
                return visitor.visitPartitionValueItemListParen(self)
            else:
                return visitor.visitChildren(self)




    def partitionValueItemListParen(self):

        localctx = MySQLParser.PartitionValueItemListParenContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1230, self.RULE_partitionValueItemListParen)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8605
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 8606
            self.partitionValueItem()
            self.state = 8611
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 8607
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 8608
                self.partitionValueItem()
                self.state = 8613
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 8614
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartitionValueItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def bitExpr(self):
            return self.getTypedRuleContext(MySQLParser.BitExprContext,0)


        def MAXVALUE_SYMBOL(self):
            return self.getToken(MySQLParser.MAXVALUE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_partitionValueItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartitionValueItem" ):
                listener.enterPartitionValueItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartitionValueItem" ):
                listener.exitPartitionValueItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPartitionValueItem" ):
                return visitor.visitPartitionValueItem(self)
            else:
                return visitor.visitChildren(self)




    def partitionValueItem(self):

        localctx = MySQLParser.PartitionValueItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1232, self.RULE_partitionValueItem)
        try:
            self.state = 8618
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1096,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8616
                self.bitExpr(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8617
                self.match(MySQLParser.MAXVALUE_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefinerClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFINER_SYMBOL(self):
            return self.getToken(MySQLParser.DEFINER_SYMBOL, 0)

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def user(self):
            return self.getTypedRuleContext(MySQLParser.UserContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_definerClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefinerClause" ):
                listener.enterDefinerClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefinerClause" ):
                listener.exitDefinerClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefinerClause" ):
                return visitor.visitDefinerClause(self)
            else:
                return visitor.visitChildren(self)




    def definerClause(self):

        localctx = MySQLParser.DefinerClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1234, self.RULE_definerClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8620
            self.match(MySQLParser.DEFINER_SYMBOL)
            self.state = 8621
            self.match(MySQLParser.EQUAL_OPERATOR)
            self.state = 8622
            self.user()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfExistsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF_SYMBOL(self):
            return self.getToken(MySQLParser.IF_SYMBOL, 0)

        def EXISTS_SYMBOL(self):
            return self.getToken(MySQLParser.EXISTS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_ifExists

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfExists" ):
                listener.enterIfExists(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfExists" ):
                listener.exitIfExists(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfExists" ):
                return visitor.visitIfExists(self)
            else:
                return visitor.visitChildren(self)




    def ifExists(self):

        localctx = MySQLParser.IfExistsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1236, self.RULE_ifExists)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8624
            self.match(MySQLParser.IF_SYMBOL)
            self.state = 8625
            self.match(MySQLParser.EXISTS_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfExistsIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ifExists(self):
            return self.getTypedRuleContext(MySQLParser.IfExistsContext,0)


        def persistedVariableIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.PersistedVariableIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_ifExistsIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfExistsIdentifier" ):
                listener.enterIfExistsIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfExistsIdentifier" ):
                listener.exitIfExistsIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfExistsIdentifier" ):
                return visitor.visitIfExistsIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def ifExistsIdentifier(self):

        localctx = MySQLParser.IfExistsIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1238, self.RULE_ifExistsIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8627
            self.ifExists()
            self.state = 8628
            self.persistedVariableIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PersistedVariableIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.QualifiedIdentifierContext,0)


        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def dotIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.DotIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_persistedVariableIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPersistedVariableIdentifier" ):
                listener.enterPersistedVariableIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPersistedVariableIdentifier" ):
                listener.exitPersistedVariableIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPersistedVariableIdentifier" ):
                return visitor.visitPersistedVariableIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def persistedVariableIdentifier(self):

        localctx = MySQLParser.PersistedVariableIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1240, self.RULE_persistedVariableIdentifier)
        try:
            self.state = 8637
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1098,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8630
                self.identifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8631
                if not self.isServerVersionGe80032():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80032()")
                self.state = 8635
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1097,self._ctx)
                if la_ == 1:
                    self.state = 8632
                    self.qualifiedIdentifier()
                    pass

                elif la_ == 2:
                    self.state = 8633
                    self.match(MySQLParser.DEFAULT_SYMBOL)
                    self.state = 8634
                    self.dotIdentifier()
                    pass


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfNotExistsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF_SYMBOL(self):
            return self.getToken(MySQLParser.IF_SYMBOL, 0)

        def notRule(self):
            return self.getTypedRuleContext(MySQLParser.NotRuleContext,0)


        def EXISTS_SYMBOL(self):
            return self.getToken(MySQLParser.EXISTS_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_ifNotExists

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfNotExists" ):
                listener.enterIfNotExists(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfNotExists" ):
                listener.exitIfNotExists(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfNotExists" ):
                return visitor.visitIfNotExists(self)
            else:
                return visitor.visitChildren(self)




    def ifNotExists(self):

        localctx = MySQLParser.IfNotExistsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1242, self.RULE_ifNotExists)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8639
            self.match(MySQLParser.IF_SYMBOL)
            self.state = 8640
            self.notRule()
            self.state = 8641
            self.match(MySQLParser.EXISTS_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IgnoreUnknownUserContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IGNORE_SYMBOL(self):
            return self.getToken(MySQLParser.IGNORE_SYMBOL, 0)

        def UNKNOWN_SYMBOL(self):
            return self.getToken(MySQLParser.UNKNOWN_SYMBOL, 0)

        def USER_SYMBOL(self):
            return self.getToken(MySQLParser.USER_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_ignoreUnknownUser

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIgnoreUnknownUser" ):
                listener.enterIgnoreUnknownUser(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIgnoreUnknownUser" ):
                listener.exitIgnoreUnknownUser(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIgnoreUnknownUser" ):
                return visitor.visitIgnoreUnknownUser(self)
            else:
                return visitor.visitChildren(self)




    def ignoreUnknownUser(self):

        localctx = MySQLParser.IgnoreUnknownUserContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1244, self.RULE_ignoreUnknownUser)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8643
            self.match(MySQLParser.IGNORE_SYMBOL)
            self.state = 8644
            self.match(MySQLParser.UNKNOWN_SYMBOL)
            self.state = 8645
            self.match(MySQLParser.USER_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcedureParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # Token

        def functionParameter(self):
            return self.getTypedRuleContext(MySQLParser.FunctionParameterContext,0)


        def IN_SYMBOL(self):
            return self.getToken(MySQLParser.IN_SYMBOL, 0)

        def OUT_SYMBOL(self):
            return self.getToken(MySQLParser.OUT_SYMBOL, 0)

        def INOUT_SYMBOL(self):
            return self.getToken(MySQLParser.INOUT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_procedureParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcedureParameter" ):
                listener.enterProcedureParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcedureParameter" ):
                listener.exitProcedureParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcedureParameter" ):
                return visitor.visitProcedureParameter(self)
            else:
                return visitor.visitChildren(self)




    def procedureParameter(self):

        localctx = MySQLParser.ProcedureParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1246, self.RULE_procedureParameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8648
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1099,self._ctx)
            if la_ == 1:
                self.state = 8647
                localctx.type_ = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==272 or _la==282 or _la==415):
                    localctx.type_ = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 8650
            self.functionParameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameterName(self):
            return self.getTypedRuleContext(MySQLParser.ParameterNameContext,0)


        def typeWithOptCollate(self):
            return self.getTypedRuleContext(MySQLParser.TypeWithOptCollateContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_functionParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionParameter" ):
                listener.enterFunctionParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionParameter" ):
                listener.exitFunctionParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionParameter" ):
                return visitor.visitFunctionParameter(self)
            else:
                return visitor.visitChildren(self)




    def functionParameter(self):

        localctx = MySQLParser.FunctionParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1248, self.RULE_functionParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8652
            self.parameterName()
            self.state = 8653
            self.typeWithOptCollate()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CollateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLLATE_SYMBOL(self):
            return self.getToken(MySQLParser.COLLATE_SYMBOL, 0)

        def collationName(self):
            return self.getTypedRuleContext(MySQLParser.CollationNameContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_collate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCollate" ):
                listener.enterCollate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCollate" ):
                listener.exitCollate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCollate" ):
                return visitor.visitCollate(self)
            else:
                return visitor.visitChildren(self)




    def collate(self):

        localctx = MySQLParser.CollateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1250, self.RULE_collate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8655
            self.match(MySQLParser.COLLATE_SYMBOL)
            self.state = 8656
            self.collationName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeWithOptCollateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dataType(self):
            return self.getTypedRuleContext(MySQLParser.DataTypeContext,0)


        def collate(self):
            return self.getTypedRuleContext(MySQLParser.CollateContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_typeWithOptCollate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeWithOptCollate" ):
                listener.enterTypeWithOptCollate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeWithOptCollate" ):
                listener.exitTypeWithOptCollate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeWithOptCollate" ):
                return visitor.visitTypeWithOptCollate(self)
            else:
                return visitor.visitChildren(self)




    def typeWithOptCollate(self):

        localctx = MySQLParser.TypeWithOptCollateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1252, self.RULE_typeWithOptCollate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8658
            self.dataType()
            self.state = 8660
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1100,self._ctx)
            if la_ == 1:
                self.state = 8659
                self.collate()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SchemaIdentifierPairContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def schemaRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.SchemaRefContext)
            else:
                return self.getTypedRuleContext(MySQLParser.SchemaRefContext,i)


        def COMMA_SYMBOL(self):
            return self.getToken(MySQLParser.COMMA_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_schemaIdentifierPair

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchemaIdentifierPair" ):
                listener.enterSchemaIdentifierPair(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchemaIdentifierPair" ):
                listener.exitSchemaIdentifierPair(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSchemaIdentifierPair" ):
                return visitor.visitSchemaIdentifierPair(self)
            else:
                return visitor.visitChildren(self)




    def schemaIdentifierPair(self):

        localctx = MySQLParser.SchemaIdentifierPairContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1254, self.RULE_schemaIdentifierPair)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8662
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 8663
            self.schemaRef()
            self.state = 8664
            self.match(MySQLParser.COMMA_SYMBOL)
            self.state = 8665
            self.schemaRef()
            self.state = 8666
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ViewRefListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def viewRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ViewRefContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ViewRefContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_viewRefList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterViewRefList" ):
                listener.enterViewRefList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitViewRefList" ):
                listener.exitViewRefList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitViewRefList" ):
                return visitor.visitViewRefList(self)
            else:
                return visitor.visitChildren(self)




    def viewRefList(self):

        localctx = MySQLParser.ViewRefListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1256, self.RULE_viewRefList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8668
            self.viewRef()
            self.state = 8673
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 8669
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 8670
                self.viewRef()
                self.state = 8675
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UpdateListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def updateElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.UpdateElementContext)
            else:
                return self.getTypedRuleContext(MySQLParser.UpdateElementContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_updateList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpdateList" ):
                listener.enterUpdateList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpdateList" ):
                listener.exitUpdateList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUpdateList" ):
                return visitor.visitUpdateList(self)
            else:
                return visitor.visitChildren(self)




    def updateList(self):

        localctx = MySQLParser.UpdateListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1258, self.RULE_updateList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8676
            self.updateElement()
            self.state = 8681
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,1102,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 8677
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 8678
                    self.updateElement() 
                self.state = 8683
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1102,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UpdateElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def columnRef(self):
            return self.getTypedRuleContext(MySQLParser.ColumnRefContext,0)


        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def expr(self):
            return self.getTypedRuleContext(MySQLParser.ExprContext,0)


        def DEFAULT_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_updateElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpdateElement" ):
                listener.enterUpdateElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpdateElement" ):
                listener.exitUpdateElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUpdateElement" ):
                return visitor.visitUpdateElement(self)
            else:
                return visitor.visitChildren(self)




    def updateElement(self):

        localctx = MySQLParser.UpdateElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1260, self.RULE_updateElement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8684
            self.columnRef()
            self.state = 8685
            self.match(MySQLParser.EQUAL_OPERATOR)
            self.state = 8688
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1103,self._ctx)
            if la_ == 1:
                self.state = 8686
                self.expr(0)
                pass

            elif la_ == 2:
                self.state = 8687
                self.match(MySQLParser.DEFAULT_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CharsetClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def charset(self):
            return self.getTypedRuleContext(MySQLParser.CharsetContext,0)


        def charsetName(self):
            return self.getTypedRuleContext(MySQLParser.CharsetNameContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_charsetClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCharsetClause" ):
                listener.enterCharsetClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCharsetClause" ):
                listener.exitCharsetClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCharsetClause" ):
                return visitor.visitCharsetClause(self)
            else:
                return visitor.visitChildren(self)




    def charsetClause(self):

        localctx = MySQLParser.CharsetClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1262, self.RULE_charsetClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8690
            self.charset()
            self.state = 8691
            self.charsetName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FieldsClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLUMNS_SYMBOL(self):
            return self.getToken(MySQLParser.COLUMNS_SYMBOL, 0)

        def fieldTerm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.FieldTermContext)
            else:
                return self.getTypedRuleContext(MySQLParser.FieldTermContext,i)


        def getRuleIndex(self):
            return MySQLParser.RULE_fieldsClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFieldsClause" ):
                listener.enterFieldsClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFieldsClause" ):
                listener.exitFieldsClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFieldsClause" ):
                return visitor.visitFieldsClause(self)
            else:
                return visitor.visitChildren(self)




    def fieldsClause(self):

        localctx = MySQLParser.FieldsClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1264, self.RULE_fieldsClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8693
            self.match(MySQLParser.COLUMNS_SYMBOL)
            self.state = 8695 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 8694
                    self.fieldTerm()

                else:
                    raise NoViableAltException(self)
                self.state = 8697 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1104,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FieldTermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TERMINATED_SYMBOL(self):
            return self.getToken(MySQLParser.TERMINATED_SYMBOL, 0)

        def BY_SYMBOL(self):
            return self.getToken(MySQLParser.BY_SYMBOL, 0)

        def textString(self):
            return self.getTypedRuleContext(MySQLParser.TextStringContext,0)


        def ENCLOSED_SYMBOL(self):
            return self.getToken(MySQLParser.ENCLOSED_SYMBOL, 0)

        def OPTIONALLY_SYMBOL(self):
            return self.getToken(MySQLParser.OPTIONALLY_SYMBOL, 0)

        def ESCAPED_SYMBOL(self):
            return self.getToken(MySQLParser.ESCAPED_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_fieldTerm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFieldTerm" ):
                listener.enterFieldTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFieldTerm" ):
                listener.exitFieldTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFieldTerm" ):
                return visitor.visitFieldTerm(self)
            else:
                return visitor.visitChildren(self)




    def fieldTerm(self):

        localctx = MySQLParser.FieldTermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1266, self.RULE_fieldTerm)
        self._la = 0 # Token type
        try:
            self.state = 8711
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [588]:
                self.enterOuterAlt(localctx, 1)
                self.state = 8699
                self.match(MySQLParser.TERMINATED_SYMBOL)
                self.state = 8700
                self.match(MySQLParser.BY_SYMBOL)
                self.state = 8701
                self.textString()
                pass
            elif token in [193, 410]:
                self.enterOuterAlt(localctx, 2)
                self.state = 8703
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==410:
                    self.state = 8702
                    self.match(MySQLParser.OPTIONALLY_SYMBOL)


                self.state = 8705
                self.match(MySQLParser.ENCLOSED_SYMBOL)
                self.state = 8706
                self.match(MySQLParser.BY_SYMBOL)
                self.state = 8707
                self.textString()
                pass
            elif token in [202]:
                self.enterOuterAlt(localctx, 3)
                self.state = 8708
                self.match(MySQLParser.ESCAPED_SYMBOL)
                self.state = 8709
                self.match(MySQLParser.BY_SYMBOL)
                self.state = 8710
                self.textString()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LinesClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LINES_SYMBOL(self):
            return self.getToken(MySQLParser.LINES_SYMBOL, 0)

        def lineTerm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.LineTermContext)
            else:
                return self.getTypedRuleContext(MySQLParser.LineTermContext,i)


        def getRuleIndex(self):
            return MySQLParser.RULE_linesClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLinesClause" ):
                listener.enterLinesClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLinesClause" ):
                listener.exitLinesClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLinesClause" ):
                return visitor.visitLinesClause(self)
            else:
                return visitor.visitChildren(self)




    def linesClause(self):

        localctx = MySQLParser.LinesClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1268, self.RULE_linesClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8713
            self.match(MySQLParser.LINES_SYMBOL)
            self.state = 8715 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 8714
                    self.lineTerm()

                else:
                    raise NoViableAltException(self)
                self.state = 8717 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1107,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LineTermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BY_SYMBOL(self):
            return self.getToken(MySQLParser.BY_SYMBOL, 0)

        def textString(self):
            return self.getTypedRuleContext(MySQLParser.TextStringContext,0)


        def TERMINATED_SYMBOL(self):
            return self.getToken(MySQLParser.TERMINATED_SYMBOL, 0)

        def STARTING_SYMBOL(self):
            return self.getToken(MySQLParser.STARTING_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_lineTerm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLineTerm" ):
                listener.enterLineTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLineTerm" ):
                listener.exitLineTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLineTerm" ):
                return visitor.visitLineTerm(self)
            else:
                return visitor.visitChildren(self)




    def lineTerm(self):

        localctx = MySQLParser.LineTermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1270, self.RULE_lineTerm)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8719
            _la = self._input.LA(1)
            if not(_la==551 or _la==588):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 8720
            self.match(MySQLParser.BY_SYMBOL)
            self.state = 8721
            self.textString()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UserListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def user(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.UserContext)
            else:
                return self.getTypedRuleContext(MySQLParser.UserContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_userList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUserList" ):
                listener.enterUserList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUserList" ):
                listener.exitUserList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUserList" ):
                return visitor.visitUserList(self)
            else:
                return visitor.visitChildren(self)




    def userList(self):

        localctx = MySQLParser.UserListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1272, self.RULE_userList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8723
            self.user()
            self.state = 8728
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,1108,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 8724
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 8725
                    self.user() 
                self.state = 8730
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1108,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateUserListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def createUser(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.CreateUserContext)
            else:
                return self.getTypedRuleContext(MySQLParser.CreateUserContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_createUserList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateUserList" ):
                listener.enterCreateUserList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateUserList" ):
                listener.exitCreateUserList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateUserList" ):
                return visitor.visitCreateUserList(self)
            else:
                return visitor.visitChildren(self)




    def createUserList(self):

        localctx = MySQLParser.CreateUserListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1274, self.RULE_createUserList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8731
            self.createUser()
            self.state = 8736
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,1109,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 8732
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 8733
                    self.createUser() 
                self.state = 8738
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1109,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateUserContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def user(self):
            return self.getTypedRuleContext(MySQLParser.UserContext,0)


        def identification(self):
            return self.getTypedRuleContext(MySQLParser.IdentificationContext,0)


        def identifiedWithPlugin(self):
            return self.getTypedRuleContext(MySQLParser.IdentifiedWithPluginContext,0)


        def createUserWithMfa(self):
            return self.getTypedRuleContext(MySQLParser.CreateUserWithMfaContext,0)


        def initialAuth(self):
            return self.getTypedRuleContext(MySQLParser.InitialAuthContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_createUser

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateUser" ):
                listener.enterCreateUser(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateUser" ):
                listener.exitCreateUser(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateUser" ):
                return visitor.visitCreateUser(self)
            else:
                return visitor.visitChildren(self)




    def createUser(self):

        localctx = MySQLParser.CreateUserContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1276, self.RULE_createUser)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8739
            self.user()
            self.state = 8749
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1112,self._ctx)
            if la_ == 1:
                self.state = 8740
                self.identification()
                self.state = 8742
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1110,self._ctx)
                if la_ == 1:
                    self.state = 8741
                    self.createUserWithMfa()



            elif la_ == 2:
                self.state = 8744
                self.identifiedWithPlugin()
                self.state = 8746
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1111,self._ctx)
                if la_ == 1:
                    self.state = 8745
                    self.initialAuth()



            elif la_ == 3:
                self.state = 8748
                self.createUserWithMfa()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateUserWithMfaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AND_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.AND_SYMBOL)
            else:
                return self.getToken(MySQLParser.AND_SYMBOL, i)

        def identification(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.IdentificationContext)
            else:
                return self.getTypedRuleContext(MySQLParser.IdentificationContext,i)


        def getRuleIndex(self):
            return MySQLParser.RULE_createUserWithMfa

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateUserWithMfa" ):
                listener.enterCreateUserWithMfa(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateUserWithMfa" ):
                listener.exitCreateUserWithMfa(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateUserWithMfa" ):
                return visitor.visitCreateUserWithMfa(self)
            else:
                return visitor.visitChildren(self)




    def createUserWithMfa(self):

        localctx = MySQLParser.CreateUserWithMfaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1278, self.RULE_createUserWithMfa)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8751
            self.match(MySQLParser.AND_SYMBOL)
            self.state = 8752
            self.identification()
            self.state = 8755
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1113,self._ctx)
            if la_ == 1:
                self.state = 8753
                self.match(MySQLParser.AND_SYMBOL)
                self.state = 8754
                self.identification()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifiedByPassword(self):
            return self.getTypedRuleContext(MySQLParser.IdentifiedByPasswordContext,0)


        def identifiedByRandomPassword(self):
            return self.getTypedRuleContext(MySQLParser.IdentifiedByRandomPasswordContext,0)


        def identifiedWithPlugin(self):
            return self.getTypedRuleContext(MySQLParser.IdentifiedWithPluginContext,0)


        def identifiedWithPluginAsAuth(self):
            return self.getTypedRuleContext(MySQLParser.IdentifiedWithPluginAsAuthContext,0)


        def identifiedWithPluginByPassword(self):
            return self.getTypedRuleContext(MySQLParser.IdentifiedWithPluginByPasswordContext,0)


        def identifiedWithPluginByRandomPassword(self):
            return self.getTypedRuleContext(MySQLParser.IdentifiedWithPluginByRandomPasswordContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_identification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentification" ):
                listener.enterIdentification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentification" ):
                listener.exitIdentification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentification" ):
                return visitor.visitIdentification(self)
            else:
                return visitor.visitChildren(self)




    def identification(self):

        localctx = MySQLParser.IdentificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1280, self.RULE_identification)
        try:
            self.state = 8763
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1114,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8757
                self.identifiedByPassword()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8758
                self.identifiedByRandomPassword()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 8759
                self.identifiedWithPlugin()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 8760
                self.identifiedWithPluginAsAuth()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 8761
                self.identifiedWithPluginByPassword()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 8762
                self.identifiedWithPluginByRandomPassword()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifiedByPasswordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIED_SYMBOL(self):
            return self.getToken(MySQLParser.IDENTIFIED_SYMBOL, 0)

        def BY_SYMBOL(self):
            return self.getToken(MySQLParser.BY_SYMBOL, 0)

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_identifiedByPassword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifiedByPassword" ):
                listener.enterIdentifiedByPassword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifiedByPassword" ):
                listener.exitIdentifiedByPassword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifiedByPassword" ):
                return visitor.visitIdentifiedByPassword(self)
            else:
                return visitor.visitChildren(self)




    def identifiedByPassword(self):

        localctx = MySQLParser.IdentifiedByPasswordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1282, self.RULE_identifiedByPassword)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8765
            self.match(MySQLParser.IDENTIFIED_SYMBOL)
            self.state = 8766
            self.match(MySQLParser.BY_SYMBOL)
            self.state = 8767
            self.textStringLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifiedByRandomPasswordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIED_SYMBOL(self):
            return self.getToken(MySQLParser.IDENTIFIED_SYMBOL, 0)

        def BY_SYMBOL(self):
            return self.getToken(MySQLParser.BY_SYMBOL, 0)

        def RANDOM_SYMBOL(self):
            return self.getToken(MySQLParser.RANDOM_SYMBOL, 0)

        def PASSWORD_SYMBOL(self):
            return self.getToken(MySQLParser.PASSWORD_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_identifiedByRandomPassword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifiedByRandomPassword" ):
                listener.enterIdentifiedByRandomPassword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifiedByRandomPassword" ):
                listener.exitIdentifiedByRandomPassword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifiedByRandomPassword" ):
                return visitor.visitIdentifiedByRandomPassword(self)
            else:
                return visitor.visitChildren(self)




    def identifiedByRandomPassword(self):

        localctx = MySQLParser.IdentifiedByRandomPasswordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1284, self.RULE_identifiedByRandomPassword)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8769
            self.match(MySQLParser.IDENTIFIED_SYMBOL)
            self.state = 8770
            self.match(MySQLParser.BY_SYMBOL)
            self.state = 8771
            self.match(MySQLParser.RANDOM_SYMBOL)
            self.state = 8772
            self.match(MySQLParser.PASSWORD_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifiedWithPluginContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIED_SYMBOL(self):
            return self.getToken(MySQLParser.IDENTIFIED_SYMBOL, 0)

        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_identifiedWithPlugin

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifiedWithPlugin" ):
                listener.enterIdentifiedWithPlugin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifiedWithPlugin" ):
                listener.exitIdentifiedWithPlugin(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifiedWithPlugin" ):
                return visitor.visitIdentifiedWithPlugin(self)
            else:
                return visitor.visitChildren(self)




    def identifiedWithPlugin(self):

        localctx = MySQLParser.IdentifiedWithPluginContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1286, self.RULE_identifiedWithPlugin)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8774
            self.match(MySQLParser.IDENTIFIED_SYMBOL)
            self.state = 8775
            self.match(MySQLParser.WITH_SYMBOL)
            self.state = 8776
            self.textOrIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifiedWithPluginAsAuthContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIED_SYMBOL(self):
            return self.getToken(MySQLParser.IDENTIFIED_SYMBOL, 0)

        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def AS_SYMBOL(self):
            return self.getToken(MySQLParser.AS_SYMBOL, 0)

        def textStringHash(self):
            return self.getTypedRuleContext(MySQLParser.TextStringHashContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_identifiedWithPluginAsAuth

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifiedWithPluginAsAuth" ):
                listener.enterIdentifiedWithPluginAsAuth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifiedWithPluginAsAuth" ):
                listener.exitIdentifiedWithPluginAsAuth(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifiedWithPluginAsAuth" ):
                return visitor.visitIdentifiedWithPluginAsAuth(self)
            else:
                return visitor.visitChildren(self)




    def identifiedWithPluginAsAuth(self):

        localctx = MySQLParser.IdentifiedWithPluginAsAuthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1288, self.RULE_identifiedWithPluginAsAuth)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8778
            self.match(MySQLParser.IDENTIFIED_SYMBOL)
            self.state = 8779
            self.match(MySQLParser.WITH_SYMBOL)
            self.state = 8780
            self.textOrIdentifier()
            self.state = 8781
            self.match(MySQLParser.AS_SYMBOL)
            self.state = 8782
            self.textStringHash()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifiedWithPluginByPasswordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIED_SYMBOL(self):
            return self.getToken(MySQLParser.IDENTIFIED_SYMBOL, 0)

        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def BY_SYMBOL(self):
            return self.getToken(MySQLParser.BY_SYMBOL, 0)

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_identifiedWithPluginByPassword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifiedWithPluginByPassword" ):
                listener.enterIdentifiedWithPluginByPassword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifiedWithPluginByPassword" ):
                listener.exitIdentifiedWithPluginByPassword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifiedWithPluginByPassword" ):
                return visitor.visitIdentifiedWithPluginByPassword(self)
            else:
                return visitor.visitChildren(self)




    def identifiedWithPluginByPassword(self):

        localctx = MySQLParser.IdentifiedWithPluginByPasswordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1290, self.RULE_identifiedWithPluginByPassword)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8784
            self.match(MySQLParser.IDENTIFIED_SYMBOL)
            self.state = 8785
            self.match(MySQLParser.WITH_SYMBOL)
            self.state = 8786
            self.textOrIdentifier()
            self.state = 8787
            self.match(MySQLParser.BY_SYMBOL)
            self.state = 8788
            self.textStringLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifiedWithPluginByRandomPasswordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIED_SYMBOL(self):
            return self.getToken(MySQLParser.IDENTIFIED_SYMBOL, 0)

        def WITH_SYMBOL(self):
            return self.getToken(MySQLParser.WITH_SYMBOL, 0)

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def BY_SYMBOL(self):
            return self.getToken(MySQLParser.BY_SYMBOL, 0)

        def RANDOM_SYMBOL(self):
            return self.getToken(MySQLParser.RANDOM_SYMBOL, 0)

        def PASSWORD_SYMBOL(self):
            return self.getToken(MySQLParser.PASSWORD_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_identifiedWithPluginByRandomPassword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifiedWithPluginByRandomPassword" ):
                listener.enterIdentifiedWithPluginByRandomPassword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifiedWithPluginByRandomPassword" ):
                listener.exitIdentifiedWithPluginByRandomPassword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifiedWithPluginByRandomPassword" ):
                return visitor.visitIdentifiedWithPluginByRandomPassword(self)
            else:
                return visitor.visitChildren(self)




    def identifiedWithPluginByRandomPassword(self):

        localctx = MySQLParser.IdentifiedWithPluginByRandomPasswordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1292, self.RULE_identifiedWithPluginByRandomPassword)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8790
            self.match(MySQLParser.IDENTIFIED_SYMBOL)
            self.state = 8791
            self.match(MySQLParser.WITH_SYMBOL)
            self.state = 8792
            self.textOrIdentifier()
            self.state = 8793
            self.match(MySQLParser.BY_SYMBOL)
            self.state = 8794
            self.match(MySQLParser.RANDOM_SYMBOL)
            self.state = 8795
            self.match(MySQLParser.PASSWORD_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InitialAuthContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INITIAL_SYMBOL(self):
            return self.getToken(MySQLParser.INITIAL_SYMBOL, 0)

        def AUTHENTICATION_SYMBOL(self):
            return self.getToken(MySQLParser.AUTHENTICATION_SYMBOL, 0)

        def identifiedByRandomPassword(self):
            return self.getTypedRuleContext(MySQLParser.IdentifiedByRandomPasswordContext,0)


        def identifiedWithPluginAsAuth(self):
            return self.getTypedRuleContext(MySQLParser.IdentifiedWithPluginAsAuthContext,0)


        def identifiedByPassword(self):
            return self.getTypedRuleContext(MySQLParser.IdentifiedByPasswordContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_initialAuth

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInitialAuth" ):
                listener.enterInitialAuth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInitialAuth" ):
                listener.exitInitialAuth(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInitialAuth" ):
                return visitor.visitInitialAuth(self)
            else:
                return visitor.visitChildren(self)




    def initialAuth(self):

        localctx = MySQLParser.InitialAuthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1294, self.RULE_initialAuth)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8797
            self.match(MySQLParser.INITIAL_SYMBOL)
            self.state = 8798
            self.match(MySQLParser.AUTHENTICATION_SYMBOL)
            self.state = 8802
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1115,self._ctx)
            if la_ == 1:
                self.state = 8799
                self.identifiedByRandomPassword()
                pass

            elif la_ == 2:
                self.state = 8800
                self.identifiedWithPluginAsAuth()
                pass

            elif la_ == 3:
                self.state = 8801
                self.identifiedByPassword()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RetainCurrentPasswordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETAIN_SYMBOL(self):
            return self.getToken(MySQLParser.RETAIN_SYMBOL, 0)

        def CURRENT_SYMBOL(self):
            return self.getToken(MySQLParser.CURRENT_SYMBOL, 0)

        def PASSWORD_SYMBOL(self):
            return self.getToken(MySQLParser.PASSWORD_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_retainCurrentPassword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRetainCurrentPassword" ):
                listener.enterRetainCurrentPassword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRetainCurrentPassword" ):
                listener.exitRetainCurrentPassword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRetainCurrentPassword" ):
                return visitor.visitRetainCurrentPassword(self)
            else:
                return visitor.visitChildren(self)




    def retainCurrentPassword(self):

        localctx = MySQLParser.RetainCurrentPasswordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1296, self.RULE_retainCurrentPassword)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8804
            self.match(MySQLParser.RETAIN_SYMBOL)
            self.state = 8805
            self.match(MySQLParser.CURRENT_SYMBOL)
            self.state = 8806
            self.match(MySQLParser.PASSWORD_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DiscardOldPasswordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISCARD_SYMBOL(self):
            return self.getToken(MySQLParser.DISCARD_SYMBOL, 0)

        def OLD_SYMBOL(self):
            return self.getToken(MySQLParser.OLD_SYMBOL, 0)

        def PASSWORD_SYMBOL(self):
            return self.getToken(MySQLParser.PASSWORD_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_discardOldPassword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDiscardOldPassword" ):
                listener.enterDiscardOldPassword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDiscardOldPassword" ):
                listener.exitDiscardOldPassword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDiscardOldPassword" ):
                return visitor.visitDiscardOldPassword(self)
            else:
                return visitor.visitChildren(self)




    def discardOldPassword(self):

        localctx = MySQLParser.DiscardOldPasswordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1298, self.RULE_discardOldPassword)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8808
            self.match(MySQLParser.DISCARD_SYMBOL)
            self.state = 8809
            self.match(MySQLParser.OLD_SYMBOL)
            self.state = 8810
            self.match(MySQLParser.PASSWORD_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UserRegistrationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def factor(self):
            return self.getTypedRuleContext(MySQLParser.FactorContext,0)


        def INITIATE_SYMBOL(self):
            return self.getToken(MySQLParser.INITIATE_SYMBOL, 0)

        def REGISTRATION_SYMBOL(self):
            return self.getToken(MySQLParser.REGISTRATION_SYMBOL, 0)

        def UNREGISTER_SYMBOL(self):
            return self.getToken(MySQLParser.UNREGISTER_SYMBOL, 0)

        def FINISH_SYMBOL(self):
            return self.getToken(MySQLParser.FINISH_SYMBOL, 0)

        def SET_SYMBOL(self):
            return self.getToken(MySQLParser.SET_SYMBOL, 0)

        def CHALLENGE_RESPONSE_SYMBOL(self):
            return self.getToken(MySQLParser.CHALLENGE_RESPONSE_SYMBOL, 0)

        def AS_SYMBOL(self):
            return self.getToken(MySQLParser.AS_SYMBOL, 0)

        def textStringHash(self):
            return self.getTypedRuleContext(MySQLParser.TextStringHashContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_userRegistration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUserRegistration" ):
                listener.enterUserRegistration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUserRegistration" ):
                listener.exitUserRegistration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUserRegistration" ):
                return visitor.visitUserRegistration(self)
            else:
                return visitor.visitChildren(self)




    def userRegistration(self):

        localctx = MySQLParser.UserRegistrationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1300, self.RULE_userRegistration)
        try:
            self.state = 8827
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1116,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8812
                self.factor()
                self.state = 8813
                self.match(MySQLParser.INITIATE_SYMBOL)
                self.state = 8814
                self.match(MySQLParser.REGISTRATION_SYMBOL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8816
                self.factor()
                self.state = 8817
                self.match(MySQLParser.UNREGISTER_SYMBOL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 8819
                self.factor()
                self.state = 8820
                self.match(MySQLParser.FINISH_SYMBOL)
                self.state = 8821
                self.match(MySQLParser.REGISTRATION_SYMBOL)
                self.state = 8822
                self.match(MySQLParser.SET_SYMBOL)
                self.state = 8823
                self.match(MySQLParser.CHALLENGE_RESPONSE_SYMBOL)
                self.state = 8824
                self.match(MySQLParser.AS_SYMBOL)
                self.state = 8825
                self.textStringHash()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FactorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numLiteral(self):
            return self.getTypedRuleContext(MySQLParser.NumLiteralContext,0)


        def FACTOR_SYMBOL(self):
            return self.getToken(MySQLParser.FACTOR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_factor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactor" ):
                listener.enterFactor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactor" ):
                listener.exitFactor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactor" ):
                return visitor.visitFactor(self)
            else:
                return visitor.visitChildren(self)




    def factor(self):

        localctx = MySQLParser.FactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1302, self.RULE_factor)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8829
            self.numLiteral()
            self.state = 8830
            self.match(MySQLParser.FACTOR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReplacePasswordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPLACE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLACE_SYMBOL, 0)

        def textString(self):
            return self.getTypedRuleContext(MySQLParser.TextStringContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_replacePassword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplacePassword" ):
                listener.enterReplacePassword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplacePassword" ):
                listener.exitReplacePassword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReplacePassword" ):
                return visitor.visitReplacePassword(self)
            else:
                return visitor.visitChildren(self)




    def replacePassword(self):

        localctx = MySQLParser.ReplacePasswordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1304, self.RULE_replacePassword)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8832
            self.match(MySQLParser.REPLACE_SYMBOL)
            self.state = 8833
            self.textString()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UserIdentifierOrTextContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def userVariable(self):
            return self.getTypedRuleContext(MySQLParser.UserVariableContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_userIdentifierOrText

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUserIdentifierOrText" ):
                listener.enterUserIdentifierOrText(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUserIdentifierOrText" ):
                listener.exitUserIdentifierOrText(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUserIdentifierOrText" ):
                return visitor.visitUserIdentifierOrText(self)
            else:
                return visitor.visitChildren(self)




    def userIdentifierOrText(self):

        localctx = MySQLParser.UserIdentifierOrTextContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1306, self.RULE_userIdentifierOrText)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8835
            self.textOrIdentifier()
            self.state = 8837
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1117,self._ctx)
            if la_ == 1:
                self.state = 8836
                self.userVariable()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UserContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def userIdentifierOrText(self):
            return self.getTypedRuleContext(MySQLParser.UserIdentifierOrTextContext,0)


        def CURRENT_USER_SYMBOL(self):
            return self.getToken(MySQLParser.CURRENT_USER_SYMBOL, 0)

        def parentheses(self):
            return self.getTypedRuleContext(MySQLParser.ParenthesesContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_user

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUser" ):
                listener.enterUser(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUser" ):
                listener.exitUser(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUser" ):
                return visitor.visitUser(self)
            else:
                return visitor.visitChildren(self)




    def user(self):

        localctx = MySQLParser.UserContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1308, self.RULE_user)
        try:
            self.state = 8844
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1119,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8839
                self.userIdentifierOrText()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8840
                self.match(MySQLParser.CURRENT_USER_SYMBOL)
                self.state = 8842
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1118,self._ctx)
                if la_ == 1:
                    self.state = 8841
                    self.parentheses()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LikeClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIKE_SYMBOL(self):
            return self.getToken(MySQLParser.LIKE_SYMBOL, 0)

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_likeClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLikeClause" ):
                listener.enterLikeClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLikeClause" ):
                listener.exitLikeClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLikeClause" ):
                return visitor.visitLikeClause(self)
            else:
                return visitor.visitChildren(self)




    def likeClause(self):

        localctx = MySQLParser.LikeClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1310, self.RULE_likeClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8846
            self.match(MySQLParser.LIKE_SYMBOL)
            self.state = 8847
            self.textStringLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LikeOrWhereContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def likeClause(self):
            return self.getTypedRuleContext(MySQLParser.LikeClauseContext,0)


        def whereClause(self):
            return self.getTypedRuleContext(MySQLParser.WhereClauseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_likeOrWhere

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLikeOrWhere" ):
                listener.enterLikeOrWhere(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLikeOrWhere" ):
                listener.exitLikeOrWhere(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLikeOrWhere" ):
                return visitor.visitLikeOrWhere(self)
            else:
                return visitor.visitChildren(self)




    def likeOrWhere(self):

        localctx = MySQLParser.LikeOrWhereContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1312, self.RULE_likeOrWhere)
        try:
            self.state = 8851
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [305]:
                self.enterOuterAlt(localctx, 1)
                self.state = 8849
                self.likeClause()
                pass
            elif token in [651]:
                self.enterOuterAlt(localctx, 2)
                self.state = 8850
                self.whereClause()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnlineOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ONLINE_SYMBOL(self):
            return self.getToken(MySQLParser.ONLINE_SYMBOL, 0)

        def OFFLINE_SYMBOL(self):
            return self.getToken(MySQLParser.OFFLINE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_onlineOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnlineOption" ):
                listener.enterOnlineOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnlineOption" ):
                listener.exitOnlineOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnlineOption" ):
                return visitor.visitOnlineOption(self)
            else:
                return visitor.visitChildren(self)




    def onlineOption(self):

        localctx = MySQLParser.OnlineOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1314, self.RULE_onlineOption)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8853
            _la = self._input.LA(1)
            if not(_la==399 or _la==403):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NoWriteToBinLogContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOCAL_SYMBOL(self):
            return self.getToken(MySQLParser.LOCAL_SYMBOL, 0)

        def NO_WRITE_TO_BINLOG_SYMBOL(self):
            return self.getToken(MySQLParser.NO_WRITE_TO_BINLOG_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_noWriteToBinLog

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNoWriteToBinLog" ):
                listener.enterNoWriteToBinLog(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNoWriteToBinLog" ):
                listener.exitNoWriteToBinLog(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNoWriteToBinLog" ):
                return visitor.visitNoWriteToBinLog(self)
            else:
                return visitor.visitChildren(self)




    def noWriteToBinLog(self):

        localctx = MySQLParser.NoWriteToBinLogContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1316, self.RULE_noWriteToBinLog)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8855
            _la = self._input.LA(1)
            if not(_la==312 or _la==394):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UsePartitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARTITION_SYMBOL(self):
            return self.getToken(MySQLParser.PARTITION_SYMBOL, 0)

        def identifierListWithParentheses(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierListWithParenthesesContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_usePartition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUsePartition" ):
                listener.enterUsePartition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUsePartition" ):
                listener.exitUsePartition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUsePartition" ):
                return visitor.visitUsePartition(self)
            else:
                return visitor.visitChildren(self)




    def usePartition(self):

        localctx = MySQLParser.UsePartitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1318, self.RULE_usePartition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8857
            self.match(MySQLParser.PARTITION_SYMBOL)
            self.state = 8858
            self.identifierListWithParentheses()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FieldIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dotIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.DotIdentifierContext,0)


        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_fieldIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFieldIdentifier" ):
                listener.enterFieldIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFieldIdentifier" ):
                listener.exitFieldIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFieldIdentifier" ):
                return visitor.visitFieldIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def fieldIdentifier(self):

        localctx = MySQLParser.FieldIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1320, self.RULE_fieldIdentifier)
        try:
            self.state = 8865
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1122,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8860
                self.dotIdentifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8861
                self.qualifiedIdentifier()
                self.state = 8863
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1121,self._ctx)
                if la_ == 1:
                    self.state = 8862
                    self.dotIdentifier()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_columnName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnName" ):
                listener.enterColumnName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnName" ):
                listener.exitColumnName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnName" ):
                return visitor.visitColumnName(self)
            else:
                return visitor.visitChildren(self)




    def columnName(self):

        localctx = MySQLParser.ColumnNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1322, self.RULE_columnName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8867
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnInternalRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_columnInternalRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnInternalRef" ):
                listener.enterColumnInternalRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnInternalRef" ):
                listener.exitColumnInternalRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnInternalRef" ):
                return visitor.visitColumnInternalRef(self)
            else:
                return visitor.visitChildren(self)




    def columnInternalRef(self):

        localctx = MySQLParser.ColumnInternalRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1324, self.RULE_columnInternalRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8869
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnInternalRefListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def columnInternalRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.ColumnInternalRefContext)
            else:
                return self.getTypedRuleContext(MySQLParser.ColumnInternalRefContext,i)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_columnInternalRefList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnInternalRefList" ):
                listener.enterColumnInternalRefList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnInternalRefList" ):
                listener.exitColumnInternalRefList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnInternalRefList" ):
                return visitor.visitColumnInternalRefList(self)
            else:
                return visitor.visitChildren(self)




    def columnInternalRefList(self):

        localctx = MySQLParser.ColumnInternalRefListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1326, self.RULE_columnInternalRefList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8871
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 8872
            self.columnInternalRef()
            self.state = 8877
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 8873
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 8874
                self.columnInternalRef()
                self.state = 8879
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 8880
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fieldIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.FieldIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_columnRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnRef" ):
                listener.enterColumnRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnRef" ):
                listener.exitColumnRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnRef" ):
                return visitor.visitColumnRef(self)
            else:
                return visitor.visitChildren(self)




    def columnRef(self):

        localctx = MySQLParser.ColumnRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1328, self.RULE_columnRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8882
            self.fieldIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InsertIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def columnRef(self):
            return self.getTypedRuleContext(MySQLParser.ColumnRefContext,0)


        def tableWild(self):
            return self.getTypedRuleContext(MySQLParser.TableWildContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_insertIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsertIdentifier" ):
                listener.enterInsertIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsertIdentifier" ):
                listener.exitInsertIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInsertIdentifier" ):
                return visitor.visitInsertIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def insertIdentifier(self):

        localctx = MySQLParser.InsertIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1330, self.RULE_insertIdentifier)
        try:
            self.state = 8886
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1124,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8884
                self.columnRef()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8885
                self.tableWild()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndexNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_indexName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndexName" ):
                listener.enterIndexName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndexName" ):
                listener.exitIndexName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndexName" ):
                return visitor.visitIndexName(self)
            else:
                return visitor.visitChildren(self)




    def indexName(self):

        localctx = MySQLParser.IndexNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1332, self.RULE_indexName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8888
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndexRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fieldIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.FieldIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_indexRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndexRef" ):
                listener.enterIndexRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndexRef" ):
                listener.exitIndexRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndexRef" ):
                return visitor.visitIndexRef(self)
            else:
                return visitor.visitChildren(self)




    def indexRef(self):

        localctx = MySQLParser.IndexRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1334, self.RULE_indexRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8890
            self.fieldIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableWildContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(MySQLParser.IdentifierContext,i)


        def DOT_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.DOT_SYMBOL)
            else:
                return self.getToken(MySQLParser.DOT_SYMBOL, i)

        def MULT_OPERATOR(self):
            return self.getToken(MySQLParser.MULT_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_tableWild

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableWild" ):
                listener.enterTableWild(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableWild" ):
                listener.exitTableWild(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableWild" ):
                return visitor.visitTableWild(self)
            else:
                return visitor.visitChildren(self)




    def tableWild(self):

        localctx = MySQLParser.TableWildContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1336, self.RULE_tableWild)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8892
            self.identifier()
            self.state = 8893
            self.match(MySQLParser.DOT_SYMBOL)
            self.state = 8897
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1125,self._ctx)
            if la_ == 1:
                self.state = 8894
                self.identifier()
                self.state = 8895
                self.match(MySQLParser.DOT_SYMBOL)


            self.state = 8899
            self.match(MySQLParser.MULT_OPERATOR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SchemaNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_schemaName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchemaName" ):
                listener.enterSchemaName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchemaName" ):
                listener.exitSchemaName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSchemaName" ):
                return visitor.visitSchemaName(self)
            else:
                return visitor.visitChildren(self)




    def schemaName(self):

        localctx = MySQLParser.SchemaNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1338, self.RULE_schemaName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8901
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SchemaRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_schemaRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchemaRef" ):
                listener.enterSchemaRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchemaRef" ):
                listener.exitSchemaRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSchemaRef" ):
                return visitor.visitSchemaRef(self)
            else:
                return visitor.visitChildren(self)




    def schemaRef(self):

        localctx = MySQLParser.SchemaRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1340, self.RULE_schemaRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8903
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcedureNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_procedureName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcedureName" ):
                listener.enterProcedureName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcedureName" ):
                listener.exitProcedureName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcedureName" ):
                return visitor.visitProcedureName(self)
            else:
                return visitor.visitChildren(self)




    def procedureName(self):

        localctx = MySQLParser.ProcedureNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1342, self.RULE_procedureName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8905
            self.qualifiedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcedureRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_procedureRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcedureRef" ):
                listener.enterProcedureRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcedureRef" ):
                listener.exitProcedureRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcedureRef" ):
                return visitor.visitProcedureRef(self)
            else:
                return visitor.visitChildren(self)




    def procedureRef(self):

        localctx = MySQLParser.ProcedureRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1344, self.RULE_procedureRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8907
            self.qualifiedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_functionName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionName" ):
                listener.enterFunctionName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionName" ):
                listener.exitFunctionName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionName" ):
                return visitor.visitFunctionName(self)
            else:
                return visitor.visitChildren(self)




    def functionName(self):

        localctx = MySQLParser.FunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1346, self.RULE_functionName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8909
            self.qualifiedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_functionRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionRef" ):
                listener.enterFunctionRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionRef" ):
                listener.exitFunctionRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionRef" ):
                return visitor.visitFunctionRef(self)
            else:
                return visitor.visitChildren(self)




    def functionRef(self):

        localctx = MySQLParser.FunctionRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1348, self.RULE_functionRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8911
            self.qualifiedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TriggerNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_triggerName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTriggerName" ):
                listener.enterTriggerName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTriggerName" ):
                listener.exitTriggerName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTriggerName" ):
                return visitor.visitTriggerName(self)
            else:
                return visitor.visitChildren(self)




    def triggerName(self):

        localctx = MySQLParser.TriggerNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1350, self.RULE_triggerName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8913
            self.qualifiedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TriggerRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_triggerRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTriggerRef" ):
                listener.enterTriggerRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTriggerRef" ):
                listener.exitTriggerRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTriggerRef" ):
                return visitor.visitTriggerRef(self)
            else:
                return visitor.visitChildren(self)




    def triggerRef(self):

        localctx = MySQLParser.TriggerRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1352, self.RULE_triggerRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8915
            self.qualifiedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ViewNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.QualifiedIdentifierContext,0)


        def dotIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.DotIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_viewName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterViewName" ):
                listener.enterViewName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitViewName" ):
                listener.exitViewName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitViewName" ):
                return visitor.visitViewName(self)
            else:
                return visitor.visitChildren(self)




    def viewName(self):

        localctx = MySQLParser.ViewNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1354, self.RULE_viewName)
        try:
            self.state = 8919
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1126,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8917
                self.qualifiedIdentifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8918
                self.dotIdentifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ViewRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.QualifiedIdentifierContext,0)


        def dotIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.DotIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_viewRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterViewRef" ):
                listener.enterViewRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitViewRef" ):
                listener.exitViewRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitViewRef" ):
                return visitor.visitViewRef(self)
            else:
                return visitor.visitChildren(self)




    def viewRef(self):

        localctx = MySQLParser.ViewRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1356, self.RULE_viewRef)
        try:
            self.state = 8923
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1127,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8921
                self.qualifiedIdentifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8922
                self.dotIdentifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TablespaceNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_tablespaceName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTablespaceName" ):
                listener.enterTablespaceName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTablespaceName" ):
                listener.exitTablespaceName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTablespaceName" ):
                return visitor.visitTablespaceName(self)
            else:
                return visitor.visitChildren(self)




    def tablespaceName(self):

        localctx = MySQLParser.TablespaceNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1358, self.RULE_tablespaceName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8925
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TablespaceRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_tablespaceRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTablespaceRef" ):
                listener.enterTablespaceRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTablespaceRef" ):
                listener.exitTablespaceRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTablespaceRef" ):
                return visitor.visitTablespaceRef(self)
            else:
                return visitor.visitChildren(self)




    def tablespaceRef(self):

        localctx = MySQLParser.TablespaceRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1360, self.RULE_tablespaceRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8927
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogfileGroupNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_logfileGroupName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogfileGroupName" ):
                listener.enterLogfileGroupName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogfileGroupName" ):
                listener.exitLogfileGroupName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogfileGroupName" ):
                return visitor.visitLogfileGroupName(self)
            else:
                return visitor.visitChildren(self)




    def logfileGroupName(self):

        localctx = MySQLParser.LogfileGroupNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1362, self.RULE_logfileGroupName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8929
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogfileGroupRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_logfileGroupRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogfileGroupRef" ):
                listener.enterLogfileGroupRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogfileGroupRef" ):
                listener.exitLogfileGroupRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogfileGroupRef" ):
                return visitor.visitLogfileGroupRef(self)
            else:
                return visitor.visitChildren(self)




    def logfileGroupRef(self):

        localctx = MySQLParser.LogfileGroupRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1364, self.RULE_logfileGroupRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8931
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_eventName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEventName" ):
                listener.enterEventName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEventName" ):
                listener.exitEventName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEventName" ):
                return visitor.visitEventName(self)
            else:
                return visitor.visitChildren(self)




    def eventName(self):

        localctx = MySQLParser.EventNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1366, self.RULE_eventName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8933
            self.qualifiedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_eventRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEventRef" ):
                listener.enterEventRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEventRef" ):
                listener.exitEventRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEventRef" ):
                return visitor.visitEventRef(self)
            else:
                return visitor.visitChildren(self)




    def eventRef(self):

        localctx = MySQLParser.EventRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1368, self.RULE_eventRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8935
            self.qualifiedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UdfNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_udfName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUdfName" ):
                listener.enterUdfName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUdfName" ):
                listener.exitUdfName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUdfName" ):
                return visitor.visitUdfName(self)
            else:
                return visitor.visitChildren(self)




    def udfName(self):

        localctx = MySQLParser.UdfNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1370, self.RULE_udfName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8937
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ServerNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_serverName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterServerName" ):
                listener.enterServerName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitServerName" ):
                listener.exitServerName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitServerName" ):
                return visitor.visitServerName(self)
            else:
                return visitor.visitChildren(self)




    def serverName(self):

        localctx = MySQLParser.ServerNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1372, self.RULE_serverName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8939
            self.textOrIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ServerRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_serverRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterServerRef" ):
                listener.enterServerRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitServerRef" ):
                listener.exitServerRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitServerRef" ):
                return visitor.visitServerRef(self)
            else:
                return visitor.visitChildren(self)




    def serverRef(self):

        localctx = MySQLParser.ServerRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1374, self.RULE_serverRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8941
            self.textOrIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EngineRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textOrIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.TextOrIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_engineRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEngineRef" ):
                listener.enterEngineRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEngineRef" ):
                listener.exitEngineRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEngineRef" ):
                return visitor.visitEngineRef(self)
            else:
                return visitor.visitChildren(self)




    def engineRef(self):

        localctx = MySQLParser.EngineRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1376, self.RULE_engineRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8943
            self.textOrIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.QualifiedIdentifierContext,0)


        def dotIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.DotIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_tableName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableName" ):
                listener.enterTableName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableName" ):
                listener.exitTableName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableName" ):
                return visitor.visitTableName(self)
            else:
                return visitor.visitChildren(self)




    def tableName(self):

        localctx = MySQLParser.TableNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1378, self.RULE_tableName)
        try:
            self.state = 8947
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1128,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8945
                self.qualifiedIdentifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8946
                self.dotIdentifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FilterTableRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def schemaRef(self):
            return self.getTypedRuleContext(MySQLParser.SchemaRefContext,0)


        def dotIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.DotIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_filterTableRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilterTableRef" ):
                listener.enterFilterTableRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilterTableRef" ):
                listener.exitFilterTableRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilterTableRef" ):
                return visitor.visitFilterTableRef(self)
            else:
                return visitor.visitChildren(self)




    def filterTableRef(self):

        localctx = MySQLParser.FilterTableRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1380, self.RULE_filterTableRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8949
            self.schemaRef()
            self.state = 8950
            self.dotIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableRefWithWildcardContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def DOT_SYMBOL(self):
            return self.getToken(MySQLParser.DOT_SYMBOL, 0)

        def MULT_OPERATOR(self):
            return self.getToken(MySQLParser.MULT_OPERATOR, 0)

        def dotIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.DotIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_tableRefWithWildcard

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableRefWithWildcard" ):
                listener.enterTableRefWithWildcard(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableRefWithWildcard" ):
                listener.exitTableRefWithWildcard(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableRefWithWildcard" ):
                return visitor.visitTableRefWithWildcard(self)
            else:
                return visitor.visitChildren(self)




    def tableRefWithWildcard(self):

        localctx = MySQLParser.TableRefWithWildcardContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1382, self.RULE_tableRefWithWildcard)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8952
            self.identifier()
            self.state = 8960
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1130,self._ctx)
            if la_ == 1:
                self.state = 8953
                self.match(MySQLParser.DOT_SYMBOL)
                self.state = 8954
                self.match(MySQLParser.MULT_OPERATOR)

            elif la_ == 2:
                self.state = 8955
                self.dotIdentifier()
                self.state = 8958
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==28:
                    self.state = 8956
                    self.match(MySQLParser.DOT_SYMBOL)
                    self.state = 8957
                    self.match(MySQLParser.MULT_OPERATOR)




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.QualifiedIdentifierContext,0)


        def dotIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.DotIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_tableRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableRef" ):
                listener.enterTableRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableRef" ):
                listener.exitTableRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableRef" ):
                return visitor.visitTableRef(self)
            else:
                return visitor.visitChildren(self)




    def tableRef(self):

        localctx = MySQLParser.TableRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1384, self.RULE_tableRef)
        try:
            self.state = 8964
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1131,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8962
                self.qualifiedIdentifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8963
                self.dotIdentifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableRefListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.TableRefContext)
            else:
                return self.getTypedRuleContext(MySQLParser.TableRefContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_tableRefList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableRefList" ):
                listener.enterTableRefList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableRefList" ):
                listener.exitTableRefList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableRefList" ):
                return visitor.visitTableRefList(self)
            else:
                return visitor.visitChildren(self)




    def tableRefList(self):

        localctx = MySQLParser.TableRefListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1386, self.RULE_tableRefList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8966
            self.tableRef()
            self.state = 8971
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 8967
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 8968
                self.tableRef()
                self.state = 8973
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableAliasRefListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableRefWithWildcard(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.TableRefWithWildcardContext)
            else:
                return self.getTypedRuleContext(MySQLParser.TableRefWithWildcardContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_tableAliasRefList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableAliasRefList" ):
                listener.enterTableAliasRefList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableAliasRefList" ):
                listener.exitTableAliasRefList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableAliasRefList" ):
                return visitor.visitTableAliasRefList(self)
            else:
                return visitor.visitChildren(self)




    def tableAliasRefList(self):

        localctx = MySQLParser.TableAliasRefListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1388, self.RULE_tableAliasRefList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8974
            self.tableRefWithWildcard()
            self.state = 8979
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 8975
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 8976
                self.tableRefWithWildcard()
                self.state = 8981
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_parameterName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterName" ):
                listener.enterParameterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterName" ):
                listener.exitParameterName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterName" ):
                return visitor.visitParameterName(self)
            else:
                return visitor.visitChildren(self)




    def parameterName(self):

        localctx = MySQLParser.ParameterNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1390, self.RULE_parameterName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8982
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pureIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.PureIdentifierContext,0)


        def labelKeyword(self):
            return self.getTypedRuleContext(MySQLParser.LabelKeywordContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_labelIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelIdentifier" ):
                listener.enterLabelIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelIdentifier" ):
                listener.exitLabelIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabelIdentifier" ):
                return visitor.visitLabelIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def labelIdentifier(self):

        localctx = MySQLParser.LabelIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1392, self.RULE_labelIdentifier)
        try:
            self.state = 8986
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1134,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8984
                self.pureIdentifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8985
                self.labelKeyword()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def labelIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.LabelIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_labelRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelRef" ):
                listener.enterLabelRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelRef" ):
                listener.exitLabelRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabelRef" ):
                return visitor.visitLabelRef(self)
            else:
                return visitor.visitChildren(self)




    def labelRef(self):

        localctx = MySQLParser.LabelRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1394, self.RULE_labelRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8988
            self.labelIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pureIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.PureIdentifierContext,0)


        def roleKeyword(self):
            return self.getTypedRuleContext(MySQLParser.RoleKeywordContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_roleIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoleIdentifier" ):
                listener.enterRoleIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoleIdentifier" ):
                listener.exitRoleIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRoleIdentifier" ):
                return visitor.visitRoleIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def roleIdentifier(self):

        localctx = MySQLParser.RoleIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1396, self.RULE_roleIdentifier)
        try:
            self.state = 8992
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1135,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 8990
                self.pureIdentifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 8991
                self.roleKeyword()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PluginRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_pluginRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPluginRef" ):
                listener.enterPluginRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPluginRef" ):
                listener.exitPluginRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPluginRef" ):
                return visitor.visitPluginRef(self)
            else:
                return visitor.visitChildren(self)




    def pluginRef(self):

        localctx = MySQLParser.PluginRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1398, self.RULE_pluginRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8994
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComponentRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_componentRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComponentRef" ):
                listener.enterComponentRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComponentRef" ):
                listener.exitComponentRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComponentRef" ):
                return visitor.visitComponentRef(self)
            else:
                return visitor.visitChildren(self)




    def componentRef(self):

        localctx = MySQLParser.ComponentRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1400, self.RULE_componentRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8996
            self.textStringLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResourceGroupRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_resourceGroupRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResourceGroupRef" ):
                listener.enterResourceGroupRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResourceGroupRef" ):
                listener.exitResourceGroupRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResourceGroupRef" ):
                return visitor.visitResourceGroupRef(self)
            else:
                return visitor.visitChildren(self)




    def resourceGroupRef(self):

        localctx = MySQLParser.ResourceGroupRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1402, self.RULE_resourceGroupRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 8998
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_windowName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowName" ):
                listener.enterWindowName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowName" ):
                listener.exitWindowName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowName" ):
                return visitor.visitWindowName(self)
            else:
                return visitor.visitChildren(self)




    def windowName(self):

        localctx = MySQLParser.WindowNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1404, self.RULE_windowName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9000
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PureIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(MySQLParser.IDENTIFIER, 0)

        def BACK_TICK_QUOTED_ID(self):
            return self.getToken(MySQLParser.BACK_TICK_QUOTED_ID, 0)

        def DOUBLE_QUOTED_TEXT(self):
            return self.getToken(MySQLParser.DOUBLE_QUOTED_TEXT, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_pureIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPureIdentifier" ):
                listener.enterPureIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPureIdentifier" ):
                listener.exitPureIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPureIdentifier" ):
                return visitor.visitPureIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def pureIdentifier(self):

        localctx = MySQLParser.PureIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1406, self.RULE_pureIdentifier)
        self._la = 0 # Token type
        try:
            self.state = 9005
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1136,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9002
                _la = self._input.LA(1)
                if not(_la==821 or _la==823):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9003
                if not self.isPureIdentifier():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isPureIdentifier()")
                self.state = 9004
                self.match(MySQLParser.DOUBLE_QUOTED_TEXT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pureIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.PureIdentifierContext,0)


        def identifierKeyword(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierKeywordContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifier" ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = MySQLParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1408, self.RULE_identifier)
        try:
            self.state = 9009
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1137,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9007
                self.pureIdentifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9008
                self.identifierKeyword()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(MySQLParser.IdentifierContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_identifierList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierList" ):
                listener.enterIdentifierList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierList" ):
                listener.exitIdentifierList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierList" ):
                return visitor.visitIdentifierList(self)
            else:
                return visitor.visitChildren(self)




    def identifierList(self):

        localctx = MySQLParser.IdentifierListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1410, self.RULE_identifierList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9011
            self.identifier()
            self.state = 9016
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,1138,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 9012
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 9013
                    self.identifier() 
                self.state = 9018
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1138,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierListWithParenthesesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def identifierList(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierListContext,0)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_identifierListWithParentheses

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierListWithParentheses" ):
                listener.enterIdentifierListWithParentheses(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierListWithParentheses" ):
                listener.exitIdentifierListWithParentheses(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierListWithParentheses" ):
                return visitor.visitIdentifierListWithParentheses(self)
            else:
                return visitor.visitChildren(self)




    def identifierListWithParentheses(self):

        localctx = MySQLParser.IdentifierListWithParenthesesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1412, self.RULE_identifierListWithParentheses)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9019
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 9020
            self.identifierList()
            self.state = 9021
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QualifiedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def dotIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.DotIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_qualifiedIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQualifiedIdentifier" ):
                listener.enterQualifiedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQualifiedIdentifier" ):
                listener.exitQualifiedIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQualifiedIdentifier" ):
                return visitor.visitQualifiedIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def qualifiedIdentifier(self):

        localctx = MySQLParser.QualifiedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1414, self.RULE_qualifiedIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9023
            self.identifier()
            self.state = 9025
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1139,self._ctx)
            if la_ == 1:
                self.state = 9024
                self.dotIdentifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def dotIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.DotIdentifierContext)
            else:
                return self.getTypedRuleContext(MySQLParser.DotIdentifierContext,i)


        def getRuleIndex(self):
            return MySQLParser.RULE_simpleIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleIdentifier" ):
                listener.enterSimpleIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleIdentifier" ):
                listener.exitSimpleIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleIdentifier" ):
                return visitor.visitSimpleIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def simpleIdentifier(self):

        localctx = MySQLParser.SimpleIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1416, self.RULE_simpleIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9027
            self.identifier()
            self.state = 9032
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==28:
                self.state = 9028
                self.dotIdentifier()
                self.state = 9030
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==28:
                    self.state = 9029
                    self.dotIdentifier()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DotIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOT_SYMBOL(self):
            return self.getToken(MySQLParser.DOT_SYMBOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_dotIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDotIdentifier" ):
                listener.enterDotIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDotIdentifier" ):
                listener.exitDotIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDotIdentifier" ):
                return visitor.visitDotIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def dotIdentifier(self):

        localctx = MySQLParser.DotIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1418, self.RULE_dotIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9034
            self.match(MySQLParser.DOT_SYMBOL)
            self.state = 9035
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ulong_numberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_NUMBER(self):
            return self.getToken(MySQLParser.INT_NUMBER, 0)

        def HEX_NUMBER(self):
            return self.getToken(MySQLParser.HEX_NUMBER, 0)

        def LONG_NUMBER(self):
            return self.getToken(MySQLParser.LONG_NUMBER, 0)

        def ULONGLONG_NUMBER(self):
            return self.getToken(MySQLParser.ULONGLONG_NUMBER, 0)

        def DECIMAL_NUMBER(self):
            return self.getToken(MySQLParser.DECIMAL_NUMBER, 0)

        def FLOAT_NUMBER(self):
            return self.getToken(MySQLParser.FLOAT_NUMBER, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_ulong_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUlong_number" ):
                listener.enterUlong_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUlong_number" ):
                listener.exitUlong_number(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUlong_number" ):
                return visitor.visitUlong_number(self)
            else:
                return visitor.visitChildren(self)




    def ulong_number(self):

        localctx = MySQLParser.Ulong_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1420, self.RULE_ulong_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9037
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 228698418577464) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Real_ulong_numberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_NUMBER(self):
            return self.getToken(MySQLParser.INT_NUMBER, 0)

        def HEX_NUMBER(self):
            return self.getToken(MySQLParser.HEX_NUMBER, 0)

        def LONG_NUMBER(self):
            return self.getToken(MySQLParser.LONG_NUMBER, 0)

        def ULONGLONG_NUMBER(self):
            return self.getToken(MySQLParser.ULONGLONG_NUMBER, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_real_ulong_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReal_ulong_number" ):
                listener.enterReal_ulong_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReal_ulong_number" ):
                listener.exitReal_ulong_number(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReal_ulong_number" ):
                return visitor.visitReal_ulong_number(self)
            else:
                return visitor.visitChildren(self)




    def real_ulong_number(self):

        localctx = MySQLParser.Real_ulong_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1422, self.RULE_real_ulong_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9039
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 17592186044472) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UlonglongNumberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_NUMBER(self):
            return self.getToken(MySQLParser.INT_NUMBER, 0)

        def LONG_NUMBER(self):
            return self.getToken(MySQLParser.LONG_NUMBER, 0)

        def ULONGLONG_NUMBER(self):
            return self.getToken(MySQLParser.ULONGLONG_NUMBER, 0)

        def DECIMAL_NUMBER(self):
            return self.getToken(MySQLParser.DECIMAL_NUMBER, 0)

        def FLOAT_NUMBER(self):
            return self.getToken(MySQLParser.FLOAT_NUMBER, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_ulonglongNumber

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUlonglongNumber" ):
                listener.enterUlonglongNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUlonglongNumber" ):
                listener.exitUlonglongNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUlonglongNumber" ):
                return visitor.visitUlonglongNumber(self)
            else:
                return visitor.visitChildren(self)




    def ulonglongNumber(self):

        localctx = MySQLParser.UlonglongNumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1424, self.RULE_ulonglongNumber)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9041
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 211106232533048) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Real_ulonglong_numberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_NUMBER(self):
            return self.getToken(MySQLParser.INT_NUMBER, 0)

        def HEX_NUMBER(self):
            return self.getToken(MySQLParser.HEX_NUMBER, 0)

        def ULONGLONG_NUMBER(self):
            return self.getToken(MySQLParser.ULONGLONG_NUMBER, 0)

        def LONG_NUMBER(self):
            return self.getToken(MySQLParser.LONG_NUMBER, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_real_ulonglong_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReal_ulonglong_number" ):
                listener.enterReal_ulonglong_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReal_ulonglong_number" ):
                listener.exitReal_ulonglong_number(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReal_ulonglong_number" ):
                return visitor.visitReal_ulonglong_number(self)
            else:
                return visitor.visitChildren(self)




    def real_ulonglong_number(self):

        localctx = MySQLParser.Real_ulonglong_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1426, self.RULE_real_ulonglong_number)
        try:
            self.state = 9048
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1142,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9043
                self.match(MySQLParser.INT_NUMBER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9044
                if not self.isServerVersionGe80017():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80017()")
                self.state = 9045
                self.match(MySQLParser.HEX_NUMBER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 9046
                self.match(MySQLParser.ULONGLONG_NUMBER)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 9047
                self.match(MySQLParser.LONG_NUMBER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SignedLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self):
            return self.getTypedRuleContext(MySQLParser.LiteralContext,0)


        def PLUS_OPERATOR(self):
            return self.getToken(MySQLParser.PLUS_OPERATOR, 0)

        def ulong_number(self):
            return self.getTypedRuleContext(MySQLParser.Ulong_numberContext,0)


        def MINUS_OPERATOR(self):
            return self.getToken(MySQLParser.MINUS_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_signedLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignedLiteral" ):
                listener.enterSignedLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignedLiteral" ):
                listener.exitSignedLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignedLiteral" ):
                return visitor.visitSignedLiteral(self)
            else:
                return visitor.visitChildren(self)




    def signedLiteral(self):

        localctx = MySQLParser.SignedLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1428, self.RULE_signedLiteral)
        try:
            self.state = 9055
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1143,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9050
                self.literal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9051
                self.match(MySQLParser.PLUS_OPERATOR)
                self.state = 9052
                self.ulong_number()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 9053
                self.match(MySQLParser.MINUS_OPERATOR)
                self.state = 9054
                self.ulong_number()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SignedLiteralOrNullContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def signedLiteral(self):
            return self.getTypedRuleContext(MySQLParser.SignedLiteralContext,0)


        def nullAsLiteral(self):
            return self.getTypedRuleContext(MySQLParser.NullAsLiteralContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_signedLiteralOrNull

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignedLiteralOrNull" ):
                listener.enterSignedLiteralOrNull(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignedLiteralOrNull" ):
                listener.exitSignedLiteralOrNull(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignedLiteralOrNull" ):
                return visitor.visitSignedLiteralOrNull(self)
            else:
                return visitor.visitChildren(self)




    def signedLiteralOrNull(self):

        localctx = MySQLParser.SignedLiteralOrNullContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1430, self.RULE_signedLiteralOrNull)
        try:
            self.state = 9060
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1144,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9057
                self.signedLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9058
                if not self.isServerVersionGe80024():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                self.state = 9059
                self.nullAsLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextLiteralContext,0)


        def numLiteral(self):
            return self.getTypedRuleContext(MySQLParser.NumLiteralContext,0)


        def temporalLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TemporalLiteralContext,0)


        def nullLiteral(self):
            return self.getTypedRuleContext(MySQLParser.NullLiteralContext,0)


        def boolLiteral(self):
            return self.getTypedRuleContext(MySQLParser.BoolLiteralContext,0)


        def HEX_NUMBER(self):
            return self.getToken(MySQLParser.HEX_NUMBER, 0)

        def BIN_NUMBER(self):
            return self.getToken(MySQLParser.BIN_NUMBER, 0)

        def UNDERSCORE_CHARSET(self):
            return self.getToken(MySQLParser.UNDERSCORE_CHARSET, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteral" ):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)




    def literal(self):

        localctx = MySQLParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1432, self.RULE_literal)
        self._la = 0 # Token type
        try:
            self.state = 9071
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1146,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9062
                self.textLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9063
                self.numLiteral()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 9064
                self.temporalLiteral()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 9065
                self.nullLiteral()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 9066
                self.boolLiteral()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 9068
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==819:
                    self.state = 9067
                    self.match(MySQLParser.UNDERSCORE_CHARSET)


                self.state = 9070
                _la = self._input.LA(1)
                if not(_la==44 or _la==45):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralOrNullContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self):
            return self.getTypedRuleContext(MySQLParser.LiteralContext,0)


        def nullAsLiteral(self):
            return self.getTypedRuleContext(MySQLParser.NullAsLiteralContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_literalOrNull

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteralOrNull" ):
                listener.enterLiteralOrNull(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteralOrNull" ):
                listener.exitLiteralOrNull(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteralOrNull" ):
                return visitor.visitLiteralOrNull(self)
            else:
                return visitor.visitChildren(self)




    def literalOrNull(self):

        localctx = MySQLParser.LiteralOrNullContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1434, self.RULE_literalOrNull)
        try:
            self.state = 9076
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1147,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9073
                self.literal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9074
                if not self.isServerVersionGe80024():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80024()")
                self.state = 9075
                self.nullAsLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NullAsLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NULL_SYMBOL(self):
            return self.getToken(MySQLParser.NULL_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_nullAsLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNullAsLiteral" ):
                listener.enterNullAsLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNullAsLiteral" ):
                listener.exitNullAsLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNullAsLiteral" ):
                return visitor.visitNullAsLiteral(self)
            else:
                return visitor.visitChildren(self)




    def nullAsLiteral(self):

        localctx = MySQLParser.NullAsLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1436, self.RULE_nullAsLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9078
            self.match(MySQLParser.NULL_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def textString(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.TextStringContext)
            else:
                return self.getTypedRuleContext(MySQLParser.TextStringContext,i)


        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_stringList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringList" ):
                listener.enterStringList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringList" ):
                listener.exitStringList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringList" ):
                return visitor.visitStringList(self)
            else:
                return visitor.visitChildren(self)




    def stringList(self):

        localctx = MySQLParser.StringListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1438, self.RULE_stringList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9080
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 9081
            self.textString()
            self.state = 9086
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 9082
                self.match(MySQLParser.COMMA_SYMBOL)
                self.state = 9083
                self.textString()
                self.state = 9088
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 9089
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TextStringLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.value = None # Token

        def SINGLE_QUOTED_TEXT(self):
            return self.getToken(MySQLParser.SINGLE_QUOTED_TEXT, 0)

        def DOUBLE_QUOTED_TEXT(self):
            return self.getToken(MySQLParser.DOUBLE_QUOTED_TEXT, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_textStringLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTextStringLiteral" ):
                listener.enterTextStringLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTextStringLiteral" ):
                listener.exitTextStringLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTextStringLiteral" ):
                return visitor.visitTextStringLiteral(self)
            else:
                return visitor.visitChildren(self)




    def textStringLiteral(self):

        localctx = MySQLParser.TextStringLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1440, self.RULE_textStringLiteral)
        try:
            self.state = 9094
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1149,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9091
                localctx.value = self.match(MySQLParser.SINGLE_QUOTED_TEXT)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9092
                if not self.isTextStringLiteral():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isTextStringLiteral()")
                self.state = 9093
                localctx.value = self.match(MySQLParser.DOUBLE_QUOTED_TEXT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TextStringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def HEX_NUMBER(self):
            return self.getToken(MySQLParser.HEX_NUMBER, 0)

        def BIN_NUMBER(self):
            return self.getToken(MySQLParser.BIN_NUMBER, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_textString

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTextString" ):
                listener.enterTextString(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTextString" ):
                listener.exitTextString(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTextString" ):
                return visitor.visitTextString(self)
            else:
                return visitor.visitChildren(self)




    def textString(self):

        localctx = MySQLParser.TextStringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1442, self.RULE_textString)
        try:
            self.state = 9099
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1150,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9096
                self.textStringLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9097
                self.match(MySQLParser.HEX_NUMBER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 9098
                self.match(MySQLParser.BIN_NUMBER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TextStringHashContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def HEX_NUMBER(self):
            return self.getToken(MySQLParser.HEX_NUMBER, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_textStringHash

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTextStringHash" ):
                listener.enterTextStringHash(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTextStringHash" ):
                listener.exitTextStringHash(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTextStringHash" ):
                return visitor.visitTextStringHash(self)
            else:
                return visitor.visitChildren(self)




    def textStringHash(self):

        localctx = MySQLParser.TextStringHashContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1444, self.RULE_textStringHash)
        try:
            self.state = 9104
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1151,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9101
                self.textStringLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9102
                if not self.isServerVersionGe80017():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80017()")
                self.state = 9103
                self.match(MySQLParser.HEX_NUMBER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TextLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textStringLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.TextStringLiteralContext)
            else:
                return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,i)


        def NCHAR_TEXT(self):
            return self.getToken(MySQLParser.NCHAR_TEXT, 0)

        def UNDERSCORE_CHARSET(self):
            return self.getToken(MySQLParser.UNDERSCORE_CHARSET, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_textLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTextLiteral" ):
                listener.enterTextLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTextLiteral" ):
                listener.exitTextLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTextLiteral" ):
                return visitor.visitTextLiteral(self)
            else:
                return visitor.visitChildren(self)




    def textLiteral(self):

        localctx = MySQLParser.TextLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1446, self.RULE_textLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9111
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1153,self._ctx)
            if la_ == 1:
                self.state = 9107
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1152,self._ctx)
                if la_ == 1:
                    self.state = 9106
                    self.match(MySQLParser.UNDERSCORE_CHARSET)


                self.state = 9109
                self.textStringLiteral()
                pass

            elif la_ == 2:
                self.state = 9110
                self.match(MySQLParser.NCHAR_TEXT)
                pass


            self.state = 9116
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,1154,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 9113
                    self.textStringLiteral() 
                self.state = 9118
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1154,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TextStringNoLinebreakContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_textStringNoLinebreak

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTextStringNoLinebreak" ):
                listener.enterTextStringNoLinebreak(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTextStringNoLinebreak" ):
                listener.exitTextStringNoLinebreak(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTextStringNoLinebreak" ):
                return visitor.visitTextStringNoLinebreak(self)
            else:
                return visitor.visitChildren(self)




    def textStringNoLinebreak(self):

        localctx = MySQLParser.TextStringNoLinebreakContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1448, self.RULE_textStringNoLinebreak)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9119
            self.textStringLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TextStringLiteralListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textStringLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.TextStringLiteralContext)
            else:
                return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,i)


        def COMMA_SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA_SYMBOL)
            else:
                return self.getToken(MySQLParser.COMMA_SYMBOL, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_textStringLiteralList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTextStringLiteralList" ):
                listener.enterTextStringLiteralList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTextStringLiteralList" ):
                listener.exitTextStringLiteralList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTextStringLiteralList" ):
                return visitor.visitTextStringLiteralList(self)
            else:
                return visitor.visitChildren(self)




    def textStringLiteralList(self):

        localctx = MySQLParser.TextStringLiteralListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1450, self.RULE_textStringLiteralList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9121
            self.textStringLiteral()
            self.state = 9126
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,1155,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 9122
                    self.match(MySQLParser.COMMA_SYMBOL)
                    self.state = 9123
                    self.textStringLiteral() 
                self.state = 9128
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1155,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def int64Literal(self):
            return self.getTypedRuleContext(MySQLParser.Int64LiteralContext,0)


        def DECIMAL_NUMBER(self):
            return self.getToken(MySQLParser.DECIMAL_NUMBER, 0)

        def FLOAT_NUMBER(self):
            return self.getToken(MySQLParser.FLOAT_NUMBER, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_numLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumLiteral" ):
                listener.enterNumLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumLiteral" ):
                listener.exitNumLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumLiteral" ):
                return visitor.visitNumLiteral(self)
            else:
                return visitor.visitChildren(self)




    def numLiteral(self):

        localctx = MySQLParser.NumLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1452, self.RULE_numLiteral)
        try:
            self.state = 9132
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 4, 5]:
                self.enterOuterAlt(localctx, 1)
                self.state = 9129
                self.int64Literal()
                pass
            elif token in [46]:
                self.enterOuterAlt(localctx, 2)
                self.state = 9130
                self.match(MySQLParser.DECIMAL_NUMBER)
                pass
            elif token in [47]:
                self.enterOuterAlt(localctx, 3)
                self.state = 9131
                self.match(MySQLParser.FLOAT_NUMBER)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE_SYMBOL(self):
            return self.getToken(MySQLParser.TRUE_SYMBOL, 0)

        def FALSE_SYMBOL(self):
            return self.getToken(MySQLParser.FALSE_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_boolLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolLiteral" ):
                listener.enterBoolLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolLiteral" ):
                listener.exitBoolLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolLiteral" ):
                return visitor.visitBoolLiteral(self)
            else:
                return visitor.visitChildren(self)




    def boolLiteral(self):

        localctx = MySQLParser.BoolLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1454, self.RULE_boolLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9134
            _la = self._input.LA(1)
            if not(_la==218 or _la==605):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NullLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NULL_SYMBOL(self):
            return self.getToken(MySQLParser.NULL_SYMBOL, 0)

        def NULL2_SYMBOL(self):
            return self.getToken(MySQLParser.NULL2_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_nullLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNullLiteral" ):
                listener.enterNullLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNullLiteral" ):
                listener.exitNullLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNullLiteral" ):
                return visitor.visitNullLiteral(self)
            else:
                return visitor.visitChildren(self)




    def nullLiteral(self):

        localctx = MySQLParser.NullLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1456, self.RULE_nullLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9136
            _la = self._input.LA(1)
            if not(_la==42 or _la==395):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Int64LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_NUMBER(self):
            return self.getToken(MySQLParser.INT_NUMBER, 0)

        def LONG_NUMBER(self):
            return self.getToken(MySQLParser.LONG_NUMBER, 0)

        def ULONGLONG_NUMBER(self):
            return self.getToken(MySQLParser.ULONGLONG_NUMBER, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_int64Literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInt64Literal" ):
                listener.enterInt64Literal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInt64Literal" ):
                listener.exitInt64Literal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInt64Literal" ):
                return visitor.visitInt64Literal(self)
            else:
                return visitor.visitChildren(self)




    def int64Literal(self):

        localctx = MySQLParser.Int64LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1458, self.RULE_int64Literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9138
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 56) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TemporalLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATE_SYMBOL(self):
            return self.getToken(MySQLParser.DATE_SYMBOL, 0)

        def SINGLE_QUOTED_TEXT(self):
            return self.getToken(MySQLParser.SINGLE_QUOTED_TEXT, 0)

        def TIME_SYMBOL(self):
            return self.getToken(MySQLParser.TIME_SYMBOL, 0)

        def TIMESTAMP_SYMBOL(self):
            return self.getToken(MySQLParser.TIMESTAMP_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_temporalLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemporalLiteral" ):
                listener.enterTemporalLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemporalLiteral" ):
                listener.exitTemporalLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTemporalLiteral" ):
                return visitor.visitTemporalLiteral(self)
            else:
                return visitor.visitChildren(self)




    def temporalLiteral(self):

        localctx = MySQLParser.TemporalLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1460, self.RULE_temporalLiteral)
        try:
            self.state = 9146
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [157]:
                self.enterOuterAlt(localctx, 1)
                self.state = 9140
                self.match(MySQLParser.DATE_SYMBOL)
                self.state = 9141
                self.match(MySQLParser.SINGLE_QUOTED_TEXT)
                pass
            elif token in [595]:
                self.enterOuterAlt(localctx, 2)
                self.state = 9142
                self.match(MySQLParser.TIME_SYMBOL)
                self.state = 9143
                self.match(MySQLParser.SINGLE_QUOTED_TEXT)
                pass
            elif token in [592]:
                self.enterOuterAlt(localctx, 3)
                self.state = 9144
                self.match(MySQLParser.TIMESTAMP_SYMBOL)
                self.state = 9145
                self.match(MySQLParser.SINGLE_QUOTED_TEXT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FloatOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fieldLength(self):
            return self.getTypedRuleContext(MySQLParser.FieldLengthContext,0)


        def precision(self):
            return self.getTypedRuleContext(MySQLParser.PrecisionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_floatOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFloatOptions" ):
                listener.enterFloatOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFloatOptions" ):
                listener.exitFloatOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFloatOptions" ):
                return visitor.visitFloatOptions(self)
            else:
                return visitor.visitChildren(self)




    def floatOptions(self):

        localctx = MySQLParser.FloatOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1462, self.RULE_floatOptions)
        try:
            self.state = 9150
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1158,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9148
                self.fieldLength()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9149
                self.precision()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StandardFloatOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def precision(self):
            return self.getTypedRuleContext(MySQLParser.PrecisionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_standardFloatOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStandardFloatOptions" ):
                listener.enterStandardFloatOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStandardFloatOptions" ):
                listener.exitStandardFloatOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStandardFloatOptions" ):
                return visitor.visitStandardFloatOptions(self)
            else:
                return visitor.visitChildren(self)




    def standardFloatOptions(self):

        localctx = MySQLParser.StandardFloatOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1464, self.RULE_standardFloatOptions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9152
            self.precision()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrecisionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def INT_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(MySQLParser.INT_NUMBER)
            else:
                return self.getToken(MySQLParser.INT_NUMBER, i)

        def COMMA_SYMBOL(self):
            return self.getToken(MySQLParser.COMMA_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_precision

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrecision" ):
                listener.enterPrecision(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrecision" ):
                listener.exitPrecision(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrecision" ):
                return visitor.visitPrecision(self)
            else:
                return visitor.visitChildren(self)




    def precision(self):

        localctx = MySQLParser.PrecisionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1466, self.RULE_precision)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9154
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 9155
            self.match(MySQLParser.INT_NUMBER)
            self.state = 9156
            self.match(MySQLParser.COMMA_SYMBOL)
            self.state = 9157
            self.match(MySQLParser.INT_NUMBER)
            self.state = 9158
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TextOrIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierContext,0)


        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_textOrIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTextOrIdentifier" ):
                listener.enterTextOrIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTextOrIdentifier" ):
                listener.exitTextOrIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTextOrIdentifier" ):
                return visitor.visitTextOrIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def textOrIdentifier(self):

        localctx = MySQLParser.TextOrIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1468, self.RULE_textOrIdentifier)
        try:
            self.state = 9162
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1159,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9160
                self.identifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9161
                self.textStringLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LValueIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pureIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.PureIdentifierContext,0)


        def lValueKeyword(self):
            return self.getTypedRuleContext(MySQLParser.LValueKeywordContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_lValueIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLValueIdentifier" ):
                listener.enterLValueIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLValueIdentifier" ):
                listener.exitLValueIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLValueIdentifier" ):
                return visitor.visitLValueIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def lValueIdentifier(self):

        localctx = MySQLParser.LValueIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1470, self.RULE_lValueIdentifier)
        try:
            self.state = 9166
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1160,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9164
                self.pureIdentifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9165
                self.lValueKeyword()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleIdentifierOrTextContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def roleIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.RoleIdentifierContext,0)


        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_roleIdentifierOrText

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoleIdentifierOrText" ):
                listener.enterRoleIdentifierOrText(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoleIdentifierOrText" ):
                listener.exitRoleIdentifierOrText(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRoleIdentifierOrText" ):
                return visitor.visitRoleIdentifierOrText(self)
            else:
                return visitor.visitChildren(self)




    def roleIdentifierOrText(self):

        localctx = MySQLParser.RoleIdentifierOrTextContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1472, self.RULE_roleIdentifierOrText)
        try:
            self.state = 9170
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1161,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9168
                self.roleIdentifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9169
                self.textStringLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SizeNumberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def real_ulonglong_number(self):
            return self.getTypedRuleContext(MySQLParser.Real_ulonglong_numberContext,0)


        def pureIdentifier(self):
            return self.getTypedRuleContext(MySQLParser.PureIdentifierContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_sizeNumber

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSizeNumber" ):
                listener.enterSizeNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSizeNumber" ):
                listener.exitSizeNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSizeNumber" ):
                return visitor.visitSizeNumber(self)
            else:
                return visitor.visitChildren(self)




    def sizeNumber(self):

        localctx = MySQLParser.SizeNumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1474, self.RULE_sizeNumber)
        try:
            self.state = 9174
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1162,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9172
                self.real_ulonglong_number()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9173
                self.pureIdentifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParenthesesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_PAR_SYMBOL, 0)

        def CLOSE_PAR_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_PAR_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_parentheses

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParentheses" ):
                listener.enterParentheses(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParentheses" ):
                listener.exitParentheses(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParentheses" ):
                return visitor.visitParentheses(self)
            else:
                return visitor.visitChildren(self)




    def parentheses(self):

        localctx = MySQLParser.ParenthesesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1476, self.RULE_parentheses)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9176
            self.match(MySQLParser.OPEN_PAR_SYMBOL)
            self.state = 9177
            self.match(MySQLParser.CLOSE_PAR_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EqualContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL_OPERATOR(self):
            return self.getToken(MySQLParser.EQUAL_OPERATOR, 0)

        def ASSIGN_OPERATOR(self):
            return self.getToken(MySQLParser.ASSIGN_OPERATOR, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_equal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEqual" ):
                listener.enterEqual(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEqual" ):
                listener.exitEqual(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEqual" ):
                return visitor.visitEqual(self)
            else:
                return visitor.visitChildren(self)




    def equal(self):

        localctx = MySQLParser.EqualContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1478, self.RULE_equal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9179
            _la = self._input.LA(1)
            if not(_la==6 or _la==7):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PERSIST_SYMBOL(self):
            return self.getToken(MySQLParser.PERSIST_SYMBOL, 0)

        def PERSIST_ONLY_SYMBOL(self):
            return self.getToken(MySQLParser.PERSIST_ONLY_SYMBOL, 0)

        def GLOBAL_SYMBOL(self):
            return self.getToken(MySQLParser.GLOBAL_SYMBOL, 0)

        def LOCAL_SYMBOL(self):
            return self.getToken(MySQLParser.LOCAL_SYMBOL, 0)

        def SESSION_SYMBOL(self):
            return self.getToken(MySQLParser.SESSION_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_optionType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptionType" ):
                listener.enterOptionType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptionType" ):
                listener.exitOptionType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOptionType" ):
                return visitor.visitOptionType(self)
            else:
                return visitor.visitChildren(self)




    def optionType(self):

        localctx = MySQLParser.OptionTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1480, self.RULE_optionType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9181
            _la = self._input.LA(1)
            if not(_la==246 or _la==312 or _la==516 or _la==666 or _la==681):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RvalueSystemVariableTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GLOBAL_SYMBOL(self):
            return self.getToken(MySQLParser.GLOBAL_SYMBOL, 0)

        def DOT_SYMBOL(self):
            return self.getToken(MySQLParser.DOT_SYMBOL, 0)

        def LOCAL_SYMBOL(self):
            return self.getToken(MySQLParser.LOCAL_SYMBOL, 0)

        def SESSION_SYMBOL(self):
            return self.getToken(MySQLParser.SESSION_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_rvalueSystemVariableType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRvalueSystemVariableType" ):
                listener.enterRvalueSystemVariableType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRvalueSystemVariableType" ):
                listener.exitRvalueSystemVariableType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRvalueSystemVariableType" ):
                return visitor.visitRvalueSystemVariableType(self)
            else:
                return visitor.visitChildren(self)




    def rvalueSystemVariableType(self):

        localctx = MySQLParser.RvalueSystemVariableTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1482, self.RULE_rvalueSystemVariableType)
        try:
            self.state = 9189
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [246]:
                self.enterOuterAlt(localctx, 1)
                self.state = 9183
                self.match(MySQLParser.GLOBAL_SYMBOL)
                self.state = 9184
                self.match(MySQLParser.DOT_SYMBOL)
                pass
            elif token in [312]:
                self.enterOuterAlt(localctx, 2)
                self.state = 9185
                self.match(MySQLParser.LOCAL_SYMBOL)
                self.state = 9186
                self.match(MySQLParser.DOT_SYMBOL)
                pass
            elif token in [516]:
                self.enterOuterAlt(localctx, 3)
                self.state = 9187
                self.match(MySQLParser.SESSION_SYMBOL)
                self.state = 9188
                self.match(MySQLParser.DOT_SYMBOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetVarIdentTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOT_SYMBOL(self):
            return self.getToken(MySQLParser.DOT_SYMBOL, 0)

        def PERSIST_SYMBOL(self):
            return self.getToken(MySQLParser.PERSIST_SYMBOL, 0)

        def PERSIST_ONLY_SYMBOL(self):
            return self.getToken(MySQLParser.PERSIST_ONLY_SYMBOL, 0)

        def GLOBAL_SYMBOL(self):
            return self.getToken(MySQLParser.GLOBAL_SYMBOL, 0)

        def LOCAL_SYMBOL(self):
            return self.getToken(MySQLParser.LOCAL_SYMBOL, 0)

        def SESSION_SYMBOL(self):
            return self.getToken(MySQLParser.SESSION_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_setVarIdentType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetVarIdentType" ):
                listener.enterSetVarIdentType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetVarIdentType" ):
                listener.exitSetVarIdentType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetVarIdentType" ):
                return visitor.visitSetVarIdentType(self)
            else:
                return visitor.visitChildren(self)




    def setVarIdentType(self):

        localctx = MySQLParser.SetVarIdentTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1484, self.RULE_setVarIdentType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9191
            _la = self._input.LA(1)
            if not(_la==246 or _la==312 or _la==516 or _la==666 or _la==681):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 9192
            self.match(MySQLParser.DOT_SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JsonAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textStringLiteral(self):
            return self.getTypedRuleContext(MySQLParser.TextStringLiteralContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_jsonAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJsonAttribute" ):
                listener.enterJsonAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJsonAttribute" ):
                listener.exitJsonAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJsonAttribute" ):
                return visitor.visitJsonAttribute(self)
            else:
                return visitor.visitChildren(self)




    def jsonAttribute(self):

        localctx = MySQLParser.JsonAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1486, self.RULE_jsonAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9194
            self.textStringLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierKeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def labelKeyword(self):
            return self.getTypedRuleContext(MySQLParser.LabelKeywordContext,0)


        def roleOrIdentifierKeyword(self):
            return self.getTypedRuleContext(MySQLParser.RoleOrIdentifierKeywordContext,0)


        def EXECUTE_SYMBOL(self):
            return self.getToken(MySQLParser.EXECUTE_SYMBOL, 0)

        def SHUTDOWN_SYMBOL(self):
            return self.getToken(MySQLParser.SHUTDOWN_SYMBOL, 0)

        def RESTART_SYMBOL(self):
            return self.getToken(MySQLParser.RESTART_SYMBOL, 0)

        def identifierKeywordsUnambiguous(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierKeywordsUnambiguousContext,0)


        def identifierKeywordsAmbiguous1RolesAndLabels(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierKeywordsAmbiguous1RolesAndLabelsContext,0)


        def identifierKeywordsAmbiguous2Labels(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierKeywordsAmbiguous2LabelsContext,0)


        def identifierKeywordsAmbiguous3Roles(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierKeywordsAmbiguous3RolesContext,0)


        def identifierKeywordsAmbiguous4SystemVariables(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierKeywordsAmbiguous4SystemVariablesContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_identifierKeyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierKeyword" ):
                listener.enterIdentifierKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierKeyword" ):
                listener.exitIdentifierKeyword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierKeyword" ):
                return visitor.visitIdentifierKeyword(self)
            else:
                return visitor.visitChildren(self)




    def identifierKeyword(self):

        localctx = MySQLParser.IdentifierKeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1488, self.RULE_identifierKeyword)
        try:
            self.state = 9212
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1166,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9196
                if not self.isServerVersionLt80017():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionLt80017()")
                self.state = 9203
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1164,self._ctx)
                if la_ == 1:
                    self.state = 9197
                    self.labelKeyword()
                    pass

                elif la_ == 2:
                    self.state = 9198
                    self.roleOrIdentifierKeyword()
                    pass

                elif la_ == 3:
                    self.state = 9199
                    self.match(MySQLParser.EXECUTE_SYMBOL)
                    pass

                elif la_ == 4:
                    self.state = 9200
                    self.match(MySQLParser.SHUTDOWN_SYMBOL)
                    pass

                elif la_ == 5:
                    self.state = 9201
                    if not self.isServerVersionGe80011():
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.isServerVersionGe80011()")
                    self.state = 9202
                    self.match(MySQLParser.RESTART_SYMBOL)
                    pass


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9210
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1165,self._ctx)
                if la_ == 1:
                    self.state = 9205
                    self.identifierKeywordsUnambiguous()
                    pass

                elif la_ == 2:
                    self.state = 9206
                    self.identifierKeywordsAmbiguous1RolesAndLabels()
                    pass

                elif la_ == 3:
                    self.state = 9207
                    self.identifierKeywordsAmbiguous2Labels()
                    pass

                elif la_ == 4:
                    self.state = 9208
                    self.identifierKeywordsAmbiguous3Roles()
                    pass

                elif la_ == 5:
                    self.state = 9209
                    self.identifierKeywordsAmbiguous4SystemVariables()
                    pass


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierKeywordsAmbiguous1RolesAndLabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXECUTE_SYMBOL(self):
            return self.getToken(MySQLParser.EXECUTE_SYMBOL, 0)

        def RESTART_SYMBOL(self):
            return self.getToken(MySQLParser.RESTART_SYMBOL, 0)

        def SHUTDOWN_SYMBOL(self):
            return self.getToken(MySQLParser.SHUTDOWN_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_identifierKeywordsAmbiguous1RolesAndLabels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierKeywordsAmbiguous1RolesAndLabels" ):
                listener.enterIdentifierKeywordsAmbiguous1RolesAndLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierKeywordsAmbiguous1RolesAndLabels" ):
                listener.exitIdentifierKeywordsAmbiguous1RolesAndLabels(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierKeywordsAmbiguous1RolesAndLabels" ):
                return visitor.visitIdentifierKeywordsAmbiguous1RolesAndLabels(self)
            else:
                return visitor.visitChildren(self)




    def identifierKeywordsAmbiguous1RolesAndLabels(self):

        localctx = MySQLParser.IdentifierKeywordsAmbiguous1RolesAndLabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1490, self.RULE_identifierKeywordsAmbiguous1RolesAndLabels)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9214
            _la = self._input.LA(1)
            if not(_la==208 or _la==522 or _la==722):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierKeywordsAmbiguous2LabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASCII_SYMBOL(self):
            return self.getToken(MySQLParser.ASCII_SYMBOL, 0)

        def BEGIN_SYMBOL(self):
            return self.getToken(MySQLParser.BEGIN_SYMBOL, 0)

        def BYTE_SYMBOL(self):
            return self.getToken(MySQLParser.BYTE_SYMBOL, 0)

        def CACHE_SYMBOL(self):
            return self.getToken(MySQLParser.CACHE_SYMBOL, 0)

        def CHARSET_SYMBOL(self):
            return self.getToken(MySQLParser.CHARSET_SYMBOL, 0)

        def CHECKSUM_SYMBOL(self):
            return self.getToken(MySQLParser.CHECKSUM_SYMBOL, 0)

        def CLONE_SYMBOL(self):
            return self.getToken(MySQLParser.CLONE_SYMBOL, 0)

        def COMMENT_SYMBOL(self):
            return self.getToken(MySQLParser.COMMENT_SYMBOL, 0)

        def COMMIT_SYMBOL(self):
            return self.getToken(MySQLParser.COMMIT_SYMBOL, 0)

        def CONTAINS_SYMBOL(self):
            return self.getToken(MySQLParser.CONTAINS_SYMBOL, 0)

        def DEALLOCATE_SYMBOL(self):
            return self.getToken(MySQLParser.DEALLOCATE_SYMBOL, 0)

        def DO_SYMBOL(self):
            return self.getToken(MySQLParser.DO_SYMBOL, 0)

        def END_SYMBOL(self):
            return self.getToken(MySQLParser.END_SYMBOL, 0)

        def FLUSH_SYMBOL(self):
            return self.getToken(MySQLParser.FLUSH_SYMBOL, 0)

        def FOLLOWS_SYMBOL(self):
            return self.getToken(MySQLParser.FOLLOWS_SYMBOL, 0)

        def HANDLER_SYMBOL(self):
            return self.getToken(MySQLParser.HANDLER_SYMBOL, 0)

        def HELP_SYMBOL(self):
            return self.getToken(MySQLParser.HELP_SYMBOL, 0)

        def IMPORT_SYMBOL(self):
            return self.getToken(MySQLParser.IMPORT_SYMBOL, 0)

        def INSTALL_SYMBOL(self):
            return self.getToken(MySQLParser.INSTALL_SYMBOL, 0)

        def LANGUAGE_SYMBOL(self):
            return self.getToken(MySQLParser.LANGUAGE_SYMBOL, 0)

        def NO_SYMBOL(self):
            return self.getToken(MySQLParser.NO_SYMBOL, 0)

        def PRECEDES_SYMBOL(self):
            return self.getToken(MySQLParser.PRECEDES_SYMBOL, 0)

        def PREPARE_SYMBOL(self):
            return self.getToken(MySQLParser.PREPARE_SYMBOL, 0)

        def REPAIR_SYMBOL(self):
            return self.getToken(MySQLParser.REPAIR_SYMBOL, 0)

        def RESET_SYMBOL(self):
            return self.getToken(MySQLParser.RESET_SYMBOL, 0)

        def ROLLBACK_SYMBOL(self):
            return self.getToken(MySQLParser.ROLLBACK_SYMBOL, 0)

        def SAVEPOINT_SYMBOL(self):
            return self.getToken(MySQLParser.SAVEPOINT_SYMBOL, 0)

        def SIGNED_SYMBOL(self):
            return self.getToken(MySQLParser.SIGNED_SYMBOL, 0)

        def SLAVE_SYMBOL(self):
            return self.getToken(MySQLParser.SLAVE_SYMBOL, 0)

        def START_SYMBOL(self):
            return self.getToken(MySQLParser.START_SYMBOL, 0)

        def STOP_SYMBOL(self):
            return self.getToken(MySQLParser.STOP_SYMBOL, 0)

        def TRUNCATE_SYMBOL(self):
            return self.getToken(MySQLParser.TRUNCATE_SYMBOL, 0)

        def UNICODE_SYMBOL(self):
            return self.getToken(MySQLParser.UNICODE_SYMBOL, 0)

        def UNINSTALL_SYMBOL(self):
            return self.getToken(MySQLParser.UNINSTALL_SYMBOL, 0)

        def XA_SYMBOL(self):
            return self.getToken(MySQLParser.XA_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_identifierKeywordsAmbiguous2Labels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierKeywordsAmbiguous2Labels" ):
                listener.enterIdentifierKeywordsAmbiguous2Labels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierKeywordsAmbiguous2Labels" ):
                listener.exitIdentifierKeywordsAmbiguous2Labels(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierKeywordsAmbiguous2Labels" ):
                return visitor.visitIdentifierKeywordsAmbiguous2Labels(self)
            else:
                return visitor.visitChildren(self)




    def identifierKeywordsAmbiguous2Labels(self):

        localctx = MySQLParser.IdentifierKeywordsAmbiguous2LabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1492, self.RULE_identifierKeywordsAmbiguous2Labels)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9216
            _la = self._input.LA(1)
            if not(((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 45036683569136129) != 0) or ((((_la - 133)) & ~0x3f) == 0 and ((1 << (_la - 133)) & 4612811919407972353) != 0) or ((((_la - 228)) & ~0x3f) == 0 and ((1 << (_la - 228)) & 563224906825731) != 0) or _la==297 or ((((_la - 392)) & ~0x3f) == 0 and ((1 << (_la - 392)) & 10995116277761) != 0) or ((((_la - 472)) & ~0x3f) == 0 and ((1 << (_la - 472)) & 22518006743572481) != 0) or ((((_la - 553)) & ~0x3f) == 0 and ((1 << (_la - 553)) & -4602678819172646399) != 0) or _la==659 or _la==685):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelKeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def roleOrLabelKeyword(self):
            return self.getTypedRuleContext(MySQLParser.RoleOrLabelKeywordContext,0)


        def EVENT_SYMBOL(self):
            return self.getToken(MySQLParser.EVENT_SYMBOL, 0)

        def FILE_SYMBOL(self):
            return self.getToken(MySQLParser.FILE_SYMBOL, 0)

        def NONE_SYMBOL(self):
            return self.getToken(MySQLParser.NONE_SYMBOL, 0)

        def PROCESS_SYMBOL(self):
            return self.getToken(MySQLParser.PROCESS_SYMBOL, 0)

        def PROXY_SYMBOL(self):
            return self.getToken(MySQLParser.PROXY_SYMBOL, 0)

        def RELOAD_SYMBOL(self):
            return self.getToken(MySQLParser.RELOAD_SYMBOL, 0)

        def REPLICATION_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATION_SYMBOL, 0)

        def RESOURCE_SYMBOL(self):
            return self.getToken(MySQLParser.RESOURCE_SYMBOL, 0)

        def SUPER_SYMBOL(self):
            return self.getToken(MySQLParser.SUPER_SYMBOL, 0)

        def identifierKeywordsUnambiguous(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierKeywordsUnambiguousContext,0)


        def identifierKeywordsAmbiguous3Roles(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierKeywordsAmbiguous3RolesContext,0)


        def identifierKeywordsAmbiguous4SystemVariables(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierKeywordsAmbiguous4SystemVariablesContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_labelKeyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelKeyword" ):
                listener.enterLabelKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelKeyword" ):
                listener.exitLabelKeyword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabelKeyword" ):
                return visitor.visitLabelKeyword(self)
            else:
                return visitor.visitChildren(self)




    def labelKeyword(self):

        localctx = MySQLParser.LabelKeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1494, self.RULE_labelKeyword)
        try:
            self.state = 9236
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1169,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9218
                if not self.isServerVersionLt80017():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionLt80017()")
                self.state = 9229
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1167,self._ctx)
                if la_ == 1:
                    self.state = 9219
                    self.roleOrLabelKeyword()
                    pass

                elif la_ == 2:
                    self.state = 9220
                    self.match(MySQLParser.EVENT_SYMBOL)
                    pass

                elif la_ == 3:
                    self.state = 9221
                    self.match(MySQLParser.FILE_SYMBOL)
                    pass

                elif la_ == 4:
                    self.state = 9222
                    self.match(MySQLParser.NONE_SYMBOL)
                    pass

                elif la_ == 5:
                    self.state = 9223
                    self.match(MySQLParser.PROCESS_SYMBOL)
                    pass

                elif la_ == 6:
                    self.state = 9224
                    self.match(MySQLParser.PROXY_SYMBOL)
                    pass

                elif la_ == 7:
                    self.state = 9225
                    self.match(MySQLParser.RELOAD_SYMBOL)
                    pass

                elif la_ == 8:
                    self.state = 9226
                    self.match(MySQLParser.REPLICATION_SYMBOL)
                    pass

                elif la_ == 9:
                    self.state = 9227
                    self.match(MySQLParser.RESOURCE_SYMBOL)
                    pass

                elif la_ == 10:
                    self.state = 9228
                    self.match(MySQLParser.SUPER_SYMBOL)
                    pass


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9234
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1168,self._ctx)
                if la_ == 1:
                    self.state = 9231
                    self.identifierKeywordsUnambiguous()
                    pass

                elif la_ == 2:
                    self.state = 9232
                    self.identifierKeywordsAmbiguous3Roles()
                    pass

                elif la_ == 3:
                    self.state = 9233
                    self.identifierKeywordsAmbiguous4SystemVariables()
                    pass


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierKeywordsAmbiguous3RolesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EVENT_SYMBOL(self):
            return self.getToken(MySQLParser.EVENT_SYMBOL, 0)

        def FILE_SYMBOL(self):
            return self.getToken(MySQLParser.FILE_SYMBOL, 0)

        def NONE_SYMBOL(self):
            return self.getToken(MySQLParser.NONE_SYMBOL, 0)

        def PROCESS_SYMBOL(self):
            return self.getToken(MySQLParser.PROCESS_SYMBOL, 0)

        def PROXY_SYMBOL(self):
            return self.getToken(MySQLParser.PROXY_SYMBOL, 0)

        def RELOAD_SYMBOL(self):
            return self.getToken(MySQLParser.RELOAD_SYMBOL, 0)

        def REPLICATION_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATION_SYMBOL, 0)

        def RESOURCE_SYMBOL(self):
            return self.getToken(MySQLParser.RESOURCE_SYMBOL, 0)

        def SUPER_SYMBOL(self):
            return self.getToken(MySQLParser.SUPER_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_identifierKeywordsAmbiguous3Roles

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierKeywordsAmbiguous3Roles" ):
                listener.enterIdentifierKeywordsAmbiguous3Roles(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierKeywordsAmbiguous3Roles" ):
                listener.exitIdentifierKeywordsAmbiguous3Roles(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierKeywordsAmbiguous3Roles" ):
                return visitor.visitIdentifierKeywordsAmbiguous3Roles(self)
            else:
                return visitor.visitChildren(self)




    def identifierKeywordsAmbiguous3Roles(self):

        localctx = MySQLParser.IdentifierKeywordsAmbiguous3RolesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1496, self.RULE_identifierKeywordsAmbiguous3Roles)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9238
            _la = self._input.LA(1)
            if not(_la==205 or _la==222 or ((((_la - 389)) & ~0x3f) == 0 and ((1 << (_la - 389)) & 76561193665298433) != 0) or _la==468 or _la==476 or _la==575 or _la==717):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierKeywordsUnambiguousContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ACTION_SYMBOL(self):
            return self.getToken(MySQLParser.ACTION_SYMBOL, 0)

        def ACCOUNT_SYMBOL(self):
            return self.getToken(MySQLParser.ACCOUNT_SYMBOL, 0)

        def ACTIVE_SYMBOL(self):
            return self.getToken(MySQLParser.ACTIVE_SYMBOL, 0)

        def ADDDATE_SYMBOL(self):
            return self.getToken(MySQLParser.ADDDATE_SYMBOL, 0)

        def ADMIN_SYMBOL(self):
            return self.getToken(MySQLParser.ADMIN_SYMBOL, 0)

        def AFTER_SYMBOL(self):
            return self.getToken(MySQLParser.AFTER_SYMBOL, 0)

        def AGAINST_SYMBOL(self):
            return self.getToken(MySQLParser.AGAINST_SYMBOL, 0)

        def AGGREGATE_SYMBOL(self):
            return self.getToken(MySQLParser.AGGREGATE_SYMBOL, 0)

        def ALGORITHM_SYMBOL(self):
            return self.getToken(MySQLParser.ALGORITHM_SYMBOL, 0)

        def ALWAYS_SYMBOL(self):
            return self.getToken(MySQLParser.ALWAYS_SYMBOL, 0)

        def ANY_SYMBOL(self):
            return self.getToken(MySQLParser.ANY_SYMBOL, 0)

        def AT_SYMBOL(self):
            return self.getToken(MySQLParser.AT_SYMBOL, 0)

        def ATTRIBUTE_SYMBOL(self):
            return self.getToken(MySQLParser.ATTRIBUTE_SYMBOL, 0)

        def AUTHENTICATION_SYMBOL(self):
            return self.getToken(MySQLParser.AUTHENTICATION_SYMBOL, 0)

        def AUTOEXTEND_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.AUTOEXTEND_SIZE_SYMBOL, 0)

        def AUTO_INCREMENT_SYMBOL(self):
            return self.getToken(MySQLParser.AUTO_INCREMENT_SYMBOL, 0)

        def AVG_ROW_LENGTH_SYMBOL(self):
            return self.getToken(MySQLParser.AVG_ROW_LENGTH_SYMBOL, 0)

        def AVG_SYMBOL(self):
            return self.getToken(MySQLParser.AVG_SYMBOL, 0)

        def BACKUP_SYMBOL(self):
            return self.getToken(MySQLParser.BACKUP_SYMBOL, 0)

        def BINLOG_SYMBOL(self):
            return self.getToken(MySQLParser.BINLOG_SYMBOL, 0)

        def BIT_SYMBOL(self):
            return self.getToken(MySQLParser.BIT_SYMBOL, 0)

        def BLOCK_SYMBOL(self):
            return self.getToken(MySQLParser.BLOCK_SYMBOL, 0)

        def BOOLEAN_SYMBOL(self):
            return self.getToken(MySQLParser.BOOLEAN_SYMBOL, 0)

        def BOOL_SYMBOL(self):
            return self.getToken(MySQLParser.BOOL_SYMBOL, 0)

        def BTREE_SYMBOL(self):
            return self.getToken(MySQLParser.BTREE_SYMBOL, 0)

        def BUCKETS_SYMBOL(self):
            return self.getToken(MySQLParser.BUCKETS_SYMBOL, 0)

        def CASCADED_SYMBOL(self):
            return self.getToken(MySQLParser.CASCADED_SYMBOL, 0)

        def CATALOG_NAME_SYMBOL(self):
            return self.getToken(MySQLParser.CATALOG_NAME_SYMBOL, 0)

        def CHAIN_SYMBOL(self):
            return self.getToken(MySQLParser.CHAIN_SYMBOL, 0)

        def CHALLENGE_RESPONSE_SYMBOL(self):
            return self.getToken(MySQLParser.CHALLENGE_RESPONSE_SYMBOL, 0)

        def CHANGED_SYMBOL(self):
            return self.getToken(MySQLParser.CHANGED_SYMBOL, 0)

        def CHANNEL_SYMBOL(self):
            return self.getToken(MySQLParser.CHANNEL_SYMBOL, 0)

        def CIPHER_SYMBOL(self):
            return self.getToken(MySQLParser.CIPHER_SYMBOL, 0)

        def CLASS_ORIGIN_SYMBOL(self):
            return self.getToken(MySQLParser.CLASS_ORIGIN_SYMBOL, 0)

        def CLIENT_SYMBOL(self):
            return self.getToken(MySQLParser.CLIENT_SYMBOL, 0)

        def CLOSE_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_SYMBOL, 0)

        def COALESCE_SYMBOL(self):
            return self.getToken(MySQLParser.COALESCE_SYMBOL, 0)

        def CODE_SYMBOL(self):
            return self.getToken(MySQLParser.CODE_SYMBOL, 0)

        def COLLATION_SYMBOL(self):
            return self.getToken(MySQLParser.COLLATION_SYMBOL, 0)

        def COLUMNS_SYMBOL(self):
            return self.getToken(MySQLParser.COLUMNS_SYMBOL, 0)

        def COLUMN_FORMAT_SYMBOL(self):
            return self.getToken(MySQLParser.COLUMN_FORMAT_SYMBOL, 0)

        def COLUMN_NAME_SYMBOL(self):
            return self.getToken(MySQLParser.COLUMN_NAME_SYMBOL, 0)

        def COMMITTED_SYMBOL(self):
            return self.getToken(MySQLParser.COMMITTED_SYMBOL, 0)

        def COMPACT_SYMBOL(self):
            return self.getToken(MySQLParser.COMPACT_SYMBOL, 0)

        def COMPLETION_SYMBOL(self):
            return self.getToken(MySQLParser.COMPLETION_SYMBOL, 0)

        def COMPONENT_SYMBOL(self):
            return self.getToken(MySQLParser.COMPONENT_SYMBOL, 0)

        def COMPRESSED_SYMBOL(self):
            return self.getToken(MySQLParser.COMPRESSED_SYMBOL, 0)

        def COMPRESSION_SYMBOL(self):
            return self.getToken(MySQLParser.COMPRESSION_SYMBOL, 0)

        def CONCURRENT_SYMBOL(self):
            return self.getToken(MySQLParser.CONCURRENT_SYMBOL, 0)

        def CONNECTION_SYMBOL(self):
            return self.getToken(MySQLParser.CONNECTION_SYMBOL, 0)

        def CONSISTENT_SYMBOL(self):
            return self.getToken(MySQLParser.CONSISTENT_SYMBOL, 0)

        def CONSTRAINT_CATALOG_SYMBOL(self):
            return self.getToken(MySQLParser.CONSTRAINT_CATALOG_SYMBOL, 0)

        def CONSTRAINT_NAME_SYMBOL(self):
            return self.getToken(MySQLParser.CONSTRAINT_NAME_SYMBOL, 0)

        def CONSTRAINT_SCHEMA_SYMBOL(self):
            return self.getToken(MySQLParser.CONSTRAINT_SCHEMA_SYMBOL, 0)

        def CONTEXT_SYMBOL(self):
            return self.getToken(MySQLParser.CONTEXT_SYMBOL, 0)

        def CPU_SYMBOL(self):
            return self.getToken(MySQLParser.CPU_SYMBOL, 0)

        def CURRENT_SYMBOL(self):
            return self.getToken(MySQLParser.CURRENT_SYMBOL, 0)

        def CURSOR_NAME_SYMBOL(self):
            return self.getToken(MySQLParser.CURSOR_NAME_SYMBOL, 0)

        def DATAFILE_SYMBOL(self):
            return self.getToken(MySQLParser.DATAFILE_SYMBOL, 0)

        def DATA_SYMBOL(self):
            return self.getToken(MySQLParser.DATA_SYMBOL, 0)

        def DATETIME_SYMBOL(self):
            return self.getToken(MySQLParser.DATETIME_SYMBOL, 0)

        def DATE_SYMBOL(self):
            return self.getToken(MySQLParser.DATE_SYMBOL, 0)

        def DAY_SYMBOL(self):
            return self.getToken(MySQLParser.DAY_SYMBOL, 0)

        def DEFAULT_AUTH_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_AUTH_SYMBOL, 0)

        def DEFINER_SYMBOL(self):
            return self.getToken(MySQLParser.DEFINER_SYMBOL, 0)

        def DEFINITION_SYMBOL(self):
            return self.getToken(MySQLParser.DEFINITION_SYMBOL, 0)

        def DELAY_KEY_WRITE_SYMBOL(self):
            return self.getToken(MySQLParser.DELAY_KEY_WRITE_SYMBOL, 0)

        def DESCRIPTION_SYMBOL(self):
            return self.getToken(MySQLParser.DESCRIPTION_SYMBOL, 0)

        def DIAGNOSTICS_SYMBOL(self):
            return self.getToken(MySQLParser.DIAGNOSTICS_SYMBOL, 0)

        def DIRECTORY_SYMBOL(self):
            return self.getToken(MySQLParser.DIRECTORY_SYMBOL, 0)

        def DISABLE_SYMBOL(self):
            return self.getToken(MySQLParser.DISABLE_SYMBOL, 0)

        def DISCARD_SYMBOL(self):
            return self.getToken(MySQLParser.DISCARD_SYMBOL, 0)

        def DISK_SYMBOL(self):
            return self.getToken(MySQLParser.DISK_SYMBOL, 0)

        def DUMPFILE_SYMBOL(self):
            return self.getToken(MySQLParser.DUMPFILE_SYMBOL, 0)

        def DUPLICATE_SYMBOL(self):
            return self.getToken(MySQLParser.DUPLICATE_SYMBOL, 0)

        def DYNAMIC_SYMBOL(self):
            return self.getToken(MySQLParser.DYNAMIC_SYMBOL, 0)

        def ENABLE_SYMBOL(self):
            return self.getToken(MySQLParser.ENABLE_SYMBOL, 0)

        def ENCRYPTION_SYMBOL(self):
            return self.getToken(MySQLParser.ENCRYPTION_SYMBOL, 0)

        def ENDS_SYMBOL(self):
            return self.getToken(MySQLParser.ENDS_SYMBOL, 0)

        def ENFORCED_SYMBOL(self):
            return self.getToken(MySQLParser.ENFORCED_SYMBOL, 0)

        def ENGINES_SYMBOL(self):
            return self.getToken(MySQLParser.ENGINES_SYMBOL, 0)

        def ENGINE_SYMBOL(self):
            return self.getToken(MySQLParser.ENGINE_SYMBOL, 0)

        def ENUM_SYMBOL(self):
            return self.getToken(MySQLParser.ENUM_SYMBOL, 0)

        def ERRORS_SYMBOL(self):
            return self.getToken(MySQLParser.ERRORS_SYMBOL, 0)

        def ERROR_SYMBOL(self):
            return self.getToken(MySQLParser.ERROR_SYMBOL, 0)

        def ESCAPE_SYMBOL(self):
            return self.getToken(MySQLParser.ESCAPE_SYMBOL, 0)

        def EVENTS_SYMBOL(self):
            return self.getToken(MySQLParser.EVENTS_SYMBOL, 0)

        def EVERY_SYMBOL(self):
            return self.getToken(MySQLParser.EVERY_SYMBOL, 0)

        def EXCHANGE_SYMBOL(self):
            return self.getToken(MySQLParser.EXCHANGE_SYMBOL, 0)

        def EXCLUDE_SYMBOL(self):
            return self.getToken(MySQLParser.EXCLUDE_SYMBOL, 0)

        def EXPANSION_SYMBOL(self):
            return self.getToken(MySQLParser.EXPANSION_SYMBOL, 0)

        def EXPIRE_SYMBOL(self):
            return self.getToken(MySQLParser.EXPIRE_SYMBOL, 0)

        def EXPORT_SYMBOL(self):
            return self.getToken(MySQLParser.EXPORT_SYMBOL, 0)

        def EXTENDED_SYMBOL(self):
            return self.getToken(MySQLParser.EXTENDED_SYMBOL, 0)

        def EXTENT_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.EXTENT_SIZE_SYMBOL, 0)

        def FACTOR_SYMBOL(self):
            return self.getToken(MySQLParser.FACTOR_SYMBOL, 0)

        def FAST_SYMBOL(self):
            return self.getToken(MySQLParser.FAST_SYMBOL, 0)

        def FAULTS_SYMBOL(self):
            return self.getToken(MySQLParser.FAULTS_SYMBOL, 0)

        def FILE_BLOCK_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.FILE_BLOCK_SIZE_SYMBOL, 0)

        def FILTER_SYMBOL(self):
            return self.getToken(MySQLParser.FILTER_SYMBOL, 0)

        def FINISH_SYMBOL(self):
            return self.getToken(MySQLParser.FINISH_SYMBOL, 0)

        def FIRST_SYMBOL(self):
            return self.getToken(MySQLParser.FIRST_SYMBOL, 0)

        def FIXED_SYMBOL(self):
            return self.getToken(MySQLParser.FIXED_SYMBOL, 0)

        def FOLLOWING_SYMBOL(self):
            return self.getToken(MySQLParser.FOLLOWING_SYMBOL, 0)

        def FORMAT_SYMBOL(self):
            return self.getToken(MySQLParser.FORMAT_SYMBOL, 0)

        def FOUND_SYMBOL(self):
            return self.getToken(MySQLParser.FOUND_SYMBOL, 0)

        def FULL_SYMBOL(self):
            return self.getToken(MySQLParser.FULL_SYMBOL, 0)

        def GENERAL_SYMBOL(self):
            return self.getToken(MySQLParser.GENERAL_SYMBOL, 0)

        def GEOMETRYCOLLECTION_SYMBOL(self):
            return self.getToken(MySQLParser.GEOMETRYCOLLECTION_SYMBOL, 0)

        def GEOMETRY_SYMBOL(self):
            return self.getToken(MySQLParser.GEOMETRY_SYMBOL, 0)

        def GET_FORMAT_SYMBOL(self):
            return self.getToken(MySQLParser.GET_FORMAT_SYMBOL, 0)

        def GET_MASTER_PUBLIC_KEY_SYMBOL(self):
            return self.getToken(MySQLParser.GET_MASTER_PUBLIC_KEY_SYMBOL, 0)

        def GET_SOURCE_PUBLIC_KEY_SYMBOL(self):
            return self.getToken(MySQLParser.GET_SOURCE_PUBLIC_KEY_SYMBOL, 0)

        def GRANTS_SYMBOL(self):
            return self.getToken(MySQLParser.GRANTS_SYMBOL, 0)

        def GROUP_REPLICATION_SYMBOL(self):
            return self.getToken(MySQLParser.GROUP_REPLICATION_SYMBOL, 0)

        def GTID_ONLY_SYMBOL(self):
            return self.getToken(MySQLParser.GTID_ONLY_SYMBOL, 0)

        def HASH_SYMBOL(self):
            return self.getToken(MySQLParser.HASH_SYMBOL, 0)

        def HISTOGRAM_SYMBOL(self):
            return self.getToken(MySQLParser.HISTOGRAM_SYMBOL, 0)

        def HISTORY_SYMBOL(self):
            return self.getToken(MySQLParser.HISTORY_SYMBOL, 0)

        def HOSTS_SYMBOL(self):
            return self.getToken(MySQLParser.HOSTS_SYMBOL, 0)

        def HOST_SYMBOL(self):
            return self.getToken(MySQLParser.HOST_SYMBOL, 0)

        def HOUR_SYMBOL(self):
            return self.getToken(MySQLParser.HOUR_SYMBOL, 0)

        def IDENTIFIED_SYMBOL(self):
            return self.getToken(MySQLParser.IDENTIFIED_SYMBOL, 0)

        def IGNORE_SERVER_IDS_SYMBOL(self):
            return self.getToken(MySQLParser.IGNORE_SERVER_IDS_SYMBOL, 0)

        def INACTIVE_SYMBOL(self):
            return self.getToken(MySQLParser.INACTIVE_SYMBOL, 0)

        def INDEXES_SYMBOL(self):
            return self.getToken(MySQLParser.INDEXES_SYMBOL, 0)

        def INITIAL_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.INITIAL_SIZE_SYMBOL, 0)

        def INITIAL_SYMBOL(self):
            return self.getToken(MySQLParser.INITIAL_SYMBOL, 0)

        def INITIATE_SYMBOL(self):
            return self.getToken(MySQLParser.INITIATE_SYMBOL, 0)

        def INSERT_METHOD_SYMBOL(self):
            return self.getToken(MySQLParser.INSERT_METHOD_SYMBOL, 0)

        def INSTANCE_SYMBOL(self):
            return self.getToken(MySQLParser.INSTANCE_SYMBOL, 0)

        def INVISIBLE_SYMBOL(self):
            return self.getToken(MySQLParser.INVISIBLE_SYMBOL, 0)

        def INVOKER_SYMBOL(self):
            return self.getToken(MySQLParser.INVOKER_SYMBOL, 0)

        def IO_SYMBOL(self):
            return self.getToken(MySQLParser.IO_SYMBOL, 0)

        def IPC_SYMBOL(self):
            return self.getToken(MySQLParser.IPC_SYMBOL, 0)

        def ISOLATION_SYMBOL(self):
            return self.getToken(MySQLParser.ISOLATION_SYMBOL, 0)

        def ISSUER_SYMBOL(self):
            return self.getToken(MySQLParser.ISSUER_SYMBOL, 0)

        def JSON_SYMBOL(self):
            return self.getToken(MySQLParser.JSON_SYMBOL, 0)

        def JSON_VALUE_SYMBOL(self):
            return self.getToken(MySQLParser.JSON_VALUE_SYMBOL, 0)

        def KEY_BLOCK_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.KEY_BLOCK_SIZE_SYMBOL, 0)

        def KEYRING_SYMBOL(self):
            return self.getToken(MySQLParser.KEYRING_SYMBOL, 0)

        def LAST_SYMBOL(self):
            return self.getToken(MySQLParser.LAST_SYMBOL, 0)

        def LEAVES_SYMBOL(self):
            return self.getToken(MySQLParser.LEAVES_SYMBOL, 0)

        def LESS_SYMBOL(self):
            return self.getToken(MySQLParser.LESS_SYMBOL, 0)

        def LEVEL_SYMBOL(self):
            return self.getToken(MySQLParser.LEVEL_SYMBOL, 0)

        def LINESTRING_SYMBOL(self):
            return self.getToken(MySQLParser.LINESTRING_SYMBOL, 0)

        def LIST_SYMBOL(self):
            return self.getToken(MySQLParser.LIST_SYMBOL, 0)

        def LOCKED_SYMBOL(self):
            return self.getToken(MySQLParser.LOCKED_SYMBOL, 0)

        def LOCKS_SYMBOL(self):
            return self.getToken(MySQLParser.LOCKS_SYMBOL, 0)

        def LOGFILE_SYMBOL(self):
            return self.getToken(MySQLParser.LOGFILE_SYMBOL, 0)

        def LOGS_SYMBOL(self):
            return self.getToken(MySQLParser.LOGS_SYMBOL, 0)

        def MASTER_AUTO_POSITION_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_AUTO_POSITION_SYMBOL, 0)

        def MASTER_COMPRESSION_ALGORITHM_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_COMPRESSION_ALGORITHM_SYMBOL, 0)

        def MASTER_CONNECT_RETRY_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_CONNECT_RETRY_SYMBOL, 0)

        def MASTER_DELAY_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_DELAY_SYMBOL, 0)

        def MASTER_HEARTBEAT_PERIOD_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_HEARTBEAT_PERIOD_SYMBOL, 0)

        def MASTER_HOST_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_HOST_SYMBOL, 0)

        def NETWORK_NAMESPACE_SYMBOL(self):
            return self.getToken(MySQLParser.NETWORK_NAMESPACE_SYMBOL, 0)

        def MASTER_LOG_FILE_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_LOG_FILE_SYMBOL, 0)

        def MASTER_LOG_POS_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_LOG_POS_SYMBOL, 0)

        def MASTER_PASSWORD_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_PASSWORD_SYMBOL, 0)

        def MASTER_PORT_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_PORT_SYMBOL, 0)

        def MASTER_PUBLIC_KEY_PATH_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_PUBLIC_KEY_PATH_SYMBOL, 0)

        def MASTER_RETRY_COUNT_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_RETRY_COUNT_SYMBOL, 0)

        def MASTER_SSL_CAPATH_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_CAPATH_SYMBOL, 0)

        def MASTER_SSL_CA_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_CA_SYMBOL, 0)

        def MASTER_SSL_CERT_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_CERT_SYMBOL, 0)

        def MASTER_SSL_CIPHER_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_CIPHER_SYMBOL, 0)

        def MASTER_SSL_CRLPATH_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_CRLPATH_SYMBOL, 0)

        def MASTER_SSL_CRL_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_CRL_SYMBOL, 0)

        def MASTER_SSL_KEY_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_KEY_SYMBOL, 0)

        def MASTER_SSL_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_SYMBOL, 0)

        def MASTER_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SYMBOL, 0)

        def MASTER_TLS_CIPHERSUITES_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_TLS_CIPHERSUITES_SYMBOL, 0)

        def MASTER_TLS_VERSION_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_TLS_VERSION_SYMBOL, 0)

        def MASTER_USER_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_USER_SYMBOL, 0)

        def MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, 0)

        def MAX_CONNECTIONS_PER_HOUR_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_CONNECTIONS_PER_HOUR_SYMBOL, 0)

        def MAX_QUERIES_PER_HOUR_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_QUERIES_PER_HOUR_SYMBOL, 0)

        def MAX_ROWS_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_ROWS_SYMBOL, 0)

        def MAX_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_SIZE_SYMBOL, 0)

        def MAX_UPDATES_PER_HOUR_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_UPDATES_PER_HOUR_SYMBOL, 0)

        def MAX_USER_CONNECTIONS_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_USER_CONNECTIONS_SYMBOL, 0)

        def MEDIUM_SYMBOL(self):
            return self.getToken(MySQLParser.MEDIUM_SYMBOL, 0)

        def MEMORY_SYMBOL(self):
            return self.getToken(MySQLParser.MEMORY_SYMBOL, 0)

        def MERGE_SYMBOL(self):
            return self.getToken(MySQLParser.MERGE_SYMBOL, 0)

        def MESSAGE_TEXT_SYMBOL(self):
            return self.getToken(MySQLParser.MESSAGE_TEXT_SYMBOL, 0)

        def MICROSECOND_SYMBOL(self):
            return self.getToken(MySQLParser.MICROSECOND_SYMBOL, 0)

        def MIGRATE_SYMBOL(self):
            return self.getToken(MySQLParser.MIGRATE_SYMBOL, 0)

        def MINUTE_SYMBOL(self):
            return self.getToken(MySQLParser.MINUTE_SYMBOL, 0)

        def MIN_ROWS_SYMBOL(self):
            return self.getToken(MySQLParser.MIN_ROWS_SYMBOL, 0)

        def MODE_SYMBOL(self):
            return self.getToken(MySQLParser.MODE_SYMBOL, 0)

        def MODIFY_SYMBOL(self):
            return self.getToken(MySQLParser.MODIFY_SYMBOL, 0)

        def MONTH_SYMBOL(self):
            return self.getToken(MySQLParser.MONTH_SYMBOL, 0)

        def MULTILINESTRING_SYMBOL(self):
            return self.getToken(MySQLParser.MULTILINESTRING_SYMBOL, 0)

        def MULTIPOINT_SYMBOL(self):
            return self.getToken(MySQLParser.MULTIPOINT_SYMBOL, 0)

        def MULTIPOLYGON_SYMBOL(self):
            return self.getToken(MySQLParser.MULTIPOLYGON_SYMBOL, 0)

        def MUTEX_SYMBOL(self):
            return self.getToken(MySQLParser.MUTEX_SYMBOL, 0)

        def MYSQL_ERRNO_SYMBOL(self):
            return self.getToken(MySQLParser.MYSQL_ERRNO_SYMBOL, 0)

        def NAMES_SYMBOL(self):
            return self.getToken(MySQLParser.NAMES_SYMBOL, 0)

        def NAME_SYMBOL(self):
            return self.getToken(MySQLParser.NAME_SYMBOL, 0)

        def NATIONAL_SYMBOL(self):
            return self.getToken(MySQLParser.NATIONAL_SYMBOL, 0)

        def NCHAR_SYMBOL(self):
            return self.getToken(MySQLParser.NCHAR_SYMBOL, 0)

        def NDBCLUSTER_SYMBOL(self):
            return self.getToken(MySQLParser.NDBCLUSTER_SYMBOL, 0)

        def NESTED_SYMBOL(self):
            return self.getToken(MySQLParser.NESTED_SYMBOL, 0)

        def NEVER_SYMBOL(self):
            return self.getToken(MySQLParser.NEVER_SYMBOL, 0)

        def NEW_SYMBOL(self):
            return self.getToken(MySQLParser.NEW_SYMBOL, 0)

        def NEXT_SYMBOL(self):
            return self.getToken(MySQLParser.NEXT_SYMBOL, 0)

        def NODEGROUP_SYMBOL(self):
            return self.getToken(MySQLParser.NODEGROUP_SYMBOL, 0)

        def NOWAIT_SYMBOL(self):
            return self.getToken(MySQLParser.NOWAIT_SYMBOL, 0)

        def NO_WAIT_SYMBOL(self):
            return self.getToken(MySQLParser.NO_WAIT_SYMBOL, 0)

        def NULLS_SYMBOL(self):
            return self.getToken(MySQLParser.NULLS_SYMBOL, 0)

        def NUMBER_SYMBOL(self):
            return self.getToken(MySQLParser.NUMBER_SYMBOL, 0)

        def NVARCHAR_SYMBOL(self):
            return self.getToken(MySQLParser.NVARCHAR_SYMBOL, 0)

        def OFFSET_SYMBOL(self):
            return self.getToken(MySQLParser.OFFSET_SYMBOL, 0)

        def OJ_SYMBOL(self):
            return self.getToken(MySQLParser.OJ_SYMBOL, 0)

        def OLD_SYMBOL(self):
            return self.getToken(MySQLParser.OLD_SYMBOL, 0)

        def ONE_SYMBOL(self):
            return self.getToken(MySQLParser.ONE_SYMBOL, 0)

        def ONLY_SYMBOL(self):
            return self.getToken(MySQLParser.ONLY_SYMBOL, 0)

        def OPEN_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_SYMBOL, 0)

        def OPTIONAL_SYMBOL(self):
            return self.getToken(MySQLParser.OPTIONAL_SYMBOL, 0)

        def OPTIONS_SYMBOL(self):
            return self.getToken(MySQLParser.OPTIONS_SYMBOL, 0)

        def ORDINALITY_SYMBOL(self):
            return self.getToken(MySQLParser.ORDINALITY_SYMBOL, 0)

        def ORGANIZATION_SYMBOL(self):
            return self.getToken(MySQLParser.ORGANIZATION_SYMBOL, 0)

        def OTHERS_SYMBOL(self):
            return self.getToken(MySQLParser.OTHERS_SYMBOL, 0)

        def OWNER_SYMBOL(self):
            return self.getToken(MySQLParser.OWNER_SYMBOL, 0)

        def PACK_KEYS_SYMBOL(self):
            return self.getToken(MySQLParser.PACK_KEYS_SYMBOL, 0)

        def PAGE_SYMBOL(self):
            return self.getToken(MySQLParser.PAGE_SYMBOL, 0)

        def PARSER_SYMBOL(self):
            return self.getToken(MySQLParser.PARSER_SYMBOL, 0)

        def PARTIAL_SYMBOL(self):
            return self.getToken(MySQLParser.PARTIAL_SYMBOL, 0)

        def PARTITIONING_SYMBOL(self):
            return self.getToken(MySQLParser.PARTITIONING_SYMBOL, 0)

        def PARTITIONS_SYMBOL(self):
            return self.getToken(MySQLParser.PARTITIONS_SYMBOL, 0)

        def PASSWORD_SYMBOL(self):
            return self.getToken(MySQLParser.PASSWORD_SYMBOL, 0)

        def PATH_SYMBOL(self):
            return self.getToken(MySQLParser.PATH_SYMBOL, 0)

        def PHASE_SYMBOL(self):
            return self.getToken(MySQLParser.PHASE_SYMBOL, 0)

        def PLUGINS_SYMBOL(self):
            return self.getToken(MySQLParser.PLUGINS_SYMBOL, 0)

        def PLUGIN_DIR_SYMBOL(self):
            return self.getToken(MySQLParser.PLUGIN_DIR_SYMBOL, 0)

        def PLUGIN_SYMBOL(self):
            return self.getToken(MySQLParser.PLUGIN_SYMBOL, 0)

        def POINT_SYMBOL(self):
            return self.getToken(MySQLParser.POINT_SYMBOL, 0)

        def POLYGON_SYMBOL(self):
            return self.getToken(MySQLParser.POLYGON_SYMBOL, 0)

        def PORT_SYMBOL(self):
            return self.getToken(MySQLParser.PORT_SYMBOL, 0)

        def PRECEDING_SYMBOL(self):
            return self.getToken(MySQLParser.PRECEDING_SYMBOL, 0)

        def PRESERVE_SYMBOL(self):
            return self.getToken(MySQLParser.PRESERVE_SYMBOL, 0)

        def PREV_SYMBOL(self):
            return self.getToken(MySQLParser.PREV_SYMBOL, 0)

        def PRIVILEGES_SYMBOL(self):
            return self.getToken(MySQLParser.PRIVILEGES_SYMBOL, 0)

        def PRIVILEGE_CHECKS_USER_SYMBOL(self):
            return self.getToken(MySQLParser.PRIVILEGE_CHECKS_USER_SYMBOL, 0)

        def PROCESSLIST_SYMBOL(self):
            return self.getToken(MySQLParser.PROCESSLIST_SYMBOL, 0)

        def PROFILES_SYMBOL(self):
            return self.getToken(MySQLParser.PROFILES_SYMBOL, 0)

        def PROFILE_SYMBOL(self):
            return self.getToken(MySQLParser.PROFILE_SYMBOL, 0)

        def QUARTER_SYMBOL(self):
            return self.getToken(MySQLParser.QUARTER_SYMBOL, 0)

        def QUERY_SYMBOL(self):
            return self.getToken(MySQLParser.QUERY_SYMBOL, 0)

        def QUICK_SYMBOL(self):
            return self.getToken(MySQLParser.QUICK_SYMBOL, 0)

        def READ_ONLY_SYMBOL(self):
            return self.getToken(MySQLParser.READ_ONLY_SYMBOL, 0)

        def REBUILD_SYMBOL(self):
            return self.getToken(MySQLParser.REBUILD_SYMBOL, 0)

        def RECOVER_SYMBOL(self):
            return self.getToken(MySQLParser.RECOVER_SYMBOL, 0)

        def REDO_BUFFER_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.REDO_BUFFER_SIZE_SYMBOL, 0)

        def REDUNDANT_SYMBOL(self):
            return self.getToken(MySQLParser.REDUNDANT_SYMBOL, 0)

        def REFERENCE_SYMBOL(self):
            return self.getToken(MySQLParser.REFERENCE_SYMBOL, 0)

        def REGISTRATION_SYMBOL(self):
            return self.getToken(MySQLParser.REGISTRATION_SYMBOL, 0)

        def RELAY_SYMBOL(self):
            return self.getToken(MySQLParser.RELAY_SYMBOL, 0)

        def RELAYLOG_SYMBOL(self):
            return self.getToken(MySQLParser.RELAYLOG_SYMBOL, 0)

        def RELAY_LOG_FILE_SYMBOL(self):
            return self.getToken(MySQLParser.RELAY_LOG_FILE_SYMBOL, 0)

        def RELAY_LOG_POS_SYMBOL(self):
            return self.getToken(MySQLParser.RELAY_LOG_POS_SYMBOL, 0)

        def RELAY_THREAD_SYMBOL(self):
            return self.getToken(MySQLParser.RELAY_THREAD_SYMBOL, 0)

        def REMOVE_SYMBOL(self):
            return self.getToken(MySQLParser.REMOVE_SYMBOL, 0)

        def ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_SYMBOL(self):
            return self.getToken(MySQLParser.ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_SYMBOL, 0)

        def REORGANIZE_SYMBOL(self):
            return self.getToken(MySQLParser.REORGANIZE_SYMBOL, 0)

        def REPEATABLE_SYMBOL(self):
            return self.getToken(MySQLParser.REPEATABLE_SYMBOL, 0)

        def REPLICAS_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICAS_SYMBOL, 0)

        def REPLICATE_DO_DB_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_DO_DB_SYMBOL, 0)

        def REPLICATE_DO_TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_DO_TABLE_SYMBOL, 0)

        def REPLICATE_IGNORE_DB_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_IGNORE_DB_SYMBOL, 0)

        def REPLICATE_IGNORE_TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_IGNORE_TABLE_SYMBOL, 0)

        def REPLICATE_REWRITE_DB_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_REWRITE_DB_SYMBOL, 0)

        def REPLICATE_WILD_DO_TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_WILD_DO_TABLE_SYMBOL, 0)

        def REPLICATE_WILD_IGNORE_TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_WILD_IGNORE_TABLE_SYMBOL, 0)

        def REPLICA_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICA_SYMBOL, 0)

        def USER_RESOURCES_SYMBOL(self):
            return self.getToken(MySQLParser.USER_RESOURCES_SYMBOL, 0)

        def RESPECT_SYMBOL(self):
            return self.getToken(MySQLParser.RESPECT_SYMBOL, 0)

        def RESTORE_SYMBOL(self):
            return self.getToken(MySQLParser.RESTORE_SYMBOL, 0)

        def RESUME_SYMBOL(self):
            return self.getToken(MySQLParser.RESUME_SYMBOL, 0)

        def RETAIN_SYMBOL(self):
            return self.getToken(MySQLParser.RETAIN_SYMBOL, 0)

        def RETURNED_SQLSTATE_SYMBOL(self):
            return self.getToken(MySQLParser.RETURNED_SQLSTATE_SYMBOL, 0)

        def RETURNING_SYMBOL(self):
            return self.getToken(MySQLParser.RETURNING_SYMBOL, 0)

        def RETURNS_SYMBOL(self):
            return self.getToken(MySQLParser.RETURNS_SYMBOL, 0)

        def REUSE_SYMBOL(self):
            return self.getToken(MySQLParser.REUSE_SYMBOL, 0)

        def REVERSE_SYMBOL(self):
            return self.getToken(MySQLParser.REVERSE_SYMBOL, 0)

        def ROLE_SYMBOL(self):
            return self.getToken(MySQLParser.ROLE_SYMBOL, 0)

        def ROLLUP_SYMBOL(self):
            return self.getToken(MySQLParser.ROLLUP_SYMBOL, 0)

        def ROTATE_SYMBOL(self):
            return self.getToken(MySQLParser.ROTATE_SYMBOL, 0)

        def ROUTINE_SYMBOL(self):
            return self.getToken(MySQLParser.ROUTINE_SYMBOL, 0)

        def ROW_COUNT_SYMBOL(self):
            return self.getToken(MySQLParser.ROW_COUNT_SYMBOL, 0)

        def ROW_FORMAT_SYMBOL(self):
            return self.getToken(MySQLParser.ROW_FORMAT_SYMBOL, 0)

        def RTREE_SYMBOL(self):
            return self.getToken(MySQLParser.RTREE_SYMBOL, 0)

        def SCHEDULE_SYMBOL(self):
            return self.getToken(MySQLParser.SCHEDULE_SYMBOL, 0)

        def SCHEMA_NAME_SYMBOL(self):
            return self.getToken(MySQLParser.SCHEMA_NAME_SYMBOL, 0)

        def SECONDARY_ENGINE_SYMBOL(self):
            return self.getToken(MySQLParser.SECONDARY_ENGINE_SYMBOL, 0)

        def SECONDARY_ENGINE_ATTRIBUTE_SYMBOL(self):
            return self.getToken(MySQLParser.SECONDARY_ENGINE_ATTRIBUTE_SYMBOL, 0)

        def SECONDARY_LOAD_SYMBOL(self):
            return self.getToken(MySQLParser.SECONDARY_LOAD_SYMBOL, 0)

        def SECONDARY_SYMBOL(self):
            return self.getToken(MySQLParser.SECONDARY_SYMBOL, 0)

        def SECONDARY_UNLOAD_SYMBOL(self):
            return self.getToken(MySQLParser.SECONDARY_UNLOAD_SYMBOL, 0)

        def SECOND_SYMBOL(self):
            return self.getToken(MySQLParser.SECOND_SYMBOL, 0)

        def SECURITY_SYMBOL(self):
            return self.getToken(MySQLParser.SECURITY_SYMBOL, 0)

        def SERIALIZABLE_SYMBOL(self):
            return self.getToken(MySQLParser.SERIALIZABLE_SYMBOL, 0)

        def SERIAL_SYMBOL(self):
            return self.getToken(MySQLParser.SERIAL_SYMBOL, 0)

        def SERVER_SYMBOL(self):
            return self.getToken(MySQLParser.SERVER_SYMBOL, 0)

        def SHARE_SYMBOL(self):
            return self.getToken(MySQLParser.SHARE_SYMBOL, 0)

        def SIMPLE_SYMBOL(self):
            return self.getToken(MySQLParser.SIMPLE_SYMBOL, 0)

        def SKIP_SYMBOL(self):
            return self.getToken(MySQLParser.SKIP_SYMBOL, 0)

        def SLOW_SYMBOL(self):
            return self.getToken(MySQLParser.SLOW_SYMBOL, 0)

        def SNAPSHOT_SYMBOL(self):
            return self.getToken(MySQLParser.SNAPSHOT_SYMBOL, 0)

        def SOCKET_SYMBOL(self):
            return self.getToken(MySQLParser.SOCKET_SYMBOL, 0)

        def SONAME_SYMBOL(self):
            return self.getToken(MySQLParser.SONAME_SYMBOL, 0)

        def SOUNDS_SYMBOL(self):
            return self.getToken(MySQLParser.SOUNDS_SYMBOL, 0)

        def SOURCE_AUTO_POSITION_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_AUTO_POSITION_SYMBOL, 0)

        def SOURCE_BIND_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_BIND_SYMBOL, 0)

        def SOURCE_COMPRESSION_ALGORITHM_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_COMPRESSION_ALGORITHM_SYMBOL, 0)

        def SOURCE_CONNECTION_AUTO_FAILOVER_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_CONNECTION_AUTO_FAILOVER_SYMBOL, 0)

        def SOURCE_CONNECT_RETRY_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_CONNECT_RETRY_SYMBOL, 0)

        def SOURCE_DELAY_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_DELAY_SYMBOL, 0)

        def SOURCE_HEARTBEAT_PERIOD_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_HEARTBEAT_PERIOD_SYMBOL, 0)

        def SOURCE_HOST_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_HOST_SYMBOL, 0)

        def SOURCE_LOG_FILE_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_LOG_FILE_SYMBOL, 0)

        def SOURCE_LOG_POS_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_LOG_POS_SYMBOL, 0)

        def SOURCE_PASSWORD_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_PASSWORD_SYMBOL, 0)

        def SOURCE_PORT_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_PORT_SYMBOL, 0)

        def SOURCE_PUBLIC_KEY_PATH_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_PUBLIC_KEY_PATH_SYMBOL, 0)

        def SOURCE_RETRY_COUNT_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_RETRY_COUNT_SYMBOL, 0)

        def SOURCE_SSL_CAPATH_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SSL_CAPATH_SYMBOL, 0)

        def SOURCE_SSL_CA_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SSL_CA_SYMBOL, 0)

        def SOURCE_SSL_CERT_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SSL_CERT_SYMBOL, 0)

        def SOURCE_SSL_CIPHER_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SSL_CIPHER_SYMBOL, 0)

        def SOURCE_SSL_CRLPATH_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SSL_CRLPATH_SYMBOL, 0)

        def SOURCE_SSL_CRL_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SSL_CRL_SYMBOL, 0)

        def SOURCE_SSL_KEY_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SSL_KEY_SYMBOL, 0)

        def SOURCE_SSL_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SSL_SYMBOL, 0)

        def SOURCE_SSL_VERIFY_SERVER_CERT_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SSL_VERIFY_SERVER_CERT_SYMBOL, 0)

        def SOURCE_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SYMBOL, 0)

        def SOURCE_TLS_CIPHERSUITES_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_TLS_CIPHERSUITES_SYMBOL, 0)

        def SOURCE_TLS_VERSION_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_TLS_VERSION_SYMBOL, 0)

        def SOURCE_USER_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_USER_SYMBOL, 0)

        def SOURCE_ZSTD_COMPRESSION_LEVEL_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_ZSTD_COMPRESSION_LEVEL_SYMBOL, 0)

        def SQL_AFTER_GTIDS_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_AFTER_GTIDS_SYMBOL, 0)

        def SQL_AFTER_MTS_GAPS_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_AFTER_MTS_GAPS_SYMBOL, 0)

        def SQL_BEFORE_GTIDS_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_BEFORE_GTIDS_SYMBOL, 0)

        def SQL_BUFFER_RESULT_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_BUFFER_RESULT_SYMBOL, 0)

        def SQL_NO_CACHE_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_NO_CACHE_SYMBOL, 0)

        def SQL_THREAD_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_THREAD_SYMBOL, 0)

        def SRID_SYMBOL(self):
            return self.getToken(MySQLParser.SRID_SYMBOL, 0)

        def STACKED_SYMBOL(self):
            return self.getToken(MySQLParser.STACKED_SYMBOL, 0)

        def STARTS_SYMBOL(self):
            return self.getToken(MySQLParser.STARTS_SYMBOL, 0)

        def STATS_AUTO_RECALC_SYMBOL(self):
            return self.getToken(MySQLParser.STATS_AUTO_RECALC_SYMBOL, 0)

        def STATS_PERSISTENT_SYMBOL(self):
            return self.getToken(MySQLParser.STATS_PERSISTENT_SYMBOL, 0)

        def STATS_SAMPLE_PAGES_SYMBOL(self):
            return self.getToken(MySQLParser.STATS_SAMPLE_PAGES_SYMBOL, 0)

        def STATUS_SYMBOL(self):
            return self.getToken(MySQLParser.STATUS_SYMBOL, 0)

        def STORAGE_SYMBOL(self):
            return self.getToken(MySQLParser.STORAGE_SYMBOL, 0)

        def STRING_SYMBOL(self):
            return self.getToken(MySQLParser.STRING_SYMBOL, 0)

        def ST_COLLECT_SYMBOL(self):
            return self.getToken(MySQLParser.ST_COLLECT_SYMBOL, 0)

        def SUBCLASS_ORIGIN_SYMBOL(self):
            return self.getToken(MySQLParser.SUBCLASS_ORIGIN_SYMBOL, 0)

        def SUBDATE_SYMBOL(self):
            return self.getToken(MySQLParser.SUBDATE_SYMBOL, 0)

        def SUBJECT_SYMBOL(self):
            return self.getToken(MySQLParser.SUBJECT_SYMBOL, 0)

        def SUBPARTITIONS_SYMBOL(self):
            return self.getToken(MySQLParser.SUBPARTITIONS_SYMBOL, 0)

        def SUBPARTITION_SYMBOL(self):
            return self.getToken(MySQLParser.SUBPARTITION_SYMBOL, 0)

        def SUSPEND_SYMBOL(self):
            return self.getToken(MySQLParser.SUSPEND_SYMBOL, 0)

        def SWAPS_SYMBOL(self):
            return self.getToken(MySQLParser.SWAPS_SYMBOL, 0)

        def SWITCHES_SYMBOL(self):
            return self.getToken(MySQLParser.SWITCHES_SYMBOL, 0)

        def TABLES_SYMBOL(self):
            return self.getToken(MySQLParser.TABLES_SYMBOL, 0)

        def TABLESPACE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLESPACE_SYMBOL, 0)

        def TABLE_CHECKSUM_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_CHECKSUM_SYMBOL, 0)

        def TABLE_NAME_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_NAME_SYMBOL, 0)

        def TEMPORARY_SYMBOL(self):
            return self.getToken(MySQLParser.TEMPORARY_SYMBOL, 0)

        def TEMPTABLE_SYMBOL(self):
            return self.getToken(MySQLParser.TEMPTABLE_SYMBOL, 0)

        def TEXT_SYMBOL(self):
            return self.getToken(MySQLParser.TEXT_SYMBOL, 0)

        def THAN_SYMBOL(self):
            return self.getToken(MySQLParser.THAN_SYMBOL, 0)

        def THREAD_PRIORITY_SYMBOL(self):
            return self.getToken(MySQLParser.THREAD_PRIORITY_SYMBOL, 0)

        def TIES_SYMBOL(self):
            return self.getToken(MySQLParser.TIES_SYMBOL, 0)

        def TIMESTAMPADD_SYMBOL(self):
            return self.getToken(MySQLParser.TIMESTAMPADD_SYMBOL, 0)

        def TIMESTAMPDIFF_SYMBOL(self):
            return self.getToken(MySQLParser.TIMESTAMPDIFF_SYMBOL, 0)

        def TIMESTAMP_SYMBOL(self):
            return self.getToken(MySQLParser.TIMESTAMP_SYMBOL, 0)

        def TIME_SYMBOL(self):
            return self.getToken(MySQLParser.TIME_SYMBOL, 0)

        def TLS_SYMBOL(self):
            return self.getToken(MySQLParser.TLS_SYMBOL, 0)

        def TRANSACTION_SYMBOL(self):
            return self.getToken(MySQLParser.TRANSACTION_SYMBOL, 0)

        def TRIGGERS_SYMBOL(self):
            return self.getToken(MySQLParser.TRIGGERS_SYMBOL, 0)

        def TYPES_SYMBOL(self):
            return self.getToken(MySQLParser.TYPES_SYMBOL, 0)

        def TYPE_SYMBOL(self):
            return self.getToken(MySQLParser.TYPE_SYMBOL, 0)

        def UNBOUNDED_SYMBOL(self):
            return self.getToken(MySQLParser.UNBOUNDED_SYMBOL, 0)

        def UNCOMMITTED_SYMBOL(self):
            return self.getToken(MySQLParser.UNCOMMITTED_SYMBOL, 0)

        def UNDEFINED_SYMBOL(self):
            return self.getToken(MySQLParser.UNDEFINED_SYMBOL, 0)

        def UNDOFILE_SYMBOL(self):
            return self.getToken(MySQLParser.UNDOFILE_SYMBOL, 0)

        def UNDO_BUFFER_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.UNDO_BUFFER_SIZE_SYMBOL, 0)

        def UNKNOWN_SYMBOL(self):
            return self.getToken(MySQLParser.UNKNOWN_SYMBOL, 0)

        def UNREGISTER_SYMBOL(self):
            return self.getToken(MySQLParser.UNREGISTER_SYMBOL, 0)

        def UNTIL_SYMBOL(self):
            return self.getToken(MySQLParser.UNTIL_SYMBOL, 0)

        def UPGRADE_SYMBOL(self):
            return self.getToken(MySQLParser.UPGRADE_SYMBOL, 0)

        def USER_SYMBOL(self):
            return self.getToken(MySQLParser.USER_SYMBOL, 0)

        def USE_FRM_SYMBOL(self):
            return self.getToken(MySQLParser.USE_FRM_SYMBOL, 0)

        def VALIDATION_SYMBOL(self):
            return self.getToken(MySQLParser.VALIDATION_SYMBOL, 0)

        def VALUE_SYMBOL(self):
            return self.getToken(MySQLParser.VALUE_SYMBOL, 0)

        def VARIABLES_SYMBOL(self):
            return self.getToken(MySQLParser.VARIABLES_SYMBOL, 0)

        def VCPU_SYMBOL(self):
            return self.getToken(MySQLParser.VCPU_SYMBOL, 0)

        def VIEW_SYMBOL(self):
            return self.getToken(MySQLParser.VIEW_SYMBOL, 0)

        def VISIBLE_SYMBOL(self):
            return self.getToken(MySQLParser.VISIBLE_SYMBOL, 0)

        def WAIT_SYMBOL(self):
            return self.getToken(MySQLParser.WAIT_SYMBOL, 0)

        def WARNINGS_SYMBOL(self):
            return self.getToken(MySQLParser.WARNINGS_SYMBOL, 0)

        def WEEK_SYMBOL(self):
            return self.getToken(MySQLParser.WEEK_SYMBOL, 0)

        def WEIGHT_STRING_SYMBOL(self):
            return self.getToken(MySQLParser.WEIGHT_STRING_SYMBOL, 0)

        def WITHOUT_SYMBOL(self):
            return self.getToken(MySQLParser.WITHOUT_SYMBOL, 0)

        def WORK_SYMBOL(self):
            return self.getToken(MySQLParser.WORK_SYMBOL, 0)

        def WRAPPER_SYMBOL(self):
            return self.getToken(MySQLParser.WRAPPER_SYMBOL, 0)

        def X509_SYMBOL(self):
            return self.getToken(MySQLParser.X509_SYMBOL, 0)

        def XID_SYMBOL(self):
            return self.getToken(MySQLParser.XID_SYMBOL, 0)

        def XML_SYMBOL(self):
            return self.getToken(MySQLParser.XML_SYMBOL, 0)

        def YEAR_SYMBOL(self):
            return self.getToken(MySQLParser.YEAR_SYMBOL, 0)

        def ZONE_SYMBOL(self):
            return self.getToken(MySQLParser.ZONE_SYMBOL, 0)

        def ARRAY_SYMBOL(self):
            return self.getToken(MySQLParser.ARRAY_SYMBOL, 0)

        def FAILED_LOGIN_ATTEMPTS_SYMBOL(self):
            return self.getToken(MySQLParser.FAILED_LOGIN_ATTEMPTS_SYMBOL, 0)

        def MEMBER_SYMBOL(self):
            return self.getToken(MySQLParser.MEMBER_SYMBOL, 0)

        def OFF_SYMBOL(self):
            return self.getToken(MySQLParser.OFF_SYMBOL, 0)

        def PASSWORD_LOCK_TIME_SYMBOL(self):
            return self.getToken(MySQLParser.PASSWORD_LOCK_TIME_SYMBOL, 0)

        def RANDOM_SYMBOL(self):
            return self.getToken(MySQLParser.RANDOM_SYMBOL, 0)

        def REQUIRE_ROW_FORMAT_SYMBOL(self):
            return self.getToken(MySQLParser.REQUIRE_ROW_FORMAT_SYMBOL, 0)

        def REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL(self):
            return self.getToken(MySQLParser.REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, 0)

        def STREAM_SYMBOL(self):
            return self.getToken(MySQLParser.STREAM_SYMBOL, 0)

        def BULK_SYMBOL(self):
            return self.getToken(MySQLParser.BULK_SYMBOL, 0)

        def GENERATE_SYMBOL(self):
            return self.getToken(MySQLParser.GENERATE_SYMBOL, 0)

        def GTIDS_SYMBOL(self):
            return self.getToken(MySQLParser.GTIDS_SYMBOL, 0)

        def LOG_SYMBOL(self):
            return self.getToken(MySQLParser.LOG_SYMBOL, 0)

        def PARSE_TREE_SYMBOL(self):
            return self.getToken(MySQLParser.PARSE_TREE_SYMBOL, 0)

        def S3_SYMBOL(self):
            return self.getToken(MySQLParser.S3_SYMBOL, 0)

        def BERNOULLI_SYMBOL(self):
            return self.getToken(MySQLParser.BERNOULLI_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_identifierKeywordsUnambiguous

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierKeywordsUnambiguous" ):
                listener.enterIdentifierKeywordsUnambiguous(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierKeywordsUnambiguous" ):
                listener.exitIdentifierKeywordsUnambiguous(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierKeywordsUnambiguous" ):
                return visitor.visitIdentifierKeywordsUnambiguous(self)
            else:
                return visitor.visitChildren(self)




    def identifierKeywordsUnambiguous(self):

        localctx = MySQLParser.IdentifierKeywordsUnambiguousContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1498, self.RULE_identifierKeywordsUnambiguous)
        self._la = 0 # Token type
        try:
            self.state = 9245
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1170,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9240
                _la = self._input.LA(1)
                if not(((((_la - 49)) & ~0x3f) == 0 and ((1 << (_la - 49)) & 9086892652644541691) != 0) or ((((_la - 113)) & ~0x3f) == 0 and ((1 << (_la - 113)) & -4412943208922816677) != 0) or ((((_la - 177)) & ~0x3f) == 0 and ((1 << (_la - 177)) & -8429668761677951481) != 0) or ((((_la - 242)) & ~0x3f) == 0 and ((1 << (_la - 242)) & 7283684567714153551) != 0) or ((((_la - 309)) & ~0x3f) == 0 and ((1 << (_la - 309)) & 6223708532345118931) != 0) or ((((_la - 373)) & ~0x3f) == 0 and ((1 << (_la - 373)) & -8648045939034882561) != 0) or ((((_la - 437)) & ~0x3f) == 0 and ((1 << (_la - 437)) & 8175298952803425509) != 0) or ((((_la - 501)) & ~0x3f) == 0 and ((1 << (_la - 501)) & 4749773417287869291) != 0) or ((((_la - 566)) & ~0x3f) == 0 and ((1 << (_la - 566)) & 8440016285667793983) != 0) or ((((_la - 634)) & ~0x3f) == 0 and ((1 << (_la - 634)) & -9132393641699904475) != 0) or ((((_la - 698)) & ~0x3f) == 0 and ((1 << (_la - 698)) & 8611416781445657001) != 0) or ((((_la - 762)) & ~0x3f) == 0 and ((1 << (_la - 762)) & 2199023255551) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9241
                if not self.isServerVersionGe80019():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80019()")
                self.state = 9242
                _la = self._input.LA(1)
                if not(_la==592 or _la==595 or ((((_la - 739)) & ~0x3f) == 0 and ((1 << (_la - 739)) & 16381) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 9243
                if not self.isServerVersionGe80200():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80200()")
                self.state = 9244
                _la = self._input.LA(1)
                if not(((((_la - 804)) & ~0x3f) == 0 and ((1 << (_la - 804)) & 2237) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleKeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def roleOrLabelKeyword(self):
            return self.getTypedRuleContext(MySQLParser.RoleOrLabelKeywordContext,0)


        def roleOrIdentifierKeyword(self):
            return self.getTypedRuleContext(MySQLParser.RoleOrIdentifierKeywordContext,0)


        def identifierKeywordsUnambiguous(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierKeywordsUnambiguousContext,0)


        def identifierKeywordsAmbiguous2Labels(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierKeywordsAmbiguous2LabelsContext,0)


        def identifierKeywordsAmbiguous4SystemVariables(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierKeywordsAmbiguous4SystemVariablesContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_roleKeyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoleKeyword" ):
                listener.enterRoleKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoleKeyword" ):
                listener.exitRoleKeyword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRoleKeyword" ):
                return visitor.visitRoleKeyword(self)
            else:
                return visitor.visitChildren(self)




    def roleKeyword(self):

        localctx = MySQLParser.RoleKeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1500, self.RULE_roleKeyword)
        try:
            self.state = 9257
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1173,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9247
                if not self.isServerVersionLt80017():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionLt80017()")
                self.state = 9250
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1171,self._ctx)
                if la_ == 1:
                    self.state = 9248
                    self.roleOrLabelKeyword()
                    pass

                elif la_ == 2:
                    self.state = 9249
                    self.roleOrIdentifierKeyword()
                    pass


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9255
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1172,self._ctx)
                if la_ == 1:
                    self.state = 9252
                    self.identifierKeywordsUnambiguous()
                    pass

                elif la_ == 2:
                    self.state = 9253
                    self.identifierKeywordsAmbiguous2Labels()
                    pass

                elif la_ == 3:
                    self.state = 9254
                    self.identifierKeywordsAmbiguous4SystemVariables()
                    pass


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LValueKeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierKeywordsUnambiguous(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierKeywordsUnambiguousContext,0)


        def identifierKeywordsAmbiguous1RolesAndLabels(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierKeywordsAmbiguous1RolesAndLabelsContext,0)


        def identifierKeywordsAmbiguous2Labels(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierKeywordsAmbiguous2LabelsContext,0)


        def identifierKeywordsAmbiguous3Roles(self):
            return self.getTypedRuleContext(MySQLParser.IdentifierKeywordsAmbiguous3RolesContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_lValueKeyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLValueKeyword" ):
                listener.enterLValueKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLValueKeyword" ):
                listener.exitLValueKeyword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLValueKeyword" ):
                return visitor.visitLValueKeyword(self)
            else:
                return visitor.visitChildren(self)




    def lValueKeyword(self):

        localctx = MySQLParser.LValueKeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1502, self.RULE_lValueKeyword)
        try:
            self.state = 9263
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1174,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9259
                self.identifierKeywordsUnambiguous()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9260
                self.identifierKeywordsAmbiguous1RolesAndLabels()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 9261
                self.identifierKeywordsAmbiguous2Labels()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 9262
                self.identifierKeywordsAmbiguous3Roles()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierKeywordsAmbiguous4SystemVariablesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GLOBAL_SYMBOL(self):
            return self.getToken(MySQLParser.GLOBAL_SYMBOL, 0)

        def LOCAL_SYMBOL(self):
            return self.getToken(MySQLParser.LOCAL_SYMBOL, 0)

        def PERSIST_SYMBOL(self):
            return self.getToken(MySQLParser.PERSIST_SYMBOL, 0)

        def PERSIST_ONLY_SYMBOL(self):
            return self.getToken(MySQLParser.PERSIST_ONLY_SYMBOL, 0)

        def SESSION_SYMBOL(self):
            return self.getToken(MySQLParser.SESSION_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_identifierKeywordsAmbiguous4SystemVariables

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierKeywordsAmbiguous4SystemVariables" ):
                listener.enterIdentifierKeywordsAmbiguous4SystemVariables(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierKeywordsAmbiguous4SystemVariables" ):
                listener.exitIdentifierKeywordsAmbiguous4SystemVariables(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierKeywordsAmbiguous4SystemVariables" ):
                return visitor.visitIdentifierKeywordsAmbiguous4SystemVariables(self)
            else:
                return visitor.visitChildren(self)




    def identifierKeywordsAmbiguous4SystemVariables(self):

        localctx = MySQLParser.IdentifierKeywordsAmbiguous4SystemVariablesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1504, self.RULE_identifierKeywordsAmbiguous4SystemVariables)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9265
            _la = self._input.LA(1)
            if not(_la==246 or _la==312 or _la==516 or _la==666 or _la==681):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleOrIdentifierKeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ACCOUNT_SYMBOL(self):
            return self.getToken(MySQLParser.ACCOUNT_SYMBOL, 0)

        def ASCII_SYMBOL(self):
            return self.getToken(MySQLParser.ASCII_SYMBOL, 0)

        def ALWAYS_SYMBOL(self):
            return self.getToken(MySQLParser.ALWAYS_SYMBOL, 0)

        def BACKUP_SYMBOL(self):
            return self.getToken(MySQLParser.BACKUP_SYMBOL, 0)

        def BEGIN_SYMBOL(self):
            return self.getToken(MySQLParser.BEGIN_SYMBOL, 0)

        def BYTE_SYMBOL(self):
            return self.getToken(MySQLParser.BYTE_SYMBOL, 0)

        def CACHE_SYMBOL(self):
            return self.getToken(MySQLParser.CACHE_SYMBOL, 0)

        def CHARSET_SYMBOL(self):
            return self.getToken(MySQLParser.CHARSET_SYMBOL, 0)

        def CHECKSUM_SYMBOL(self):
            return self.getToken(MySQLParser.CHECKSUM_SYMBOL, 0)

        def CLONE_SYMBOL(self):
            return self.getToken(MySQLParser.CLONE_SYMBOL, 0)

        def CLOSE_SYMBOL(self):
            return self.getToken(MySQLParser.CLOSE_SYMBOL, 0)

        def COMMENT_SYMBOL(self):
            return self.getToken(MySQLParser.COMMENT_SYMBOL, 0)

        def COMMIT_SYMBOL(self):
            return self.getToken(MySQLParser.COMMIT_SYMBOL, 0)

        def CONTAINS_SYMBOL(self):
            return self.getToken(MySQLParser.CONTAINS_SYMBOL, 0)

        def DEALLOCATE_SYMBOL(self):
            return self.getToken(MySQLParser.DEALLOCATE_SYMBOL, 0)

        def DO_SYMBOL(self):
            return self.getToken(MySQLParser.DO_SYMBOL, 0)

        def END_SYMBOL(self):
            return self.getToken(MySQLParser.END_SYMBOL, 0)

        def FLUSH_SYMBOL(self):
            return self.getToken(MySQLParser.FLUSH_SYMBOL, 0)

        def FOLLOWS_SYMBOL(self):
            return self.getToken(MySQLParser.FOLLOWS_SYMBOL, 0)

        def FORMAT_SYMBOL(self):
            return self.getToken(MySQLParser.FORMAT_SYMBOL, 0)

        def GROUP_REPLICATION_SYMBOL(self):
            return self.getToken(MySQLParser.GROUP_REPLICATION_SYMBOL, 0)

        def HANDLER_SYMBOL(self):
            return self.getToken(MySQLParser.HANDLER_SYMBOL, 0)

        def HELP_SYMBOL(self):
            return self.getToken(MySQLParser.HELP_SYMBOL, 0)

        def HOST_SYMBOL(self):
            return self.getToken(MySQLParser.HOST_SYMBOL, 0)

        def INSTALL_SYMBOL(self):
            return self.getToken(MySQLParser.INSTALL_SYMBOL, 0)

        def INVISIBLE_SYMBOL(self):
            return self.getToken(MySQLParser.INVISIBLE_SYMBOL, 0)

        def LANGUAGE_SYMBOL(self):
            return self.getToken(MySQLParser.LANGUAGE_SYMBOL, 0)

        def NO_SYMBOL(self):
            return self.getToken(MySQLParser.NO_SYMBOL, 0)

        def OPEN_SYMBOL(self):
            return self.getToken(MySQLParser.OPEN_SYMBOL, 0)

        def OPTIONS_SYMBOL(self):
            return self.getToken(MySQLParser.OPTIONS_SYMBOL, 0)

        def OWNER_SYMBOL(self):
            return self.getToken(MySQLParser.OWNER_SYMBOL, 0)

        def PARSER_SYMBOL(self):
            return self.getToken(MySQLParser.PARSER_SYMBOL, 0)

        def PARTITION_SYMBOL(self):
            return self.getToken(MySQLParser.PARTITION_SYMBOL, 0)

        def PORT_SYMBOL(self):
            return self.getToken(MySQLParser.PORT_SYMBOL, 0)

        def PRECEDES_SYMBOL(self):
            return self.getToken(MySQLParser.PRECEDES_SYMBOL, 0)

        def PREPARE_SYMBOL(self):
            return self.getToken(MySQLParser.PREPARE_SYMBOL, 0)

        def REMOVE_SYMBOL(self):
            return self.getToken(MySQLParser.REMOVE_SYMBOL, 0)

        def REPAIR_SYMBOL(self):
            return self.getToken(MySQLParser.REPAIR_SYMBOL, 0)

        def RESET_SYMBOL(self):
            return self.getToken(MySQLParser.RESET_SYMBOL, 0)

        def RESTORE_SYMBOL(self):
            return self.getToken(MySQLParser.RESTORE_SYMBOL, 0)

        def ROLE_SYMBOL(self):
            return self.getToken(MySQLParser.ROLE_SYMBOL, 0)

        def ROLLBACK_SYMBOL(self):
            return self.getToken(MySQLParser.ROLLBACK_SYMBOL, 0)

        def SAVEPOINT_SYMBOL(self):
            return self.getToken(MySQLParser.SAVEPOINT_SYMBOL, 0)

        def SECONDARY_SYMBOL(self):
            return self.getToken(MySQLParser.SECONDARY_SYMBOL, 0)

        def SECONDARY_ENGINE_SYMBOL(self):
            return self.getToken(MySQLParser.SECONDARY_ENGINE_SYMBOL, 0)

        def SECONDARY_LOAD_SYMBOL(self):
            return self.getToken(MySQLParser.SECONDARY_LOAD_SYMBOL, 0)

        def SECONDARY_UNLOAD_SYMBOL(self):
            return self.getToken(MySQLParser.SECONDARY_UNLOAD_SYMBOL, 0)

        def SECURITY_SYMBOL(self):
            return self.getToken(MySQLParser.SECURITY_SYMBOL, 0)

        def SERVER_SYMBOL(self):
            return self.getToken(MySQLParser.SERVER_SYMBOL, 0)

        def SIGNED_SYMBOL(self):
            return self.getToken(MySQLParser.SIGNED_SYMBOL, 0)

        def SOCKET_SYMBOL(self):
            return self.getToken(MySQLParser.SOCKET_SYMBOL, 0)

        def SLAVE_SYMBOL(self):
            return self.getToken(MySQLParser.SLAVE_SYMBOL, 0)

        def SONAME_SYMBOL(self):
            return self.getToken(MySQLParser.SONAME_SYMBOL, 0)

        def START_SYMBOL(self):
            return self.getToken(MySQLParser.START_SYMBOL, 0)

        def STOP_SYMBOL(self):
            return self.getToken(MySQLParser.STOP_SYMBOL, 0)

        def TRUNCATE_SYMBOL(self):
            return self.getToken(MySQLParser.TRUNCATE_SYMBOL, 0)

        def UNICODE_SYMBOL(self):
            return self.getToken(MySQLParser.UNICODE_SYMBOL, 0)

        def UNINSTALL_SYMBOL(self):
            return self.getToken(MySQLParser.UNINSTALL_SYMBOL, 0)

        def UPGRADE_SYMBOL(self):
            return self.getToken(MySQLParser.UPGRADE_SYMBOL, 0)

        def VISIBLE_SYMBOL(self):
            return self.getToken(MySQLParser.VISIBLE_SYMBOL, 0)

        def WRAPPER_SYMBOL(self):
            return self.getToken(MySQLParser.WRAPPER_SYMBOL, 0)

        def XA_SYMBOL(self):
            return self.getToken(MySQLParser.XA_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_roleOrIdentifierKeyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoleOrIdentifierKeyword" ):
                listener.enterRoleOrIdentifierKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoleOrIdentifierKeyword" ):
                listener.exitRoleOrIdentifierKeyword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRoleOrIdentifierKeyword" ):
                return visitor.visitRoleOrIdentifierKeyword(self)
            else:
                return visitor.visitChildren(self)




    def roleOrIdentifierKeyword(self):

        localctx = MySQLParser.RoleOrIdentifierKeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1506, self.RULE_roleOrIdentifierKeyword)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 9267
            _la = self._input.LA(1)
            if not(((((_la - 49)) & ~0x3f) == 0 and ((1 << (_la - 49)) & 1197964097992328193) != 0) or ((((_la - 118)) & ~0x3f) == 0 and ((1 << (_la - 118)) & 35184372121605) != 0) or ((((_la - 183)) & ~0x3f) == 0 and ((1 << (_la - 183)) & 577692205326536705) != 0) or ((((_la - 251)) & ~0x3f) == 0 and ((1 << (_la - 251)) & 70368811286569) != 0) or ((((_la - 392)) & ~0x3f) == 0 and ((1 << (_la - 392)) & 11547170643969) != 0) or ((((_la - 469)) & ~0x3f) == 0 and ((1 << (_la - 469)) & 7097956755589890057) != 0) or ((((_la - 553)) & ~0x3f) == 0 and ((1 << (_la - 553)) & -4602678819172646399) != 0) or ((((_la - 624)) & ~0x3f) == 0 and ((1 << (_la - 624)) & 2305957397077688321) != 0) or ((((_la - 728)) & ~0x3f) == 0 and ((1 << (_la - 728)) & 15) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleOrLabelKeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ACTION_SYMBOL(self):
            return self.getToken(MySQLParser.ACTION_SYMBOL, 0)

        def ACTIVE_SYMBOL(self):
            return self.getToken(MySQLParser.ACTIVE_SYMBOL, 0)

        def ADDDATE_SYMBOL(self):
            return self.getToken(MySQLParser.ADDDATE_SYMBOL, 0)

        def AFTER_SYMBOL(self):
            return self.getToken(MySQLParser.AFTER_SYMBOL, 0)

        def AGAINST_SYMBOL(self):
            return self.getToken(MySQLParser.AGAINST_SYMBOL, 0)

        def AGGREGATE_SYMBOL(self):
            return self.getToken(MySQLParser.AGGREGATE_SYMBOL, 0)

        def ALGORITHM_SYMBOL(self):
            return self.getToken(MySQLParser.ALGORITHM_SYMBOL, 0)

        def ANY_SYMBOL(self):
            return self.getToken(MySQLParser.ANY_SYMBOL, 0)

        def AT_SYMBOL(self):
            return self.getToken(MySQLParser.AT_SYMBOL, 0)

        def AUTO_INCREMENT_SYMBOL(self):
            return self.getToken(MySQLParser.AUTO_INCREMENT_SYMBOL, 0)

        def AUTOEXTEND_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.AUTOEXTEND_SIZE_SYMBOL, 0)

        def AVG_ROW_LENGTH_SYMBOL(self):
            return self.getToken(MySQLParser.AVG_ROW_LENGTH_SYMBOL, 0)

        def AVG_SYMBOL(self):
            return self.getToken(MySQLParser.AVG_SYMBOL, 0)

        def BINLOG_SYMBOL(self):
            return self.getToken(MySQLParser.BINLOG_SYMBOL, 0)

        def BIT_SYMBOL(self):
            return self.getToken(MySQLParser.BIT_SYMBOL, 0)

        def BLOCK_SYMBOL(self):
            return self.getToken(MySQLParser.BLOCK_SYMBOL, 0)

        def BOOL_SYMBOL(self):
            return self.getToken(MySQLParser.BOOL_SYMBOL, 0)

        def BOOLEAN_SYMBOL(self):
            return self.getToken(MySQLParser.BOOLEAN_SYMBOL, 0)

        def BTREE_SYMBOL(self):
            return self.getToken(MySQLParser.BTREE_SYMBOL, 0)

        def BUCKETS_SYMBOL(self):
            return self.getToken(MySQLParser.BUCKETS_SYMBOL, 0)

        def CASCADED_SYMBOL(self):
            return self.getToken(MySQLParser.CASCADED_SYMBOL, 0)

        def CATALOG_NAME_SYMBOL(self):
            return self.getToken(MySQLParser.CATALOG_NAME_SYMBOL, 0)

        def CHAIN_SYMBOL(self):
            return self.getToken(MySQLParser.CHAIN_SYMBOL, 0)

        def CHANGED_SYMBOL(self):
            return self.getToken(MySQLParser.CHANGED_SYMBOL, 0)

        def CHANNEL_SYMBOL(self):
            return self.getToken(MySQLParser.CHANNEL_SYMBOL, 0)

        def CIPHER_SYMBOL(self):
            return self.getToken(MySQLParser.CIPHER_SYMBOL, 0)

        def CLIENT_SYMBOL(self):
            return self.getToken(MySQLParser.CLIENT_SYMBOL, 0)

        def CLASS_ORIGIN_SYMBOL(self):
            return self.getToken(MySQLParser.CLASS_ORIGIN_SYMBOL, 0)

        def COALESCE_SYMBOL(self):
            return self.getToken(MySQLParser.COALESCE_SYMBOL, 0)

        def CODE_SYMBOL(self):
            return self.getToken(MySQLParser.CODE_SYMBOL, 0)

        def COLLATION_SYMBOL(self):
            return self.getToken(MySQLParser.COLLATION_SYMBOL, 0)

        def COLUMN_NAME_SYMBOL(self):
            return self.getToken(MySQLParser.COLUMN_NAME_SYMBOL, 0)

        def COLUMN_FORMAT_SYMBOL(self):
            return self.getToken(MySQLParser.COLUMN_FORMAT_SYMBOL, 0)

        def COLUMNS_SYMBOL(self):
            return self.getToken(MySQLParser.COLUMNS_SYMBOL, 0)

        def COMMITTED_SYMBOL(self):
            return self.getToken(MySQLParser.COMMITTED_SYMBOL, 0)

        def COMPACT_SYMBOL(self):
            return self.getToken(MySQLParser.COMPACT_SYMBOL, 0)

        def COMPLETION_SYMBOL(self):
            return self.getToken(MySQLParser.COMPLETION_SYMBOL, 0)

        def COMPONENT_SYMBOL(self):
            return self.getToken(MySQLParser.COMPONENT_SYMBOL, 0)

        def COMPRESSED_SYMBOL(self):
            return self.getToken(MySQLParser.COMPRESSED_SYMBOL, 0)

        def COMPRESSION_SYMBOL(self):
            return self.getToken(MySQLParser.COMPRESSION_SYMBOL, 0)

        def CONCURRENT_SYMBOL(self):
            return self.getToken(MySQLParser.CONCURRENT_SYMBOL, 0)

        def CONNECTION_SYMBOL(self):
            return self.getToken(MySQLParser.CONNECTION_SYMBOL, 0)

        def CONSISTENT_SYMBOL(self):
            return self.getToken(MySQLParser.CONSISTENT_SYMBOL, 0)

        def CONSTRAINT_CATALOG_SYMBOL(self):
            return self.getToken(MySQLParser.CONSTRAINT_CATALOG_SYMBOL, 0)

        def CONSTRAINT_SCHEMA_SYMBOL(self):
            return self.getToken(MySQLParser.CONSTRAINT_SCHEMA_SYMBOL, 0)

        def CONSTRAINT_NAME_SYMBOL(self):
            return self.getToken(MySQLParser.CONSTRAINT_NAME_SYMBOL, 0)

        def CONTEXT_SYMBOL(self):
            return self.getToken(MySQLParser.CONTEXT_SYMBOL, 0)

        def CPU_SYMBOL(self):
            return self.getToken(MySQLParser.CPU_SYMBOL, 0)

        def CURRENT_SYMBOL(self):
            return self.getToken(MySQLParser.CURRENT_SYMBOL, 0)

        def CURSOR_NAME_SYMBOL(self):
            return self.getToken(MySQLParser.CURSOR_NAME_SYMBOL, 0)

        def DATA_SYMBOL(self):
            return self.getToken(MySQLParser.DATA_SYMBOL, 0)

        def DATAFILE_SYMBOL(self):
            return self.getToken(MySQLParser.DATAFILE_SYMBOL, 0)

        def DATETIME_SYMBOL(self):
            return self.getToken(MySQLParser.DATETIME_SYMBOL, 0)

        def DATE_SYMBOL(self):
            return self.getToken(MySQLParser.DATE_SYMBOL, 0)

        def DAY_SYMBOL(self):
            return self.getToken(MySQLParser.DAY_SYMBOL, 0)

        def DEFAULT_AUTH_SYMBOL(self):
            return self.getToken(MySQLParser.DEFAULT_AUTH_SYMBOL, 0)

        def DEFINER_SYMBOL(self):
            return self.getToken(MySQLParser.DEFINER_SYMBOL, 0)

        def DELAY_KEY_WRITE_SYMBOL(self):
            return self.getToken(MySQLParser.DELAY_KEY_WRITE_SYMBOL, 0)

        def DESCRIPTION_SYMBOL(self):
            return self.getToken(MySQLParser.DESCRIPTION_SYMBOL, 0)

        def DIAGNOSTICS_SYMBOL(self):
            return self.getToken(MySQLParser.DIAGNOSTICS_SYMBOL, 0)

        def DIRECTORY_SYMBOL(self):
            return self.getToken(MySQLParser.DIRECTORY_SYMBOL, 0)

        def DISABLE_SYMBOL(self):
            return self.getToken(MySQLParser.DISABLE_SYMBOL, 0)

        def DISCARD_SYMBOL(self):
            return self.getToken(MySQLParser.DISCARD_SYMBOL, 0)

        def DISK_SYMBOL(self):
            return self.getToken(MySQLParser.DISK_SYMBOL, 0)

        def DUMPFILE_SYMBOL(self):
            return self.getToken(MySQLParser.DUMPFILE_SYMBOL, 0)

        def DUPLICATE_SYMBOL(self):
            return self.getToken(MySQLParser.DUPLICATE_SYMBOL, 0)

        def DYNAMIC_SYMBOL(self):
            return self.getToken(MySQLParser.DYNAMIC_SYMBOL, 0)

        def ENCRYPTION_SYMBOL(self):
            return self.getToken(MySQLParser.ENCRYPTION_SYMBOL, 0)

        def ENDS_SYMBOL(self):
            return self.getToken(MySQLParser.ENDS_SYMBOL, 0)

        def ENUM_SYMBOL(self):
            return self.getToken(MySQLParser.ENUM_SYMBOL, 0)

        def ENGINE_SYMBOL(self):
            return self.getToken(MySQLParser.ENGINE_SYMBOL, 0)

        def ENGINES_SYMBOL(self):
            return self.getToken(MySQLParser.ENGINES_SYMBOL, 0)

        def ENGINE_ATTRIBUTE_SYMBOL(self):
            return self.getToken(MySQLParser.ENGINE_ATTRIBUTE_SYMBOL, 0)

        def ERROR_SYMBOL(self):
            return self.getToken(MySQLParser.ERROR_SYMBOL, 0)

        def ERRORS_SYMBOL(self):
            return self.getToken(MySQLParser.ERRORS_SYMBOL, 0)

        def ESCAPE_SYMBOL(self):
            return self.getToken(MySQLParser.ESCAPE_SYMBOL, 0)

        def EVENTS_SYMBOL(self):
            return self.getToken(MySQLParser.EVENTS_SYMBOL, 0)

        def EVERY_SYMBOL(self):
            return self.getToken(MySQLParser.EVERY_SYMBOL, 0)

        def EXCLUDE_SYMBOL(self):
            return self.getToken(MySQLParser.EXCLUDE_SYMBOL, 0)

        def EXPANSION_SYMBOL(self):
            return self.getToken(MySQLParser.EXPANSION_SYMBOL, 0)

        def EXPORT_SYMBOL(self):
            return self.getToken(MySQLParser.EXPORT_SYMBOL, 0)

        def EXTENDED_SYMBOL(self):
            return self.getToken(MySQLParser.EXTENDED_SYMBOL, 0)

        def EXTENT_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.EXTENT_SIZE_SYMBOL, 0)

        def FAULTS_SYMBOL(self):
            return self.getToken(MySQLParser.FAULTS_SYMBOL, 0)

        def FAST_SYMBOL(self):
            return self.getToken(MySQLParser.FAST_SYMBOL, 0)

        def FOLLOWING_SYMBOL(self):
            return self.getToken(MySQLParser.FOLLOWING_SYMBOL, 0)

        def FOUND_SYMBOL(self):
            return self.getToken(MySQLParser.FOUND_SYMBOL, 0)

        def ENABLE_SYMBOL(self):
            return self.getToken(MySQLParser.ENABLE_SYMBOL, 0)

        def FULL_SYMBOL(self):
            return self.getToken(MySQLParser.FULL_SYMBOL, 0)

        def FILE_BLOCK_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.FILE_BLOCK_SIZE_SYMBOL, 0)

        def FILTER_SYMBOL(self):
            return self.getToken(MySQLParser.FILTER_SYMBOL, 0)

        def FIRST_SYMBOL(self):
            return self.getToken(MySQLParser.FIRST_SYMBOL, 0)

        def FIXED_SYMBOL(self):
            return self.getToken(MySQLParser.FIXED_SYMBOL, 0)

        def GENERAL_SYMBOL(self):
            return self.getToken(MySQLParser.GENERAL_SYMBOL, 0)

        def GEOMETRY_SYMBOL(self):
            return self.getToken(MySQLParser.GEOMETRY_SYMBOL, 0)

        def GEOMETRYCOLLECTION_SYMBOL(self):
            return self.getToken(MySQLParser.GEOMETRYCOLLECTION_SYMBOL, 0)

        def GET_FORMAT_SYMBOL(self):
            return self.getToken(MySQLParser.GET_FORMAT_SYMBOL, 0)

        def GRANTS_SYMBOL(self):
            return self.getToken(MySQLParser.GRANTS_SYMBOL, 0)

        def GLOBAL_SYMBOL(self):
            return self.getToken(MySQLParser.GLOBAL_SYMBOL, 0)

        def HASH_SYMBOL(self):
            return self.getToken(MySQLParser.HASH_SYMBOL, 0)

        def HISTOGRAM_SYMBOL(self):
            return self.getToken(MySQLParser.HISTOGRAM_SYMBOL, 0)

        def HISTORY_SYMBOL(self):
            return self.getToken(MySQLParser.HISTORY_SYMBOL, 0)

        def HOSTS_SYMBOL(self):
            return self.getToken(MySQLParser.HOSTS_SYMBOL, 0)

        def HOUR_SYMBOL(self):
            return self.getToken(MySQLParser.HOUR_SYMBOL, 0)

        def IDENTIFIED_SYMBOL(self):
            return self.getToken(MySQLParser.IDENTIFIED_SYMBOL, 0)

        def IGNORE_SERVER_IDS_SYMBOL(self):
            return self.getToken(MySQLParser.IGNORE_SERVER_IDS_SYMBOL, 0)

        def INVOKER_SYMBOL(self):
            return self.getToken(MySQLParser.INVOKER_SYMBOL, 0)

        def INDEXES_SYMBOL(self):
            return self.getToken(MySQLParser.INDEXES_SYMBOL, 0)

        def INITIAL_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.INITIAL_SIZE_SYMBOL, 0)

        def INSTANCE_SYMBOL(self):
            return self.getToken(MySQLParser.INSTANCE_SYMBOL, 0)

        def INACTIVE_SYMBOL(self):
            return self.getToken(MySQLParser.INACTIVE_SYMBOL, 0)

        def IO_SYMBOL(self):
            return self.getToken(MySQLParser.IO_SYMBOL, 0)

        def IPC_SYMBOL(self):
            return self.getToken(MySQLParser.IPC_SYMBOL, 0)

        def ISOLATION_SYMBOL(self):
            return self.getToken(MySQLParser.ISOLATION_SYMBOL, 0)

        def ISSUER_SYMBOL(self):
            return self.getToken(MySQLParser.ISSUER_SYMBOL, 0)

        def INSERT_METHOD_SYMBOL(self):
            return self.getToken(MySQLParser.INSERT_METHOD_SYMBOL, 0)

        def JSON_SYMBOL(self):
            return self.getToken(MySQLParser.JSON_SYMBOL, 0)

        def KEY_BLOCK_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.KEY_BLOCK_SIZE_SYMBOL, 0)

        def LAST_SYMBOL(self):
            return self.getToken(MySQLParser.LAST_SYMBOL, 0)

        def LEAVES_SYMBOL(self):
            return self.getToken(MySQLParser.LEAVES_SYMBOL, 0)

        def LESS_SYMBOL(self):
            return self.getToken(MySQLParser.LESS_SYMBOL, 0)

        def LEVEL_SYMBOL(self):
            return self.getToken(MySQLParser.LEVEL_SYMBOL, 0)

        def LINESTRING_SYMBOL(self):
            return self.getToken(MySQLParser.LINESTRING_SYMBOL, 0)

        def LIST_SYMBOL(self):
            return self.getToken(MySQLParser.LIST_SYMBOL, 0)

        def LOCAL_SYMBOL(self):
            return self.getToken(MySQLParser.LOCAL_SYMBOL, 0)

        def LOCKED_SYMBOL(self):
            return self.getToken(MySQLParser.LOCKED_SYMBOL, 0)

        def LOCKS_SYMBOL(self):
            return self.getToken(MySQLParser.LOCKS_SYMBOL, 0)

        def LOGFILE_SYMBOL(self):
            return self.getToken(MySQLParser.LOGFILE_SYMBOL, 0)

        def LOGS_SYMBOL(self):
            return self.getToken(MySQLParser.LOGS_SYMBOL, 0)

        def MAX_ROWS_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_ROWS_SYMBOL, 0)

        def MASTER_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SYMBOL, 0)

        def MASTER_HEARTBEAT_PERIOD_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_HEARTBEAT_PERIOD_SYMBOL, 0)

        def MASTER_HOST_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_HOST_SYMBOL, 0)

        def MASTER_PORT_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_PORT_SYMBOL, 0)

        def MASTER_LOG_FILE_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_LOG_FILE_SYMBOL, 0)

        def MASTER_LOG_POS_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_LOG_POS_SYMBOL, 0)

        def MASTER_USER_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_USER_SYMBOL, 0)

        def MASTER_PASSWORD_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_PASSWORD_SYMBOL, 0)

        def MASTER_PUBLIC_KEY_PATH_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_PUBLIC_KEY_PATH_SYMBOL, 0)

        def MASTER_CONNECT_RETRY_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_CONNECT_RETRY_SYMBOL, 0)

        def MASTER_RETRY_COUNT_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_RETRY_COUNT_SYMBOL, 0)

        def MASTER_DELAY_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_DELAY_SYMBOL, 0)

        def MASTER_SSL_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_SYMBOL, 0)

        def MASTER_SSL_CA_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_CA_SYMBOL, 0)

        def MASTER_SSL_CAPATH_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_CAPATH_SYMBOL, 0)

        def MASTER_TLS_VERSION_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_TLS_VERSION_SYMBOL, 0)

        def MASTER_SSL_CERT_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_CERT_SYMBOL, 0)

        def MASTER_SSL_CIPHER_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_CIPHER_SYMBOL, 0)

        def MASTER_SSL_CRL_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_CRL_SYMBOL, 0)

        def MASTER_SSL_CRLPATH_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_CRLPATH_SYMBOL, 0)

        def MASTER_SSL_KEY_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_SSL_KEY_SYMBOL, 0)

        def MASTER_AUTO_POSITION_SYMBOL(self):
            return self.getToken(MySQLParser.MASTER_AUTO_POSITION_SYMBOL, 0)

        def MAX_CONNECTIONS_PER_HOUR_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_CONNECTIONS_PER_HOUR_SYMBOL, 0)

        def MAX_QUERIES_PER_HOUR_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_QUERIES_PER_HOUR_SYMBOL, 0)

        def MAX_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_SIZE_SYMBOL, 0)

        def MAX_UPDATES_PER_HOUR_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_UPDATES_PER_HOUR_SYMBOL, 0)

        def MAX_USER_CONNECTIONS_SYMBOL(self):
            return self.getToken(MySQLParser.MAX_USER_CONNECTIONS_SYMBOL, 0)

        def MEDIUM_SYMBOL(self):
            return self.getToken(MySQLParser.MEDIUM_SYMBOL, 0)

        def MEMORY_SYMBOL(self):
            return self.getToken(MySQLParser.MEMORY_SYMBOL, 0)

        def MERGE_SYMBOL(self):
            return self.getToken(MySQLParser.MERGE_SYMBOL, 0)

        def MESSAGE_TEXT_SYMBOL(self):
            return self.getToken(MySQLParser.MESSAGE_TEXT_SYMBOL, 0)

        def MICROSECOND_SYMBOL(self):
            return self.getToken(MySQLParser.MICROSECOND_SYMBOL, 0)

        def MIGRATE_SYMBOL(self):
            return self.getToken(MySQLParser.MIGRATE_SYMBOL, 0)

        def MINUTE_SYMBOL(self):
            return self.getToken(MySQLParser.MINUTE_SYMBOL, 0)

        def MIN_ROWS_SYMBOL(self):
            return self.getToken(MySQLParser.MIN_ROWS_SYMBOL, 0)

        def MODIFY_SYMBOL(self):
            return self.getToken(MySQLParser.MODIFY_SYMBOL, 0)

        def MODE_SYMBOL(self):
            return self.getToken(MySQLParser.MODE_SYMBOL, 0)

        def MONTH_SYMBOL(self):
            return self.getToken(MySQLParser.MONTH_SYMBOL, 0)

        def MULTILINESTRING_SYMBOL(self):
            return self.getToken(MySQLParser.MULTILINESTRING_SYMBOL, 0)

        def MULTIPOINT_SYMBOL(self):
            return self.getToken(MySQLParser.MULTIPOINT_SYMBOL, 0)

        def MULTIPOLYGON_SYMBOL(self):
            return self.getToken(MySQLParser.MULTIPOLYGON_SYMBOL, 0)

        def MUTEX_SYMBOL(self):
            return self.getToken(MySQLParser.MUTEX_SYMBOL, 0)

        def MYSQL_ERRNO_SYMBOL(self):
            return self.getToken(MySQLParser.MYSQL_ERRNO_SYMBOL, 0)

        def NAME_SYMBOL(self):
            return self.getToken(MySQLParser.NAME_SYMBOL, 0)

        def NAMES_SYMBOL(self):
            return self.getToken(MySQLParser.NAMES_SYMBOL, 0)

        def NATIONAL_SYMBOL(self):
            return self.getToken(MySQLParser.NATIONAL_SYMBOL, 0)

        def NCHAR_SYMBOL(self):
            return self.getToken(MySQLParser.NCHAR_SYMBOL, 0)

        def NDBCLUSTER_SYMBOL(self):
            return self.getToken(MySQLParser.NDBCLUSTER_SYMBOL, 0)

        def NESTED_SYMBOL(self):
            return self.getToken(MySQLParser.NESTED_SYMBOL, 0)

        def NEVER_SYMBOL(self):
            return self.getToken(MySQLParser.NEVER_SYMBOL, 0)

        def NEXT_SYMBOL(self):
            return self.getToken(MySQLParser.NEXT_SYMBOL, 0)

        def NEW_SYMBOL(self):
            return self.getToken(MySQLParser.NEW_SYMBOL, 0)

        def NO_WAIT_SYMBOL(self):
            return self.getToken(MySQLParser.NO_WAIT_SYMBOL, 0)

        def NODEGROUP_SYMBOL(self):
            return self.getToken(MySQLParser.NODEGROUP_SYMBOL, 0)

        def NULLS_SYMBOL(self):
            return self.getToken(MySQLParser.NULLS_SYMBOL, 0)

        def NOWAIT_SYMBOL(self):
            return self.getToken(MySQLParser.NOWAIT_SYMBOL, 0)

        def NUMBER_SYMBOL(self):
            return self.getToken(MySQLParser.NUMBER_SYMBOL, 0)

        def NVARCHAR_SYMBOL(self):
            return self.getToken(MySQLParser.NVARCHAR_SYMBOL, 0)

        def OFFSET_SYMBOL(self):
            return self.getToken(MySQLParser.OFFSET_SYMBOL, 0)

        def OLD_SYMBOL(self):
            return self.getToken(MySQLParser.OLD_SYMBOL, 0)

        def ONE_SYMBOL(self):
            return self.getToken(MySQLParser.ONE_SYMBOL, 0)

        def OPTIONAL_SYMBOL(self):
            return self.getToken(MySQLParser.OPTIONAL_SYMBOL, 0)

        def ORDINALITY_SYMBOL(self):
            return self.getToken(MySQLParser.ORDINALITY_SYMBOL, 0)

        def ORGANIZATION_SYMBOL(self):
            return self.getToken(MySQLParser.ORGANIZATION_SYMBOL, 0)

        def OTHERS_SYMBOL(self):
            return self.getToken(MySQLParser.OTHERS_SYMBOL, 0)

        def PACK_KEYS_SYMBOL(self):
            return self.getToken(MySQLParser.PACK_KEYS_SYMBOL, 0)

        def PAGE_SYMBOL(self):
            return self.getToken(MySQLParser.PAGE_SYMBOL, 0)

        def PARTIAL_SYMBOL(self):
            return self.getToken(MySQLParser.PARTIAL_SYMBOL, 0)

        def PARTITIONING_SYMBOL(self):
            return self.getToken(MySQLParser.PARTITIONING_SYMBOL, 0)

        def PARTITIONS_SYMBOL(self):
            return self.getToken(MySQLParser.PARTITIONS_SYMBOL, 0)

        def PASSWORD_SYMBOL(self):
            return self.getToken(MySQLParser.PASSWORD_SYMBOL, 0)

        def PATH_SYMBOL(self):
            return self.getToken(MySQLParser.PATH_SYMBOL, 0)

        def PHASE_SYMBOL(self):
            return self.getToken(MySQLParser.PHASE_SYMBOL, 0)

        def PLUGIN_DIR_SYMBOL(self):
            return self.getToken(MySQLParser.PLUGIN_DIR_SYMBOL, 0)

        def PLUGIN_SYMBOL(self):
            return self.getToken(MySQLParser.PLUGIN_SYMBOL, 0)

        def PLUGINS_SYMBOL(self):
            return self.getToken(MySQLParser.PLUGINS_SYMBOL, 0)

        def POINT_SYMBOL(self):
            return self.getToken(MySQLParser.POINT_SYMBOL, 0)

        def POLYGON_SYMBOL(self):
            return self.getToken(MySQLParser.POLYGON_SYMBOL, 0)

        def PRECEDING_SYMBOL(self):
            return self.getToken(MySQLParser.PRECEDING_SYMBOL, 0)

        def PRESERVE_SYMBOL(self):
            return self.getToken(MySQLParser.PRESERVE_SYMBOL, 0)

        def PREV_SYMBOL(self):
            return self.getToken(MySQLParser.PREV_SYMBOL, 0)

        def THREAD_PRIORITY_SYMBOL(self):
            return self.getToken(MySQLParser.THREAD_PRIORITY_SYMBOL, 0)

        def PRIVILEGES_SYMBOL(self):
            return self.getToken(MySQLParser.PRIVILEGES_SYMBOL, 0)

        def PROCESSLIST_SYMBOL(self):
            return self.getToken(MySQLParser.PROCESSLIST_SYMBOL, 0)

        def PROFILE_SYMBOL(self):
            return self.getToken(MySQLParser.PROFILE_SYMBOL, 0)

        def PROFILES_SYMBOL(self):
            return self.getToken(MySQLParser.PROFILES_SYMBOL, 0)

        def QUARTER_SYMBOL(self):
            return self.getToken(MySQLParser.QUARTER_SYMBOL, 0)

        def QUERY_SYMBOL(self):
            return self.getToken(MySQLParser.QUERY_SYMBOL, 0)

        def QUICK_SYMBOL(self):
            return self.getToken(MySQLParser.QUICK_SYMBOL, 0)

        def READ_ONLY_SYMBOL(self):
            return self.getToken(MySQLParser.READ_ONLY_SYMBOL, 0)

        def REBUILD_SYMBOL(self):
            return self.getToken(MySQLParser.REBUILD_SYMBOL, 0)

        def RECOVER_SYMBOL(self):
            return self.getToken(MySQLParser.RECOVER_SYMBOL, 0)

        def REDO_BUFFER_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.REDO_BUFFER_SIZE_SYMBOL, 0)

        def REDUNDANT_SYMBOL(self):
            return self.getToken(MySQLParser.REDUNDANT_SYMBOL, 0)

        def RELAY_SYMBOL(self):
            return self.getToken(MySQLParser.RELAY_SYMBOL, 0)

        def RELAYLOG_SYMBOL(self):
            return self.getToken(MySQLParser.RELAYLOG_SYMBOL, 0)

        def RELAY_LOG_FILE_SYMBOL(self):
            return self.getToken(MySQLParser.RELAY_LOG_FILE_SYMBOL, 0)

        def RELAY_LOG_POS_SYMBOL(self):
            return self.getToken(MySQLParser.RELAY_LOG_POS_SYMBOL, 0)

        def RELAY_THREAD_SYMBOL(self):
            return self.getToken(MySQLParser.RELAY_THREAD_SYMBOL, 0)

        def REMOTE_SYMBOL(self):
            return self.getToken(MySQLParser.REMOTE_SYMBOL, 0)

        def REORGANIZE_SYMBOL(self):
            return self.getToken(MySQLParser.REORGANIZE_SYMBOL, 0)

        def REPEATABLE_SYMBOL(self):
            return self.getToken(MySQLParser.REPEATABLE_SYMBOL, 0)

        def REPLICATE_DO_DB_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_DO_DB_SYMBOL, 0)

        def REPLICATE_IGNORE_DB_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_IGNORE_DB_SYMBOL, 0)

        def REPLICATE_DO_TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_DO_TABLE_SYMBOL, 0)

        def REPLICATE_IGNORE_TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_IGNORE_TABLE_SYMBOL, 0)

        def REPLICATE_WILD_DO_TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_WILD_DO_TABLE_SYMBOL, 0)

        def REPLICATE_WILD_IGNORE_TABLE_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_WILD_IGNORE_TABLE_SYMBOL, 0)

        def REPLICATE_REWRITE_DB_SYMBOL(self):
            return self.getToken(MySQLParser.REPLICATE_REWRITE_DB_SYMBOL, 0)

        def USER_RESOURCES_SYMBOL(self):
            return self.getToken(MySQLParser.USER_RESOURCES_SYMBOL, 0)

        def RESPECT_SYMBOL(self):
            return self.getToken(MySQLParser.RESPECT_SYMBOL, 0)

        def RESUME_SYMBOL(self):
            return self.getToken(MySQLParser.RESUME_SYMBOL, 0)

        def RETAIN_SYMBOL(self):
            return self.getToken(MySQLParser.RETAIN_SYMBOL, 0)

        def RETURNED_SQLSTATE_SYMBOL(self):
            return self.getToken(MySQLParser.RETURNED_SQLSTATE_SYMBOL, 0)

        def RETURNS_SYMBOL(self):
            return self.getToken(MySQLParser.RETURNS_SYMBOL, 0)

        def REUSE_SYMBOL(self):
            return self.getToken(MySQLParser.REUSE_SYMBOL, 0)

        def REVERSE_SYMBOL(self):
            return self.getToken(MySQLParser.REVERSE_SYMBOL, 0)

        def ROLLUP_SYMBOL(self):
            return self.getToken(MySQLParser.ROLLUP_SYMBOL, 0)

        def ROTATE_SYMBOL(self):
            return self.getToken(MySQLParser.ROTATE_SYMBOL, 0)

        def ROUTINE_SYMBOL(self):
            return self.getToken(MySQLParser.ROUTINE_SYMBOL, 0)

        def ROW_COUNT_SYMBOL(self):
            return self.getToken(MySQLParser.ROW_COUNT_SYMBOL, 0)

        def ROW_FORMAT_SYMBOL(self):
            return self.getToken(MySQLParser.ROW_FORMAT_SYMBOL, 0)

        def RTREE_SYMBOL(self):
            return self.getToken(MySQLParser.RTREE_SYMBOL, 0)

        def SCHEDULE_SYMBOL(self):
            return self.getToken(MySQLParser.SCHEDULE_SYMBOL, 0)

        def SCHEMA_NAME_SYMBOL(self):
            return self.getToken(MySQLParser.SCHEMA_NAME_SYMBOL, 0)

        def SECOND_SYMBOL(self):
            return self.getToken(MySQLParser.SECOND_SYMBOL, 0)

        def SERIAL_SYMBOL(self):
            return self.getToken(MySQLParser.SERIAL_SYMBOL, 0)

        def SERIALIZABLE_SYMBOL(self):
            return self.getToken(MySQLParser.SERIALIZABLE_SYMBOL, 0)

        def SESSION_SYMBOL(self):
            return self.getToken(MySQLParser.SESSION_SYMBOL, 0)

        def SHARE_SYMBOL(self):
            return self.getToken(MySQLParser.SHARE_SYMBOL, 0)

        def SIMPLE_SYMBOL(self):
            return self.getToken(MySQLParser.SIMPLE_SYMBOL, 0)

        def SKIP_SYMBOL(self):
            return self.getToken(MySQLParser.SKIP_SYMBOL, 0)

        def SLOW_SYMBOL(self):
            return self.getToken(MySQLParser.SLOW_SYMBOL, 0)

        def SNAPSHOT_SYMBOL(self):
            return self.getToken(MySQLParser.SNAPSHOT_SYMBOL, 0)

        def SOUNDS_SYMBOL(self):
            return self.getToken(MySQLParser.SOUNDS_SYMBOL, 0)

        def SOURCE_SYMBOL(self):
            return self.getToken(MySQLParser.SOURCE_SYMBOL, 0)

        def SQL_AFTER_GTIDS_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_AFTER_GTIDS_SYMBOL, 0)

        def SQL_AFTER_MTS_GAPS_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_AFTER_MTS_GAPS_SYMBOL, 0)

        def SQL_BEFORE_GTIDS_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_BEFORE_GTIDS_SYMBOL, 0)

        def SQL_BUFFER_RESULT_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_BUFFER_RESULT_SYMBOL, 0)

        def SQL_NO_CACHE_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_NO_CACHE_SYMBOL, 0)

        def SQL_THREAD_SYMBOL(self):
            return self.getToken(MySQLParser.SQL_THREAD_SYMBOL, 0)

        def SRID_SYMBOL(self):
            return self.getToken(MySQLParser.SRID_SYMBOL, 0)

        def STACKED_SYMBOL(self):
            return self.getToken(MySQLParser.STACKED_SYMBOL, 0)

        def STARTS_SYMBOL(self):
            return self.getToken(MySQLParser.STARTS_SYMBOL, 0)

        def STATS_AUTO_RECALC_SYMBOL(self):
            return self.getToken(MySQLParser.STATS_AUTO_RECALC_SYMBOL, 0)

        def STATS_PERSISTENT_SYMBOL(self):
            return self.getToken(MySQLParser.STATS_PERSISTENT_SYMBOL, 0)

        def STATS_SAMPLE_PAGES_SYMBOL(self):
            return self.getToken(MySQLParser.STATS_SAMPLE_PAGES_SYMBOL, 0)

        def STATUS_SYMBOL(self):
            return self.getToken(MySQLParser.STATUS_SYMBOL, 0)

        def STORAGE_SYMBOL(self):
            return self.getToken(MySQLParser.STORAGE_SYMBOL, 0)

        def STRING_SYMBOL(self):
            return self.getToken(MySQLParser.STRING_SYMBOL, 0)

        def SUBCLASS_ORIGIN_SYMBOL(self):
            return self.getToken(MySQLParser.SUBCLASS_ORIGIN_SYMBOL, 0)

        def SUBDATE_SYMBOL(self):
            return self.getToken(MySQLParser.SUBDATE_SYMBOL, 0)

        def SUBJECT_SYMBOL(self):
            return self.getToken(MySQLParser.SUBJECT_SYMBOL, 0)

        def SUBPARTITION_SYMBOL(self):
            return self.getToken(MySQLParser.SUBPARTITION_SYMBOL, 0)

        def SUBPARTITIONS_SYMBOL(self):
            return self.getToken(MySQLParser.SUBPARTITIONS_SYMBOL, 0)

        def SUPER_SYMBOL(self):
            return self.getToken(MySQLParser.SUPER_SYMBOL, 0)

        def SUSPEND_SYMBOL(self):
            return self.getToken(MySQLParser.SUSPEND_SYMBOL, 0)

        def SWAPS_SYMBOL(self):
            return self.getToken(MySQLParser.SWAPS_SYMBOL, 0)

        def SWITCHES_SYMBOL(self):
            return self.getToken(MySQLParser.SWITCHES_SYMBOL, 0)

        def TABLE_NAME_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_NAME_SYMBOL, 0)

        def TABLES_SYMBOL(self):
            return self.getToken(MySQLParser.TABLES_SYMBOL, 0)

        def TABLE_CHECKSUM_SYMBOL(self):
            return self.getToken(MySQLParser.TABLE_CHECKSUM_SYMBOL, 0)

        def TABLESPACE_SYMBOL(self):
            return self.getToken(MySQLParser.TABLESPACE_SYMBOL, 0)

        def TEMPORARY_SYMBOL(self):
            return self.getToken(MySQLParser.TEMPORARY_SYMBOL, 0)

        def TEMPTABLE_SYMBOL(self):
            return self.getToken(MySQLParser.TEMPTABLE_SYMBOL, 0)

        def TEXT_SYMBOL(self):
            return self.getToken(MySQLParser.TEXT_SYMBOL, 0)

        def THAN_SYMBOL(self):
            return self.getToken(MySQLParser.THAN_SYMBOL, 0)

        def TIES_SYMBOL(self):
            return self.getToken(MySQLParser.TIES_SYMBOL, 0)

        def TRANSACTION_SYMBOL(self):
            return self.getToken(MySQLParser.TRANSACTION_SYMBOL, 0)

        def TRIGGERS_SYMBOL(self):
            return self.getToken(MySQLParser.TRIGGERS_SYMBOL, 0)

        def TIMESTAMP_SYMBOL(self):
            return self.getToken(MySQLParser.TIMESTAMP_SYMBOL, 0)

        def TIMESTAMPADD_SYMBOL(self):
            return self.getToken(MySQLParser.TIMESTAMPADD_SYMBOL, 0)

        def TIMESTAMPDIFF_SYMBOL(self):
            return self.getToken(MySQLParser.TIMESTAMPDIFF_SYMBOL, 0)

        def TIME_SYMBOL(self):
            return self.getToken(MySQLParser.TIME_SYMBOL, 0)

        def TYPES_SYMBOL(self):
            return self.getToken(MySQLParser.TYPES_SYMBOL, 0)

        def TYPE_SYMBOL(self):
            return self.getToken(MySQLParser.TYPE_SYMBOL, 0)

        def UDF_RETURNS_SYMBOL(self):
            return self.getToken(MySQLParser.UDF_RETURNS_SYMBOL, 0)

        def UNBOUNDED_SYMBOL(self):
            return self.getToken(MySQLParser.UNBOUNDED_SYMBOL, 0)

        def UNCOMMITTED_SYMBOL(self):
            return self.getToken(MySQLParser.UNCOMMITTED_SYMBOL, 0)

        def UNDEFINED_SYMBOL(self):
            return self.getToken(MySQLParser.UNDEFINED_SYMBOL, 0)

        def UNDO_BUFFER_SIZE_SYMBOL(self):
            return self.getToken(MySQLParser.UNDO_BUFFER_SIZE_SYMBOL, 0)

        def UNDOFILE_SYMBOL(self):
            return self.getToken(MySQLParser.UNDOFILE_SYMBOL, 0)

        def UNKNOWN_SYMBOL(self):
            return self.getToken(MySQLParser.UNKNOWN_SYMBOL, 0)

        def UNTIL_SYMBOL(self):
            return self.getToken(MySQLParser.UNTIL_SYMBOL, 0)

        def USER_SYMBOL(self):
            return self.getToken(MySQLParser.USER_SYMBOL, 0)

        def USE_FRM_SYMBOL(self):
            return self.getToken(MySQLParser.USE_FRM_SYMBOL, 0)

        def VARIABLES_SYMBOL(self):
            return self.getToken(MySQLParser.VARIABLES_SYMBOL, 0)

        def VCPU_SYMBOL(self):
            return self.getToken(MySQLParser.VCPU_SYMBOL, 0)

        def VIEW_SYMBOL(self):
            return self.getToken(MySQLParser.VIEW_SYMBOL, 0)

        def VALUE_SYMBOL(self):
            return self.getToken(MySQLParser.VALUE_SYMBOL, 0)

        def WARNINGS_SYMBOL(self):
            return self.getToken(MySQLParser.WARNINGS_SYMBOL, 0)

        def WAIT_SYMBOL(self):
            return self.getToken(MySQLParser.WAIT_SYMBOL, 0)

        def WEEK_SYMBOL(self):
            return self.getToken(MySQLParser.WEEK_SYMBOL, 0)

        def WORK_SYMBOL(self):
            return self.getToken(MySQLParser.WORK_SYMBOL, 0)

        def WEIGHT_STRING_SYMBOL(self):
            return self.getToken(MySQLParser.WEIGHT_STRING_SYMBOL, 0)

        def X509_SYMBOL(self):
            return self.getToken(MySQLParser.X509_SYMBOL, 0)

        def XID_SYMBOL(self):
            return self.getToken(MySQLParser.XID_SYMBOL, 0)

        def XML_SYMBOL(self):
            return self.getToken(MySQLParser.XML_SYMBOL, 0)

        def YEAR_SYMBOL(self):
            return self.getToken(MySQLParser.YEAR_SYMBOL, 0)

        def ADMIN_SYMBOL(self):
            return self.getToken(MySQLParser.ADMIN_SYMBOL, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_roleOrLabelKeyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoleOrLabelKeyword" ):
                listener.enterRoleOrLabelKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoleOrLabelKeyword" ):
                listener.exitRoleOrLabelKeyword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRoleOrLabelKeyword" ):
                return visitor.visitRoleOrLabelKeyword(self)
            else:
                return visitor.visitChildren(self)




    def roleOrLabelKeyword(self):

        localctx = MySQLParser.RoleOrLabelKeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 1508, self.RULE_roleOrLabelKeyword)
        self._la = 0 # Token type
        try:
            self.state = 9272
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1175,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 9269
                _la = self._input.LA(1)
                if not(((((_la - 50)) & ~0x3f) == 0 and ((1 << (_la - 50)) & -5256386462840123267) != 0) or ((((_la - 114)) & ~0x3f) == 0 and ((1 << (_la - 114)) & -2206471604461408339) != 0) or ((((_la - 178)) & ~0x3f) == 0 and ((1 << (_la - 178)) & 4972508841280096003) != 0) or ((((_la - 243)) & ~0x3f) == 0 and ((1 << (_la - 243)) & 3641842283857068591) != 0) or ((((_la - 309)) & ~0x3f) == 0 and ((1 << (_la - 309)) & 6223708532345118939) != 0) or ((((_la - 373)) & ~0x3f) == 0 and ((1 << (_la - 373)) & -8936355520825983489) != 0) or ((((_la - 437)) & ~0x3f) == 0 and ((1 << (_la - 437)) & 8174173048601615589) != 0) or ((((_la - 501)) & ~0x3f) == 0 and ((1 << (_la - 501)) & 4749773415677223275) != 0) or ((((_la - 566)) & ~0x3f) == 0 and ((1 << (_la - 566)) & 8151794705609104959) != 0) or ((((_la - 636)) & ~0x3f) == 0 and ((1 << (_la - 636)) & 6940555069192944905) != 0) or ((((_la - 701)) & ~0x3f) == 0 and ((1 << (_la - 701)) & 72057652113112629) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 9270
                if not self.isServerVersionGe80014():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.isServerVersionGe80014()")
                self.state = 9271
                self.match(MySQLParser.ADMIN_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[3] = self.alterStatement_sempred
        self._predicates[15] = self.standaloneAlterCommands_sempred
        self._predicates[19] = self.alterListItem_sempred
        self._predicates[29] = self.alterTablespace_sempred
        self._predicates[34] = self.alterTablespaceOption_sempred
        self._predicates[40] = self.alterInstanceStatement_sempred
        self._predicates[41] = self.createStatement_sempred
        self._predicates[43] = self.createDatabaseOption_sempred
        self._predicates[54] = self.storedRoutineBody_sempred
        self._predicates[59] = self.routineOption_sempred
        self._predicates[71] = self.tsDataFileName_sempred
        self._predicates[74] = self.tablespaceOption_sempred
        self._predicates[97] = self.dropStatement_sempred
        self._predicates[118] = self.deleteStatement_sempred
        self._predicates[132] = self.valuesReference_sempred
        self._predicates[137] = self.loadFrom_sempred
        self._predicates[138] = self.loadSourceType_sempred
        self._predicates[139] = self.sourceCount_sempred
        self._predicates[140] = self.sourceOrder_sempred
        self._predicates[145] = self.loadAlgorithm_sempred
        self._predicates[146] = self.loadParallel_sempred
        self._predicates[147] = self.loadMemory_sempred
        self._predicates[150] = self.selectStatementWithInto_sempred
        self._predicates[152] = self.queryExpressionBody_sempred
        self._predicates[154] = self.queryPrimary_sempred
        self._predicates[165] = self.qualifyClause_sempred
        self._predicates[179] = self.groupByClause_sempred
        self._predicates[189] = self.lockingClauseList_sempred
        self._predicates[197] = self.tableReference_sempred
        self._predicates[203] = self.tableFactor_sempred
        self._predicates[206] = self.derivedTable_sempred
        self._predicates[210] = self.jtColumn_sempred
        self._predicates[217] = self.tableAlias_sempred
        self._predicates[241] = self.masterOrBinaryLogsAndGtids_sempred
        self._predicates[244] = self.changeReplicationSource_sempred
        self._predicates[247] = self.sourceDefinition_sempred
        self._predicates[307] = self.cloneStatement_sempred
        self._predicates[311] = self.alterUserStatement_sempred
        self._predicates[313] = self.alterUser_sempred
        self._predicates[317] = self.createUserTail_sempred
        self._predicates[322] = self.accountLockPasswordExpireOptions_sempred
        self._predicates[326] = self.grantTargetList_sempred
        self._predicates[331] = self.versionedRequireClause_sempred
        self._predicates[333] = self.revokeStatement_sempred
        self._predicates[337] = self.grantIdentifier_sempred
        self._predicates[340] = self.grantOption_sempred
        self._predicates[345] = self.histogramAutoUpdate_sempred
        self._predicates[346] = self.histogramUpdateParam_sempred
        self._predicates[347] = self.histogramNumBuckets_sempred
        self._predicates[356] = self.installSetValueList_sempred
        self._predicates[358] = self.startOptionValueList_sempred
        self._predicates[363] = self.optionValueNoOptionType_sempred
        self._predicates[375] = self.showParseTreeStatement_sempred
        self._predicates[447] = self.utilityStatement_sempred
        self._predicates[449] = self.explainStatement_sempred
        self._predicates[450] = self.explainOptions_sempred
        self._predicates[456] = self.expr_sempred
        self._predicates[457] = self.boolPri_sempred
        self._predicates[459] = self.predicate_sempred
        self._predicates[461] = self.bitExpr_sempred
        self._predicates[462] = self.simpleExpr_sempred
        self._predicates[463] = self.arrayCast_sempred
        self._predicates[467] = self.windowFunctionCall_sempred
        self._predicates[470] = self.tablesampleClause_sempred
        self._predicates[472] = self.leadLagInfo_sempred
        self._predicates[481] = self.runtimeFunctionCall_sempred
        self._predicates[497] = self.lvalueVariable_sempred
        self._predicates[502] = self.castType_sempred
        self._predicates[558] = self.checkOrReferences_sempred
        self._predicates[560] = self.constraintEnforcement_sempred
        self._predicates[564] = self.columnAttribute_sempred
        self._predicates[575] = self.keyPartOrExpression_sempred
        self._predicates[578] = self.commonIndexOption_sempred
        self._predicates[595] = self.charsetName_sempred
        self._predicates[596] = self.collationName_sempred
        self._predicates[601] = self.createTableOption_sempred
        self._predicates[620] = self.persistedVariableIdentifier_sempred
        self._predicates[703] = self.pureIdentifier_sempred
        self._predicates[713] = self.real_ulonglong_number_sempred
        self._predicates[715] = self.signedLiteralOrNull_sempred
        self._predicates[717] = self.literalOrNull_sempred
        self._predicates[720] = self.textStringLiteral_sempred
        self._predicates[722] = self.textStringHash_sempred
        self._predicates[744] = self.identifierKeyword_sempred
        self._predicates[747] = self.labelKeyword_sempred
        self._predicates[749] = self.identifierKeywordsUnambiguous_sempred
        self._predicates[750] = self.roleKeyword_sempred
        self._predicates[754] = self.roleOrLabelKeyword_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def alterStatement_sempred(self, localctx:AlterStatementContext, predIndex:int):
            if predIndex == 0:
                return self.isServerVersionGe80014()
         

    def standaloneAlterCommands_sempred(self, localctx:StandaloneAlterCommandsContext, predIndex:int):
            if predIndex == 1:
                return self.isServerVersionGe80014()
         

    def alterListItem_sempred(self, localctx:AlterListItemContext, predIndex:int):
            if predIndex == 2:
                return self.isServerVersionGe80017()
         

            if predIndex == 3:
                return self.isServerVersionGe80019()
         

            if predIndex == 4:
                return self.isServerVersionGe80014()
         

            if predIndex == 5:
                return self.isServerVersionGe80024()
         

            if predIndex == 6:
                return self.isServerVersionGe80017()
         

            if predIndex == 7:
                return self.isServerVersionGe80019()
         

            if predIndex == 8:
                return self.isServerVersionGe80014()
         

    def alterTablespace_sempred(self, localctx:AlterTablespaceContext, predIndex:int):
            if predIndex == 9:
                return self.isServerVersionGe80014()
         

    def alterTablespaceOption_sempred(self, localctx:AlterTablespaceOptionContext, predIndex:int):
            if predIndex == 10:
                return self.isServerVersionGe80024()
         

    def alterInstanceStatement_sempred(self, localctx:AlterInstanceStatementContext, predIndex:int):
            if predIndex == 11:
                return self.isServerVersionGe80024()
         

    def createStatement_sempred(self, localctx:CreateStatementContext, predIndex:int):
            if predIndex == 12:
                return self.isServerVersionGe80011()
         

            if predIndex == 13:
                return self.isServerVersionGe80014()
         

    def createDatabaseOption_sempred(self, localctx:CreateDatabaseOptionContext, predIndex:int):
            if predIndex == 14:
                return self.isServerVersionGe80016()
         

    def storedRoutineBody_sempred(self, localctx:StoredRoutineBodyContext, predIndex:int):
            if predIndex == 15:
                return self.isStoredRoutineBody()
         

    def routineOption_sempred(self, localctx:RoutineOptionContext, predIndex:int):
            if predIndex == 16:
                return self.isServerVersionGe80032()
         

    def tsDataFileName_sempred(self, localctx:TsDataFileNameContext, predIndex:int):
            if predIndex == 17:
                return self.isServerVersionGe80014()
         

    def tablespaceOption_sempred(self, localctx:TablespaceOptionContext, predIndex:int):
            if predIndex == 18:
                return self.isServerVersionGe80014()
         

    def dropStatement_sempred(self, localctx:DropStatementContext, predIndex:int):
            if predIndex == 19:
                return self.isServerVersionGe80011()
         

            if predIndex == 20:
                return self.isServerVersionGe80014()
         

    def deleteStatement_sempred(self, localctx:DeleteStatementContext, predIndex:int):
            if predIndex == 21:
                return self.isServerVersionGe80017()
         

    def valuesReference_sempred(self, localctx:ValuesReferenceContext, predIndex:int):
            if predIndex == 22:
                return self.isServerVersionGe80018()
         

    def loadFrom_sempred(self, localctx:LoadFromContext, predIndex:int):
            if predIndex == 23:
                return self.isServerVersionGe80200()
         

    def loadSourceType_sempred(self, localctx:LoadSourceTypeContext, predIndex:int):
            if predIndex == 24:
                return self.isServerVersionGe80200()
         

    def sourceCount_sempred(self, localctx:SourceCountContext, predIndex:int):
            if predIndex == 25:
                return self.isServerVersionGe80200()
         

    def sourceOrder_sempred(self, localctx:SourceOrderContext, predIndex:int):
            if predIndex == 26:
                return self.isServerVersionGe80200()
         

    def loadAlgorithm_sempred(self, localctx:LoadAlgorithmContext, predIndex:int):
            if predIndex == 27:
                return self.isServerVersionGe80200()
         

    def loadParallel_sempred(self, localctx:LoadParallelContext, predIndex:int):
            if predIndex == 28:
                return self.isServerVersionGe80200()
         

    def loadMemory_sempred(self, localctx:LoadMemoryContext, predIndex:int):
            if predIndex == 29:
                return self.isServerVersionGe80200()
         

    def selectStatementWithInto_sempred(self, localctx:SelectStatementWithIntoContext, predIndex:int):
            if predIndex == 30:
                return self.isSelectStatementWithInto()
         

    def queryExpressionBody_sempred(self, localctx:QueryExpressionBodyContext, predIndex:int):
            if predIndex == 31:
                return self.isServerVersionGe80031()
         

    def queryPrimary_sempred(self, localctx:QueryPrimaryContext, predIndex:int):
            if predIndex == 32:
                return self.isServerVersionGe80019()
         

            if predIndex == 33:
                return self.isServerVersionGe80019()
         

    def qualifyClause_sempred(self, localctx:QualifyClauseContext, predIndex:int):
            if predIndex == 34:
                return self.isServerVersionGe80200()
         

    def groupByClause_sempred(self, localctx:GroupByClauseContext, predIndex:int):
            if predIndex == 35:
                return self.isServerVersionGe80032()
         

    def lockingClauseList_sempred(self, localctx:LockingClauseListContext, predIndex:int):
            if predIndex == 36:
                return self.isServerVersionGe80031()
         

    def tableReference_sempred(self, localctx:TableReferenceContext, predIndex:int):
            if predIndex == 37:
                return self.isServerVersionGe80017()
         

    def tableFactor_sempred(self, localctx:TableFactorContext, predIndex:int):
            if predIndex == 38:
                return self.isServerVersionGe80004()
         

    def derivedTable_sempred(self, localctx:DerivedTableContext, predIndex:int):
            if predIndex == 39:
                return self.isServerVersionGe80014()
         

    def jtColumn_sempred(self, localctx:JtColumnContext, predIndex:int):
            if predIndex == 40:
                return self.isServerVersionGe80014()
         

    def tableAlias_sempred(self, localctx:TableAliasContext, predIndex:int):
            if predIndex == 41:
                return self.isServerVersionGe80017()
         

    def masterOrBinaryLogsAndGtids_sempred(self, localctx:MasterOrBinaryLogsAndGtidsContext, predIndex:int):
            if predIndex == 42:
                return self.isServerVersionGe80032()
         

    def changeReplicationSource_sempred(self, localctx:ChangeReplicationSourceContext, predIndex:int):
            if predIndex == 43:
                return self.isServerVersionGe80024()
         

    def sourceDefinition_sempred(self, localctx:SourceDefinitionContext, predIndex:int):
            if predIndex == 44:
                return self.isServerVersionGe80024()
         

            if predIndex == 45:
                return self.isServerVersionGe80024()
         

            if predIndex == 46:
                return self.isServerVersionGe80027()
         

    def cloneStatement_sempred(self, localctx:CloneStatementContext, predIndex:int):
            if predIndex == 47:
                return self.isServerVersionGe80014()
         

    def alterUserStatement_sempred(self, localctx:AlterUserStatementContext, predIndex:int):
            if predIndex == 48:
                return self.isServerVersionGe80014()
         

            if predIndex == 49:
                return self.isServerVersionGe80014()
         

    def alterUser_sempred(self, localctx:AlterUserContext, predIndex:int):
            if predIndex == 50:
                return self.isServerVersionLt80025()
         

            if predIndex == 51:
                return self.isServerVersionGe80025()
         

    def createUserTail_sempred(self, localctx:CreateUserTailContext, predIndex:int):
            if predIndex == 52:
                return self.isServerVersionGe80024()
         

    def accountLockPasswordExpireOptions_sempred(self, localctx:AccountLockPasswordExpireOptionsContext, predIndex:int):
            if predIndex == 53:
                return self.isServerVersionGe80014()
         

    def grantTargetList_sempred(self, localctx:GrantTargetListContext, predIndex:int):
            if predIndex == 54:
                return self.isServerVersionLt80011()
         

            if predIndex == 55:
                return self.isServerVersionGe80011()
         

    def versionedRequireClause_sempred(self, localctx:VersionedRequireClauseContext, predIndex:int):
            if predIndex == 56:
                return self.isServerVersionLt80011()
         

    def revokeStatement_sempred(self, localctx:RevokeStatementContext, predIndex:int):
            if predIndex == 57:
                return self.isServerVersionGe80031()
         

            if predIndex == 58:
                return self.isServerVersionGe80031()
         

    def grantIdentifier_sempred(self, localctx:GrantIdentifierContext, predIndex:int):
            if predIndex == 59:
                return self.isServerVersionGe80017()
         

    def grantOption_sempred(self, localctx:GrantOptionContext, predIndex:int):
            if predIndex == 60:
                return self.isServerVersionLt80011()
         

    def histogramAutoUpdate_sempred(self, localctx:HistogramAutoUpdateContext, predIndex:int):
            if predIndex == 61:
                return self.isServerVersionGe80200()
         

    def histogramUpdateParam_sempred(self, localctx:HistogramUpdateParamContext, predIndex:int):
            if predIndex == 62:
                return self.isServerVersionGe80031()
         

    def histogramNumBuckets_sempred(self, localctx:HistogramNumBucketsContext, predIndex:int):
            if predIndex == 63:
                return self.isServerVersionGe80200()
         

    def installSetValueList_sempred(self, localctx:InstallSetValueListContext, predIndex:int):
            if predIndex == 64:
                return self.isServerVersionGe80032()
         

    def startOptionValueList_sempred(self, localctx:StartOptionValueListContext, predIndex:int):
            if predIndex == 65:
                return self.isServerVersionLt80014()
         

            if predIndex == 66:
                return self.isServerVersionGe80018()
         

    def optionValueNoOptionType_sempred(self, localctx:OptionValueNoOptionTypeContext, predIndex:int):
            if predIndex == 67:
                return self.isServerVersionGe80011()
         

    def showParseTreeStatement_sempred(self, localctx:ShowParseTreeStatementContext, predIndex:int):
            if predIndex == 68:
                return self.isServerVersionGe80100()
         

    def utilityStatement_sempred(self, localctx:UtilityStatementContext, predIndex:int):
            if predIndex == 69:
                return self.isServerVersionGe80011()
         

    def explainStatement_sempred(self, localctx:ExplainStatementContext, predIndex:int):
            if predIndex == 70:
                return self.isServerVersionGe80032()
         

    def explainOptions_sempred(self, localctx:ExplainOptionsContext, predIndex:int):
            if predIndex == 71:
                return self.isServerVersionGe80032()
         

            if predIndex == 72:
                return self.isServerVersionLt80012()
         

            if predIndex == 73:
                return self.isServerVersionGe80018()
         

            if predIndex == 74:
                return self.isServerVersionGe80019()
         

    def expr_sempred(self, localctx:ExprContext, predIndex:int):
            if predIndex == 75:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 76:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 77:
                return self.precpred(self._ctx, 1)
         

    def boolPri_sempred(self, localctx:BoolPriContext, predIndex:int):
            if predIndex == 78:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 79:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 80:
                return self.precpred(self._ctx, 1)
         

    def predicate_sempred(self, localctx:PredicateContext, predIndex:int):
            if predIndex == 81:
                return self.isServerVersionGe80017()
         

    def bitExpr_sempred(self, localctx:BitExprContext, predIndex:int):
            if predIndex == 82:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 83:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 84:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 85:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 86:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 87:
                return self.precpred(self._ctx, 1)
         

            if predIndex == 88:
                return self.precpred(self._ctx, 4)
         

    def simpleExpr_sempred(self, localctx:SimpleExprContext, predIndex:int):
            if predIndex == 89:
                return self.precpred(self._ctx, 16)
         

            if predIndex == 90:
                return self.precpred(self._ctx, 24)
         

    def arrayCast_sempred(self, localctx:ArrayCastContext, predIndex:int):
            if predIndex == 91:
                return self.isServerVersionGe80017()
         

    def windowFunctionCall_sempred(self, localctx:WindowFunctionCallContext, predIndex:int):
            if predIndex == 92:
                return self.isServerVersionLt80024()
         

    def tablesampleClause_sempred(self, localctx:TablesampleClauseContext, predIndex:int):
            if predIndex == 93:
                return self.isServerVersionGe80200()
         

    def leadLagInfo_sempred(self, localctx:LeadLagInfoContext, predIndex:int):
            if predIndex == 94:
                return self.isServerVersionGe80024()
         

    def runtimeFunctionCall_sempred(self, localctx:RuntimeFunctionCallContext, predIndex:int):
            if predIndex == 95:
                return self.isServerVersionGe80032()
         

            if predIndex == 96:
                return self.isServerVersionLt80011()
         

    def lvalueVariable_sempred(self, localctx:LvalueVariableContext, predIndex:int):
            if predIndex == 97:
                return self.isServerVersionGe80017()
         

    def castType_sempred(self, localctx:CastTypeContext, predIndex:int):
            if predIndex == 98:
                return self.isServerVersionGe80024()
         

            if predIndex == 99:
                return self.isServerVersionGe80017()
         

            if predIndex == 100:
                return self.isServerVersionGe80017()
         

            if predIndex == 101:
                return self.isServerVersionGe80027()
         

    def checkOrReferences_sempred(self, localctx:CheckOrReferencesContext, predIndex:int):
            if predIndex == 102:
                return self.isServerVersionLt80016()
         

    def constraintEnforcement_sempred(self, localctx:ConstraintEnforcementContext, predIndex:int):
            if predIndex == 103:
                return self.isServerVersionGe80017()
         

    def columnAttribute_sempred(self, localctx:ColumnAttributeContext, predIndex:int):
            if predIndex == 104:
                return self.isServerVersionGe80014()
         

            if predIndex == 105:
                return self.isServerVersionGe80013()
         

            if predIndex == 106:
                return self.isServerVersionGe80017()
         

            if predIndex == 107:
                return self.isServerVersionGe80017()
         

            if predIndex == 108:
                return self.isServerVersionGe80024()
         

            if predIndex == 109:
                return self.isServerVersionGe80024()
         

            if predIndex == 110:
                return self.isServerVersionGe80024()
         

    def keyPartOrExpression_sempred(self, localctx:KeyPartOrExpressionContext, predIndex:int):
            if predIndex == 111:
                return self.isServerVersionGe80013()
         

    def commonIndexOption_sempred(self, localctx:CommonIndexOptionContext, predIndex:int):
            if predIndex == 112:
                return self.isServerVersionGe80024()
         

            if predIndex == 113:
                return self.isServerVersionGe80024()
         

    def charsetName_sempred(self, localctx:CharsetNameContext, predIndex:int):
            if predIndex == 114:
                return self.isServerVersionLt80011()
         

    def collationName_sempred(self, localctx:CollationNameContext, predIndex:int):
            if predIndex == 115:
                return self.isServerVersionLt80011()
         

            if predIndex == 116:
                return self.isServerVersionGe80018()
         

    def createTableOption_sempred(self, localctx:CreateTableOptionContext, predIndex:int):
            if predIndex == 117:
                return self.isServerVersionGe80014()
         

            if predIndex == 118:
                return self.isServerVersionGe80024()
         

            if predIndex == 119:
                return self.isServerVersionGe80024()
         

            if predIndex == 120:
                return self.isServerVersionGe80024()
         

            if predIndex == 121:
                return self.isServerVersionGe80024()
         

    def persistedVariableIdentifier_sempred(self, localctx:PersistedVariableIdentifierContext, predIndex:int):
            if predIndex == 122:
                return self.isServerVersionGe80032()
         

    def pureIdentifier_sempred(self, localctx:PureIdentifierContext, predIndex:int):
            if predIndex == 123:
                return self.isPureIdentifier()
         

    def real_ulonglong_number_sempred(self, localctx:Real_ulonglong_numberContext, predIndex:int):
            if predIndex == 124:
                return self.isServerVersionGe80017()
         

    def signedLiteralOrNull_sempred(self, localctx:SignedLiteralOrNullContext, predIndex:int):
            if predIndex == 125:
                return self.isServerVersionGe80024()
         

    def literalOrNull_sempred(self, localctx:LiteralOrNullContext, predIndex:int):
            if predIndex == 126:
                return self.isServerVersionGe80024()
         

    def textStringLiteral_sempred(self, localctx:TextStringLiteralContext, predIndex:int):
            if predIndex == 127:
                return self.isTextStringLiteral()
         

    def textStringHash_sempred(self, localctx:TextStringHashContext, predIndex:int):
            if predIndex == 128:
                return self.isServerVersionGe80017()
         

    def identifierKeyword_sempred(self, localctx:IdentifierKeywordContext, predIndex:int):
            if predIndex == 129:
                return self.isServerVersionLt80017()
         

            if predIndex == 130:
                return self.isServerVersionGe80011()
         

    def labelKeyword_sempred(self, localctx:LabelKeywordContext, predIndex:int):
            if predIndex == 131:
                return self.isServerVersionLt80017()
         

    def identifierKeywordsUnambiguous_sempred(self, localctx:IdentifierKeywordsUnambiguousContext, predIndex:int):
            if predIndex == 132:
                return self.isServerVersionGe80019()
         

            if predIndex == 133:
                return self.isServerVersionGe80200()
         

    def roleKeyword_sempred(self, localctx:RoleKeywordContext, predIndex:int):
            if predIndex == 134:
                return self.isServerVersionLt80017()
         

    def roleOrLabelKeyword_sempred(self, localctx:RoleOrLabelKeywordContext, predIndex:int):
            if predIndex == 135:
                return self.isServerVersionGe80014()
         




